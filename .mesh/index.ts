// @ts-nocheck
import { GraphQLResolveInfo, SelectionSetNode, FieldNode, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';
import { findAndParseConfig } from '@graphql-mesh/cli';
import { createMeshHTTPHandler, MeshHTTPHandler } from '@graphql-mesh/http';
import { getMesh, ExecuteMeshFn, SubscribeMeshFn, MeshContext as BaseMeshContext, MeshInstance } from '@graphql-mesh/runtime';
import { MeshStore, FsStoreStorageAdapter } from '@graphql-mesh/store';
import { path as pathModule } from '@graphql-mesh/cross-helpers';
import { ImportFn } from '@graphql-mesh/types';
import type { ChurrosTypes } from './sources/Churros/types';
import type { AuthentikTypes } from './sources/Authentik/types';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
export type RequireFields<T, K extends keyof T> = Omit<T, K> & { [P in K]-?: NonNullable<T[P]> };



/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  /** The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text. */
  String: { input: string; output: string; }
  /** The `Boolean` scalar type represents `true` or `false`. */
  Boolean: { input: boolean; output: boolean; }
  /** The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. */
  Int: { input: number; output: number; }
  /** The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). */
  Float: { input: number; output: number; }
  ChurrosBooleanMap: { input: any; output: any; }
  ChurrosCounts: { input: any; output: any; }
  /** A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar. */
  DateTime: { input: Date | string; output: Date | string; }
  ChurrosFile: { input: any; output: any; }
  ChurrosLocalID: { input: any; output: any; }
  ChurrosUID: { input: any; output: any; }
  /** The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */
  JSON: { input: any; output: any; }
  /** Integers that will have a value greater than 0. */
  PositiveInt: { input: number; output: number; }
  /** The human-readable name of this device. */
  QueryAuthenticatorsAdminDuoListOneOf_0ResultsItemsName: { input: any; output: any; }
  /** The human-readable name of this device. */
  QueryAuthenticatorsAdminSmsListOneOf_0ResultsItemsName: { input: any; output: any; }
  /** The human-readable name of this device. */
  QueryAuthenticatorsAdminStaticListOneOf_0ResultsItemsName: { input: any; output: any; }
  QueryAuthenticatorsAdminStaticListOneOf_0ResultsItemsTokenSetItemsToken: { input: any; output: any; }
  /** The human-readable name of this device. */
  QueryAuthenticatorsAdminTotpListOneOf_0ResultsItemsName: { input: any; output: any; }
  QueryAuthenticatorsAdminWebauthnListOneOf_0ResultsItemsName: { input: any; output: any; }
  /** A field whose value is a generic Universally Unique Identifier: https://en.wikipedia.org/wiki/Universally_unique_identifier. */
  UUID: { input: string; output: string; }
  QueryCoreApplicationsListOneOf_0ResultsItemsSlug: { input: string; output: string; }
  /** A field whose value conforms to the standard URL format as specified in RFC3986: https://www.ietf.org/rfc/rfc3986.txt. */
  URL: { input: URL | string; output: URL | string; }
  QueryCoreGroupsListOneOf_0ResultsItemsName: { input: any; output: any; }
  QueryCoreGroupsListOneOf_0ResultsItemsUsersObjItemsUsername: { input: string; output: string; }
  /** A field whose value conforms to the standard internet email address format as specified in HTML Spec: https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address. */
  EmailAddress: { input: string; output: string; }
  QueryCoreGroupsListOneOf_0ResultsItemsRolesObjItemsName: { input: any; output: any; }
  QueryCoreTokensListOneOf_0ResultsItemsIdentifier: { input: string; output: string; }
  QueryCoreTokensListOneOf_0ResultsItemsUserObjUsername: { input: any; output: any; }
  QueryCoreTokensListOneOf_0ResultsItemsUserObjGroupsObjItemsName: { input: any; output: any; }
  /** Represents empty values */
  Void: { input: void; output: void; }
  QueryCoreUsersMeRetrieveOneOf_0UserUsername: { input: string; output: string; }
  QueryFlowsBindingsListOneOf_0ResultsItemsStageObjFlowSetItemsSlug: { input: string; output: string; }
  QueryFlowsInstancesListOneOf_0ResultsItemsSlug: { input: string; output: string; }
  /** The `File` scalar type represents a file upload. */
  File: { input: File; output: File; }
  QueryOauth2AccessTokensListOneOf_0ResultsItemsProviderClientId: { input: any; output: any; }
  QueryOauth2AccessTokensListOneOf_0ResultsItemsProviderClientSecret: { input: any; output: any; }
  QueryOutpostsProxyListOneOf_0ResultsItemsClientId: { input: any; output: any; }
  QueryOutpostsProxyListOneOf_0ResultsItemsClientSecret: { input: any; output: any; }
  /** Integers that will have a value of 0 or more. */
  NonNegativeInt: { input: number; output: number; }
  /** The `BigInt` scalar type represents non-fractional signed whole numeric values. */
  BigInt: { input: bigint; output: bigint; }
  QueryRbacPermissionsListOneOf_0ResultsItemsName: { input: any; output: any; }
  QueryRbacPermissionsListOneOf_0ResultsItemsCodename: { input: any; output: any; }
  QueryRbacPermissionsAssignedByUsersListOneOf_0ResultsItemsUsername: { input: string; output: string; }
  QuerySourcesAllListOneOf_0ResultsItemsSlug: { input: string; output: string; }
  QuerySourcesLdapListOneOf_0ResultsItemsSlug: { input: string; output: string; }
  QuerySourcesOauthListOneOf_0ResultsItemsSlug: { input: string; output: string; }
  /** URL used to request the initial token. This URL is only required for OAuth 1. */
  QuerySourcesOauthListOneOf_0ResultsItemsRequestTokenUrl: { input: any; output: any; }
  /** URL the user is redirect to to conest the flow. */
  QuerySourcesOauthListOneOf_0ResultsItemsAuthorizationUrl: { input: any; output: any; }
  /** URL used by authentik to retrieve tokens. */
  QuerySourcesOauthListOneOf_0ResultsItemsAccessTokenUrl: { input: any; output: any; }
  /** URL used by authentik to get user information. */
  QuerySourcesOauthListOneOf_0ResultsItemsProfileUrl: { input: any; output: any; }
  QuerySourcesPlexListOneOf_0ResultsItemsSlug: { input: string; output: string; }
  QuerySourcesSamlListOneOf_0ResultsItemsSlug: { input: string; output: string; }
  QuerySourcesScimListOneOf_0ResultsItemsSlug: { input: string; output: string; }
  QuerySourcesUserConnectionsOauthListOneOf_0ResultsItemsIdentifier: { input: any; output: any; }
  QueryStagesInvitationInvitationsListOneOf_0ResultsItemsName: { input: string; output: string; }
  /** A string that cannot be passed as an empty value */
  NonEmptyString: { input: string; output: string; }
  /** The human-readable name of this device. */
  MutationInputAuthenticatorsAdminDuoCreateInputName: { input: any; output: any; }
  /** The human-readable name of this device. */
  MutationInputAuthenticatorsAdminDuoPartialUpdateInputName: { input: any; output: any; }
  /** The human-readable name of this device. */
  MutationInputAuthenticatorsAdminSmsCreateInputName: { input: any; output: any; }
  /** The human-readable name of this device. */
  MutationInputAuthenticatorsAdminSmsPartialUpdateInputName: { input: any; output: any; }
  /** The human-readable name of this device. */
  MutationInputAuthenticatorsAdminStaticCreateInputName: { input: any; output: any; }
  /** The human-readable name of this device. */
  MutationInputAuthenticatorsAdminStaticPartialUpdateInputName: { input: any; output: any; }
  /** The human-readable name of this device. */
  MutationInputAuthenticatorsAdminTotpCreateInputName: { input: any; output: any; }
  /** The human-readable name of this device. */
  MutationInputAuthenticatorsAdminTotpPartialUpdateInputName: { input: any; output: any; }
  MutationInputAuthenticatorsAdminWebauthnCreateInputName: { input: any; output: any; }
  MutationInputAuthenticatorsAdminWebauthnPartialUpdateInputName: { input: any; output: any; }
  MutationInputCoreApplicationsCreateInputSlug: { input: string; output: string; }
  MutationInputCoreApplicationsPartialUpdateInputSlug: { input: string; output: string; }
  MutationInputCoreGroupsCreateInputName: { input: any; output: any; }
  MutationInputCoreGroupsPartialUpdateInputName: { input: any; output: any; }
  MutationInputCoreTokensCreateInputIdentifier: { input: string; output: string; }
  MutationInputCoreTokensPartialUpdateInputIdentifier: { input: string; output: string; }
  MutationInputCoreTransactionalApplicationsUpdateInputProviderOneOf_1ClientId: { input: any; output: any; }
  MutationInputCoreTransactionalApplicationsUpdateInputProviderOneOf_1ClientSecret: { input: any; output: any; }
  MutationInputCoreUsersCreateInputUsername: { input: any; output: any; }
  MutationInputCoreUsersPartialUpdateInputUsername: { input: any; output: any; }
  MutationInputFlowsInstancesCreateInputSlug: { input: string; output: string; }
  MutationInputFlowsInstancesPartialUpdateInputSlug: { input: string; output: string; }
  MutationInputProvidersOauth2PartialUpdateInputClientId: { input: any; output: any; }
  MutationInputProvidersOauth2PartialUpdateInputClientSecret: { input: any; output: any; }
  MutationInputRbacRolesCreateInputName: { input: any; output: any; }
  MutationInputRbacRolesPartialUpdateInputName: { input: any; output: any; }
  MutationInputSourcesLdapCreateInputSlug: { input: string; output: string; }
  MutationInputSourcesLdapPartialUpdateInputSlug: { input: string; output: string; }
  MutationInputSourcesOauthCreateInputSlug: { input: string; output: string; }
  /** URL used to request the initial token. This URL is only required for OAuth 1. */
  MutationInputSourcesOauthCreateInputRequestTokenUrl: { input: any; output: any; }
  /** URL the user is redirect to to conest the flow. */
  MutationInputSourcesOauthCreateInputAuthorizationUrl: { input: any; output: any; }
  /** URL used by authentik to retrieve tokens. */
  MutationInputSourcesOauthCreateInputAccessTokenUrl: { input: any; output: any; }
  /** URL used by authentik to get user information. */
  MutationInputSourcesOauthCreateInputProfileUrl: { input: any; output: any; }
  MutationInputSourcesOauthPartialUpdateInputSlug: { input: string; output: string; }
  /** URL used to request the initial token. This URL is only required for OAuth 1. */
  MutationInputSourcesOauthPartialUpdateInputRequestTokenUrl: { input: any; output: any; }
  /** URL the user is redirect to to conest the flow. */
  MutationInputSourcesOauthPartialUpdateInputAuthorizationUrl: { input: any; output: any; }
  /** URL used by authentik to retrieve tokens. */
  MutationInputSourcesOauthPartialUpdateInputAccessTokenUrl: { input: any; output: any; }
  /** URL used by authentik to get user information. */
  MutationInputSourcesOauthPartialUpdateInputProfileUrl: { input: any; output: any; }
  MutationInputSourcesPlexCreateInputSlug: { input: string; output: string; }
  MutationInputSourcesPlexPartialUpdateInputSlug: { input: string; output: string; }
  MutationInputSourcesSamlCreateInputSlug: { input: string; output: string; }
  MutationInputSourcesSamlPartialUpdateInputSlug: { input: string; output: string; }
  MutationInputSourcesScimCreateInputSlug: { input: string; output: string; }
  MutationInputSourcesScimPartialUpdateInputSlug: { input: string; output: string; }
  MutationInputSourcesUserConnectionsOauthCreateInputIdentifier: { input: any; output: any; }
  MutationInputSourcesUserConnectionsOauthPartialUpdateInputIdentifier: { input: any; output: any; }
  MutationInputStagesAuthenticatorDuoCreateInputFlowSetItemsSlug: { input: string; output: string; }
  MutationInputStagesInvitationInvitationsCreateInputName: { input: string; output: string; }
  MutationInputStagesInvitationInvitationsPartialUpdateInputName: { input: string; output: string; }
  ObjMap: { input: any; output: any; }
  ResolveToSourceArgs: { input: any; output: any; }
};

export type Query = {
  group: ChurrosGroup;
  /** - **Rate limit:** 6000/minute */
  me: ChurrosUser;
  user: ChurrosUser;
  /** Custom list method that checks Policy based access instead of guardian */
  applications?: Maybe<CoreApplicationsListResponse>;
  /** Application Viewset */
  application?: Maybe<CoreApplicationsRetrieveResponse>;
  /** Check access to a single application by slug */
  coreApplicationsCheckAccessRetrieve?: Maybe<CoreApplicationsCheckAccessRetrieveResponse>;
  /** Metrics for application logins */
  applicationMetrics?: Maybe<Array<Maybe<CoreApplicationsMetricsListResponse>>>;
  /** Get a list of all objects that use this object */
  coreApplicationsUsedByList?: Maybe<Array<Maybe<CoreApplicationsUsedByListResponse>>>;
  /** FlowStageBinding Viewset */
  flowsBindingsList?: Maybe<FlowsBindingsListResponse>;
  /** FlowStageBinding Viewset */
  flowsBindingsRetrieve?: Maybe<FlowsBindingsRetrieveResponse>;
  /** Get a list of all objects that use this object */
  flowsBindingsUsedByList?: Maybe<Array<Maybe<FlowsBindingsUsedByListResponse>>>;
  /** Get the next pending challenge from the currently active flow. */
  flowsExecutorGet?: Maybe<FlowsExecutorGetResponse>;
  /** Get current flow state and record it */
  flowsInspectorGet?: Maybe<FlowsInspectorGetResponse>;
  /** Flow Viewset */
  flowsInstancesList?: Maybe<FlowsInstancesListResponse>;
  /** Flow Viewset */
  flowsInstancesRetrieve?: Maybe<FlowsInstancesRetrieveResponse>;
  /** Return diagram for flow with slug `slug`, in the format used by flowchart.js */
  flowsInstancesDiagramRetrieve?: Maybe<FlowsInstancesDiagramRetrieveResponse>;
  /** Execute flow for current user */
  flowsInstancesExecuteRetrieve?: Maybe<FlowsInstancesExecuteRetrieveResponse>;
  /** Export flow to .yaml file */
  flowsInstancesExportRetrieve?: Maybe<FlowsInstancesExportRetrieveResponse>;
  /** Get a list of all objects that use this object */
  flowsInstancesUsedByList?: Maybe<Array<Maybe<FlowsInstancesUsedByListResponse>>>;
  /** Info about cached flows */
  flowsInstancesCacheInfoRetrieve?: Maybe<FlowsInstancesCacheInfoRetrieveResponse>;
  /** Provider Viewset */
  providers?: Maybe<ProvidersAllListResponse>;
  /** Provider Viewset */
  provider?: Maybe<ProvidersAllRetrieveResponse>;
  /** Get a list of all objects that use this object */
  providersAllUsedByList?: Maybe<Array<Maybe<ProvidersAllUsedByListResponse>>>;
  /** Get all creatable provider types */
  providersAllTypesList?: Maybe<Array<Maybe<ProvidersAllTypesListResponse>>>;
};


export type QuerygroupArgs = {
  uid: Scalars['String']['input'];
};


export type QueryuserArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
  uid?: InputMaybe<Scalars['String']['input']>;
};


export type QueryapplicationsArgs = {
  forUser?: InputMaybe<Scalars['Int']['input']>;
  group?: InputMaybe<Scalars['String']['input']>;
  metaDescription?: InputMaybe<Scalars['String']['input']>;
  metaLaunchUrl?: InputMaybe<Scalars['String']['input']>;
  metaPublisher?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ordering?: InputMaybe<Scalars['String']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  pageSize?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  slug?: InputMaybe<Scalars['String']['input']>;
  superuserFullList?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryapplicationArgs = {
  slug: Scalars['String']['input'];
};


export type QuerycoreApplicationsCheckAccessRetrieveArgs = {
  slug: Scalars['String']['input'];
  forUser?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryapplicationMetricsArgs = {
  slug: Scalars['String']['input'];
};


export type QuerycoreApplicationsUsedByListArgs = {
  slug: Scalars['String']['input'];
};


export type QueryflowsBindingsListArgs = {
  evaluateOnPlan?: InputMaybe<Scalars['Boolean']['input']>;
  fsbUuid?: InputMaybe<Scalars['UUID']['input']>;
  invalidResponseAction?: InputMaybe<QueryInputFlowsBindingsListInvalidResponseAction>;
  order?: InputMaybe<Scalars['Int']['input']>;
  ordering?: InputMaybe<Scalars['String']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  pageSize?: InputMaybe<Scalars['Int']['input']>;
  pbmUuid?: InputMaybe<Scalars['UUID']['input']>;
  policies?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  policyEngineMode?: InputMaybe<QueryInputFlowsBindingsListPolicyEngineMode>;
  reEvaluatePolicies?: InputMaybe<Scalars['Boolean']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  stage?: InputMaybe<Scalars['UUID']['input']>;
  target?: InputMaybe<Scalars['UUID']['input']>;
};


export type QueryflowsBindingsRetrieveArgs = {
  fsbUuid: Scalars['UUID']['input'];
};


export type QueryflowsBindingsUsedByListArgs = {
  fsbUuid: Scalars['UUID']['input'];
};


export type QueryflowsExecutorGetArgs = {
  flowSlug: Scalars['String']['input'];
  query: Scalars['String']['input'];
};


export type QueryflowsInspectorGetArgs = {
  flowSlug: Scalars['String']['input'];
};


export type QueryflowsInstancesListArgs = {
  deniedAction?: InputMaybe<QueryInputFlowsInstancesListDeniedAction>;
  designation?: InputMaybe<QueryInputFlowsInstancesListDesignation>;
  flowUuid?: InputMaybe<Scalars['UUID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ordering?: InputMaybe<Scalars['String']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  pageSize?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  slug?: InputMaybe<Scalars['String']['input']>;
};


export type QueryflowsInstancesRetrieveArgs = {
  slug: Scalars['String']['input'];
};


export type QueryflowsInstancesDiagramRetrieveArgs = {
  slug: Scalars['String']['input'];
};


export type QueryflowsInstancesExecuteRetrieveArgs = {
  slug: Scalars['String']['input'];
};


export type QueryflowsInstancesExportRetrieveArgs = {
  slug: Scalars['String']['input'];
};


export type QueryflowsInstancesUsedByListArgs = {
  slug: Scalars['String']['input'];
};


export type QueryprovidersArgs = {
  applicationIsnull?: InputMaybe<Scalars['Boolean']['input']>;
  backchannelOnly?: InputMaybe<Scalars['Boolean']['input']>;
  ordering?: InputMaybe<Scalars['String']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  pageSize?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
};


export type QueryproviderArgs = {
  id: Scalars['Int']['input'];
};


export type QueryprovidersAllUsedByListArgs = {
  id: Scalars['Int']['input'];
};

/**
 * Permet de faire des requêtes de données temps-réel, via des _websockets_.
 * L'endpoint pour le temps réel est `wss://churros.inpt.fr/graphql`.
 *
 * Pour un client JavaScript, il y a par exemple [GraphQL-WebSocket](https://the-guild.dev/graphql/ws/get-started#use-the-client)
 *
 * - **Rate limit par défault:** 600 / 10 minutes (par utilisateur·ice et par query)
 */
export type Subscription = {
  announcementsNow: Array<ChurrosAnnouncement>;
  article: ChurrosArticle;
  event: ChurrosEvent;
  /** Récupère un formulaire. On peut utiliser une subscription pour avoir la mise à jour en temps réel des réponses au formulaire. */
  form?: Maybe<ChurrosForm>;
  /** Gets the homepage articles, customized if the user is logged in. */
  homepage: ChurrosQueryHomepageConnection;
  kioskReload: Scalars['Boolean']['output'];
  registration: ChurrosSubscriptionRegistrationResult;
  thirdPartyApp: ChurrosThirdPartyApp;
};


/**
 * Permet de faire des requêtes de données temps-réel, via des _websockets_.
 * L'endpoint pour le temps réel est `wss://churros.inpt.fr/graphql`.
 *
 * Pour un client JavaScript, il y a par exemple [GraphQL-WebSocket](https://the-guild.dev/graphql/ws/get-started#use-the-client)
 *
 * - **Rate limit par défault:** 600 / 10 minutes (par utilisateur·ice et par query)
 */
export type SubscriptionarticleArgs = {
  id: Scalars['ChurrosLocalID']['input'];
};


/**
 * Permet de faire des requêtes de données temps-réel, via des _websockets_.
 * L'endpoint pour le temps réel est `wss://churros.inpt.fr/graphql`.
 *
 * Pour un client JavaScript, il y a par exemple [GraphQL-WebSocket](https://the-guild.dev/graphql/ws/get-started#use-the-client)
 *
 * - **Rate limit par défault:** 600 / 10 minutes (par utilisateur·ice et par query)
 */
export type SubscriptioneventArgs = {
  group?: InputMaybe<Scalars['ChurrosUID']['input']>;
  id?: InputMaybe<Scalars['ChurrosLocalID']['input']>;
  slug?: InputMaybe<Scalars['String']['input']>;
};


/**
 * Permet de faire des requêtes de données temps-réel, via des _websockets_.
 * L'endpoint pour le temps réel est `wss://churros.inpt.fr/graphql`.
 *
 * Pour un client JavaScript, il y a par exemple [GraphQL-WebSocket](https://the-guild.dev/graphql/ws/get-started#use-the-client)
 *
 * - **Rate limit par défault:** 600 / 10 minutes (par utilisateur·ice et par query)
 */
export type SubscriptionformArgs = {
  localId: Scalars['String']['input'];
};


/**
 * Permet de faire des requêtes de données temps-réel, via des _websockets_.
 * L'endpoint pour le temps réel est `wss://churros.inpt.fr/graphql`.
 *
 * Pour un client JavaScript, il y a par exemple [GraphQL-WebSocket](https://the-guild.dev/graphql/ws/get-started#use-the-client)
 *
 * - **Rate limit par défault:** 600 / 10 minutes (par utilisateur·ice et par query)
 */
export type SubscriptionhomepageArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Permet de faire des requêtes de données temps-réel, via des _websockets_.
 * L'endpoint pour le temps réel est `wss://churros.inpt.fr/graphql`.
 *
 * Pour un client JavaScript, il y a par exemple [GraphQL-WebSocket](https://the-guild.dev/graphql/ws/get-started#use-the-client)
 *
 * - **Rate limit par défault:** 600 / 10 minutes (par utilisateur·ice et par query)
 */
export type SubscriptionregistrationArgs = {
  id: Scalars['ID']['input'];
};


/**
 * Permet de faire des requêtes de données temps-réel, via des _websockets_.
 * L'endpoint pour le temps réel est `wss://churros.inpt.fr/graphql`.
 *
 * Pour un client JavaScript, il y a par exemple [GraphQL-WebSocket](https://the-guild.dev/graphql/ws/get-started#use-the-client)
 *
 * - **Rate limit par défault:** 600 / 10 minutes (par utilisateur·ice et par query)
 */
export type SubscriptionthirdPartyAppArgs = {
  id: Scalars['ID']['input'];
};

/** Announcement is a way to get a message accross the entire site, such as for maintenance announcements. */
export type ChurrosAnnouncement = ChurrosNode & {
  body: Scalars['String']['output'];
  bodyHtml: Scalars['String']['output'];
  by?: Maybe<ChurrosUser>;
  createdAt: Scalars['DateTime']['output'];
  endsAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  /** L'identifiant local de la ressource (sans préfixe) */
  localID: Scalars['ChurrosLocalID']['output'];
  startsAt: Scalars['DateTime']['output'];
  title: Scalars['String']['output'];
  updatedAt: Scalars['DateTime']['output'];
  userId?: Maybe<Scalars['ID']['output']>;
  warning: Scalars['Boolean']['output'];
};

/** Une réponse à un formulaire. Les réponses peuvent être de plusieurs types différents (en fonction de la question). */
export type ChurrosAnswer = {
  answerString: Scalars['String']['output'];
  /** Réservation associée à la réponse */
  booking?: Maybe<ChurrosRegistration>;
  checkboxIsMarked?: Maybe<Scalars['Boolean']['output']>;
  /** Date de création de la réponse */
  createdAt: Scalars['DateTime']['output'];
  /** Utilisateur ayant répondu à la question */
  createdBy?: Maybe<ChurrosUser>;
  /** Formulaire auquel appartient la question */
  form: ChurrosForm;
  /** Préfixe de l'identifiant: `answer:` */
  id: Scalars['ID']['output'];
  question: ChurrosQuestion;
  /** Section du formulaire auquel appartient la question */
  section: ChurrosFormSection;
  /** Date de dernière mise à jour de la réponse */
  updatedAt: Scalars['DateTime']['output'];
};

/** Réponse de type `Date` (voir [`QuestionKind`](#QuestionKind)) */
export type ChurrosAnswerDate = ChurrosAnswer & {
  answerString: Scalars['String']['output'];
  /** Réservation associée à la réponse */
  booking?: Maybe<ChurrosRegistration>;
  checkboxIsMarked?: Maybe<Scalars['Boolean']['output']>;
  /** Date de création de la réponse */
  createdAt: Scalars['DateTime']['output'];
  /** Utilisateur ayant répondu à la question */
  createdBy?: Maybe<ChurrosUser>;
  /** Formulaire auquel appartient la question */
  form: ChurrosForm;
  /** Préfixe de l'identifiant: `answer:` */
  id: Scalars['ID']['output'];
  /** Question à laquelle la réponse est associée */
  question: ChurrosQuestionScalar;
  /** Réponse donnée, brute (sous forme de texte) */
  rawValue?: Maybe<Scalars['String']['output']>;
  /** Section du formulaire auquel appartient la question */
  section: ChurrosFormSection;
  /** Date de dernière mise à jour de la réponse */
  updatedAt: Scalars['DateTime']['output'];
  /** Réponse donnée */
  value?: Maybe<Scalars['DateTime']['output']>;
};

/** Réponse de type `FileUpload` (voir [`QuestionKind`](#QuestionKind)) */
export type ChurrosAnswerFileUpload = ChurrosAnswer & {
  answerString: Scalars['String']['output'];
  /** Réservation associée à la réponse */
  booking?: Maybe<ChurrosRegistration>;
  checkboxIsMarked?: Maybe<Scalars['Boolean']['output']>;
  /** Date de création de la réponse */
  createdAt: Scalars['DateTime']['output'];
  /** Utilisateur ayant répondu à la question */
  createdBy?: Maybe<ChurrosUser>;
  /** Formulaire auquel appartient la question */
  form: ChurrosForm;
  /** Préfixe de l'identifiant: `answer:` */
  id: Scalars['ID']['output'];
  /** Question à laquelle la réponse est associée */
  question: ChurrosQuestionFileUpload;
  /** Section du formulaire auquel appartient la question */
  section: ChurrosFormSection;
  /** Date de dernière mise à jour de la réponse */
  updatedAt: Scalars['DateTime']['output'];
  /** Réponse donnée */
  value?: Maybe<Scalars['String']['output']>;
};

export type ChurrosAnswerInput = {
  /**
   *
   * Réponse à la question. Pour les questions à une seule réponse, ne mettre qu'un seul élément.
   *
   * - Pour les questions de type `Date`, utiliser le format `YYYY-mm-dd`
   * - Pour les questions de type `Time`, utiliser le format `HH:MM:ss`
   * - Pour les questions de type `Scale`, utiliser simplement le nombre répondu par l'utilisateur·ice
   * - Pour les questions de type `FileUpload`, utiliser la mutation [`answerFileQuestion`](#mutation/answerFileQuestion)
   *
   */
  answer: Array<Scalars['String']['input']>;
  /** ID de la question à laquelle répondre */
  question: Scalars['ID']['input'];
};

/** Réponse de type `LongText` (voir [`QuestionKind`](#QuestionKind)) */
export type ChurrosAnswerLongText = ChurrosAnswer & {
  answerString: Scalars['String']['output'];
  /** Réservation associée à la réponse */
  booking?: Maybe<ChurrosRegistration>;
  checkboxIsMarked?: Maybe<Scalars['Boolean']['output']>;
  /** Date de création de la réponse */
  createdAt: Scalars['DateTime']['output'];
  /** Utilisateur ayant répondu à la question */
  createdBy?: Maybe<ChurrosUser>;
  /** Formulaire auquel appartient la question */
  form: ChurrosForm;
  /** Préfixe de l'identifiant: `answer:` */
  id: Scalars['ID']['output'];
  /** Question à laquelle la réponse est associée */
  question: ChurrosQuestionScalar;
  /** Section du formulaire auquel appartient la question */
  section: ChurrosFormSection;
  /** Date de dernière mise à jour de la réponse */
  updatedAt: Scalars['DateTime']['output'];
  /** Réponse donnée */
  value?: Maybe<Scalars['String']['output']>;
};

/** Réponse de type `Number` (voir [`QuestionKind`](#QuestionKind)) */
export type ChurrosAnswerNumber = ChurrosAnswer & {
  answerString: Scalars['String']['output'];
  /** Réservation associée à la réponse */
  booking?: Maybe<ChurrosRegistration>;
  checkboxIsMarked?: Maybe<Scalars['Boolean']['output']>;
  /** Date de création de la réponse */
  createdAt: Scalars['DateTime']['output'];
  /** Utilisateur ayant répondu à la question */
  createdBy?: Maybe<ChurrosUser>;
  /** Formulaire auquel appartient la question */
  form: ChurrosForm;
  /** Préfixe de l'identifiant: `answer:` */
  id: Scalars['ID']['output'];
  /** Question à laquelle la réponse est associée */
  question: ChurrosQuestionScalar;
  /** Section du formulaire auquel appartient la question */
  section: ChurrosFormSection;
  /** Date de dernière mise à jour de la réponse */
  updatedAt: Scalars['DateTime']['output'];
  /** Réponse donnée */
  value?: Maybe<Scalars['Float']['output']>;
};

/** Réponse de type `Scale` (voir [`QuestionKind`](#QuestionKind)) */
export type ChurrosAnswerScale = ChurrosAnswer & {
  answerString: Scalars['String']['output'];
  /** Réservation associée à la réponse */
  booking?: Maybe<ChurrosRegistration>;
  checkboxIsMarked?: Maybe<Scalars['Boolean']['output']>;
  /** Date de création de la réponse */
  createdAt: Scalars['DateTime']['output'];
  /** Utilisateur ayant répondu à la question */
  createdBy?: Maybe<ChurrosUser>;
  /** Formulaire auquel appartient la question */
  form: ChurrosForm;
  /** Préfixe de l'identifiant: `answer:` */
  id: Scalars['ID']['output'];
  /** Réponse donnée, entre 0 et 1 */
  normalizedValue?: Maybe<Scalars['Float']['output']>;
  /** Question à laquelle la réponse est associée */
  question: ChurrosQuestionScale;
  /** Section du formulaire auquel appartient la question */
  section: ChurrosFormSection;
  /** Date de dernière mise à jour de la réponse */
  updatedAt: Scalars['DateTime']['output'];
  /** Réponse donnée */
  value?: Maybe<Scalars['Int']['output']>;
};

export type ChurrosAnswerSearchResult = {
  answer: ChurrosAnswer;
  id: Scalars['ID']['output'];
  rank?: Maybe<Scalars['Float']['output']>;
  similarity: Scalars['Float']['output'];
};

/** Réponse de type `SelectMultiple` (voir [`QuestionKind`](#QuestionKind)) */
export type ChurrosAnswerSelectMultiple = ChurrosAnswer & {
  answerString: Scalars['String']['output'];
  /** Réservation associée à la réponse */
  booking?: Maybe<ChurrosRegistration>;
  checkboxIsMarked?: Maybe<Scalars['Boolean']['output']>;
  /** Date de création de la réponse */
  createdAt: Scalars['DateTime']['output'];
  /** Utilisateur ayant répondu à la question */
  createdBy?: Maybe<ChurrosUser>;
  /** Formulaire auquel appartient la question */
  form: ChurrosForm;
  /** Préfixe de l'identifiant: `answer:` */
  id: Scalars['ID']['output'];
  /** Question à laquelle la réponse est associée */
  question: ChurrosQuestionSelectMultiple;
  /** Section du formulaire auquel appartient la question */
  section: ChurrosFormSection;
  /** Date de dernière mise à jour de la réponse */
  updatedAt: Scalars['DateTime']['output'];
  /** Réponse donnée */
  value?: Maybe<Array<Scalars['String']['output']>>;
};

/** Réponse de type `SelectOne` (voir [`QuestionKind`](#QuestionKind)) */
export type ChurrosAnswerSelectOne = ChurrosAnswer & {
  answerString: Scalars['String']['output'];
  /** Réservation associée à la réponse */
  booking?: Maybe<ChurrosRegistration>;
  checkboxIsMarked?: Maybe<Scalars['Boolean']['output']>;
  /** Date de création de la réponse */
  createdAt: Scalars['DateTime']['output'];
  /** Utilisateur ayant répondu à la question */
  createdBy?: Maybe<ChurrosUser>;
  /** Formulaire auquel appartient la question */
  form: ChurrosForm;
  /** Préfixe de l'identifiant: `answer:` */
  id: Scalars['ID']['output'];
  /** Question à laquelle la réponse est associée */
  question: ChurrosQuestionSelectOne;
  /** Section du formulaire auquel appartient la question */
  section: ChurrosFormSection;
  /** Date de dernière mise à jour de la réponse */
  updatedAt: Scalars['DateTime']['output'];
  /** Réponse donnée */
  value?: Maybe<Scalars['String']['output']>;
};

/** Réponse de type `Text` (voir [`QuestionKind`](#QuestionKind)) */
export type ChurrosAnswerText = ChurrosAnswer & {
  answerString: Scalars['String']['output'];
  /** Réservation associée à la réponse */
  booking?: Maybe<ChurrosRegistration>;
  checkboxIsMarked?: Maybe<Scalars['Boolean']['output']>;
  /** Date de création de la réponse */
  createdAt: Scalars['DateTime']['output'];
  /** Utilisateur ayant répondu à la question */
  createdBy?: Maybe<ChurrosUser>;
  /** Formulaire auquel appartient la question */
  form: ChurrosForm;
  /** Préfixe de l'identifiant: `answer:` */
  id: Scalars['ID']['output'];
  /** Question à laquelle la réponse est associée */
  question: ChurrosQuestionScalar;
  /** Section du formulaire auquel appartient la question */
  section: ChurrosFormSection;
  /** Date de dernière mise à jour de la réponse */
  updatedAt: Scalars['DateTime']['output'];
  /** Réponse donnée */
  value?: Maybe<Scalars['String']['output']>;
};

/** Réponse de type `Time` (voir [`QuestionKind`](#QuestionKind)) */
export type ChurrosAnswerTime = ChurrosAnswer & {
  answer: ChurrosAnswer;
  answerString: Scalars['String']['output'];
  /** Réservation associée à la réponse */
  booking?: Maybe<ChurrosRegistration>;
  checkboxIsMarked?: Maybe<Scalars['Boolean']['output']>;
  /** Date de création de la réponse */
  createdAt: Scalars['DateTime']['output'];
  /** Utilisateur ayant répondu à la question */
  createdBy?: Maybe<ChurrosUser>;
  /** Formulaire auquel appartient la question */
  form: ChurrosForm;
  /** Préfixe de l'identifiant: `answer:` */
  id: Scalars['ID']['output'];
  /** Question à laquelle la réponse est associée */
  question: ChurrosQuestionScalar;
  /** Réponse donnée, brute (sous forme de texte) */
  rawValue?: Maybe<Scalars['String']['output']>;
  /** Section du formulaire auquel appartient la question */
  section: ChurrosFormSection;
  /** Date de dernière mise à jour de la réponse */
  updatedAt: Scalars['DateTime']['output'];
  /** Réponse donnée */
  value?: Maybe<Scalars['DateTime']['output']>;
};

/** Formats d'export des réponses */
export type ChurrosAnswersExportFormats =
  /** Format CSV (séparateur de colonnes: virgule, séparateur de lignes: saut de ligne) */
  | 'CSV'
  /** Format TSV (séparateur de colonnes: tabulation, séparateur de lignes: saut de ligne) */
  | 'TSV';

/** Représente toutes les réponses d'un·e utilisateur·ice à un formulaire. Pratique pour grouper les réponses afin de les afficher dans un tableau */
export type ChurrosAnswersOfUser = {
  answers: Array<ChurrosAnswer>;
  /** Correspond à la date de dernière réponse parmis les réponses */
  date: Scalars['DateTime']['output'];
  user: ChurrosUser;
};

/** Des données temporelles pour construire des graphiques d'atteintes de rate limiting. La résolution temporelle est d'une minute. */
export type ChurrosApiRateLimitHits = {
  /** Le nombre d'erreurs de rate-limiting à cette date */
  count: Scalars['Int']['output'];
  /** La date à laquelle les requêtes ont été faites */
  date: Scalars['DateTime']['output'];
  /** Le nom de la query ou mutation ou subscription */
  queryName: Scalars['String']['output'];
  /** Le type de requête effectuée */
  queryType: Scalars['String']['output'];
  timestamp: Scalars['Int']['output'];
  user?: Maybe<ChurrosUser>;
};

/** Des données temporelles pour construire des graphiques d'utilisation de l'API au cours du temps. La résolution temporelle est d'une minute. */
export type ChurrosApiUsage = {
  /** Le nombre de requêtes faites à cette date */
  count: Scalars['Int']['output'];
  /** La date à laquelle les requêtes ont été faites */
  date: Scalars['DateTime']['output'];
  /** Le nom de la query ou mutation ou subscription */
  queryName: Scalars['String']['output'];
  /** Le type de requête effectuée */
  queryType: ChurrosApiUsageQueryType;
  timestamp: Scalars['Int']['output'];
  user?: Maybe<ChurrosUser>;
};

/** Type de requête effectuée sur l'API */
export type ChurrosApiUsageQueryType =
  /** Modification de données, ou autre action diverses */
  | 'Mutation'
  /** Récupération de données */
  | 'Query'
  /** Abonnement à des données pour être informé en temps réel des changements */
  | 'Subscription';

/** An article is a post in a group */
export type ChurrosArticle = ChurrosCommentable & ChurrosNode & ChurrosPictured & ChurrosReactable & {
  author?: Maybe<ChurrosUser>;
  authorId?: Maybe<Scalars['ID']['output']>;
  body: Scalars['String']['output'];
  bodyHtml: Scalars['String']['output'];
  bodyPreview: Scalars['String']['output'];
  /** Vrai si l'utilisateur·ice connecté·e peut éditer le post (en considérant qu'iel ne va pas changer l'auteur·ice ou le groupe du post) */
  canBeEdited: Scalars['Boolean']['output'];
  comments: ChurrosCommentsConnection;
  createdAt: Scalars['DateTime']['output'];
  event?: Maybe<ChurrosEvent>;
  eventId?: Maybe<Scalars['ID']['output']>;
  group: ChurrosGroup;
  groupId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  links: Array<ChurrosLink>;
  /** L'identifiant local de la ressource (sans préfixe) */
  localID: Scalars['ChurrosLocalID']['output'];
  myReactions: Scalars['ChurrosBooleanMap']['output'];
  notifiedAt?: Maybe<Scalars['DateTime']['output']>;
  pictureFile: Scalars['String']['output'];
  /** Le nom du fichier de l'image, en thème sombre */
  pictureFileDark: Scalars['String']['output'];
  /** L'URL publique de l'image */
  pictureURL: Scalars['String']['output'];
  published: Scalars['Boolean']['output'];
  publishedAt: Scalars['DateTime']['output'];
  reacted: Scalars['Boolean']['output'];
  reactionCounts: Scalars['ChurrosCounts']['output'];
  reactions: Scalars['Int']['output'];
  /** Un nom lisible sans espaces, adaptés pour des URLs. */
  slug: Scalars['String']['output'];
  title: Scalars['String']['output'];
  /** @deprecated Use `slug` instead. This field was never universally unique. */
  uid: Scalars['String']['output'];
  visibility: ChurrosVisibility;
};


/** An article is a post in a group */
export type ChurrosArticlecommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** An article is a post in a group */
export type ChurrosArticlepictureURLArgs = {
  dark?: Scalars['Boolean']['input'];
};


/** An article is a post in a group */
export type ChurrosArticlereactedArgs = {
  emoji: Scalars['String']['input'];
};


/** An article is a post in a group */
export type ChurrosArticlereactionsArgs = {
  emoji: Scalars['String']['input'];
};

export type ChurrosArticleSearchResultType = {
  article: ChurrosArticle;
  highlightedTitle: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  rank?: Maybe<Scalars['Float']['output']>;
  similarity: Scalars['Float']['output'];
};

export type ChurrosAwaitingValidationError = {
  message: Scalars['String']['output'];
};

/** A bar week is a week during which some groups takeover the bar staff */
export type ChurrosBarWeek = ChurrosNode & {
  description: Scalars['String']['output'];
  descriptionHtml: Scalars['String']['output'];
  endsAt: Scalars['DateTime']['output'];
  groups: Array<ChurrosGroup>;
  id: Scalars['ID']['output'];
  /** L'identifiant local de la ressource (sans préfixe) */
  localID: Scalars['ChurrosLocalID']['output'];
  /** Un nom lisible sans espaces, adaptés pour des URLs. */
  slug: Scalars['String']['output'];
  startsAt: Scalars['DateTime']['output'];
  /** @deprecated Use `slug` instead. This field was never universally unique. */
  uid: Scalars['String']['output'];
};

export type ChurrosBuildInfo = {
  /** Le hash du commit utilisé pour build l'API */
  commit: Scalars['String']['output'];
  /** La version actuelle de l'API (et de l'application) */
  version: Scalars['String']['output'];
};

/** A release in the changelog */
export type ChurrosChangelogRelease = {
  /** The changes of the release, grouped by category */
  changes: ChurrosReleaseChangesMaps;
  /** The date of the release */
  date?: Maybe<Scalars['DateTime']['output']>;
  /** A short description of the release */
  description: Scalars['String']['output'];
  /** A short description of the release, in HTML. Safe from XSS. */
  descriptionHtml: Scalars['String']['output'];
  /** The version of the release */
  version: Scalars['String']['output'];
};

export type ChurrosComment = ChurrosNode & ChurrosReactable & {
  author?: Maybe<ChurrosUser>;
  authorId?: Maybe<Scalars['ID']['output']>;
  body: Scalars['String']['output'];
  bodyHtml: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  document?: Maybe<ChurrosDocument>;
  documentId?: Maybe<Scalars['ID']['output']>;
  id: Scalars['ID']['output'];
  inReplyTo?: Maybe<ChurrosComment>;
  inReplyToId?: Maybe<Scalars['ID']['output']>;
  /** L'identifiant local de la ressource (sans préfixe) */
  localID: Scalars['ChurrosLocalID']['output'];
  reacted: Scalars['Boolean']['output'];
  reactions: Scalars['Int']['output'];
  replies: Array<ChurrosComment>;
  updatedAt: Scalars['DateTime']['output'];
};


export type ChurrosCommentreactedArgs = {
  emoji: Scalars['String']['input'];
};


export type ChurrosCommentreactionsArgs = {
  emoji: Scalars['String']['input'];
};

/** Une resource pouvant être commentée par les utilisateur·ice·s */
export type ChurrosCommentable = {
  comments: ChurrosCommentsConnection;
  /** L’identifiant de la resource commentée */
  id: Scalars['ID']['output'];
};


/** Une resource pouvant être commentée par les utilisateur·ice·s */
export type ChurrosCommentablecommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type ChurrosCommentsConnection = {
  edges: Array<ChurrosCommentsEdge>;
  nodes: Array<ChurrosComment>;
  pageInfo: ChurrosPageInfo;
};

export type ChurrosCommentsEdge = {
  cursor: Scalars['String']['output'];
  node: ChurrosComment;
};

export type ChurrosCompleteSignupResult = ChurrosUser | ChurrosUserCandidate;

export type ChurrosContributionOption = {
  descriptionHtml: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  offeredIn: ChurrosSchool;
  paysFor: Array<ChurrosStudentAssociation>;
  price: Scalars['Float']['output'];
};

/** A credential is a way to authenticate a user */
export type ChurrosCredential = {
  active: Scalars['Boolean']['output'];
  createdAt: Scalars['DateTime']['output'];
  expiresAt?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  token: Scalars['String']['output'];
  type: ChurrosCredentialType;
  user: ChurrosUser;
  userAgent: Scalars['String']['output'];
};

export type ChurrosCredentialType =
  | 'Google'
  | 'Password'
  | 'Token';

export type ChurrosDatabaseHealthCheck = {
  prisma: Scalars['Boolean']['output'];
};

export type ChurrosDocument = ChurrosCommentable & ChurrosNode & ChurrosReactable & {
  comments: ChurrosCommentsConnection;
  createdAt: Scalars['DateTime']['output'];
  description: Scalars['String']['output'];
  descriptionHtml: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** L'identifiant local de la ressource (sans préfixe) */
  localID: Scalars['ChurrosLocalID']['output'];
  /** Liste de chemins vers les fichiers représentant le sujet (ou la fiche de révision) */
  paperPaths: Array<Scalars['String']['output']>;
  reacted: Scalars['Boolean']['output'];
  reactions: Scalars['Int']['output'];
  schoolYear: Scalars['Int']['output'];
  /** Un nom lisible sans espaces, adaptés pour des URLs. */
  slug: Scalars['String']['output'];
  /** Liste de chemins vers les fichiers représentant la correction. */
  solutionPaths: Array<Scalars['String']['output']>;
  subject?: Maybe<ChurrosSubject>;
  subjectId?: Maybe<Scalars['ID']['output']>;
  title: Scalars['String']['output'];
  type: ChurrosDocumentType;
  /** @deprecated Use `slug` instead. This field was never universally unique. */
  uid: Scalars['String']['output'];
  updatedAt: Scalars['DateTime']['output'];
  uploader?: Maybe<ChurrosUser>;
  uploaderId?: Maybe<Scalars['ID']['output']>;
};


export type ChurrosDocumentcommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ChurrosDocumentreactedArgs = {
  emoji: Scalars['String']['input'];
};


export type ChurrosDocumentreactionsArgs = {
  emoji: Scalars['String']['input'];
};

export type ChurrosDocumentSearchResult = {
  document: ChurrosDocument;
  id: Scalars['ID']['output'];
  rank?: Maybe<Scalars['Int']['output']>;
  similarity: Scalars['Float']['output'];
};

export type ChurrosDocumentType =
  | 'CourseNotes'
  | 'CourseSlides'
  | 'Exam'
  | 'Exercises'
  | 'GradedExercises'
  | 'Miscellaneous'
  | 'Practical'
  | 'PracticalExam'
  | 'Summary';

/** A email validation request */
export type ChurrosEmailChange = {
  createdAt: Scalars['DateTime']['output'];
  email: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  pending: Scalars['Boolean']['output'];
  updatedAt: Scalars['DateTime']['output'];
  user: ChurrosUser;
  userId: Scalars['ID']['output'];
};

/** The most basic error object, based on the base JavaScript Error object. */
export type ChurrosError = ChurrosErrorInterface & {
  message: Scalars['String']['output'];
};

/** Basic interface for all error types to implement. */
export type ChurrosErrorInterface = {
  message: Scalars['String']['output'];
};

export type ChurrosEvenSearchResult = {
  event: ChurrosEvent;
  highlightedTitle: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  rank?: Maybe<Scalars['Float']['output']>;
  similarity: Scalars['Float']['output'];
};

/** An event is a date, time and place, as well as an optional ticket */
export type ChurrosEvent = ChurrosNode & ChurrosPictured & ChurrosReactable & {
  articles: Array<ChurrosArticle>;
  author?: Maybe<ChurrosUser>;
  authorId?: Maybe<Scalars['ID']['output']>;
  bannedUsers: Array<ChurrosUser>;
  beneficiary?: Maybe<ChurrosLydiaAccount>;
  bookings: ChurrosEventBookingsConnection;
  bookingsCounts: ChurrosRegistrationsCounts;
  /** Renvoie un texte au format CSV contenant un export des réservations de l'évènement. */
  bookingsCsv: ChurrosEventBookingsCsvResult;
  /** L'utilisateur·ice connecté·e peut modifier cet évènement */
  canEdit: Scalars['Boolean']['output'];
  /** L'utilisateur·ice connecté·e peut ajouter, enlever ou modifier les droits des managers de cet évènement */
  canEditManagers: Scalars['Boolean']['output'];
  /** L'utilisateur·ice connecté·e peut scanner les réservations de cet évènement */
  canScanBookings: Scalars['Boolean']['output'];
  /** L'utilisateur·ice connecté·e peut voir les réservations de cet évènement */
  canSeeBookings: Scalars['Boolean']['output'];
  /** L'utilsateur·ice connecté·e peut voir les logs de cet évènement */
  canSeeLogs: Scalars['Boolean']['output'];
  capacity: Scalars['Int']['output'];
  coOrganizers: Array<ChurrosGroup>;
  contactMail: Scalars['String']['output'];
  description: Scalars['String']['output'];
  descriptionHtml: Scalars['String']['output'];
  descriptionPreview: Scalars['String']['output'];
  endsAt: Scalars['DateTime']['output'];
  /** Formulaires associés à l'événement */
  forms: Array<ChurrosForm>;
  frequency: ChurrosEventFrequency;
  group: ChurrosGroup;
  groupId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  /** Vrai si l'évènement doit apparaître dans le mode kiosque */
  includeInKiosk: Scalars['Boolean']['output'];
  links: Array<ChurrosLink>;
  /** L'identifiant local de la ressource (sans préfixe) */
  localID: Scalars['ChurrosLocalID']['output'];
  location: Scalars['String']['output'];
  /** Logs concernant cet évènement. Ne contient pas les logs concernant les réservations. */
  logs: ChurrosEventLogsConnection;
  lydiaAccountId?: Maybe<Scalars['ID']['output']>;
  managers: Array<ChurrosEventManager>;
  /** Réservations faites par et/ou pour l'utilisateur.ice connecté.e */
  myBookings: ChurrosEventMyBookingsResult;
  myReactions: Scalars['ChurrosBooleanMap']['output'];
  mySoonestShotgunOpensAt?: Maybe<Scalars['DateTime']['output']>;
  pictureFile: Scalars['String']['output'];
  /** Le nom du fichier de l'image, en thème sombre */
  pictureFileDark: Scalars['String']['output'];
  /** L'URL publique de l'image */
  pictureURL: Scalars['String']['output'];
  placesLeft?: Maybe<Scalars['Int']['output']>;
  profitsBreakdown: ChurrosProfitsBreakdown;
  reacted: Scalars['Boolean']['output'];
  reactionCounts: Scalars['ChurrosCounts']['output'];
  reactions: Scalars['Int']['output'];
  recurringUntil?: Maybe<Scalars['DateTime']['output']>;
  searchBookings: Array<ChurrosRegistrationSearchResult>;
  /** Vrai si le nombre de places restantes doit être affiché */
  showPlacesLeft: Scalars['Boolean']['output'];
  /** Un nom lisible sans espaces, adaptés pour des URLs. */
  slug: Scalars['String']['output'];
  startsAt: Scalars['DateTime']['output'];
  ticket?: Maybe<ChurrosTicket>;
  ticketGroups: Array<ChurrosTicketGroup>;
  tickets: Array<ChurrosTicket>;
  title: Scalars['String']['output'];
  /** @deprecated Use `slug` instead. This field was never universally unique. */
  uid: Scalars['String']['output'];
  visibility: ChurrosVisibility;
};


/** An event is a date, time and place, as well as an optional ticket */
export type ChurrosEventbookingsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** An event is a date, time and place, as well as an optional ticket */
export type ChurrosEventlogsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** An event is a date, time and place, as well as an optional ticket */
export type ChurrosEventpictureURLArgs = {
  dark?: Scalars['Boolean']['input'];
};


/** An event is a date, time and place, as well as an optional ticket */
export type ChurrosEventreactedArgs = {
  emoji: Scalars['String']['input'];
};


/** An event is a date, time and place, as well as an optional ticket */
export type ChurrosEventreactionsArgs = {
  emoji: Scalars['String']['input'];
};


/** An event is a date, time and place, as well as an optional ticket */
export type ChurrosEventsearchBookingsArgs = {
  q: Scalars['String']['input'];
};


/** An event is a date, time and place, as well as an optional ticket */
export type ChurrosEventticketArgs = {
  slug: Scalars['String']['input'];
};

export type ChurrosEventBookingsConnection = {
  edges: Array<ChurrosEventBookingsConnectionEdge>;
  nodes: Array<ChurrosRegistration>;
  pageInfo: ChurrosPageInfo;
};

export type ChurrosEventBookingsConnectionEdge = {
  cursor: Scalars['String']['output'];
  node: ChurrosRegistration;
};

export type ChurrosEventBookingsCsvResult = ChurrosError | ChurrosEventBookingsCsvSuccess;

export type ChurrosEventBookingsCsvSuccess = {
  data: Scalars['String']['output'];
};

export type ChurrosEventFrequency =
  | 'Biweekly'
  | 'Monthly'
  | 'Once'
  | 'Weekly';

export type ChurrosEventLogsConnection = {
  edges: Array<ChurrosEventLogsConnectionEdge>;
  nodes: Array<ChurrosLogEntry>;
  pageInfo: ChurrosPageInfo;
};

export type ChurrosEventLogsConnectionEdge = {
  cursor: Scalars['String']['output'];
  node: ChurrosLogEntry;
};

/** An event manager is a user that can scan tickets, and may be able to manage the event */
export type ChurrosEventManager = {
  canEdit: Scalars['Boolean']['output'];
  canEditPermissions: Scalars['Boolean']['output'];
  canVerifyRegistrations: Scalars['Boolean']['output'];
  event: ChurrosEvent;
  power: ChurrosEventManagerPowerLevel;
  user: ChurrosUser;
};

export type ChurrosEventManagerPowerLevel =
  | 'Edit'
  | 'EditPermissions'
  | 'ReadOnly'
  | 'ScanTickets';

export type ChurrosEventMyBookingsResult = ChurrosError | ChurrosEventMyBookingsSuccess;

export type ChurrosEventMyBookingsSuccess = {
  data: Array<ChurrosRegistration>;
};

export type ChurrosEventsByDay = {
  date: Scalars['DateTime']['output'];
  /** Évènements qui ont lieu (commencent) à ce jour */
  happening: Array<ChurrosEvent>;
  /** Évènements qui ont leur premier shotgun à ce jour */
  shotgunning: Array<ChurrosEvent>;
};

export type ChurrosFamilyTree = {
  nesting: Scalars['String']['output'];
  users: Array<ChurrosUser>;
};

/** Un formulaire */
export type ChurrosForm = ChurrosNode & {
  /** Nombre de réponses au formulaire */
  answerCount: Scalars['Int']['output'];
  /** Réponses au formulaire */
  answers: ChurrosFormAnswersConnection;
  /** Réponses au formulaire, groupées par utilisateur·ice. Ne contient pas de réponses dont l'utilisateur·ice est inconnu·e. */
  answersByUser: ChurrosFormAnswersByUserConnection;
  /** Export des réponses au formulaires dans un format */
  answersExport: Scalars['String']['output'];
  /** Indique si l'utilisateur peut répondre au formulaire. */
  canAnswer: Scalars['Boolean']['output'];
  /** Indique si l'utilisateur peut éditer le formulaire. */
  canEdit: Scalars['Boolean']['output'];
  /** Indique si l'utilisateur·ice peut modifier ses réponses au formulaire. */
  canModifyAnswers: Scalars['Boolean']['output'];
  /** Indique si l'utilisateur peut voir les statistiques des réponses au formulaire. */
  canSeeAnswerStats: Scalars['Boolean']['output'];
  /** Indique si l'utilisateur peut voir les réponses au formulaire. */
  canSeeAnswers: Scalars['Boolean']['output'];
  /** Indique si l'utilisateur peut cocher ou décocher les cases à cocher à côté des réponses au formulaire. */
  canSetCheckboxes: Scalars['Boolean']['output'];
  checkboxesAreEnabled: Scalars['Boolean']['output'];
  /** Date de fermeture du formulaire. */
  closesAt?: Maybe<Scalars['DateTime']['output']>;
  /** Date de création du formulaire */
  createdAt: Scalars['DateTime']['output'];
  /** Utilisateur ayant créé le formulaire */
  createdBy?: Maybe<ChurrosUser>;
  /** Description en Markdown du formulaire. */
  description?: Maybe<Scalars['String']['output']>;
  /** Description en HTML du formulaire. */
  descriptionHtml: Scalars['String']['output'];
  /** Événement associé au formulaire */
  event?: Maybe<ChurrosEvent>;
  /** Groupe auquel le formulaire est associé */
  group?: Maybe<ChurrosGroup>;
  /** Vrai si le formulaire comporte des sections */
  hasSections: Scalars['Boolean']['output'];
  /** Préfixe de l'identifiant: `form:` */
  id: Scalars['ID']['output'];
  /** L'URL du Google Sheet des réponses lié à ce formulaire. Voir `createLinkedGoogleSheet` pour créer un Google Sheet lié au formulaire. */
  linkedGoogleSheetUrl?: Maybe<Scalars['String']['output']>;
  /** L'identifiant local de la ressource (sans préfixe) */
  localID: Scalars['ChurrosLocalID']['output'];
  /** Identifiant local du formulaire */
  localId: Scalars['String']['output'];
  /** Réponses de l'utilisateur·ice connecté·e à ce formulaire */
  myAnswers: Array<ChurrosAnswer>;
  /** Date d'ouverture du formulaire. */
  opensAt?: Maybe<Scalars['DateTime']['output']>;
  /** Questions du formulaire. Liste de toutes les questions, peut importe la section dans laquelle elles se trouvent. */
  questions: ChurrosFormQuestionsConnection;
  searchAnswers: Array<ChurrosAnswerSearchResult>;
  /** Une section du formulaire. */
  section: ChurrosFormSection;
  /** Sections du formulaire. Un formulaire contient toujours au moins une section (sauf s'il n'y a aucune question). Uniquement accessible par celleux qui peuvent modifier le formulaire. Utiliser `nextSection` pour afficher une section dans le but d'y répondre. */
  sections: Array<ChurrosFormSection>;
  title: Scalars['String']['output'];
  /** Date de dernière mise à jour du formulaire */
  updatedAt: Scalars['DateTime']['output'];
  /** Visibilité du formulaire */
  visibility: ChurrosVisibility;
};


/** Un formulaire */
export type ChurrosFormanswersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Un formulaire */
export type ChurrosFormanswersByUserArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
};


/** Un formulaire */
export type ChurrosFormanswersExportArgs = {
  format?: ChurrosAnswersExportFormats;
};


/** Un formulaire */
export type ChurrosFormquestionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Un formulaire */
export type ChurrosFormsearchAnswersArgs = {
  q: Scalars['String']['input'];
  similarityCutoff?: InputMaybe<Scalars['Float']['input']>;
};


/** Un formulaire */
export type ChurrosFormsectionArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
};

export type ChurrosFormAnswersByUserConnection = {
  edges: Array<ChurrosFormAnswersByUserConnectionEdge>;
  nodes: Array<ChurrosAnswersOfUser>;
  pageInfo: ChurrosPageInfo;
};

export type ChurrosFormAnswersByUserConnectionEdge = {
  cursor: Scalars['String']['output'];
  node: ChurrosAnswersOfUser;
};

export type ChurrosFormAnswersConnection = {
  edges: Array<ChurrosFormAnswersConnectionEdge>;
  nodes: Array<ChurrosAnswer>;
  pageInfo: ChurrosPageInfo;
};

export type ChurrosFormAnswersConnectionEdge = {
  cursor: Scalars['String']['output'];
  node: ChurrosAnswer;
};

export type ChurrosFormQuestionsConnection = {
  edges: Array<ChurrosFormQuestionsConnectionEdge>;
  nodes: Array<ChurrosQuestion>;
  pageInfo: ChurrosPageInfo;
};

export type ChurrosFormQuestionsConnectionEdge = {
  cursor: Scalars['String']['output'];
  node: ChurrosQuestion;
};

export type ChurrosFormSearchResult = {
  form: ChurrosForm;
  highlightedDescription: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  rank?: Maybe<Scalars['Float']['output']>;
  similarity: Scalars['Float']['output'];
};

/** Une section d'un formulaire. Les sections sont utiles pour séparer les questions en plusieurs parties, dont certaines peuvent être affichées selon des réponses à des questions précédentes */
export type ChurrosFormSection = {
  /** Réponses à cette section */
  answers: ChurrosFormSectionAnswersConnection;
  /** Description en Markdown de la section */
  description: Scalars['String']['output'];
  /** Description en HTML de la section */
  descriptionHtml: Scalars['String']['output'];
  /** Formulaire auquel appartient la section */
  form: ChurrosForm;
  id: Scalars['ID']['output'];
  /** Identifiant local de la section du formulaire */
  localId: Scalars['String']['output'];
  /** Section suivante dans le formulaire, si il y en a une. (Sinon, c'est que c'est la dernière section). Dépend du fait que des sections soit cachées à l'utilisateur (voir `restrictedToGroups`), ou que une répond à une question provoque le passaage à une autre section (voir `goToSection`)  */
  nextSection?: Maybe<ChurrosFormSection>;
  /** Ordre de la section dans le formulaire */
  order: Scalars['Int']['output'];
  /** Questions dans section */
  questions: Array<ChurrosQuestion>;
  /** Si non vide, seul·e·s les membres des groupes spécifiés peuvent accéder à cette section.  */
  restrictedToGroups: Array<ChurrosGroup>;
  /** Titre de la section */
  title: Scalars['String']['output'];
};


/** Une section d'un formulaire. Les sections sont utiles pour séparer les questions en plusieurs parties, dont certaines peuvent être affichées selon des réponses à des questions précédentes */
export type ChurrosFormSectionanswersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type ChurrosFormSectionAnswersConnection = {
  edges: Array<ChurrosFormSectionAnswersConnectionEdge>;
  nodes: Array<ChurrosAnswer>;
  pageInfo: ChurrosPageInfo;
};

export type ChurrosFormSectionAnswersConnectionEdge = {
  cursor: Scalars['String']['output'];
  node: ChurrosAnswer;
};

/** Requests to become someone's godchild. Gets deleted once the request has been accepted (or denied). godchild is the requester, godparent is the requested. */
export type ChurrosGodparentRequest = {
  createdAt: Scalars['DateTime']['output'];
  godchild: ChurrosUser;
  godparent: ChurrosUser;
  id: Scalars['ID']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

/** A group is a collection of users */
export type ChurrosGroup = ChurrosNode & ChurrosPictured & {
  address: Scalars['String']['output'];
  /** All the ancestors of this group, from the current group to the root. */
  ancestors: Array<ChurrosGroup>;
  articles: Array<ChurrosArticle>;
  boardMembers: Array<ChurrosGroupMember>;
  /** Vrai si l'utilisateur·ice connecté·e peut modifier les informations du groupe */
  canEditDetails: Scalars['Boolean']['output'];
  /** L'utilisateur·ice connecté·e peut éditer (créer ou modifier) les pages du groupe */
  canEditPages: Scalars['Boolean']['output'];
  /** L'utilisateur·ice connecté·e peut lister les pages du groupe */
  canListPages: Scalars['Boolean']['output'];
  children: Array<ChurrosGroup>;
  coOrganizedEvents: Array<ChurrosEvent>;
  color: Scalars['String']['output'];
  description: Scalars['String']['output'];
  email: Scalars['String']['output'];
  events: ChurrosGroupEventsConnection;
  familyChildren: Array<ChurrosGroup>;
  /** Helper field to get a whole tree without processing all groups\nTo be set to the group's id itself for root groups. */
  familyId?: Maybe<Scalars['ID']['output']>;
  /** Formulaires associés au groupe */
  forms: Array<ChurrosForm>;
  groupId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  ldapUid: Scalars['String']['output'];
  links: Array<ChurrosLink>;
  /** L'identifiant local de la ressource (sans préfixe) */
  localID: Scalars['ChurrosLocalID']['output'];
  longDescription: Scalars['String']['output'];
  longDescriptionHtml: Scalars['String']['output'];
  /** Comptes Lydia du groupe */
  lydiaAccounts: Array<ChurrosLydiaAccount>;
  mailingList: Scalars['String']['output'];
  members: Array<ChurrosGroupMember>;
  name: Scalars['String']['output'];
  ownEvents: Array<ChurrosEvent>;
  /** La page associée au groupe */
  page?: Maybe<ChurrosPage>;
  /** Les pages associées au groupe */
  pages: ChurrosPagesConnection;
  /** Parent group, from which this group inherits its permissions */
  parent?: Maybe<ChurrosGroup>;
  parentId?: Maybe<Scalars['ID']['output']>;
  pictureFile: Scalars['String']['output'];
  pictureFileDark: Scalars['String']['output'];
  /** L'URL publique de l'image */
  pictureURL: Scalars['String']['output'];
  president?: Maybe<ChurrosGroupMember>;
  /** Related clubs */
  related: Array<ChurrosGroup>;
  roomIsOpen: Scalars['Boolean']['output'];
  /** Family root, only created for performance reasons */
  root?: Maybe<ChurrosGroup>;
  secretaries: Array<ChurrosGroupMember>;
  selfJoinable: Scalars['Boolean']['output'];
  services: Array<ChurrosService>;
  /** Article de la boutique du groupe */
  shopItem?: Maybe<ChurrosShopItem>;
  shopItems: ChurrosGroupShopItemsConnection;
  shopOrders: Array<ChurrosShopPayment>;
  studentAssociation?: Maybe<ChurrosStudentAssociation>;
  treasurers: Array<ChurrosGroupMember>;
  type: ChurrosGroupType;
  uid: Scalars['String']['output'];
  vicePresidents: Array<ChurrosGroupMember>;
  website: Scalars['String']['output'];
};


/** A group is a collection of users */
export type ChurrosGroupeventsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A group is a collection of users */
export type ChurrosGrouppageArgs = {
  path: Scalars['String']['input'];
};


/** A group is a collection of users */
export type ChurrosGrouppagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A group is a collection of users */
export type ChurrosGrouppictureURLArgs = {
  dark?: Scalars['Boolean']['input'];
};


/** A group is a collection of users */
export type ChurrosGroupshopItemArgs = {
  id: Scalars['ChurrosLocalID']['input'];
};


/** A group is a collection of users */
export type ChurrosGroupshopItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type ChurrosGroupEventsConnection = {
  edges: Array<ChurrosGroupEventsConnectionEdge>;
  nodes: Array<ChurrosEvent>;
  pageInfo: ChurrosPageInfo;
};

export type ChurrosGroupEventsConnectionEdge = {
  cursor: Scalars['String']['output'];
  node: ChurrosEvent;
};

/** The intermediate model between users and groups */
export type ChurrosGroupMember = {
  canEditArticles: Scalars['Boolean']['output'];
  canEditMembers: Scalars['Boolean']['output'];
  canScanEvents: Scalars['Boolean']['output'];
  createdAt: Scalars['DateTime']['output'];
  group: ChurrosGroup;
  groupId: Scalars['ID']['output'];
  isDeveloper: Scalars['Boolean']['output'];
  member: ChurrosUser;
  memberId: Scalars['ID']['output'];
  president: Scalars['Boolean']['output'];
  secretary: Scalars['Boolean']['output'];
  title: Scalars['String']['output'];
  treasurer: Scalars['Boolean']['output'];
  vicePresident: Scalars['Boolean']['output'];
};

export type ChurrosGroupSearchResult = {
  group: ChurrosGroup;
  highlightedDescription: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  rank?: Maybe<Scalars['Float']['output']>;
  similarity: Scalars['Float']['output'];
};

export type ChurrosGroupShopItemsConnection = {
  edges: Array<ChurrosGroupShopItemsConnectionEdge>;
  nodes: Array<ChurrosShopItem>;
  pageInfo: ChurrosPageInfo;
};

export type ChurrosGroupShopItemsConnectionEdge = {
  cursor: Scalars['String']['output'];
  node: ChurrosShopItem;
};

export type ChurrosGroupType =
  | 'Association'
  | 'Club'
  | 'Group'
  | 'Integration'
  | 'List'
  | 'StudentAssociationSection';

/** Results of a health self-check */
export type ChurrosHealthCheck = {
  database: ChurrosDatabaseHealthCheck;
  ldap: ChurrosLdapHealthCheck;
  mail: ChurrosMailHealthCheck;
  redis: ChurrosRedisHealthCheck;
};

/** A Gitlab issue */
export type ChurrosIssue = {
  body: Scalars['String']['output'];
  bodyHtml: Scalars['String']['output'];
  comments: Array<ChurrosIssueComment>;
  deployedIn: Scalars['String']['output'];
  /** Expressed from 0 to 1 */
  difficulty?: Maybe<Scalars['Float']['output']>;
  duplicatedFrom?: Maybe<Scalars['Int']['output']>;
  /** Expressed from 0 to 1 */
  importance?: Maybe<Scalars['Float']['output']>;
  number: Scalars['Int']['output'];
  state: ChurrosIssueState;
  /** The date at which the issue was submitted */
  submittedAt: Scalars['DateTime']['output'];
  title: Scalars['String']['output'];
  url: Scalars['String']['output'];
};

/** A Gitlab issue comment */
export type ChurrosIssueComment = {
  /** The date at which the comment was added */
  addedAt: Scalars['DateTime']['output'];
  authorAvatarUrl: Scalars['String']['output'];
  authorGitlabUrl: Scalars['String']['output'];
  authorName: Scalars['String']['output'];
  body: Scalars['String']['output'];
  bodyHtml: Scalars['String']['output'];
};

export type ChurrosIssueState =
  | 'Closed'
  | 'Deployed'
  | 'Open';

export type ChurrosLdapHealthCheck = {
  /** Whether the LDAP internal client is ready */
  internal: Scalars['Boolean']['output'];
  /** Whether the LDAP school client is ready */
  school: Scalars['Boolean']['output'];
};

/** A single external link */
export type ChurrosLink = ChurrosNode & {
  computedValue: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  /** L'identifiant local de la ressource (sans préfixe) */
  localID: Scalars['ChurrosLocalID']['output'];
  name: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type ChurrosLinkInput = {
  name: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

/** A log entry is a log of an action that happened on the website */
export type ChurrosLogEntry = ChurrosNode & {
  action: Scalars['String']['output'];
  area: Scalars['String']['output'];
  happenedAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  /** L'identifiant local de la ressource (sans préfixe) */
  localID: Scalars['ChurrosLocalID']['output'];
  message: Scalars['String']['output'];
  target?: Maybe<Scalars['String']['output']>;
  user?: Maybe<ChurrosUser>;
};

export type ChurrosLogoSourceType =
  | 'ExternalLink'
  | 'GroupLogo'
  | 'Icon'
  | 'InternalLink';

/** A Lydia account */
export type ChurrosLydiaAccount = {
  events: Array<ChurrosEvent>;
  group?: Maybe<ChurrosGroup>;
  groupId?: Maybe<Scalars['ID']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  studentAssociation?: Maybe<ChurrosStudentAssociation>;
  studentAssociationId?: Maybe<Scalars['ID']['output']>;
};

export type ChurrosMailHealthCheck = {
  /** Whether the SMTP client is ready */
  smtp: Scalars['Boolean']['output'];
};

/** A school syllabus */
export type ChurrosMajor = {
  id: Scalars['ID']['output'];
  ldapSchool?: Maybe<ChurrosSchool>;
  minors: Array<ChurrosMinor>;
  name: Scalars['String']['output'];
  schools: Array<ChurrosSchool>;
  shortName: Scalars['String']['output'];
  subjects: Array<ChurrosSubject>;
  uid: Scalars['String']['output'];
};


/** A school syllabus */
export type ChurrosMajorsubjectsArgs = {
  forApprentices?: InputMaybe<Scalars['Boolean']['input']>;
  yearTier?: InputMaybe<Scalars['Int']['input']>;
};

export type ChurrosManagerOfEventInput = {
  canEdit: Scalars['Boolean']['input'];
  canEditPermissions: Scalars['Boolean']['input'];
  canVerifyRegistrations: Scalars['Boolean']['input'];
  userUid: Scalars['String']['input'];
};

export type ChurrosMinor = ChurrosNode & {
  id: Scalars['ID']['output'];
  /** L'identifiant local de la ressource (sans préfixe) */
  localID: Scalars['ChurrosLocalID']['output'];
  majors: Array<ChurrosMajor>;
  name: Scalars['String']['output'];
  shortName: Scalars['String']['output'];
  /** Un nom lisible sans espaces, adaptés pour des URLs. */
  slug: Scalars['String']['output'];
  subjects: Array<ChurrosSubject>;
  /** @deprecated Use `slug` instead. This field was never universally unique. */
  uid: Scalars['String']['output'];
  users: Array<ChurrosUser>;
  yearTier: Scalars['Int']['output'];
};

export type ChurrosMutationAcceptRegistrationResult = ChurrosError | ChurrosMutationAcceptRegistrationSuccess;

export type ChurrosMutationAcceptRegistrationSuccess = {
  data: ChurrosUser;
};

export type ChurrosMutationAddFileToPageResult = ChurrosError | ChurrosMutationAddFileToPageSuccess | ChurrosZodError;

export type ChurrosMutationAddFileToPageSuccess = {
  data: ChurrosPage;
};

export type ChurrosMutationAddGroupMemberResult = ChurrosError | ChurrosMutationAddGroupMemberSuccess;

export type ChurrosMutationAddGroupMemberSuccess = {
  data: ChurrosGroupMember;
};

export type ChurrosMutationAnswerFormSectionResult = ChurrosError | ChurrosMutationAnswerFormSectionSuccess;

export type ChurrosMutationAnswerFormSectionSuccess = {
  data: Array<ChurrosAnswer>;
};

export type ChurrosMutationAuthorizeResult = ChurrosError | ChurrosMutationAuthorizeSuccess | ChurrosOAuth2Error;

export type ChurrosMutationAuthorizeSuccess = {
  data: Scalars['String']['output'];
};

export type ChurrosMutationCancelRegistrationResult = ChurrosError | ChurrosMutationCancelRegistrationSuccess;

export type ChurrosMutationCancelRegistrationSuccess = {
  data: Scalars['Boolean']['output'];
};

export type ChurrosMutationCompleteRegistrationResult = ChurrosError | ChurrosMutationCompleteRegistrationSuccess | ChurrosZodError;

export type ChurrosMutationCompleteRegistrationSuccess = {
  data: ChurrosCompleteSignupResult;
};

export type ChurrosMutationContributeResult = ChurrosError | ChurrosMutationContributeSuccess;

export type ChurrosMutationContributeSuccess = {
  data: Scalars['Boolean']['output'];
};

export type ChurrosMutationCreatePasswordResetResult = ChurrosError | ChurrosMutationCreatePasswordResetSuccess;

export type ChurrosMutationCreatePasswordResetSuccess = {
  data: Scalars['Boolean']['output'];
};

export type ChurrosMutationDeletePageResult = ChurrosError | ChurrosMutationDeletePageSuccess | ChurrosZodError;

export type ChurrosMutationDeletePageSuccess = {
  data: ChurrosPage;
};

export type ChurrosMutationDeleteShopItemResult = ChurrosError | ChurrosMutationDeleteShopItemSuccess;

export type ChurrosMutationDeleteShopItemSuccess = {
  data: Scalars['Boolean']['output'];
};

export type ChurrosMutationFinishPaypalRegistrationPaymentResult = ChurrosError | ChurrosMutationFinishPaypalRegistrationPaymentSuccess;

export type ChurrosMutationFinishPaypalRegistrationPaymentSuccess = {
  data: Scalars['Boolean']['output'];
};

export type ChurrosMutationLoginResult = ChurrosAwaitingValidationError | ChurrosError | ChurrosMutationLoginSuccess;

export type ChurrosMutationLoginSuccess = {
  data: ChurrosCredential;
};

export type ChurrosMutationMailFormAnswersResult = ChurrosError | ChurrosMutationMailFormAnswersSuccess;

export type ChurrosMutationMailFormAnswersSuccess = {
  data: Scalars['String']['output'];
};

export type ChurrosMutationOpposeRegistrationResult = ChurrosError | ChurrosMutationOpposeRegistrationSuccess;

export type ChurrosMutationOpposeRegistrationSuccess = {
  data: Scalars['Boolean']['output'];
};

export type ChurrosMutationPaidRegistrationResult = ChurrosError | ChurrosMutationPaidRegistrationSuccess;

export type ChurrosMutationPaidRegistrationSuccess = {
  data: Scalars['String']['output'];
};

export type ChurrosMutationPaidShopPaymentResult = ChurrosError | ChurrosMutationPaidShopPaymentSuccess;

export type ChurrosMutationPaidShopPaymentSuccess = {
  data: ChurrosShopPayment;
};

export type ChurrosMutationRegisterGoogleCredentialResult = ChurrosError | ChurrosMutationRegisterGoogleCredentialSuccess;

export type ChurrosMutationRegisterGoogleCredentialSuccess = {
  data: Scalars['Boolean']['output'];
};

export type ChurrosMutationRemoveFileFromPageResult = ChurrosError | ChurrosMutationRemoveFileFromPageSuccess | ChurrosZodError;

export type ChurrosMutationRemoveFileFromPageSuccess = {
  data: ChurrosPage;
};

export type ChurrosMutationRequestEmailChangeResult = ChurrosError | ChurrosMutationRequestEmailChangeSuccess;

export type ChurrosMutationRequestEmailChangeSuccess = {
  data: Scalars['Boolean']['output'];
};

export type ChurrosMutationResetPasswordResult = ChurrosError | ChurrosMutationResetPasswordSuccess;

export type ChurrosMutationResetPasswordSuccess = {
  data: Scalars['Boolean']['output'];
};

export type ChurrosMutationStartRegistrationResult = ChurrosError | ChurrosMutationStartRegistrationSuccess | ChurrosZodError;

export type ChurrosMutationStartRegistrationSuccess = {
  data: Scalars['Boolean']['output'];
};

export type ChurrosMutationUpdateUserCandidateResult = ChurrosError | ChurrosMutationUpdateUserCandidateSuccess | ChurrosZodError;

export type ChurrosMutationUpdateUserCandidateSuccess = {
  data: Scalars['Boolean']['output'];
};

export type ChurrosMutationUpdateUserResult = ChurrosError | ChurrosMutationUpdateUserSuccess;

export type ChurrosMutationUpdateUserSuccess = {
  data: ChurrosUser;
};

export type ChurrosMutationUpsertAnnouncementResult = ChurrosError | ChurrosMutationUpsertAnnouncementSuccess | ChurrosZodError;

export type ChurrosMutationUpsertAnnouncementSuccess = {
  data: ChurrosAnnouncement;
};

export type ChurrosMutationUpsertArticleResult = ChurrosError | ChurrosMutationUpsertArticleSuccess | ChurrosZodError;

export type ChurrosMutationUpsertArticleSuccess = {
  data: ChurrosArticle;
};

export type ChurrosMutationUpsertBarWeekResult = ChurrosError | ChurrosMutationUpsertBarWeekSuccess;

export type ChurrosMutationUpsertBarWeekSuccess = {
  data: ChurrosBarWeek;
};

export type ChurrosMutationUpsertDocumentResult = ChurrosError | ChurrosMutationUpsertDocumentSuccess;

export type ChurrosMutationUpsertDocumentSuccess = {
  data: ChurrosDocument;
};

export type ChurrosMutationUpsertEventResult = ChurrosError | ChurrosMutationUpsertEventSuccess;

export type ChurrosMutationUpsertEventSuccess = {
  data: ChurrosEvent;
};

export type ChurrosMutationUpsertFormInput = {
  closesAt?: InputMaybe<Scalars['DateTime']['input']>;
  description?: Scalars['String']['input'];
  /** Identifiant de l'événement à associer au formulaire */
  eventId?: InputMaybe<Scalars['ID']['input']>;
  /** UID du groupe auquel le formulaire est associé. */
  group?: InputMaybe<Scalars['String']['input']>;
  /** Identifiant du formulaire à mettre à jour. Si non fourni, un nouveau formulaire sera créé. */
  id?: InputMaybe<Scalars['ID']['input']>;
  opensAt?: InputMaybe<Scalars['DateTime']['input']>;
  title: Scalars['String']['input'];
  visibility?: ChurrosVisibility;
};

export type ChurrosMutationUpsertFormSectionInput = {
  description?: Scalars['String']['input'];
  /** Identifiant du formulaire auquel associer la section. Il n'es pas possible de changer le formulaire auquel une section est associée, si id est fourni, ce paramètre est ignoré. L'ID peut être local */
  formId: Scalars['String']['input'];
  /** Identifiant de la section à mettre à jour. Si non fourni, une nouvelle section sera créée. */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** Position de la section dans le formulaire. Si non spécifié, la section est ajoutée à la fin du formulaire */
  order?: InputMaybe<Scalars['Int']['input']>;
  title: Scalars['String']['input'];
};

export type ChurrosMutationUpsertGodparentRequestResult = ChurrosError | ChurrosMutationUpsertGodparentRequestSuccess;

export type ChurrosMutationUpsertGodparentRequestSuccess = {
  data: ChurrosGodparentRequest;
};

export type ChurrosMutationUpsertGroupResult = ChurrosError | ChurrosMutationUpsertGroupSuccess | ChurrosZodError;

export type ChurrosMutationUpsertGroupSuccess = {
  data: ChurrosGroup;
};

export type ChurrosMutationUpsertPageResult = ChurrosError | ChurrosMutationUpsertPageSuccess | ChurrosZodError;

export type ChurrosMutationUpsertPageSuccess = {
  data: ChurrosPage;
};

export type ChurrosMutationUpsertQuestionInput = {
  /** Indique si la question doit avoir une option "Autre" */
  allowOptionOther?: Scalars['Boolean']['input'];
  /** Types de fichiers autorisés pour les questions de type `FileUpload` */
  allowedFiletypes?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Indique si les réponses à la question sont anonymes */
  anonymous: Scalars['Boolean']['input'];
  /** Valeur par défaut de la question. Voir `AnswerInput.answer` pour le format. */
  default?: Array<Scalars['String']['input']>;
  description?: Scalars['String']['input'];
  /** Identifiant du formulaire auquel associer la question. Il n'es pas possible de changer le formulaire auquel une question est associée, si id est fourni, ce paramètre est ignoré. */
  formId?: InputMaybe<Scalars['ID']['input']>;
  /** Identifiant de la question à mettre à jour. Si non fourni, une nouvelle question sera créée. */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** Indique si la question est obligatoire */
  mandatory: Scalars['Boolean']['input'];
  options?: InputMaybe<Array<ChurrosQuestionOptionInput>>;
  /** Position de la question dans la section. Si non spécifié, rajoute la question à la fin de la section. */
  order?: InputMaybe<Scalars['Int']['input']>;
  scale?: InputMaybe<ChurrosQuestionScaleInput>;
  /** Identifiant de la section de formulaire à laquelle associer la question. Si non fourni, la question est rajoutée à une section à titre vide, qui est créée au besoin. Pratique pour les formulaires plus simples sans section. */
  sectionId?: InputMaybe<Scalars['ID']['input']>;
  title: Scalars['String']['input'];
  type: ChurrosQuestionKind;
};

export type ChurrosMutationUpsertRegistrationResult = ChurrosError | ChurrosMutationUpsertRegistrationSuccess;

export type ChurrosMutationUpsertRegistrationSuccess = {
  data: ChurrosRegistration;
};

export type ChurrosMutationUpsertServiceResult = ChurrosError | ChurrosMutationUpsertServiceSuccess;

export type ChurrosMutationUpsertServiceSuccess = {
  data: ChurrosService;
};

export type ChurrosMutationUpsertShopItemResult = ChurrosError | ChurrosMutationUpsertShopItemSuccess;

export type ChurrosMutationUpsertShopItemSuccess = {
  data: ChurrosShopItem;
};

export type ChurrosMutationUpsertShopPaymentResult = ChurrosError | ChurrosMutationUpsertShopPaymentSuccess;

export type ChurrosMutationUpsertShopPaymentSuccess = {
  data: ChurrosShopPayment;
};

export type ChurrosMutationUsePasswordResetResult = ChurrosError | ChurrosMutationUsePasswordResetSuccess;

export type ChurrosMutationUsePasswordResetSuccess = {
  data: Scalars['Boolean']['output'];
};

export type ChurrosMutationValidateEmailResult = ChurrosError | ChurrosMutationValidateEmailSuccess;

export type ChurrosMutationValidateEmailSuccess = {
  data: Scalars['Boolean']['output'];
};

export type ChurrosMutationVerifyBookingResult = ChurrosError | ChurrosMutationVerifyBookingSuccess;

export type ChurrosMutationVerifyBookingSuccess = {
  data: ChurrosRegistrationVerificationResult;
};

export type ChurrosNode = {
  id: Scalars['ID']['output'];
  /** L'identifiant local de la ressource (sans préfixe) */
  localID: Scalars['ChurrosLocalID']['output'];
};

/** An error raised when a resource does not exist. */
export type ChurrosNotFoundError = ChurrosErrorInterface & {
  message: Scalars['String']['output'];
};

/** A notification is a push notification that was sent to a user */
export type ChurrosNotification = ChurrosNode & {
  actions: Array<ChurrosLink>;
  body: Scalars['String']['output'];
  channel: ChurrosNotificationChannel;
  createdAt: Scalars['DateTime']['output'];
  goto: Scalars['String']['output'];
  group?: Maybe<ChurrosGroup>;
  groupId?: Maybe<Scalars['ID']['output']>;
  id: Scalars['ID']['output'];
  imageFile: Scalars['String']['output'];
  /** L'identifiant local de la ressource (sans préfixe) */
  localID: Scalars['ChurrosLocalID']['output'];
  subscription: ChurrosNotificationSubscription;
  subscriptionId: Scalars['ID']['output'];
  timestamp?: Maybe<Scalars['DateTime']['output']>;
  title: Scalars['String']['output'];
  updatedAt: Scalars['DateTime']['output'];
  vibrate: Array<Scalars['Int']['output']>;
};

export type ChurrosNotificationChannel =
  | 'Articles'
  | 'Comments'
  | 'GodparentRequests'
  | 'GroupBoard'
  | 'Other'
  | 'Permissions'
  | 'Shotguns';

/** A NotificationSubscription stores a user's subscription to push notifications on a user agent */
export type ChurrosNotificationSubscription = {
  createdAt: Scalars['DateTime']['output'];
  endpoint: Scalars['String']['output'];
  expiresAt?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  owner: ChurrosUser;
  ownerId: Scalars['ID']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

export type ChurrosNotificationSubscriptionKeysInput = {
  auth: Scalars['String']['input'];
  p256dh: Scalars['String']['input'];
};

export type ChurrosOAuth2Error = {
  code: ChurrosOAuth2ErrorCode;
  message: Scalars['String']['output'];
};

/** OAuth2 error codes, see RFC 6749 § 4.1.2.1 */
export type ChurrosOAuth2ErrorCode =
  | 'access_denied'
  | 'invalid_request'
  | 'invalid_scope'
  | 'server_error'
  | 'temporarily_unavailable'
  | 'unauthorized_client'
  | 'unsupported_response_type';

/** Une page écrite par un·e utilisateur·rice, servant par exemple à présenter les partenariats d'une AE sur une page dédiée. */
export type ChurrosPage = {
  /** Contenu de la page. Supporte la syntaxe Markdown. */
  body: Scalars['String']['output'];
  /** Contenu de la page, converti en HTML. Protégé contre les attaques XSS. */
  bodyHtml: Scalars['String']['output'];
  /** L'utilisateur·ice connecté·e peut modifier ou supprimer cette page */
  canBeEdited: Scalars['Boolean']['output'];
  createdAt: Scalars['DateTime']['output'];
  /** Chemin vers les fichiers inclus sur la page, par exmple des images. Voir filesURLs pour obtenir les URLs de ces fichiers. */
  files: Array<Scalars['String']['output']>;
  /** URLs vers les fichiers inclus sur la page. */
  filesURLs: Array<Scalars['String']['output']>;
  /** Groupe auquel appartient la page. Peut être null si la page n'appartient à aucun groupe. */
  group?: Maybe<ChurrosGroup>;
  id: Scalars['ID']['output'];
  /** Dernier·ère utilisateur·rice ayant modifié la page. Peut être null si la page n'a jamais été modifiée, ou que l'utilisateur·ice en question a été supprimé·e. */
  lastAuthor?: Maybe<ChurrosUser>;
  /** Chemin vers la page. Doit être unique _par AE ou groupe_. L'URL finale sera donc préfixée d'une certaine manière pour éviter les collisions. */
  path: Scalars['String']['output'];
  /** Association étudiante à laquelle appartient la page. Peut être null si la page n'appartient à aucune association. */
  studentAssociation?: Maybe<ChurrosStudentAssociation>;
  /** Titre de la page. */
  title: Scalars['String']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

export type ChurrosPageInfo = {
  endCursor?: Maybe<Scalars['String']['output']>;
  hasNextPage: Scalars['Boolean']['output'];
  hasPreviousPage: Scalars['Boolean']['output'];
  startCursor?: Maybe<Scalars['String']['output']>;
};

export type ChurrosPagesConnection = {
  edges: Array<ChurrosPagesEdge>;
  nodes: Array<ChurrosPage>;
  pageInfo: ChurrosPageInfo;
};

export type ChurrosPagesEdge = {
  cursor: Scalars['String']['output'];
  node: ChurrosPage;
};

export type ChurrosPaymentMethod =
  | 'Card'
  | 'Cash'
  | 'Check'
  | 'Lydia'
  | 'Other'
  | 'PayPal'
  | 'Transfer';

export type ChurrosPicture = {
  id: Scalars['ID']['output'];
  path: Scalars['String']['output'];
  position: Scalars['Int']['output'];
};

/** Une ressource qui possède une image associée */
export type ChurrosPictured = {
  /** Le nom du fichier de l'image */
  pictureFile: Scalars['String']['output'];
  /** Le nom du fichier de l'image, en thème sombre */
  pictureFileDark: Scalars['String']['output'];
  /** L'URL publique de l'image */
  pictureURL: Scalars['String']['output'];
};


/** Une ressource qui possède une image associée */
export type ChurrosPicturedpictureURLArgs = {
  dark?: Scalars['Boolean']['input'];
};

export type ChurrosProfitsBreakdown = {
  byPaymentMethod: ChurrosProfitsBreakdownByPaymentMethod;
  byTicket: Array<ChurrosProfitsBreakdownByTicket>;
  total: Scalars['Float']['output'];
};

export type ChurrosProfitsBreakdownByPaymentMethod = {
  Card: Scalars['Float']['output'];
  Cash: Scalars['Float']['output'];
  Check: Scalars['Float']['output'];
  Lydia: Scalars['Float']['output'];
  Other: Scalars['Float']['output'];
  PayPal: Scalars['Float']['output'];
  Transfer: Scalars['Float']['output'];
};

export type ChurrosProfitsBreakdownByTicket = {
  amount: Scalars['Float']['output'];
  id: Scalars['ID']['output'];
};

export type ChurrosPromotionType =
  | 'SIMPPS';

export type ChurrosQRCode = {
  path: Scalars['String']['output'];
  viewbox: Scalars['String']['output'];
};

export type ChurrosQueryAllFormsConnection = {
  edges: Array<ChurrosQueryAllFormsConnectionEdge>;
  nodes: Array<ChurrosForm>;
  pageInfo: ChurrosPageInfo;
};

export type ChurrosQueryAllFormsConnectionEdge = {
  cursor: Scalars['String']['output'];
  node: ChurrosForm;
};

export type ChurrosQueryAllUsersConnection = {
  edges: Array<ChurrosQueryAllUsersConnectionEdge>;
  nodes: Array<ChurrosUser>;
  pageInfo: ChurrosPageInfo;
};

export type ChurrosQueryAllUsersConnectionEdge = {
  cursor: Scalars['String']['output'];
  node: ChurrosUser;
};

export type ChurrosQueryAnnouncementsConnection = {
  edges: Array<ChurrosQueryAnnouncementsConnectionEdge>;
  nodes: Array<ChurrosAnnouncement>;
  pageInfo: ChurrosPageInfo;
};

export type ChurrosQueryAnnouncementsConnectionEdge = {
  cursor: Scalars['String']['output'];
  node: ChurrosAnnouncement;
};

export type ChurrosQueryCodeContributorsResult = ChurrosError | ChurrosQueryCodeContributorsSuccess;

export type ChurrosQueryCodeContributorsSuccess = {
  data: Array<ChurrosUser>;
};

export type ChurrosQueryCombinedChangelogResult = ChurrosError | ChurrosQueryCombinedChangelogSuccess;

export type ChurrosQueryCombinedChangelogSuccess = {
  data: Array<ChurrosChangelogRelease>;
};

export type ChurrosQueryDocumentsConnection = {
  edges: Array<ChurrosQueryDocumentsConnectionEdge>;
  nodes: Array<ChurrosDocument>;
  pageInfo: ChurrosPageInfo;
};

export type ChurrosQueryDocumentsConnectionEdge = {
  cursor: Scalars['String']['output'];
  node: ChurrosDocument;
};

export type ChurrosQueryEventsByDayConnection = {
  edges: Array<ChurrosQueryEventsByDayConnectionEdge>;
  nodes: Array<ChurrosEventsByDay>;
  pageInfo: ChurrosPageInfo;
};

export type ChurrosQueryEventsByDayConnectionEdge = {
  cursor: Scalars['String']['output'];
  node: ChurrosEventsByDay;
};

export type ChurrosQueryEventsConnection = {
  edges: Array<ChurrosQueryEventsConnectionEdge>;
  nodes: Array<ChurrosEvent>;
  pageInfo: ChurrosPageInfo;
};

export type ChurrosQueryEventsConnectionEdge = {
  cursor: Scalars['String']['output'];
  node: ChurrosEvent;
};

export type ChurrosQueryFormsConnection = {
  edges: Array<ChurrosQueryFormsConnectionEdge>;
  nodes: Array<ChurrosForm>;
  pageInfo: ChurrosPageInfo;
};

export type ChurrosQueryFormsConnectionEdge = {
  cursor: Scalars['String']['output'];
  node: ChurrosForm;
};

export type ChurrosQueryGroupMembersCsvResult = ChurrosError | ChurrosQueryGroupMembersCsvSuccess;

export type ChurrosQueryGroupMembersCsvSuccess = {
  data: Scalars['String']['output'];
};

export type ChurrosQueryHomepageConnection = {
  edges: Array<ChurrosQueryHomepageConnectionEdge>;
  nodes: Array<ChurrosArticle>;
  pageInfo: ChurrosPageInfo;
};

export type ChurrosQueryHomepageConnectionEdge = {
  cursor: Scalars['String']['output'];
  node: ChurrosArticle;
};

export type ChurrosQueryLogsConnection = {
  edges: Array<ChurrosQueryLogsConnectionEdge>;
  nodes: Array<ChurrosLogEntry>;
  pageInfo: ChurrosPageInfo;
};

export type ChurrosQueryLogsConnectionEdge = {
  cursor: Scalars['String']['output'];
  node: ChurrosLogEntry;
};

export type ChurrosQueryMinorsConnection = {
  edges: Array<ChurrosQueryMinorsConnectionEdge>;
  nodes: Array<ChurrosMinor>;
  pageInfo: ChurrosPageInfo;
};

export type ChurrosQueryMinorsConnectionEdge = {
  cursor: Scalars['String']['output'];
  node: ChurrosMinor;
};

export type ChurrosQueryNotificationsConnection = {
  edges: Array<ChurrosQueryNotificationsConnectionEdge>;
  nodes: Array<ChurrosNotification>;
  pageInfo: ChurrosPageInfo;
};

export type ChurrosQueryNotificationsConnectionEdge = {
  cursor: Scalars['String']['output'];
  node: ChurrosNotification;
};

export type ChurrosQueryPagesConnection = {
  edges: Array<ChurrosQueryPagesConnectionEdge>;
  nodes: Array<ChurrosPage>;
  pageInfo: ChurrosPageInfo;
};

export type ChurrosQueryPagesConnectionEdge = {
  cursor: Scalars['String']['output'];
  node: ChurrosPage;
};

export type ChurrosQueryQuickSignupsConnection = {
  edges: Array<ChurrosQueryQuickSignupsConnectionEdge>;
  nodes: Array<ChurrosQuickSignup>;
  pageInfo: ChurrosPageInfo;
};

export type ChurrosQueryQuickSignupsConnectionEdge = {
  cursor: Scalars['String']['output'];
  node: ChurrosQuickSignup;
};

export type ChurrosQueryReactionsConnection = {
  edges: Array<ChurrosQueryReactionsConnectionEdge>;
  nodes: Array<ChurrosReaction>;
  pageInfo: ChurrosPageInfo;
};

export type ChurrosQueryReactionsConnectionEdge = {
  cursor: Scalars['String']['output'];
  node: ChurrosReaction;
};

export type ChurrosQueryRegistrationResult = ChurrosError | ChurrosQueryRegistrationSuccess;

export type ChurrosQueryRegistrationSuccess = {
  data: ChurrosRegistration;
};

export type ChurrosQueryRegistrationsOfUserConnection = {
  edges: Array<ChurrosQueryRegistrationsOfUserConnectionEdge>;
  nodes: Array<ChurrosRegistration>;
  pageInfo: ChurrosPageInfo;
};

export type ChurrosQueryRegistrationsOfUserConnectionEdge = {
  cursor: Scalars['String']['output'];
  node: ChurrosRegistration;
};

export type ChurrosQueryUpcomingChangelogResult = ChurrosError | ChurrosQueryUpcomingChangelogSuccess;

export type ChurrosQueryUpcomingChangelogSuccess = {
  data: ChurrosChangelogRelease;
};

export type ChurrosQueryUserCandidatesConnection = {
  edges: Array<ChurrosQueryUserCandidatesConnectionEdge>;
  nodes: Array<ChurrosUserCandidate>;
  pageInfo: ChurrosPageInfo;
};

export type ChurrosQueryUserCandidatesConnectionEdge = {
  cursor: Scalars['String']['output'];
  node: ChurrosUserCandidate;
};

/** Une question dans un formulaire */
export type ChurrosQuestion = {
  /** Indique si la réponse à la question est anonyme. Si oui, les personnes pouvant voir les réponses ne pouront jamais savoir la réponse d'une personne à la question */
  anonymous: Scalars['Boolean']['output'];
  answers: ChurrosQuestionAnswersConnection;
  /** La réponse par défaut à cette question. Même si le résultat est bien de type Answer, le champ `id` est vide */
  defaultAnswer?: Maybe<ChurrosAnswer>;
  /** Description en Markdown de la question */
  description: Scalars['String']['output'];
  /** Description en HTML de la question */
  descriptionHtml: Scalars['String']['output'];
  /** Préfixe d'identifiant: question: */
  id: Scalars['ID']['output'];
  /** Indique si la question est obligatoire */
  mandatory: Scalars['Boolean']['output'];
  /** La réponse de l'utilisateur·ice connecté·e à cette question */
  myAnswer?: Maybe<ChurrosAnswer>;
  /** Ordre de la question dans la section */
  order: Scalars['Int']['output'];
  /** Section du formulaire dans laquelle est la question */
  section: ChurrosFormSection;
  /** Titre de la question */
  title: Scalars['String']['output'];
  /** Nombre total de réponses à cette question */
  totalAnswers: Scalars['Int']['output'];
  /** Type de la question */
  type: ChurrosQuestionKind;
};


/** Une question dans un formulaire */
export type ChurrosQuestionanswersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  by?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type ChurrosQuestionAnswersConnection = {
  edges: Array<ChurrosQuestionAnswersConnectionEdge>;
  nodes: Array<ChurrosAnswer>;
  pageInfo: ChurrosPageInfo;
};

export type ChurrosQuestionAnswersConnectionEdge = {
  cursor: Scalars['String']['output'];
  node: ChurrosAnswer;
};

/** Question de type `FileUpload` */
export type ChurrosQuestionFileUpload = ChurrosQuestion & {
  /** Types de fichiers autorisés pour les questions de type `File`. Null si la question n'est pas de type `File`. */
  allowedFileTypes?: Maybe<Array<Scalars['String']['output']>>;
  /** Indique si la réponse à la question est anonyme. Si oui, les personnes pouvant voir les réponses ne pouront jamais savoir la réponse d'une personne à la question */
  anonymous: Scalars['Boolean']['output'];
  answers: ChurrosQuestionAnswersConnection;
  /** La réponse par défaut à cette question. Même si le résultat est bien de type Answer, le champ `id` est vide */
  defaultAnswer?: Maybe<ChurrosAnswer>;
  /** Description en Markdown de la question */
  description: Scalars['String']['output'];
  /** Description en HTML de la question */
  descriptionHtml: Scalars['String']['output'];
  /** Préfixe d'identifiant: question: */
  id: Scalars['ID']['output'];
  /** Indique si la question est obligatoire */
  mandatory: Scalars['Boolean']['output'];
  /** La réponse de l'utilisateur·ice connecté·e à cette question */
  myAnswer?: Maybe<ChurrosAnswer>;
  /** Ordre de la question dans la section */
  order: Scalars['Int']['output'];
  /** Section du formulaire dans laquelle est la question */
  section: ChurrosFormSection;
  /** Titre de la question */
  title: Scalars['String']['output'];
  /** Nombre total de réponses à cette question */
  totalAnswers: Scalars['Int']['output'];
  /** Type de la question */
  type: ChurrosQuestionKind;
};


/** Question de type `FileUpload` */
export type ChurrosQuestionFileUploadanswersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  by?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Le type de question */
export type ChurrosQuestionKind =
  /** La réponse est une date, sans heure associée. */
  | 'Date'
  /** La réponse est un fichier mis en ligne par l'utilisateur·ice. */
  | 'FileUpload'
  /** La réponse est un texte long. */
  | 'LongText'
  /** La réponse est un nombre, potentiellement à virgule. */
  | 'Number'
  /** La réponse est un nombre entier entre deux bornes */
  | 'Scale'
  /** La réponse est une ou plusieurs options parmi une liste. */
  | 'SelectMultiple'
  /** La réponse est une des options parmi une liste. */
  | 'SelectOne'
  /** La réponse est un texte court. */
  | 'Text'
  /** La réponse est un temps  (heures, minute et seconde), sans date associée. */
  | 'Time';

/** Choix pour les questions de type `SelectOne` ou `SelectMultiple` */
export type ChurrosQuestionOptionInput = {
  /** ID de la question vers laquelle sauter si ce choix est sélectionné */
  jump?: InputMaybe<Scalars['ID']['input']>;
  /** Choix */
  value: Scalars['String']['input'];
};

/** Question de type `Text`, `Number`, `Date`, `Time` ou `LongText` */
export type ChurrosQuestionScalar = ChurrosQuestion & {
  /** Indique si la réponse à la question est anonyme. Si oui, les personnes pouvant voir les réponses ne pouront jamais savoir la réponse d'une personne à la question */
  anonymous: Scalars['Boolean']['output'];
  answers: ChurrosQuestionAnswersConnection;
  /** La réponse par défaut à cette question. Même si le résultat est bien de type Answer, le champ `id` est vide */
  defaultAnswer?: Maybe<ChurrosAnswer>;
  /** Description en Markdown de la question */
  description: Scalars['String']['output'];
  /** Description en HTML de la question */
  descriptionHtml: Scalars['String']['output'];
  /** Préfixe d'identifiant: question: */
  id: Scalars['ID']['output'];
  /** Indique si la question est obligatoire */
  mandatory: Scalars['Boolean']['output'];
  /** La réponse de l'utilisateur·ice connecté·e à cette question */
  myAnswer?: Maybe<ChurrosAnswer>;
  /** Ordre de la question dans la section */
  order: Scalars['Int']['output'];
  /** Section du formulaire dans laquelle est la question */
  section: ChurrosFormSection;
  /** Titre de la question */
  title: Scalars['String']['output'];
  /** Nombre total de réponses à cette question */
  totalAnswers: Scalars['Int']['output'];
  /** Type de la question */
  type: ChurrosQuestionKind;
};


/** Question de type `Text`, `Number`, `Date`, `Time` ou `LongText` */
export type ChurrosQuestionScalaranswersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  by?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Question de type `Scale` */
export type ChurrosQuestionScale = ChurrosQuestion & {
  /** Indique si la réponse à la question est anonyme. Si oui, les personnes pouvant voir les réponses ne pouront jamais savoir la réponse d'une personne à la question */
  anonymous: Scalars['Boolean']['output'];
  /** Compte le nombre total de réponses pour chaque option. Retourne un `StringToIntMapping` où les clés sont les options et les valeurs sont le nombre de réponses pour l'option. */
  answerCounts: Array<ChurrosStringToIntMapping>;
  answers: ChurrosQuestionAnswersConnection;
  /** La réponse par défaut à cette question. Même si le résultat est bien de type Answer, le champ `id` est vide */
  defaultAnswer?: Maybe<ChurrosAnswer>;
  /** Description en Markdown de la question */
  description: Scalars['String']['output'];
  /** Description en HTML de la question */
  descriptionHtml: Scalars['String']['output'];
  /** Préfixe d'identifiant: question: */
  id: Scalars['ID']['output'];
  /** Liste des labels pour les valeurs possibles */
  labels: Array<Scalars['String']['output']>;
  /** Indique si la question est obligatoire */
  mandatory: Scalars['Boolean']['output'];
  /** Valeur maximale */
  maximum: Scalars['Int']['output'];
  /** Label de la valeur maximale */
  maximumLabel: Scalars['String']['output'];
  /** Valeur minimale */
  minimum: Scalars['Int']['output'];
  /** Label de la valeur minimale */
  minimumLabel: Scalars['String']['output'];
  /** La réponse de l'utilisateur·ice connecté·e à cette question */
  myAnswer?: Maybe<ChurrosAnswer>;
  /** Liste des valeurs possibles */
  options: Array<Scalars['Int']['output']>;
  /** Ordre de la question dans la section */
  order: Scalars['Int']['output'];
  /** Section du formulaire dans laquelle est la question */
  section: ChurrosFormSection;
  /** Titre de la question */
  title: Scalars['String']['output'];
  /** Nombre total de réponses à cette question */
  totalAnswers: Scalars['Int']['output'];
  /** Type de la question */
  type: ChurrosQuestionKind;
};


/** Question de type `Scale` */
export type ChurrosQuestionScaleanswersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  by?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Options supplémentaires pour les questions de type `Scale` */
export type ChurrosQuestionScaleInput = {
  /** Valeur maximale */
  maximum: Scalars['Int']['input'];
  /** Label de la valeur maximale */
  maximumLabel?: InputMaybe<Scalars['String']['input']>;
  /** Valeur minimale */
  minimum: Scalars['Int']['input'];
  /** Label de la valeur minimale */
  minimumLabel?: InputMaybe<Scalars['String']['input']>;
};

/** Question de type `SelectMultiple` */
export type ChurrosQuestionSelectMultiple = ChurrosQuestion & {
  /** Indique si la question de type `SelectOne` ou `SelectMultiple` permet une option "Autre", que l'utilisateur·ice peut remplir sans contrainte. */
  allowOptionsOther: Scalars['Boolean']['output'];
  /** Indique si la réponse à la question est anonyme. Si oui, les personnes pouvant voir les réponses ne pouront jamais savoir la réponse d'une personne à la question */
  anonymous: Scalars['Boolean']['output'];
  /** Compte le nombre total de réponses pour chaque option. Retourne un `StringToIntMapping` où les clés sont les options et les valeurs sont le nombre de réponses pour l'option. */
  answerCounts: Array<ChurrosStringToIntMapping>;
  answers: ChurrosQuestionAnswersConnection;
  /** La réponse par défaut à cette question. Même si le résultat est bien de type Answer, le champ `id` est vide */
  defaultAnswer?: Maybe<ChurrosAnswer>;
  /** Description en Markdown de la question */
  description: Scalars['String']['output'];
  /** Description en HTML de la question */
  descriptionHtml: Scalars['String']['output'];
  /** Préfixe d'identifiant: question: */
  id: Scalars['ID']['output'];
  /** Indique si la question est obligatoire */
  mandatory: Scalars['Boolean']['output'];
  /** La réponse de l'utilisateur·ice connecté·e à cette question */
  myAnswer?: Maybe<ChurrosAnswer>;
  /** Uniquement pertinent pour les questions de type `SelectOne` ou `SelectMultiple` */
  options: Array<Scalars['String']['output']>;
  /** Ordre de la question dans la section */
  order: Scalars['Int']['output'];
  /** Section du formulaire dans laquelle est la question */
  section: ChurrosFormSection;
  /** Titre de la question */
  title: Scalars['String']['output'];
  /** Nombre total de réponses à cette question */
  totalAnswers: Scalars['Int']['output'];
  /** Type de la question */
  type: ChurrosQuestionKind;
};


/** Question de type `SelectMultiple` */
export type ChurrosQuestionSelectMultipleanswersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  by?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Question de type `SelectOne` */
export type ChurrosQuestionSelectOne = ChurrosQuestion & {
  /** Indique si la question de type `SelectOne` ou `SelectMultiple` permet une option "Autre", que l'utilisateur·ice peut remplir sans contrainte. */
  allowOptionsOther: Scalars['Boolean']['output'];
  /** Indique si la réponse à la question est anonyme. Si oui, les personnes pouvant voir les réponses ne pouront jamais savoir la réponse d'une personne à la question */
  anonymous: Scalars['Boolean']['output'];
  /** Compte le nombre total de réponses pour chaque option. Retourne un `StringToIntMapping` où les clés sont les options et les valeurs sont le nombre de réponses pour l'option. */
  answerCounts: Array<ChurrosStringToIntMapping>;
  answers: ChurrosQuestionAnswersConnection;
  /** La réponse par défaut à cette question. Même si le résultat est bien de type Answer, le champ `id` est vide */
  defaultAnswer?: Maybe<ChurrosAnswer>;
  /** Description en Markdown de la question */
  description: Scalars['String']['output'];
  /** Description en HTML de la question */
  descriptionHtml: Scalars['String']['output'];
  /** Dans le même ordre que `options`, contient le groupe si l'option porte exactement le nom du groupe, ou null si aucun groupe ne correspond. Pratique pour les questions où l'on demande à choisir entre plusieurs groupes (comme les votes de listes par ex.) */
  groups: Array<Maybe<ChurrosGroup>>;
  /** Préfixe d'identifiant: question: */
  id: Scalars['ID']['output'];
  /** Correspondances entre les réponses à cette question et les sections du formulaire à sauter vers. Dans le même ordre que `options`. Quand un élément est null, la section suivante n'est pas modifiée */
  jumps: Array<Maybe<ChurrosFormSection>>;
  /** Indique si la question est obligatoire */
  mandatory: Scalars['Boolean']['output'];
  /** La réponse de l'utilisateur·ice connecté·e à cette question */
  myAnswer?: Maybe<ChurrosAnswer>;
  /** Uniquement pertinent pour les questions de type `SelectOne` ou `SelectMultiple` */
  options: Array<Scalars['String']['output']>;
  /** Ordre de la question dans la section */
  order: Scalars['Int']['output'];
  /** Section du formulaire dans laquelle est la question */
  section: ChurrosFormSection;
  /** Titre de la question */
  title: Scalars['String']['output'];
  /** Nombre total de réponses à cette question */
  totalAnswers: Scalars['Int']['output'];
  /** Type de la question */
  type: ChurrosQuestionKind;
};


/** Question de type `SelectOne` */
export type ChurrosQuestionSelectOneanswersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  by?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Lien d'inscription rapide, qui permet de créer un compte étudiant sans adresse mail étudiante et sans validation manuelle */
export type ChurrosQuickSignup = ChurrosNode & {
  code: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  /** Vrai si le lien est expiré */
  expired: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  /** L'identifiant local de la ressource (sans préfixe) */
  localID: Scalars['ChurrosLocalID']['output'];
  school: ChurrosSchool;
  schoolId: Scalars['ID']['output'];
  updatedAt: Scalars['DateTime']['output'];
  validUntil: Scalars['DateTime']['output'];
};

/** Une resource pouvant recevoir des réactions (likes, etc) par les utilisateur·ice·s */
export type ChurrosReactable = {
  /** L’identifiant de la resource */
  id: Scalars['ID']['output'];
  /** Vrai si l’utilisateur·ice connecté·e a réagi avec cet emoji */
  reacted: Scalars['Boolean']['output'];
  /** Nombre total de réactions avec cet emoji */
  reactions: Scalars['Int']['output'];
};


/** Une resource pouvant recevoir des réactions (likes, etc) par les utilisateur·ice·s */
export type ChurrosReactablereactedArgs = {
  emoji: Scalars['String']['input'];
};


/** Une resource pouvant recevoir des réactions (likes, etc) par les utilisateur·ice·s */
export type ChurrosReactablereactionsArgs = {
  emoji: Scalars['String']['input'];
};

export type ChurrosReaction = ChurrosNode & {
  author?: Maybe<ChurrosUser>;
  authorId?: Maybe<Scalars['ID']['output']>;
  comment?: Maybe<ChurrosComment>;
  commentId?: Maybe<Scalars['ID']['output']>;
  createdAt: Scalars['DateTime']['output'];
  document?: Maybe<ChurrosDocument>;
  documentId?: Maybe<Scalars['ID']['output']>;
  emoji: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** L'identifiant local de la ressource (sans préfixe) */
  localID: Scalars['ChurrosLocalID']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

export type ChurrosRedisHealthCheck = {
  /** Whether the Redis publisher client is ready */
  publish: Scalars['Boolean']['output'];
  /** Whether the Redis subscriber client is ready */
  subscribe: Scalars['Boolean']['output'];
};

/** A reservation is a user's registration for a ticket */
export type ChurrosRegistration = ChurrosNode & {
  author?: Maybe<ChurrosUser>;
  authorEmail: Scalars['String']['output'];
  authorId?: Maybe<Scalars['ID']['output']>;
  authorIsBeneficiary: Scalars['Boolean']['output'];
  beneficiary: Scalars['String']['output'];
  beneficiaryUser?: Maybe<ChurrosUser>;
  cancelled: Scalars['Boolean']['output'];
  cancelledAt?: Maybe<Scalars['DateTime']['output']>;
  cancelledBy?: Maybe<ChurrosUser>;
  code: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  /** L'identifiant local de la ressource (sans préfixe) */
  localID: Scalars['ChurrosLocalID']['output'];
  opposed: Scalars['Boolean']['output'];
  opposedAt?: Maybe<Scalars['DateTime']['output']>;
  opposedBy?: Maybe<ChurrosUser>;
  paid: Scalars['Boolean']['output'];
  paymentMethod?: Maybe<ChurrosPaymentMethod>;
  ticket: ChurrosTicket;
  ticketId: Scalars['ID']['output'];
  updatedAt: Scalars['DateTime']['output'];
  verified: Scalars['Boolean']['output'];
  verifiedAt?: Maybe<Scalars['DateTime']['output']>;
  verifiedBy?: Maybe<ChurrosUser>;
};

export type ChurrosRegistrationSearchResult = {
  highlightedBeneficiary: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  rank?: Maybe<Scalars['Float']['output']>;
  registration: ChurrosRegistration;
  similarity: Scalars['Float']['output'];
};

export type ChurrosRegistrationVerificationResult = {
  registration?: Maybe<ChurrosRegistration>;
  state: ChurrosRegistrationVerificationState;
};

export type ChurrosRegistrationVerificationState =
  | 'AlreadyVerified'
  | 'NotFound'
  | 'NotPaid'
  | 'Ok'
  | 'Opposed'
  | 'OtherEvent';

export type ChurrosRegistrationsCounts = {
  cancelled: Scalars['Float']['output'];
  paid: Scalars['Float']['output'];
  total: Scalars['Float']['output'];
  unpaidLydia: Scalars['Float']['output'];
  verified: Scalars['Float']['output'];
};

/** A change in the changelog */
export type ChurrosReleaseChange = {
  /** The authors of the change */
  authors: Array<Scalars['String']['output']>;
  html: Scalars['String']['output'];
  /** Issues linked to the change */
  issues: Array<Scalars['Int']['output']>;
  /** Merge requests linked to the change */
  mergeRequests: Array<Scalars['Int']['output']>;
  /** People who created the issues (gave the idea, reported the bug, etc.) */
  reporters: Array<Scalars['String']['output']>;
  /** The text of the change */
  text: Scalars['String']['output'];
};

/** Changes in the changelog, grouped by category */
export type ChurrosReleaseChangesMaps = {
  /** New features */
  added: Array<ChurrosReleaseChange>;
  /** What was fixed */
  fixed: Array<ChurrosReleaseChange>;
  /** What was improved */
  improved: Array<ChurrosReleaseChange>;
  /** Miscalleanous changes */
  other: Array<ChurrosReleaseChange>;
  /** Security changes */
  security: Array<ChurrosReleaseChange>;
  /** Technical changes */
  technical: Array<ChurrosReleaseChange>;
};

export type ChurrosSchool = ChurrosPictured & {
  address: Scalars['String']['output'];
  aliasMailDomains: Array<Scalars['String']['output']>;
  color: Scalars['String']['output'];
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  majors: Array<ChurrosMajor>;
  name: Scalars['String']['output'];
  pictureFile: Scalars['String']['output'];
  /** Le nom du fichier de l'image, en thème sombre */
  pictureFileDark: Scalars['String']['output'];
  /** L'URL publique de l'image */
  pictureURL: Scalars['String']['output'];
  services: Array<ChurrosService>;
  slug: Scalars['String']['output'];
  studentAssociations: Array<ChurrosStudentAssociation>;
  studentMailDomain: Scalars['String']['output'];
  uid: Scalars['String']['output'];
};


export type ChurrosSchoolpictureURLArgs = {
  dark?: Scalars['Boolean']['input'];
};

export type ChurrosSchoolGroup = {
  majors: Array<ChurrosMajor>;
  names: Array<Scalars['String']['output']>;
};

export type ChurrosSchoolInput = {
  color: Scalars['String']['input'];
  id?: InputMaybe<Scalars['ID']['input']>;
  name: Scalars['String']['input'];
};

/** A service */
export type ChurrosService = ChurrosNode & {
  description: Scalars['String']['output'];
  group?: Maybe<ChurrosGroup>;
  id: Scalars['ID']['output'];
  importance: Scalars['Int']['output'];
  /** L'identifiant local de la ressource (sans préfixe) */
  localID: Scalars['ChurrosLocalID']['output'];
  logo: Scalars['String']['output'];
  logoSourceType: ChurrosLogoSourceType;
  name: Scalars['String']['output'];
  school?: Maybe<ChurrosSchool>;
  studentAssociation?: Maybe<ChurrosStudentAssociation>;
  url: Scalars['String']['output'];
};

export type ChurrosShopItem = ChurrosNode & {
  createdAt: Scalars['DateTime']['output'];
  description: Scalars['String']['output'];
  descriptionHtml: Scalars['String']['output'];
  endsAt?: Maybe<Scalars['DateTime']['output']>;
  group: ChurrosGroup;
  id: Scalars['ID']['output'];
  itemOptions: Array<ChurrosShopItemOption>;
  /** L'identifiant local de la ressource (sans préfixe) */
  localID: Scalars['ChurrosLocalID']['output'];
  lydiaAccount?: Maybe<ChurrosLydiaAccount>;
  max: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  paymentMethods: Array<ChurrosPaymentMethod>;
  pictures: Array<ChurrosPicture>;
  price: Scalars['Float']['output'];
  shopPayments: Array<ChurrosShopPayment>;
  /** Un nom lisible sans espaces, adaptés pour des URLs. */
  slug: Scalars['String']['output'];
  startsAt?: Maybe<Scalars['DateTime']['output']>;
  stock: Scalars['Int']['output'];
  stockLeft: Scalars['Int']['output'];
  /** @deprecated Use `slug` instead. This field was never universally unique. */
  uid: Scalars['String']['output'];
  updatedAt: Scalars['DateTime']['output'];
  visibility: ChurrosVisibility;
};

export type ChurrosShopItemAnswer = {
  id: Scalars['ID']['output'];
  options: Array<Scalars['String']['output']>;
  shopPayment: ChurrosShopPayment;
  shopPaymentId: Scalars['String']['output'];
};

export type ChurrosShopItemOption = {
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  options: Array<Scalars['String']['output']>;
  otherToggle: Scalars['Boolean']['output'];
  required: Scalars['Boolean']['output'];
  shopItem: ChurrosShopItem;
};

export type ChurrosShopItemOptionInput = {
  id: Scalars['String']['input'];
  name: Scalars['String']['input'];
  options: Array<Scalars['String']['input']>;
  otherToggle: Scalars['Boolean']['input'];
  required: Scalars['Boolean']['input'];
};

export type ChurrosShopPayment = {
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  paid: Scalars['Boolean']['output'];
  paymentMethod: ChurrosPaymentMethod;
  quantity: Scalars['Int']['output'];
  shopItem: ChurrosShopItem;
  shopItemAnswer?: Maybe<ChurrosShopItemAnswer>;
  totalPrice: Scalars['Float']['output'];
  updatedAt: Scalars['DateTime']['output'];
  user: ChurrosUser;
};

export type ChurrosSortDirection =
  | 'Ascending'
  | 'Descending';

/** Associe une clé à une valeur de type nombre entier */
export type ChurrosStringToIntMapping = {
  /** Clé de la paire */
  key: Scalars['String']['output'];
  /** Valeur de la paire */
  value: Scalars['Int']['output'];
};

/** There is one student association per school */
export type ChurrosStudentAssociation = ChurrosPictured & {
  /** Si l'utilsateur·ice courant·e peut créer des groupes rattachés à cette AE */
  canCreateGroups: Scalars['Boolean']['output'];
  /** L'utilisateur·ice connecté·e peut éditer (créer ou modifier) les pages de l'AE */
  canEditPages: Scalars['Boolean']['output'];
  /** L'utilisateur·ice connecté·e peut lister les pages de l'AE */
  canListPages: Scalars['Boolean']['output'];
  contributionOptions: Array<ChurrosContributionOption>;
  createdAt: Scalars['DateTime']['output'];
  description: Scalars['String']['output'];
  groups: ChurrosStudentAssociationGroupsConnection;
  /** Nombre de groupes reliés à cette AE */
  groupsCount: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
  links: Array<ChurrosLink>;
  name: Scalars['String']['output'];
  /** La page associée à l'AE */
  page?: Maybe<ChurrosPage>;
  /** Les pages associées à l'AE */
  pages: ChurrosPagesConnection;
  pictureFile: Scalars['String']['output'];
  /** Le nom du fichier de l'image, en thème sombre */
  pictureFileDark: Scalars['String']['output'];
  /** L'URL publique de l'image */
  pictureURL: Scalars['String']['output'];
  school: ChurrosSchool;
  schoolId: Scalars['ID']['output'];
  uid?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['DateTime']['output'];
};


/** There is one student association per school */
export type ChurrosStudentAssociationcanCreateGroupsArgs = {
  type?: InputMaybe<ChurrosGroupType>;
};


/** There is one student association per school */
export type ChurrosStudentAssociationgroupsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  types?: InputMaybe<Array<ChurrosGroupType>>;
};


/** There is one student association per school */
export type ChurrosStudentAssociationpageArgs = {
  path: Scalars['String']['input'];
};


/** There is one student association per school */
export type ChurrosStudentAssociationpagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** There is one student association per school */
export type ChurrosStudentAssociationpictureURLArgs = {
  dark?: Scalars['Boolean']['input'];
};

export type ChurrosStudentAssociationGroupsConnection = {
  edges: Array<ChurrosStudentAssociationGroupsConnectionEdge>;
  nodes: Array<ChurrosGroup>;
  pageInfo: ChurrosPageInfo;
};

export type ChurrosStudentAssociationGroupsConnectionEdge = {
  cursor: Scalars['String']['output'];
  node: ChurrosGroup;
};

export type ChurrosSubject = {
  apogeeCode?: Maybe<Scalars['String']['output']>;
  documents: ChurrosSubjectDocumentsConnection;
  documentsCount: Scalars['Int']['output'];
  emoji: Scalars['String']['output'];
  forApprentices: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  links: Array<ChurrosLink>;
  majors: Array<ChurrosMajor>;
  minors: Array<ChurrosMinor>;
  name: Scalars['String']['output'];
  nextExamAt?: Maybe<Scalars['DateTime']['output']>;
  semester?: Maybe<Scalars['Int']['output']>;
  shortName: Scalars['String']['output'];
  /** Un nom lisible sans espaces, adaptés pour des URLs. */
  slug: Scalars['String']['output'];
  /** @deprecated Use `slug` instead. This field was never universally unique. */
  uid: Scalars['String']['output'];
  unit?: Maybe<ChurrosTeachingUnit>;
  unitId?: Maybe<Scalars['ID']['output']>;
  yearTier?: Maybe<Scalars['Int']['output']>;
};


export type ChurrosSubjectdocumentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type ChurrosSubjectDocumentsConnection = {
  edges: Array<ChurrosSubjectDocumentsConnectionEdge>;
  nodes: Array<ChurrosDocument>;
  pageInfo: ChurrosPageInfo;
};

export type ChurrosSubjectDocumentsConnectionEdge = {
  cursor: Scalars['String']['output'];
  node: ChurrosDocument;
};

export type ChurrosSubscriptionRegistrationResult = ChurrosError | ChurrosSubscriptionRegistrationSuccess;

export type ChurrosSubscriptionRegistrationSuccess = {
  data: ChurrosRegistration;
};

export type ChurrosTeachingUnit = {
  apogeeCode?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  shortName: Scalars['String']['output'];
  subjects: Array<ChurrosSubject>;
};

/** A third-party OAuth2 client */
export type ChurrosThirdPartyApp = {
  active: Scalars['Boolean']['output'];
  allowedRedirectUris: Array<Scalars['String']['output']>;
  apiUsage: ChurrosThirdPartyAppApiUsageConnection;
  clientId: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  description: Scalars['String']['output'];
  faviconUrl: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** Logs de connexion de l'application tierce, utile pour débugger des problèmes. Mise à jour en temps réel disponible via une subscription sur la query `thirdPartyApp`. */
  logs: ChurrosThirdPartyAppLogsConnection;
  name: Scalars['String']['output'];
  owner: ChurrosGroup;
  rateLimitHits: ChurrosThirdPartyAppRateLimitHitsConnection;
  secretLength: Scalars['Int']['output'];
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  users: ChurrosThirdPartyAppUsersConnection;
  usersCount: Scalars['Int']['output'];
  website: Scalars['String']['output'];
};


/** A third-party OAuth2 client */
export type ChurrosThirdPartyAppapiUsageArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A third-party OAuth2 client */
export type ChurrosThirdPartyApplogsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A third-party OAuth2 client */
export type ChurrosThirdPartyApprateLimitHitsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A third-party OAuth2 client */
export type ChurrosThirdPartyAppusersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type ChurrosThirdPartyAppApiUsageConnection = {
  edges: Array<ChurrosThirdPartyAppApiUsageConnectionEdge>;
  nodes: Array<ChurrosApiUsage>;
  pageInfo: ChurrosPageInfo;
};

export type ChurrosThirdPartyAppApiUsageConnectionEdge = {
  cursor: Scalars['String']['output'];
  node: ChurrosApiUsage;
};

export type ChurrosThirdPartyAppLogsConnection = {
  edges: Array<ChurrosThirdPartyAppLogsConnectionEdge>;
  nodes: Array<ChurrosLogEntry>;
  pageInfo: ChurrosPageInfo;
};

export type ChurrosThirdPartyAppLogsConnectionEdge = {
  cursor: Scalars['String']['output'];
  node: ChurrosLogEntry;
};

export type ChurrosThirdPartyAppRateLimitHitsConnection = {
  edges: Array<ChurrosThirdPartyAppRateLimitHitsConnectionEdge>;
  nodes: Array<ChurrosApiRateLimitHits>;
  pageInfo: ChurrosPageInfo;
};

export type ChurrosThirdPartyAppRateLimitHitsConnectionEdge = {
  cursor: Scalars['String']['output'];
  node: ChurrosApiRateLimitHits;
};

export type ChurrosThirdPartyAppRegistrationResponse = {
  client_id: Scalars['String']['output'];
  client_secret: Scalars['String']['output'];
};

export type ChurrosThirdPartyAppUsersConnection = {
  edges: Array<ChurrosThirdPartyAppUsersConnectionEdge>;
  nodes: Array<ChurrosUser>;
  pageInfo: ChurrosPageInfo;
  totalCount: Scalars['Int']['output'];
};

export type ChurrosThirdPartyAppUsersConnectionEdge = {
  cursor: Scalars['String']['output'];
  node: ChurrosUser;
};

/** A ticket is a way to register for an event. May include a price and conditions. */
export type ChurrosTicket = ChurrosNode & {
  allowedPaymentMethods: Array<ChurrosPaymentMethod>;
  autojoinGroups: Array<ChurrosGroup>;
  basePrice: Scalars['Float']['output'];
  capacity: Scalars['Int']['output'];
  closesAt?: Maybe<Scalars['DateTime']['output']>;
  description: Scalars['String']['output'];
  descriptionHtml: Scalars['String']['output'];
  event: ChurrosEvent;
  eventId: Scalars['ID']['output'];
  /** Full name, including the ticket group's name if any */
  fullName: Scalars['String']['output'];
  godsonLimit: Scalars['Int']['output'];
  group?: Maybe<ChurrosTicketGroup>;
  id: Scalars['ID']['output'];
  links: Array<ChurrosLink>;
  /** L'identifiant local de la ressource (sans préfixe) */
  localID: Scalars['ChurrosLocalID']['output'];
  name: Scalars['String']['output'];
  onlyManagersCanProvide: Scalars['Boolean']['output'];
  openToAlumni?: Maybe<Scalars['Boolean']['output']>;
  openToApprentices?: Maybe<Scalars['Boolean']['output']>;
  openToContributors?: Maybe<Scalars['Boolean']['output']>;
  openToExternal?: Maybe<Scalars['Boolean']['output']>;
  openToGroups: Array<ChurrosGroup>;
  openToMajors: Array<ChurrosMajor>;
  openToPromotions: Array<Scalars['Int']['output']>;
  openToSchools: Array<ChurrosSchool>;
  opensAt?: Maybe<Scalars['DateTime']['output']>;
  /** Nombre de places restantes. Null si l'information n'est pas disponible. N'est jamais null quand il n'y a plus de places disponibles (0) */
  placesLeft?: Maybe<Scalars['Int']['output']>;
  price: Scalars['Float']['output'];
  registrations: Array<ChurrosRegistration>;
  remainingGodsons: Scalars['Int']['output'];
  /** Un nom lisible sans espaces, adaptés pour des URLs. */
  slug: Scalars['String']['output'];
  ticketGroupId?: Maybe<Scalars['ID']['output']>;
  /** @deprecated Use `slug` instead. This field was never universally unique. */
  uid: Scalars['String']['output'];
};

/** A ticket group allows for conditions on multiple tickets, such as an upper limit on the sum of registrations in the sub-tickets */
export type ChurrosTicketGroup = ChurrosNode & {
  capacity: Scalars['Int']['output'];
  event: ChurrosEvent;
  eventId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  /** L'identifiant local de la ressource (sans préfixe) */
  localID: Scalars['ChurrosLocalID']['output'];
  name: Scalars['String']['output'];
  tickets: Array<ChurrosTicket>;
};

export type ChurrosTicketGroupInput = {
  capacity: Scalars['Int']['input'];
  id?: InputMaybe<Scalars['ID']['input']>;
  name: Scalars['String']['input'];
};

export type ChurrosTicketInput = {
  allowedPaymentMethods: Array<ChurrosPaymentMethod>;
  autojoinGroups: Array<Scalars['String']['input']>;
  capacity: Scalars['Int']['input'];
  closesAt?: InputMaybe<Scalars['DateTime']['input']>;
  description: Scalars['String']['input'];
  godsonLimit: Scalars['Int']['input'];
  groupName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  links: Array<ChurrosLinkInput>;
  name: Scalars['String']['input'];
  onlyManagersCanProvide: Scalars['Boolean']['input'];
  openToAlumni?: InputMaybe<Scalars['Boolean']['input']>;
  openToApprentices?: InputMaybe<Scalars['Boolean']['input']>;
  openToContributors?: InputMaybe<Scalars['Boolean']['input']>;
  openToExternal?: InputMaybe<Scalars['Boolean']['input']>;
  openToGroups: Array<Scalars['String']['input']>;
  openToMajors: Array<Scalars['String']['input']>;
  openToPromotions: Array<Scalars['Int']['input']>;
  openToSchools: Array<Scalars['String']['input']>;
  opensAt?: InputMaybe<Scalars['DateTime']['input']>;
  price: Scalars['Float']['input'];
};

export type ChurrosUpsertGroupInput = {
  address: Scalars['String']['input'];
  color?: InputMaybe<Scalars['String']['input']>;
  description: Scalars['String']['input'];
  email?: InputMaybe<Scalars['String']['input']>;
  links: Array<ChurrosLinkInput>;
  longDescription: Scalars['String']['input'];
  mailingList?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  parent?: InputMaybe<Scalars['ChurrosUID']['input']>;
  related: Array<Scalars['String']['input']>;
  school?: InputMaybe<Scalars['ChurrosUID']['input']>;
  selfJoinable: Scalars['Boolean']['input'];
  studentAssociation?: InputMaybe<Scalars['ChurrosUID']['input']>;
  type: ChurrosGroupType;
  /** Ne sert qu'à la création du groupe. Il est impossible de modifier un uid existant */
  uid?: InputMaybe<Scalars['ChurrosUID']['input']>;
  website: Scalars['String']['input'];
};

/** Users are the people who use the app */
export type ChurrosUser = ChurrosNode & ChurrosPictured & {
  address: Scalars['String']['output'];
  admin: Scalars['Boolean']['output'];
  /** Vrai si cette personne est administratrice de l'association étudiante donnée */
  adminOf: Scalars['Boolean']['output'];
  /** @deprecated Use `authorizedApps` instead */
  allowedApps: Array<ChurrosThirdPartyApp>;
  /** Formulaires complètement répondus par l'utilisateur */
  answeredForms: ChurrosUserAnsweredFormsConnection;
  apprentice: Scalars['Boolean']['output'];
  articles: ChurrosUserArticlesConnection;
  /** Applications tierces autorisées à accéder à ce compte utilisateur */
  authorizedApps: Array<ChurrosThirdPartyApp>;
  birthday?: Maybe<Scalars['DateTime']['output']>;
  /** Les affiliations de l'utilisateur à des groupes dont iel est au bureau */
  boardMemberships: Array<ChurrosGroupMember>;
  booking: ChurrosRegistration;
  bookings: ChurrosUserBookingsConnection;
  /** Vrai si cet utilisateur est un bot (i.e. ne représente pas une personne physique) */
  bot: Scalars['Boolean']['output'];
  canAccessDocuments: Scalars['Boolean']['output'];
  canBeEdited: Scalars['Boolean']['output'];
  /** Groupes sur lesquels l'utilisateur·ice peut créer des posts */
  canCreatePostsOn: Array<ChurrosGroup>;
  /** Vrai si cette personne peut éditer le groupe donné */
  canEditGroup: Scalars['Boolean']['output'];
  /** Vrai si cette personne peut éditer des groupes */
  canEditGroups: Scalars['Boolean']['output'];
  cededImageRightsToTVn7: Scalars['Boolean']['output'];
  contributesTo: Array<ChurrosStudentAssociation>;
  contributesWith: Array<ChurrosContributionOption>;
  createdAt: Scalars['DateTime']['output'];
  credentials: Array<ChurrosCredential>;
  description: Scalars['String']['output'];
  descriptionHtml: Scalars['String']['output'];
  email: Scalars['String']['output'];
  emailChangeRequests: Array<ChurrosEmailChange>;
  enabledNotificationChannels: Array<ChurrosNotificationChannel>;
  external: Scalars['Boolean']['output'];
  familyTree: ChurrosFamilyTree;
  firstName: Scalars['String']['output'];
  fullName: Scalars['String']['output'];
  godchildren: Array<ChurrosUser>;
  godparent?: Maybe<ChurrosUser>;
  graduationYear: Scalars['Int']['output'];
  groups: Array<ChurrosGroupMember>;
  id: Scalars['ID']['output'];
  incomingGodparentRequests: Array<ChurrosGodparentRequest>;
  lastName: Scalars['String']['output'];
  latestVersionSeenInChangelog: Scalars['String']['output'];
  links: Array<ChurrosLink>;
  /** L'identifiant local de la ressource (sans préfixe) */
  localID: Scalars['ChurrosLocalID']['output'];
  major?: Maybe<ChurrosMajor>;
  majorId?: Maybe<Scalars['ID']['output']>;
  managedEvents: Array<ChurrosEventManager>;
  minor?: Maybe<ChurrosMinor>;
  nickname: Scalars['String']['output'];
  otherEmails: Array<Scalars['String']['output']>;
  outgoingGodparentRequests: Array<ChurrosGodparentRequest>;
  /** Formulaires partiellement répondus par l'utilisateur */
  partiallyAnsweredForms: ChurrosUserPartiallyAnsweredFormsConnection;
  pendingContributions: Array<ChurrosContributionOption>;
  phone: Scalars['String']['output'];
  pictureFile: Scalars['String']['output'];
  /** Le nom du fichier de l'image, en thème sombre */
  pictureFileDark: Scalars['String']['output'];
  /** L'URL publique de l'image */
  pictureURL: Scalars['String']['output'];
  schoolUid?: Maybe<Scalars['String']['output']>;
  /** Vrai si cette personne est administratrice d'au moins une association étudiante */
  studentAssociationAdmin: Scalars['Boolean']['output'];
  uid: Scalars['String']['output'];
  yearTier: Scalars['Int']['output'];
};


/** Users are the people who use the app */
export type ChurrosUseradminOfArgs = {
  studentAssociation: Scalars['String']['input'];
};


/** Users are the people who use the app */
export type ChurrosUseransweredFormsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Users are the people who use the app */
export type ChurrosUserarticlesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Users are the people who use the app */
export type ChurrosUserbookingArgs = {
  beneficiary?: InputMaybe<Scalars['String']['input']>;
  event: Scalars['ID']['input'];
};


/** Users are the people who use the app */
export type ChurrosUserbookingsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  forUserOnly?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Users are the people who use the app */
export type ChurrosUsercanEditGroupArgs = {
  uid: Scalars['String']['input'];
};


/** Users are the people who use the app */
export type ChurrosUserpartiallyAnsweredFormsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Users are the people who use the app */
export type ChurrosUserpictureURLArgs = {
  dark?: Scalars['Boolean']['input'];
};

export type ChurrosUserAnsweredFormsConnection = {
  edges: Array<ChurrosUserAnsweredFormsConnectionEdge>;
  nodes: Array<ChurrosForm>;
  pageInfo: ChurrosPageInfo;
};

export type ChurrosUserAnsweredFormsConnectionEdge = {
  cursor: Scalars['String']['output'];
  node: ChurrosForm;
};

export type ChurrosUserArticlesConnection = {
  edges: Array<ChurrosUserArticlesConnectionEdge>;
  nodes: Array<ChurrosArticle>;
  pageInfo: ChurrosPageInfo;
};

export type ChurrosUserArticlesConnectionEdge = {
  cursor: Scalars['String']['output'];
  node: ChurrosArticle;
};

export type ChurrosUserBookingsConnection = {
  edges: Array<ChurrosUserBookingsConnectionEdge>;
  nodes: Array<ChurrosRegistration>;
  pageInfo: ChurrosPageInfo;
};

export type ChurrosUserBookingsConnectionEdge = {
  cursor: Scalars['String']['output'];
  node: ChurrosRegistration;
};

/** UserCandidates are users in the registration process */
export type ChurrosUserCandidate = ChurrosNode & {
  address: Scalars['String']['output'];
  apprentice: Scalars['Boolean']['output'];
  birthday?: Maybe<Scalars['DateTime']['output']>;
  cededImageRightsToTVn7: Scalars['Boolean']['output'];
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  email: Scalars['String']['output'];
  /** Vrai si l'email est une adresse email d'étudiant. */
  emailIsSchoolEmail: Scalars['Boolean']['output'];
  emailValidated: Scalars['Boolean']['output'];
  firstName: Scalars['String']['output'];
  fullName: Scalars['String']['output'];
  graduationYear: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
  lastName: Scalars['String']['output'];
  /** L'identifiant local de la ressource (sans préfixe) */
  localID: Scalars['ChurrosLocalID']['output'];
  major?: Maybe<ChurrosMajor>;
  majorId?: Maybe<Scalars['ID']['output']>;
  /** Vrai si l'utilisateur aura besoin d'une validation manuelle à la fin de l'inscription. Null si la notion n'a pas encore de sens. Si la filière n'a pas encore été renseignée, retourne vrai seulement si l'inscription devra être validée manuellement si une filière (peut importe laquelle) est choisie. Voir `needsManualValidationForMajor` pour être plus précis */
  needsManualValidation?: Maybe<Scalars['Boolean']['output']>;
  /** Vrai si l'utilisateur aura besoin d'une validation manuelle à la fin de l'inscription si iel choisi cette filière. Null si la notion n'a pas encore de sens. */
  needsManualValidationForMajor?: Maybe<Scalars['Boolean']['output']>;
  phone: Scalars['String']['output'];
  schoolEmail?: Maybe<Scalars['String']['output']>;
  schoolServer?: Maybe<Scalars['String']['output']>;
  schoolUid?: Maybe<Scalars['String']['output']>;
  suggestedUid: Scalars['String']['output'];
  uid: Scalars['String']['output'];
  /** Vrai si l'utilisateur a été créé via un lien d'inscription rapide. */
  usingQuickSignup: Scalars['Boolean']['output'];
};


/** UserCandidates are users in the registration process */
export type ChurrosUserCandidateneedsManualValidationForMajorArgs = {
  major: Scalars['String']['input'];
};

export type ChurrosUserPartiallyAnsweredFormsConnection = {
  edges: Array<ChurrosUserPartiallyAnsweredFormsConnectionEdge>;
  nodes: Array<ChurrosForm>;
  pageInfo: ChurrosPageInfo;
};

export type ChurrosUserPartiallyAnsweredFormsConnectionEdge = {
  cursor: Scalars['String']['output'];
  node: ChurrosForm;
};

export type ChurrosUserSearchResult = {
  highlightedDescription: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  rank?: Maybe<Scalars['Float']['output']>;
  similarity: Scalars['Float']['output'];
  user: ChurrosUser;
};

export type ChurrosVisibility =
  | 'GroupRestricted'
  | 'Private'
  | 'Public'
  | 'SchoolRestricted'
  | 'Unlisted';

/** A validation error, as a list of field errors. */
export type ChurrosZodError = ChurrosErrorInterface & {
  fieldErrors: Array<ChurrosZodFieldError>;
  message: Scalars['String']['output'];
};

/** A validation issue for a field. */
export type ChurrosZodFieldError = {
  message: Scalars['String']['output'];
  path: Array<Scalars['String']['output']>;
};

export type Mutation = {
  /** Application Viewset */
  coreApplicationsCreate?: Maybe<CoreApplicationsCreateResponse>;
  /** Application Viewset */
  coreApplicationsUpdate?: Maybe<CoreApplicationsUpdateResponse>;
  /** Application Viewset */
  coreApplicationsPartialUpdate?: Maybe<CoreApplicationsPartialUpdateResponse>;
  /** Application Viewset */
  coreApplicationsDestroy?: Maybe<CoreApplicationsDestroyResponse>;
  /** Set application icon */
  coreApplicationsSetIconCreate?: Maybe<GenericError>;
  /** Set application icon (as URL) */
  coreApplicationsSetIconUrlCreate?: Maybe<GenericError>;
  /** FlowStageBinding Viewset */
  flowsBindingsCreate?: Maybe<FlowsBindingsCreateResponse>;
  /** FlowStageBinding Viewset */
  flowsBindingsUpdate?: Maybe<FlowsBindingsUpdateResponse>;
  /** FlowStageBinding Viewset */
  flowsBindingsPartialUpdate?: Maybe<FlowsBindingsPartialUpdateResponse>;
  /** FlowStageBinding Viewset */
  flowsBindingsDestroy?: Maybe<FlowsBindingsDestroyResponse>;
  /** Solve the previously retrieved challenge and advanced to the next stage. */
  flowsExecutorSolve?: Maybe<FlowsExecutorSolveResponse>;
  /** Flow Viewset */
  flowsInstancesCreate?: Maybe<FlowsInstancesCreateResponse>;
  /** Flow Viewset */
  flowsInstancesUpdate?: Maybe<FlowsInstancesUpdateResponse>;
  /** Flow Viewset */
  flowsInstancesPartialUpdate?: Maybe<FlowsInstancesPartialUpdateResponse>;
  /** Flow Viewset */
  flowsInstancesDestroy?: Maybe<FlowsInstancesDestroyResponse>;
  /** Set Flow background */
  flowsInstancesSetBackgroundCreate?: Maybe<GenericError>;
  /** Set Flow background (as URL) */
  flowsInstancesSetBackgroundUrlCreate?: Maybe<GenericError>;
  /** Clear flow cache */
  flowsInstancesCacheClearCreate?: Maybe<FlowsInstancesCacheClearCreateResponse>;
  /** Import flow from .yaml file */
  flowsInstancesImportCreate?: Maybe<FlowsInstancesImportCreateResponse>;
  /** Provider Viewset */
  providersAllDestroy?: Maybe<ProvidersAllDestroyResponse>;
};


export type MutationcoreApplicationsCreateArgs = {
  input?: InputMaybe<ApplicationRequestInput>;
};


export type MutationcoreApplicationsUpdateArgs = {
  slug: Scalars['String']['input'];
  input?: InputMaybe<ApplicationRequestInput>;
};


export type MutationcoreApplicationsPartialUpdateArgs = {
  slug: Scalars['String']['input'];
  input?: InputMaybe<PatchedApplicationRequestInput>;
};


export type MutationcoreApplicationsDestroyArgs = {
  slug: Scalars['String']['input'];
};


export type MutationcoreApplicationsSetIconCreateArgs = {
  slug: Scalars['String']['input'];
  input?: InputMaybe<FileUploadRequestInput>;
};


export type MutationcoreApplicationsSetIconUrlCreateArgs = {
  slug: Scalars['String']['input'];
  input?: InputMaybe<FilePathRequestInput>;
};


export type MutationflowsBindingsCreateArgs = {
  input?: InputMaybe<FlowStageBindingRequestInput>;
};


export type MutationflowsBindingsUpdateArgs = {
  fsbUuid: Scalars['UUID']['input'];
  input?: InputMaybe<FlowStageBindingRequestInput>;
};


export type MutationflowsBindingsPartialUpdateArgs = {
  fsbUuid: Scalars['UUID']['input'];
  input?: InputMaybe<PatchedFlowStageBindingRequestInput>;
};


export type MutationflowsBindingsDestroyArgs = {
  fsbUuid: Scalars['UUID']['input'];
};


export type MutationflowsExecutorSolveArgs = {
  flowSlug: Scalars['String']['input'];
  query: Scalars['String']['input'];
  input?: InputMaybe<FlowChallengeResponseRequestInput>;
};


export type MutationflowsInstancesCreateArgs = {
  input?: InputMaybe<FlowRequestInput>;
};


export type MutationflowsInstancesUpdateArgs = {
  slug: Scalars['String']['input'];
  input?: InputMaybe<FlowRequestInput>;
};


export type MutationflowsInstancesPartialUpdateArgs = {
  slug: Scalars['String']['input'];
  input?: InputMaybe<PatchedFlowRequestInput>;
};


export type MutationflowsInstancesDestroyArgs = {
  slug: Scalars['String']['input'];
};


export type MutationflowsInstancesSetBackgroundCreateArgs = {
  slug: Scalars['String']['input'];
  input?: InputMaybe<FileUploadRequestInput>;
};


export type MutationflowsInstancesSetBackgroundUrlCreateArgs = {
  slug: Scalars['String']['input'];
  input?: InputMaybe<FilePathRequestInput>;
};


export type MutationflowsInstancesImportCreateArgs = {
  input?: InputMaybe<FileUploadRequestInput>;
};


export type MutationprovidersAllDestroyArgs = {
  id: Scalars['Int']['input'];
};

export type AdminAppsListResponse = App | ValidationError | GenericError;

/** Serialize Application info */
export type App = {
  name: Scalars['String']['output'];
  label: Scalars['String']['output'];
};

/** Validation Error */
export type ValidationError = {
  nonFieldErrors?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  code?: Maybe<Scalars['String']['output']>;
  additionalProperties?: Maybe<Scalars['JSON']['output']>;
};

/** Generic API Error */
export type GenericError = {
  detail: Scalars['String']['output'];
  code?: Maybe<Scalars['String']['output']>;
};

export type AdminMetricsRetrieveResponse = LoginMetrics | ValidationError | GenericError;

/** Login Metrics per 1h */
export type LoginMetrics = {
  logins: Array<Maybe<Coordinate>>;
  loginsFailed: Array<Maybe<Coordinate>>;
  authorizations: Array<Maybe<Coordinate>>;
};

/** Coordinates for diagrams */
export type Coordinate = {
  xCord: Scalars['Int']['output'];
  yCord: Scalars['Int']['output'];
};

export type AdminModelsListResponse = App | ValidationError | GenericError;

export type AdminSettingsRetrieveResponse = Settings | ValidationError | GenericError;

/** Settings Serializer */
export type Settings = {
  /** Configure how authentik should show avatars for users. */
  avatars?: Maybe<Scalars['String']['output']>;
  /** Enable the ability for users to change their name. */
  defaultUserChangeName?: Maybe<Scalars['Boolean']['output']>;
  /** Enable the ability for users to change their email address. */
  defaultUserChangeEmail?: Maybe<Scalars['Boolean']['output']>;
  /** Enable the ability for users to change their username. */
  defaultUserChangeUsername?: Maybe<Scalars['Boolean']['output']>;
  /** Events will be deleted after this duration.(Format: weeks=3;days=2;hours=3,seconds=2). */
  eventRetention?: Maybe<Scalars['String']['output']>;
  /** The option configures the footer links on the flow executor pages. */
  footerLinks?: Maybe<Scalars['JSON']['output']>;
  /** When enabled, all the events caused by a user will be deleted upon the user's deletion. */
  gdprCompliance?: Maybe<Scalars['Boolean']['output']>;
  /** Globally enable/disable impersonation. */
  impersonation?: Maybe<Scalars['Boolean']['output']>;
  /** Default token duration */
  defaultTokenDuration?: Maybe<Scalars['String']['output']>;
  /** Default token length */
  defaultTokenLength?: Maybe<Scalars['PositiveInt']['output']>;
};

export type AdminSystemRetrieveResponse = SystemInfo | ValidationError | GenericError;

/** Get system information. */
export type SystemInfo = {
  /** Get HTTP Request headers */
  httpHeaders: Scalars['JSON']['output'];
  /** Get HTTP host */
  httpHost: Scalars['String']['output'];
  /** Get HTTP Secure flag */
  httpIsSecure: Scalars['Boolean']['output'];
  runtime: QueryAdminSystemRetrieveOneOf_0Runtime;
  /** Currently active brand */
  brand: Scalars['String']['output'];
  /** Current server time */
  serverTime: Scalars['DateTime']['output'];
  /** Whether the embedded outpost is disabled */
  embeddedOutpostDisabled: Scalars['Boolean']['output'];
  /** Get the FQDN configured on the embedded outpost */
  embeddedOutpostHost: Scalars['String']['output'];
};

/** Get versions */
export type QueryAdminSystemRetrieveOneOf_0Runtime = {
  pythonVersion: Scalars['String']['output'];
  gunicornVersion: Scalars['String']['output'];
  environment: Scalars['String']['output'];
  architecture: Scalars['String']['output'];
  platform: Scalars['String']['output'];
  uname: Scalars['String']['output'];
};

export type AdminVersionRetrieveResponse = Version | ValidationError | GenericError;

/** Get running and latest version. */
export type Version = {
  /** Get current version */
  versionCurrent: Scalars['String']['output'];
  /** Get latest version from cache */
  versionLatest: Scalars['String']['output'];
  /** Check if latest version is valid */
  versionLatestValid: Scalars['Boolean']['output'];
  /** Get build hash, if version is not latest or released */
  buildHash: Scalars['String']['output'];
  /** Check if we're running the latest version */
  outdated: Scalars['Boolean']['output'];
};

export type AdminWorkersRetrieveResponse = Workers | ValidationError | GenericError;

export type Workers = {
  count: Scalars['Int']['output'];
};

export type AuthenticatorsAdminAllListResponse = Device | ValidationError | GenericError;

/** Serializer for Duo authenticator devices */
export type Device = {
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  pk: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  /** Get type of device */
  type: Scalars['String']['output'];
  confirmed: Scalars['Boolean']['output'];
};

export type AuthenticatorsAdminDuoListResponse = PaginatedDuoDeviceList | ValidationError | GenericError;

export type PaginatedDuoDeviceList = {
  pagination: Pagination;
  results: Array<Maybe<DuoDevice>>;
};

export type Pagination = {
  next: Scalars['Float']['output'];
  previous: Scalars['Float']['output'];
  count: Scalars['Float']['output'];
  current: Scalars['Float']['output'];
  totalPages: Scalars['Float']['output'];
  startIndex: Scalars['Float']['output'];
  endIndex: Scalars['Float']['output'];
};

/** Serializer for Duo authenticator devices */
export type DuoDevice = {
  pk: Scalars['Int']['output'];
  /** The human-readable name of this device. */
  name: Scalars['QueryAuthenticatorsAdminDuoListOneOf_0ResultsItemsName']['output'];
};

export type AuthenticatorsAdminDuoRetrieveResponse = DuoDevice | ValidationError | GenericError;

export type AuthenticatorsAdminSmsListResponse = PaginatedSmsDeviceList | ValidationError | GenericError;

export type PaginatedSmsDeviceList = {
  pagination: Pagination;
  results: Array<Maybe<SmsDevice>>;
};

/** Serializer for sms authenticator devices */
export type SmsDevice = {
  /** The human-readable name of this device. */
  name: Scalars['QueryAuthenticatorsAdminSmsListOneOf_0ResultsItemsName']['output'];
  pk: Scalars['Int']['output'];
  phoneNumber: Scalars['String']['output'];
};

export type AuthenticatorsAdminSmsRetrieveResponse = SmsDevice | ValidationError | GenericError;

export type AuthenticatorsAdminStaticListResponse = PaginatedStaticDeviceList | ValidationError | GenericError;

export type PaginatedStaticDeviceList = {
  pagination: Pagination;
  results: Array<Maybe<StaticDevice>>;
};

/** Serializer for static authenticator devices */
export type StaticDevice = {
  /** The human-readable name of this device. */
  name: Scalars['QueryAuthenticatorsAdminStaticListOneOf_0ResultsItemsName']['output'];
  tokenSet: Array<Maybe<StaticDeviceToken>>;
  pk: Scalars['Int']['output'];
};

/** Serializer for static device's tokens */
export type StaticDeviceToken = {
  token: Scalars['QueryAuthenticatorsAdminStaticListOneOf_0ResultsItemsTokenSetItemsToken']['output'];
};

export type AuthenticatorsAdminStaticRetrieveResponse = StaticDevice | ValidationError | GenericError;

export type AuthenticatorsAdminTotpListResponse = PaginatedTotpDeviceList | ValidationError | GenericError;

export type PaginatedTotpDeviceList = {
  pagination: Pagination;
  results: Array<Maybe<TotpDevice>>;
};

/** Serializer for totp authenticator devices */
export type TotpDevice = {
  /** The human-readable name of this device. */
  name: Scalars['QueryAuthenticatorsAdminTotpListOneOf_0ResultsItemsName']['output'];
  pk: Scalars['Int']['output'];
};

export type AuthenticatorsAdminTotpRetrieveResponse = TotpDevice | ValidationError | GenericError;

export type AuthenticatorsAdminWebauthnListResponse = PaginatedWebAuthnDeviceList | ValidationError | GenericError;

export type PaginatedWebAuthnDeviceList = {
  pagination: Pagination;
  results: Array<Maybe<WebAuthnDevice>>;
};

/** Serializer for WebAuthn authenticator devices */
export type WebAuthnDevice = {
  pk: Scalars['Int']['output'];
  name: Scalars['QueryAuthenticatorsAdminWebauthnListOneOf_0ResultsItemsName']['output'];
  createdOn: Scalars['DateTime']['output'];
  deviceType: WebAuthnDeviceType;
  aaguid: Scalars['String']['output'];
};

/** WebAuthnDeviceType Serializer */
export type WebAuthnDeviceType = {
  aaguid: Scalars['UUID']['output'];
  description: Scalars['String']['output'];
};

export type AuthenticatorsAdminWebauthnRetrieveResponse = WebAuthnDevice | ValidationError | GenericError;

export type AuthenticatorsAllListResponse = Device | ValidationError | GenericError;

export type AuthenticatorsDuoListResponse = PaginatedDuoDeviceList | ValidationError | GenericError;

export type AuthenticatorsDuoRetrieveResponse = DuoDevice | ValidationError | GenericError;

export type AuthenticatorsDuoUsedByListResponse = UsedBy | ValidationError | GenericError;

/** A list of all objects referencing the queried object */
export type UsedBy = {
  app: Scalars['String']['output'];
  modelName: Scalars['String']['output'];
  pk: Scalars['String']['output'];
  name: Scalars['String']['output'];
  action: UsedByActionEnum;
};

export type UsedByActionEnum =
  | 'CASCADE'
  | 'CASCADE_MANY'
  | 'SET_NULL'
  | 'SET_DEFAULT';

export type AuthenticatorsSmsListResponse = PaginatedSmsDeviceList | ValidationError | GenericError;

export type AuthenticatorsSmsRetrieveResponse = SmsDevice | ValidationError | GenericError;

export type AuthenticatorsSmsUsedByListResponse = UsedBy | ValidationError | GenericError;

export type AuthenticatorsStaticListResponse = PaginatedStaticDeviceList | ValidationError | GenericError;

export type AuthenticatorsStaticRetrieveResponse = StaticDevice | ValidationError | GenericError;

export type AuthenticatorsStaticUsedByListResponse = UsedBy | ValidationError | GenericError;

export type AuthenticatorsTotpListResponse = PaginatedTotpDeviceList | ValidationError | GenericError;

export type AuthenticatorsTotpRetrieveResponse = TotpDevice | ValidationError | GenericError;

export type AuthenticatorsTotpUsedByListResponse = UsedBy | ValidationError | GenericError;

export type AuthenticatorsWebauthnListResponse = PaginatedWebAuthnDeviceList | ValidationError | GenericError;

export type AuthenticatorsWebauthnRetrieveResponse = WebAuthnDevice | ValidationError | GenericError;

export type AuthenticatorsWebauthnUsedByListResponse = UsedBy | ValidationError | GenericError;

export type CoreApplicationsListResponse = PaginatedApplicationList | ValidationError | GenericError;

export type PaginatedApplicationList = {
  pagination: Pagination;
  results: Array<Maybe<Application>>;
};

/** Application Serializer */
export type Application = {
  pk: Scalars['UUID']['output'];
  /** Application's display Name. */
  name: Scalars['String']['output'];
  slug: Scalars['QueryCoreApplicationsListOneOf_0ResultsItemsSlug']['output'];
  provider?: Maybe<Scalars['Int']['output']>;
  providerObj: Provider;
  backchannelProviders?: Maybe<Array<Maybe<Scalars['Int']['output']>>>;
  backchannelProvidersObj: Array<Maybe<Provider>>;
  /** Allow formatting of launch URL */
  launchUrl?: Maybe<Scalars['String']['output']>;
  /** Open launch URL in a new browser tab or window. */
  openInNewTab?: Maybe<Scalars['Boolean']['output']>;
  metaLaunchUrl?: Maybe<Scalars['URL']['output']>;
  /**
   * Get the URL to the App Icon image. If the name is /static or starts with http
   * it is returned as-is
   */
  metaIcon?: Maybe<Scalars['String']['output']>;
  metaDescription?: Maybe<Scalars['String']['output']>;
  metaPublisher?: Maybe<Scalars['String']['output']>;
  policyEngineMode?: Maybe<PolicyEngineMode>;
  groupSlug?: Maybe<Scalars['String']['output']>;
  churrosGroup: ChurrosGroup;
  metrics?: Maybe<Array<Maybe<CoreApplicationsMetricsListResponse>>>;
};

/** Provider Serializer */
export type Provider = {
  pk: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  /** Flow used for authentication when the associated application is accessed by an un-authenticated user. */
  authenticationFlow?: Maybe<Scalars['UUID']['output']>;
  /** Flow used when authorizing this provider. */
  authorizationFlow: Scalars['UUID']['output'];
  propertyMappings?: Maybe<Array<Maybe<Scalars['UUID']['output']>>>;
  /** Get object component so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Internal application name, used in URLs. */
  assignedApplicationSlug: Scalars['String']['output'];
  /** Application's display Name. */
  assignedApplicationName: Scalars['String']['output'];
  /** Internal application name, used in URLs. */
  assignedBackchannelApplicationSlug: Scalars['String']['output'];
  /** Application's display Name. */
  assignedBackchannelApplicationName: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  additionalProperties?: Maybe<Scalars['JSON']['output']>;
  application?: Maybe<CoreApplicationsRetrieveResponse>;
};

export type PolicyEngineMode =
  | 'ALL'
  | 'ANY';

export type CoreApplicationsRetrieveResponse = Application | ValidationError | GenericError;

export type CoreApplicationsCheckAccessRetrieveResponse = PolicyTestResult | ValidationError | GenericError;

/** result of a policy test */
export type PolicyTestResult = {
  passing: Scalars['Boolean']['output'];
  messages: Array<Maybe<Scalars['String']['output']>>;
  logMessages: Array<Maybe<LogEvent>>;
};

/** Single log message with all context logged. */
export type LogEvent = {
  timestamp: Scalars['DateTime']['output'];
  logLevel: LogLevelEnum;
  logger: Scalars['String']['output'];
  event: Scalars['String']['output'];
  attributes: Scalars['JSON']['output'];
};

export type LogLevelEnum =
  | 'CRITICAL'
  | 'EXCEPTION'
  | 'ERROR'
  | 'WARN'
  | 'WARNING'
  | 'INFO'
  | 'DEBUG'
  | 'NOTSET';

export type CoreApplicationsMetricsListResponse = Coordinate | ValidationError | GenericError;

export type CoreApplicationsUsedByListResponse = UsedBy | ValidationError | GenericError;

export type CoreAuthenticatedSessionsListResponse = PaginatedAuthenticatedSessionList | ValidationError | GenericError;

export type PaginatedAuthenticatedSessionList = {
  pagination: Pagination;
  results: Array<Maybe<AuthenticatedSession>>;
};

/** AuthenticatedSession Serializer */
export type AuthenticatedSession = {
  uuid?: Maybe<Scalars['UUID']['output']>;
  /** Check if session is currently active session */
  current: Scalars['Boolean']['output'];
  userAgent: QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgent;
  geoIp?: Maybe<QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsGeoIp>;
  asn?: Maybe<QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsAsn>;
  user: Scalars['Int']['output'];
  lastIp: Scalars['String']['output'];
  lastUserAgent?: Maybe<Scalars['String']['output']>;
  lastUsed: Scalars['DateTime']['output'];
  expires?: Maybe<Scalars['DateTime']['output']>;
};

/** Get parsed user agent */
export type QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgent = {
  device: QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentDevice;
  os: QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentOs;
  userAgent: QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentUserAgent;
  string: Scalars['String']['output'];
};

/** User agent device */
export type QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentDevice = {
  brand: Scalars['String']['output'];
  family: Scalars['String']['output'];
  model: Scalars['String']['output'];
};

/** User agent os */
export type QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentOs = {
  family: Scalars['String']['output'];
  major: Scalars['String']['output'];
  minor: Scalars['String']['output'];
  patch: Scalars['String']['output'];
  patchMinor: Scalars['String']['output'];
};

/** User agent browser */
export type QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentUserAgent = {
  family: Scalars['String']['output'];
  major: Scalars['String']['output'];
  minor: Scalars['String']['output'];
  patch: Scalars['String']['output'];
};

/** Get GeoIP Data */
export type QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsGeoIp = {
  continent: Scalars['String']['output'];
  country: Scalars['String']['output'];
  lat: Scalars['Float']['output'];
  long: Scalars['Float']['output'];
  city: Scalars['String']['output'];
};

/** Get ASN Data */
export type QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsAsn = {
  asn: Scalars['Int']['output'];
  asOrg?: Maybe<Scalars['String']['output']>;
  network?: Maybe<Scalars['String']['output']>;
};

export type CoreAuthenticatedSessionsRetrieveResponse = AuthenticatedSession | ValidationError | GenericError;

export type CoreAuthenticatedSessionsUsedByListResponse = UsedBy | ValidationError | GenericError;

export type CoreBrandsListResponse = PaginatedBrandList | ValidationError | GenericError;

export type PaginatedBrandList = {
  pagination: Pagination;
  results: Array<Maybe<Brand>>;
};

/** Brand Serializer */
export type Brand = {
  brandUuid: Scalars['UUID']['output'];
  /** Domain that activates this brand. Can be a superset, i.e. `a.b` for `aa.b` and `ba.b` */
  domain: Scalars['String']['output'];
  default?: Maybe<Scalars['Boolean']['output']>;
  brandingTitle?: Maybe<Scalars['String']['output']>;
  brandingLogo?: Maybe<Scalars['String']['output']>;
  brandingFavicon?: Maybe<Scalars['String']['output']>;
  flowAuthentication?: Maybe<Scalars['UUID']['output']>;
  flowInvalidation?: Maybe<Scalars['UUID']['output']>;
  flowRecovery?: Maybe<Scalars['UUID']['output']>;
  flowUnenrollment?: Maybe<Scalars['UUID']['output']>;
  flowUserSettings?: Maybe<Scalars['UUID']['output']>;
  flowDeviceCode?: Maybe<Scalars['UUID']['output']>;
  /** Web Certificate used by the authentik Core webserver. */
  webCertificate?: Maybe<Scalars['UUID']['output']>;
  attributes?: Maybe<Scalars['JSON']['output']>;
};

export type CoreBrandsRetrieveResponse = Brand | ValidationError | GenericError;

export type CoreBrandsUsedByListResponse = UsedBy | ValidationError | GenericError;

export type CoreBrandsCurrentRetrieveResponse = CurrentBrand | ValidationError | GenericError;

/** Partial brand information for styling */
export type CurrentBrand = {
  matchedDomain: Scalars['String']['output'];
  brandingTitle: Scalars['String']['output'];
  brandingLogo: Scalars['String']['output'];
  brandingFavicon: Scalars['String']['output'];
  uiFooterLinks: Array<Maybe<FooterLink>>;
  uiTheme: UiThemeEnum;
  flowAuthentication?: Maybe<Scalars['String']['output']>;
  flowInvalidation?: Maybe<Scalars['String']['output']>;
  flowRecovery?: Maybe<Scalars['String']['output']>;
  flowUnenrollment?: Maybe<Scalars['String']['output']>;
  flowUserSettings?: Maybe<Scalars['String']['output']>;
  flowDeviceCode?: Maybe<Scalars['String']['output']>;
  defaultLocale: Scalars['String']['output'];
};

/** Links returned in Config API */
export type FooterLink = {
  href: Scalars['String']['output'];
  name: Scalars['String']['output'];
};

export type UiThemeEnum =
  | 'AUTOMATIC'
  | 'LIGHT'
  | 'DARK';

export type CoreGroupsListResponse = PaginatedGroupList | ValidationError | GenericError;

export type PaginatedGroupList = {
  pagination: Pagination;
  results: Array<Maybe<Group>>;
};

/** Group Serializer */
export type Group = {
  pk: Scalars['UUID']['output'];
  numPk: Scalars['Int']['output'];
  name: Scalars['QueryCoreGroupsListOneOf_0ResultsItemsName']['output'];
  /** Users added to this group will be superusers. */
  isSuperuser?: Maybe<Scalars['Boolean']['output']>;
  parent?: Maybe<Scalars['UUID']['output']>;
  parentName?: Maybe<Scalars['String']['output']>;
  users?: Maybe<Array<Maybe<Scalars['Int']['output']>>>;
  usersObj?: Maybe<Array<Maybe<GroupMember>>>;
  attributes?: Maybe<Scalars['JSON']['output']>;
  roles?: Maybe<Array<Maybe<Scalars['UUID']['output']>>>;
  rolesObj: Array<Maybe<Role>>;
  additionalProperties?: Maybe<Scalars['JSON']['output']>;
};

/** Stripped down user serializer to show relevant users for groups */
export type GroupMember = {
  pk: Scalars['Int']['output'];
  username: Scalars['QueryCoreGroupsListOneOf_0ResultsItemsUsersObjItemsUsername']['output'];
  /** User's display name. */
  name: Scalars['String']['output'];
  /** Designates whether this user should be treated as active. Unselect this instead of deleting accounts. */
  isActive?: Maybe<Scalars['Boolean']['output']>;
  lastLogin?: Maybe<Scalars['DateTime']['output']>;
  email?: Maybe<Scalars['EmailAddress']['output']>;
  attributes?: Maybe<Scalars['JSON']['output']>;
  uid: Scalars['String']['output'];
  additionalProperties?: Maybe<Scalars['JSON']['output']>;
};

/** Role serializer */
export type Role = {
  pk: Scalars['UUID']['output'];
  name: Scalars['QueryCoreGroupsListOneOf_0ResultsItemsRolesObjItemsName']['output'];
};

export type CoreGroupsRetrieveResponse = Group | ValidationError | GenericError;

export type CoreGroupsUsedByListResponse = UsedBy | ValidationError | GenericError;

export type CoreTokensListResponse = PaginatedTokenList | ValidationError | GenericError;

export type PaginatedTokenList = {
  pagination: Pagination;
  results: Array<Maybe<Token>>;
};

/** Token Serializer */
export type Token = {
  pk: Scalars['UUID']['output'];
  /** Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update. */
  managed?: Maybe<Scalars['String']['output']>;
  identifier: Scalars['QueryCoreTokensListOneOf_0ResultsItemsIdentifier']['output'];
  intent?: Maybe<IntentEnum>;
  user?: Maybe<Scalars['Int']['output']>;
  userObj: User;
  description?: Maybe<Scalars['String']['output']>;
  expires?: Maybe<Scalars['DateTime']['output']>;
  expiring?: Maybe<Scalars['Boolean']['output']>;
  additionalProperties?: Maybe<Scalars['JSON']['output']>;
};

export type IntentEnum =
  | 'VERIFICATION'
  | 'API'
  | 'RECOVERY'
  | 'APP_PASSWORD';

/** User Serializer */
export type User = {
  pk: Scalars['Int']['output'];
  username: Scalars['QueryCoreTokensListOneOf_0ResultsItemsUserObjUsername']['output'];
  /** User's display name. */
  name: Scalars['String']['output'];
  /** Designates whether this user should be treated as active. Unselect this instead of deleting accounts. */
  isActive?: Maybe<Scalars['Boolean']['output']>;
  lastLogin?: Maybe<Scalars['DateTime']['output']>;
  isSuperuser: Scalars['Boolean']['output'];
  groups?: Maybe<Array<Maybe<Scalars['UUID']['output']>>>;
  groupsObj?: Maybe<Array<Maybe<UserGroup>>>;
  email?: Maybe<Scalars['EmailAddress']['output']>;
  /** User's avatar, either a http/https URL or a data URI */
  avatar: Scalars['String']['output'];
  attributes?: Maybe<Scalars['JSON']['output']>;
  uid: Scalars['String']['output'];
  path?: Maybe<Scalars['String']['output']>;
  type?: Maybe<UserTypeEnum>;
  uuid: Scalars['UUID']['output'];
  additionalProperties?: Maybe<Scalars['JSON']['output']>;
};

/** Simplified Group Serializer for user's groups */
export type UserGroup = {
  pk: Scalars['UUID']['output'];
  /** Get a numerical, int32 ID for the group */
  numPk: Scalars['Int']['output'];
  name: Scalars['QueryCoreTokensListOneOf_0ResultsItemsUserObjGroupsObjItemsName']['output'];
  /** Users added to this group will be superusers. */
  isSuperuser?: Maybe<Scalars['Boolean']['output']>;
  parent?: Maybe<Scalars['UUID']['output']>;
  parentName?: Maybe<Scalars['String']['output']>;
  attributes?: Maybe<Scalars['JSON']['output']>;
  additionalProperties?: Maybe<Scalars['JSON']['output']>;
};

export type UserTypeEnum =
  | 'INTERNAL'
  | 'EXTERNAL'
  | 'SERVICE_ACCOUNT'
  | 'INTERNAL_SERVICE_ACCOUNT';

export type QueryInputCoreTokensListIntent =
  | 'API'
  | 'APP_PASSWORD'
  | 'RECOVERY'
  | 'VERIFICATION';

export type CoreTokensRetrieveResponse = Token | ValidationError | GenericError;

export type CoreTokensUsedByListResponse = UsedBy | ValidationError | GenericError;

export type CoreTokensViewKeyRetrieveResponse = TokenView | ValidationError | GenericError;

/** Show token's current key */
export type TokenView = {
  key: Scalars['String']['output'];
};

export type CoreUserConsentListResponse = PaginatedUserConsentList | ValidationError | GenericError;

export type PaginatedUserConsentList = {
  pagination: Pagination;
  results: Array<Maybe<UserConsent>>;
};

/** UserConsent Serializer */
export type UserConsent = {
  pk: Scalars['Int']['output'];
  expires?: Maybe<Scalars['DateTime']['output']>;
  expiring?: Maybe<Scalars['Boolean']['output']>;
  user: User;
  application: Application;
  permissions?: Maybe<Scalars['String']['output']>;
};

export type CoreUserConsentRetrieveResponse = UserConsent | ValidationError | GenericError;

export type CoreUserConsentUsedByListResponse = UsedBy | ValidationError | GenericError;

export type CoreUsersListResponse = PaginatedUserList | ValidationError | GenericError;

export type PaginatedUserList = {
  pagination: Pagination;
  results: Array<Maybe<User>>;
};

export type QueryInputCoreUsersListTypeItems =
  | 'EXTERNAL'
  | 'INTERNAL'
  | 'INTERNAL_SERVICE_ACCOUNT'
  | 'SERVICE_ACCOUNT';

export type CoreUsersRetrieveResponse = User | ValidationError | GenericError;

export type CoreUsersMetricsRetrieveResponse = UserMetrics | ValidationError | GenericError;

/** User Metrics */
export type UserMetrics = {
  logins: Array<Maybe<Coordinate>>;
  loginsFailed: Array<Maybe<Coordinate>>;
  authorizations: Array<Maybe<Coordinate>>;
};

export type CoreUsersUsedByListResponse = UsedBy | ValidationError | GenericError;

export type CoreUsersImpersonateEndRetrieveResponse = VoidContainer | ValidationError | GenericError;

export type VoidContainer = {
  void?: Maybe<Scalars['Void']['output']>;
};

export type CoreUsersMeRetrieveResponse = SessionUser | ValidationError | GenericError;

/**
 * Response for the /user/me endpoint, returns the currently active user (as `user` property)
 * and, if this user is being impersonated, the original user in the `original` property.
 */
export type SessionUser = {
  user: UserSelf;
  original?: Maybe<UserSelf>;
};

/** User Serializer for information a user can retrieve about themselves */
export type UserSelf = {
  pk: Scalars['Int']['output'];
  username: Scalars['QueryCoreUsersMeRetrieveOneOf_0UserUsername']['output'];
  /** User's display name. */
  name: Scalars['String']['output'];
  /** Designates whether this user should be treated as active. Unselect this instead of deleting accounts. */
  isActive: Scalars['Boolean']['output'];
  isSuperuser: Scalars['Boolean']['output'];
  groups: Array<Maybe<UserSelfGroups>>;
  email?: Maybe<Scalars['EmailAddress']['output']>;
  /** User's avatar, either a http/https URL or a data URI */
  avatar: Scalars['String']['output'];
  uid: Scalars['String']['output'];
  /** Get user settings with brand and group settings applied */
  settings: Scalars['JSON']['output'];
  type?: Maybe<UserTypeEnum>;
  /** Get all system permissions assigned to the user */
  systemPermissions: Array<Maybe<Scalars['String']['output']>>;
};

export type UserSelfGroups = {
  name: Scalars['String']['output'];
  pk: Scalars['String']['output'];
};

export type CoreUsersPathsRetrieveResponse = UserPath | ValidationError | GenericError;

export type UserPath = {
  paths: Array<Maybe<Scalars['String']['output']>>;
};

export type CryptoCertificatekeypairsListResponse = PaginatedCertificateKeyPairList | ValidationError | GenericError;

export type PaginatedCertificateKeyPairList = {
  pagination: Pagination;
  results: Array<Maybe<CertificateKeyPair>>;
};

/** CertificateKeyPair Serializer */
export type CertificateKeyPair = {
  pk: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  /** Get certificate Hash (SHA256) */
  fingerprintSha256?: Maybe<Scalars['String']['output']>;
  /** Get certificate Hash (SHA1) */
  fingerprintSha1?: Maybe<Scalars['String']['output']>;
  /** Get certificate expiry */
  certExpiry?: Maybe<Scalars['DateTime']['output']>;
  /** Get certificate subject as full rfc4514 */
  certSubject?: Maybe<Scalars['String']['output']>;
  /** Show if this keypair has a private key configured or not */
  privateKeyAvailable: Scalars['Boolean']['output'];
  /** Get the private key's type, if set */
  privateKeyType?: Maybe<Scalars['String']['output']>;
  /** Get URL to download certificate */
  certificateDownloadUrl: Scalars['String']['output'];
  /** Get URL to download private key */
  privateKeyDownloadUrl: Scalars['String']['output'];
  /** Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update. */
  managed?: Maybe<Scalars['String']['output']>;
};

export type CryptoCertificatekeypairsRetrieveResponse = CertificateKeyPair | ValidationError | GenericError;

export type CryptoCertificatekeypairsUsedByListResponse = UsedBy | ValidationError | GenericError;

export type CryptoCertificatekeypairsViewCertificateRetrieveResponse = CertificateData | ValidationError | GenericError;

/** Get CertificateKeyPair's data */
export type CertificateData = {
  data: Scalars['String']['output'];
};

export type CryptoCertificatekeypairsViewPrivateKeyRetrieveResponse = CertificateData | ValidationError | GenericError;

export type EnterpriseLicenseListResponse = PaginatedLicenseList | ValidationError | GenericError;

export type PaginatedLicenseList = {
  pagination: Pagination;
  results: Array<Maybe<License>>;
};

/** License Serializer */
export type License = {
  licenseUuid: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  key: Scalars['String']['output'];
  expiry: Scalars['DateTime']['output'];
  internalUsers: Scalars['Int']['output'];
  externalUsers: Scalars['Int']['output'];
};

export type EnterpriseLicenseRetrieveResponse = License | ValidationError | GenericError;

export type EnterpriseLicenseUsedByListResponse = UsedBy | ValidationError | GenericError;

export type EnterpriseLicenseForecastRetrieveResponse = LicenseForecast | ValidationError | GenericError;

/** Serializer for license forecast */
export type LicenseForecast = {
  internalUsers: Scalars['Int']['output'];
  externalUsers: Scalars['Int']['output'];
  forecastedInternalUsers: Scalars['Int']['output'];
  forecastedExternalUsers: Scalars['Int']['output'];
};

export type EnterpriseLicenseGetInstallIdRetrieveResponse = InstallId | ValidationError | GenericError;

export type InstallId = {
  installId: Scalars['String']['output'];
};

export type EnterpriseLicenseSummaryRetrieveResponse = LicenseSummary | ValidationError | GenericError;

/** Serializer for license status */
export type LicenseSummary = {
  internalUsers: Scalars['Int']['output'];
  externalUsers: Scalars['Int']['output'];
  valid: Scalars['Boolean']['output'];
  showAdminWarning: Scalars['Boolean']['output'];
  showUserWarning: Scalars['Boolean']['output'];
  readOnly: Scalars['Boolean']['output'];
  latestValid: Scalars['DateTime']['output'];
  hasLicense: Scalars['Boolean']['output'];
};

export type EventsEventsListResponse = PaginatedEventList | ValidationError | GenericError;

export type PaginatedEventList = {
  pagination: Pagination;
  results: Array<Maybe<Event>>;
};

/** Event Serializer */
export type Event = {
  pk: Scalars['UUID']['output'];
  user?: Maybe<Scalars['JSON']['output']>;
  action: EventActions;
  app: Scalars['String']['output'];
  context?: Maybe<Scalars['JSON']['output']>;
  clientIp?: Maybe<Scalars['String']['output']>;
  created: Scalars['DateTime']['output'];
  expires?: Maybe<Scalars['DateTime']['output']>;
  brand?: Maybe<Scalars['JSON']['output']>;
};

export type EventActions =
  | 'LOGIN'
  | 'LOGIN_FAILED'
  | 'LOGOUT'
  | 'USER_WRITE'
  | 'SUSPICIOUS_REQUEST'
  | 'PASSWORD_SET'
  | 'SECRET_VIEW'
  | 'SECRET_ROTATE'
  | 'INVITATION_USED'
  | 'AUTHORIZE_APPLICATION'
  | 'SOURCE_LINKED'
  | 'IMPERSONATION_STARTED'
  | 'IMPERSONATION_ENDED'
  | 'FLOW_EXECUTION'
  | 'POLICY_EXECUTION'
  | 'POLICY_EXCEPTION'
  | 'PROPERTY_MAPPING_EXCEPTION'
  | 'SYSTEM_TASK_EXECUTION'
  | 'SYSTEM_TASK_EXCEPTION'
  | 'SYSTEM_EXCEPTION'
  | 'CONFIGURATION_ERROR'
  | 'MODEL_CREATED'
  | 'MODEL_UPDATED'
  | 'MODEL_DELETED'
  | 'EMAIL_SENT'
  | 'UPDATE_AVAILABLE'
  | 'CUSTOM_';

export type EventsEventsRetrieveResponse = Event | ValidationError | GenericError;

export type EventsEventsActionsListResponse = TypeCreate | ValidationError | GenericError;

/** Types of an object that can be created */
export type TypeCreate = {
  name: Scalars['String']['output'];
  description: Scalars['String']['output'];
  component: Scalars['String']['output'];
  modelName: Scalars['String']['output'];
  requiresEnterprise?: Maybe<Scalars['Boolean']['output']>;
};

export type EventsEventsPerMonthListResponse = Coordinate | ValidationError | GenericError;

export type EventsEventsTopPerUserListResponse = EventTopPerUser | ValidationError | GenericError;

/** Response object of Event's top_per_user */
export type EventTopPerUser = {
  application: Scalars['JSON']['output'];
  countedEvents: Scalars['Int']['output'];
  uniqueUsers: Scalars['Int']['output'];
};

export type EventsEventsVolumeListResponse = Coordinate | ValidationError | GenericError;

export type EventsNotificationsListResponse = PaginatedNotificationList | ValidationError | GenericError;

export type PaginatedNotificationList = {
  pagination: Pagination;
  results: Array<Maybe<Notification>>;
};

/** Notification Serializer */
export type Notification = {
  pk: Scalars['UUID']['output'];
  severity: SeverityEnum;
  body: Scalars['String']['output'];
  created: Scalars['DateTime']['output'];
  event?: Maybe<Event>;
  seen?: Maybe<Scalars['Boolean']['output']>;
};

export type SeverityEnum =
  | 'NOTICE'
  | 'WARNING'
  | 'ALERT';

export type QueryInputEventsNotificationsListSeverity =
  | 'ALERT'
  | 'NOTICE'
  | 'WARNING';

export type EventsNotificationsRetrieveResponse = Notification | ValidationError | GenericError;

export type EventsNotificationsUsedByListResponse = UsedBy | ValidationError | GenericError;

export type EventsRulesListResponse = PaginatedNotificationRuleList | ValidationError | GenericError;

export type PaginatedNotificationRuleList = {
  pagination: Pagination;
  results: Array<Maybe<NotificationRule>>;
};

/** NotificationRule Serializer */
export type NotificationRule = {
  pk: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  /** Select which transports should be used to notify the user. If none are selected, the notification will only be shown in the authentik UI. */
  transports?: Maybe<Array<Maybe<Scalars['UUID']['output']>>>;
  severity?: Maybe<SeverityEnum>;
  /** Define which group of users this notification should be sent and shown to. If left empty, Notification won't ben sent. */
  group?: Maybe<Scalars['UUID']['output']>;
  groupObj: Group;
};

/** Controls which severity level the created notifications will have. */
export type QueryInputEventsRulesListSeverity =
  | 'ALERT'
  | 'NOTICE'
  | 'WARNING';

export type EventsRulesRetrieveResponse = NotificationRule | ValidationError | GenericError;

export type EventsRulesUsedByListResponse = UsedBy | ValidationError | GenericError;

export type EventsSystemTasksListResponse = PaginatedSystemTaskList | ValidationError | GenericError;

export type PaginatedSystemTaskList = {
  pagination: Pagination;
  results: Array<Maybe<SystemTask>>;
};

/** Serialize TaskInfo and TaskResult */
export type SystemTask = {
  uuid: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  /** Get full name with UID */
  fullName: Scalars['String']['output'];
  uid?: Maybe<Scalars['String']['output']>;
  description: Scalars['String']['output'];
  startTimestamp: Scalars['DateTime']['output'];
  finishTimestamp: Scalars['DateTime']['output'];
  duration: Scalars['Float']['output'];
  status: SystemTaskStatusEnum;
  messages: Array<Maybe<LogEvent>>;
};

export type SystemTaskStatusEnum =
  | 'UNKNOWN'
  | 'SUCCESSFUL'
  | 'WARNING'
  | 'ERROR';

export type QueryInputEventsSystemTasksListStatus =
  | 'ERROR'
  | 'SUCCESSFUL'
  | 'UNKNOWN'
  | 'WARNING';

export type EventsSystemTasksRetrieveResponse = SystemTask | ValidationError | GenericError;

export type EventsTransportsListResponse = PaginatedNotificationTransportList | ValidationError | GenericError;

export type PaginatedNotificationTransportList = {
  pagination: Pagination;
  results: Array<Maybe<NotificationTransport>>;
};

/** NotificationTransport Serializer */
export type NotificationTransport = {
  pk: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  mode?: Maybe<NotificationTransportModeEnum>;
  /** Return selected mode with a UI Label */
  modeVerbose: Scalars['String']['output'];
  webhookUrl?: Maybe<Scalars['URL']['output']>;
  webhookMapping?: Maybe<Scalars['UUID']['output']>;
  /** Only send notification once, for example when sending a webhook into a chat channel. */
  sendOnce?: Maybe<Scalars['Boolean']['output']>;
};

export type NotificationTransportModeEnum =
  | 'LOCAL'
  | 'WEBHOOK'
  | 'WEBHOOK_SLACK'
  | 'EMAIL';

export type QueryInputEventsTransportsListMode =
  | 'EMAIL'
  | 'LOCAL'
  | 'WEBHOOK'
  | 'WEBHOOK_SLACK';

export type EventsTransportsRetrieveResponse = NotificationTransport | ValidationError | GenericError;

export type EventsTransportsUsedByListResponse = UsedBy | ValidationError | GenericError;

export type FlowsBindingsListResponse = PaginatedFlowStageBindingList | ValidationError | GenericError;

export type PaginatedFlowStageBindingList = {
  pagination: Pagination;
  results: Array<Maybe<FlowStageBinding>>;
};

/** FlowStageBinding Serializer */
export type FlowStageBinding = {
  pk: Scalars['UUID']['output'];
  policybindingmodelPtrId: Scalars['UUID']['output'];
  target: Scalars['UUID']['output'];
  stage: Scalars['UUID']['output'];
  stageObj: Stage;
  /** Evaluate policies during the Flow planning process. */
  evaluateOnPlan?: Maybe<Scalars['Boolean']['output']>;
  /** Evaluate policies when the Stage is present to the user. */
  reEvaluatePolicies?: Maybe<Scalars['Boolean']['output']>;
  order: Scalars['Int']['output'];
  policyEngineMode?: Maybe<PolicyEngineMode>;
  invalidResponseAction?: Maybe<InvalidResponseActionEnum>;
  additionalProperties?: Maybe<Scalars['JSON']['output']>;
};

/** Stage Serializer */
export type Stage = {
  pk: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  /** Get object type so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  flowSet?: Maybe<Array<Maybe<FlowSet>>>;
  additionalProperties?: Maybe<Scalars['JSON']['output']>;
};

/** Stripped down flow serializer */
export type FlowSet = {
  pk: Scalars['UUID']['output'];
  policybindingmodelPtrId: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  slug: Scalars['QueryFlowsBindingsListOneOf_0ResultsItemsStageObjFlowSetItemsSlug']['output'];
  /** Shown as the Title in Flow pages. */
  title: Scalars['String']['output'];
  designation: FlowDesignationEnum;
  /**
   * Get the URL to the background image. If the name is /static or starts with http
   * it is returned as-is
   */
  background: Scalars['String']['output'];
  policyEngineMode?: Maybe<PolicyEngineMode>;
  /** Enable compatibility mode, increases compatibility with password managers on mobile devices. */
  compatibilityMode?: Maybe<Scalars['Boolean']['output']>;
  /** Get export URL for flow */
  exportUrl: Scalars['String']['output'];
  layout?: Maybe<FlowLayoutEnum>;
  deniedAction?: Maybe<DeniedActionEnum>;
};

export type FlowDesignationEnum =
  | 'AUTHENTICATION'
  | 'AUTHORIZATION'
  | 'INVALIDATION'
  | 'ENROLLMENT'
  | 'UNENROLLMENT'
  | 'RECOVERY'
  | 'STAGE_CONFIGURATION';

export type FlowLayoutEnum =
  | 'STACKED'
  | 'CONTENT_LEFT'
  | 'CONTENT_RIGHT'
  | 'SIDEBAR_LEFT'
  | 'SIDEBAR_RIGHT';

export type DeniedActionEnum =
  | 'MESSAGE_CONTINUE'
  | 'MESSAGE'
  | 'CONTINUE';

export type InvalidResponseActionEnum =
  | 'RETRY'
  | 'RESTART'
  | 'RESTART_WITH_CONTEXT';

/** Configure how the flow executor should handle an invalid response to a challenge. RETRY returns the error message and a similar challenge to the executor. RESTART restarts the flow from the beginning, and RESTART_WITH_CONTEXT restarts the flow while keeping the current context. */
export type QueryInputFlowsBindingsListInvalidResponseAction =
  | 'RESTART'
  | 'RESTART_WITH_CONTEXT'
  | 'RETRY';

export type QueryInputFlowsBindingsListPolicyEngineMode =
  | 'ALL'
  | 'ANY';

export type FlowsBindingsRetrieveResponse = FlowStageBinding | ValidationError | GenericError;

export type FlowsBindingsUsedByListResponse = UsedBy | ValidationError | GenericError;

export type FlowsExecutorGetResponse = AccessDeniedChallenge | AppleLoginChallenge | AuthenticatorDuoChallenge | AuthenticatorSmsChallenge | AuthenticatorStaticChallenge | AuthenticatorTotpChallenge | AuthenticatorValidationChallenge | AuthenticatorWebAuthnChallenge | AutosubmitChallenge | CaptchaChallenge | ConsentChallenge | EmailChallenge | FlowErrorChallenge | IdentificationChallenge | OAuthDeviceCodeChallenge | OAuthDeviceCodeFinishChallenge | PasswordChallenge | PlexAuthenticationChallenge | PromptChallenge | RedirectChallenge | ShellChallenge | UserLoginChallenge | ValidationError | GenericError;

/** Challenge when a flow's active stage calls `stage_invalid()`. */
export type AccessDeniedChallenge = {
  type: ChallengeChoices;
  flowInfo?: Maybe<ContextualFlowInfo>;
  component?: Maybe<Scalars['String']['output']>;
  responseErrors?: Maybe<Scalars['JSON']['output']>;
  pendingUser: Scalars['String']['output'];
  pendingUserAvatar: Scalars['String']['output'];
  errorMessage?: Maybe<Scalars['String']['output']>;
};

export type ChallengeChoices =
  | 'NATIVE'
  | 'SHELL'
  | 'REDIRECT';

/** Contextual flow information for a challenge */
export type ContextualFlowInfo = {
  title?: Maybe<Scalars['String']['output']>;
  background?: Maybe<Scalars['String']['output']>;
  cancelUrl: Scalars['String']['output'];
  layout: ContextualFlowInfoLayoutEnum;
};

export type ContextualFlowInfoLayoutEnum =
  | 'STACKED'
  | 'CONTENT_LEFT'
  | 'CONTENT_RIGHT'
  | 'SIDEBAR_LEFT'
  | 'SIDEBAR_RIGHT';

/** Special challenge for apple-native authentication flow, which happens on the client. */
export type AppleLoginChallenge = {
  type: ChallengeChoices;
  flowInfo?: Maybe<ContextualFlowInfo>;
  component?: Maybe<Scalars['String']['output']>;
  responseErrors?: Maybe<Scalars['JSON']['output']>;
  clientId: Scalars['String']['output'];
  scope: Scalars['String']['output'];
  redirectUri: Scalars['String']['output'];
  state: Scalars['String']['output'];
};

/** Duo Challenge */
export type AuthenticatorDuoChallenge = {
  type: ChallengeChoices;
  flowInfo?: Maybe<ContextualFlowInfo>;
  component?: Maybe<Scalars['String']['output']>;
  responseErrors?: Maybe<Scalars['JSON']['output']>;
  pendingUser: Scalars['String']['output'];
  pendingUserAvatar: Scalars['String']['output'];
  activationBarcode: Scalars['String']['output'];
  activationCode: Scalars['String']['output'];
  stageUuid: Scalars['String']['output'];
};

/** SMS Setup challenge */
export type AuthenticatorSmsChallenge = {
  type: ChallengeChoices;
  flowInfo?: Maybe<ContextualFlowInfo>;
  component?: Maybe<Scalars['String']['output']>;
  responseErrors?: Maybe<Scalars['JSON']['output']>;
  pendingUser: Scalars['String']['output'];
  pendingUserAvatar: Scalars['String']['output'];
  phoneNumberRequired?: Maybe<Scalars['Boolean']['output']>;
};

/** Static authenticator challenge */
export type AuthenticatorStaticChallenge = {
  type: ChallengeChoices;
  flowInfo?: Maybe<ContextualFlowInfo>;
  component?: Maybe<Scalars['String']['output']>;
  responseErrors?: Maybe<Scalars['JSON']['output']>;
  pendingUser: Scalars['String']['output'];
  pendingUserAvatar: Scalars['String']['output'];
  codes: Array<Maybe<Scalars['String']['output']>>;
};

/** TOTP Setup challenge */
export type AuthenticatorTotpChallenge = {
  type: ChallengeChoices;
  flowInfo?: Maybe<ContextualFlowInfo>;
  component?: Maybe<Scalars['String']['output']>;
  responseErrors?: Maybe<Scalars['JSON']['output']>;
  pendingUser: Scalars['String']['output'];
  pendingUserAvatar: Scalars['String']['output'];
  configUrl: Scalars['String']['output'];
};

/** Authenticator challenge */
export type AuthenticatorValidationChallenge = {
  type: ChallengeChoices;
  flowInfo?: Maybe<ContextualFlowInfo>;
  component?: Maybe<Scalars['String']['output']>;
  responseErrors?: Maybe<Scalars['JSON']['output']>;
  pendingUser: Scalars['String']['output'];
  pendingUserAvatar: Scalars['String']['output'];
  deviceChallenges: Array<Maybe<DeviceChallenge>>;
  configurationStages: Array<Maybe<SelectableStage>>;
};

/** Single device challenge */
export type DeviceChallenge = {
  deviceClass: Scalars['String']['output'];
  deviceUid: Scalars['String']['output'];
  challenge: Scalars['JSON']['output'];
};

/** Serializer for stages which can be selected by users */
export type SelectableStage = {
  pk: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  verboseName: Scalars['String']['output'];
  metaModelName: Scalars['String']['output'];
};

/** WebAuthn Challenge */
export type AuthenticatorWebAuthnChallenge = {
  type: ChallengeChoices;
  flowInfo?: Maybe<ContextualFlowInfo>;
  component?: Maybe<Scalars['String']['output']>;
  responseErrors?: Maybe<Scalars['JSON']['output']>;
  pendingUser: Scalars['String']['output'];
  pendingUserAvatar: Scalars['String']['output'];
  registration: Scalars['JSON']['output'];
};

/** Autosubmit challenge used to send and navigate a POST request */
export type AutosubmitChallenge = {
  type: ChallengeChoices;
  flowInfo?: Maybe<ContextualFlowInfo>;
  component?: Maybe<Scalars['String']['output']>;
  responseErrors?: Maybe<Scalars['JSON']['output']>;
  url: Scalars['String']['output'];
  attrs: Scalars['JSON']['output'];
  title?: Maybe<Scalars['String']['output']>;
};

/** Site public key */
export type CaptchaChallenge = {
  type: ChallengeChoices;
  flowInfo?: Maybe<ContextualFlowInfo>;
  component?: Maybe<Scalars['String']['output']>;
  responseErrors?: Maybe<Scalars['JSON']['output']>;
  pendingUser: Scalars['String']['output'];
  pendingUserAvatar: Scalars['String']['output'];
  siteKey: Scalars['String']['output'];
  jsUrl: Scalars['String']['output'];
};

/** Challenge info for consent screens */
export type ConsentChallenge = {
  type: ChallengeChoices;
  flowInfo?: Maybe<ContextualFlowInfo>;
  component?: Maybe<Scalars['String']['output']>;
  responseErrors?: Maybe<Scalars['JSON']['output']>;
  pendingUser: Scalars['String']['output'];
  pendingUserAvatar: Scalars['String']['output'];
  headerText?: Maybe<Scalars['String']['output']>;
  permissions: Array<Maybe<ConsentPermission>>;
  additionalPermissions: Array<Maybe<ConsentPermission>>;
  token: Scalars['String']['output'];
};

/** Permission used for consent */
export type ConsentPermission = {
  name: Scalars['String']['output'];
  id: Scalars['String']['output'];
};

/** Email challenge */
export type EmailChallenge = {
  type: ChallengeChoices;
  flowInfo?: Maybe<ContextualFlowInfo>;
  component?: Maybe<Scalars['String']['output']>;
  responseErrors?: Maybe<Scalars['JSON']['output']>;
};

/**
 * Challenge class when an unhandled error occurs during a stage. Normal users
 * are shown an error message, superusers are shown a full stacktrace.
 */
export type FlowErrorChallenge = {
  type?: Maybe<Scalars['String']['output']>;
  flowInfo?: Maybe<ContextualFlowInfo>;
  component?: Maybe<Scalars['String']['output']>;
  responseErrors?: Maybe<Scalars['JSON']['output']>;
  requestId: Scalars['String']['output'];
  error?: Maybe<Scalars['String']['output']>;
  traceback?: Maybe<Scalars['String']['output']>;
};

/** Identification challenges with all UI elements */
export type IdentificationChallenge = {
  type: ChallengeChoices;
  flowInfo?: Maybe<ContextualFlowInfo>;
  component?: Maybe<Scalars['String']['output']>;
  responseErrors?: Maybe<Scalars['JSON']['output']>;
  userFields?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  passwordFields: Scalars['Boolean']['output'];
  applicationPre?: Maybe<Scalars['String']['output']>;
  flowDesignation: FlowDesignationEnum;
  enrollUrl?: Maybe<Scalars['String']['output']>;
  recoveryUrl?: Maybe<Scalars['String']['output']>;
  passwordlessUrl?: Maybe<Scalars['String']['output']>;
  primaryAction: Scalars['String']['output'];
  sources?: Maybe<Array<Maybe<LoginSource>>>;
  showSourceLabels: Scalars['Boolean']['output'];
};

/** Serializer for Login buttons of sources */
export type LoginSource = {
  name: Scalars['String']['output'];
  iconUrl?: Maybe<Scalars['String']['output']>;
  challenge: LoginChallengeTypes;
};

export type LoginChallengeTypes = RedirectChallenge | PlexAuthenticationChallenge | AppleLoginChallenge;

/** Challenge type to redirect the client */
export type RedirectChallenge = {
  type: ChallengeChoices;
  flowInfo?: Maybe<ContextualFlowInfo>;
  component?: Maybe<Scalars['String']['output']>;
  responseErrors?: Maybe<Scalars['JSON']['output']>;
  to: Scalars['String']['output'];
};

/** Challenge shown to the user in identification stage */
export type PlexAuthenticationChallenge = {
  type: ChallengeChoices;
  flowInfo?: Maybe<ContextualFlowInfo>;
  component?: Maybe<Scalars['String']['output']>;
  responseErrors?: Maybe<Scalars['JSON']['output']>;
  clientId: Scalars['String']['output'];
  slug: Scalars['String']['output'];
};

/** OAuth Device code challenge */
export type OAuthDeviceCodeChallenge = {
  type: ChallengeChoices;
  flowInfo?: Maybe<ContextualFlowInfo>;
  component?: Maybe<Scalars['String']['output']>;
  responseErrors?: Maybe<Scalars['JSON']['output']>;
};

/** Final challenge after user enters their code */
export type OAuthDeviceCodeFinishChallenge = {
  type: ChallengeChoices;
  flowInfo?: Maybe<ContextualFlowInfo>;
  component?: Maybe<Scalars['String']['output']>;
  responseErrors?: Maybe<Scalars['JSON']['output']>;
};

/** Password challenge UI fields */
export type PasswordChallenge = {
  type: ChallengeChoices;
  flowInfo?: Maybe<ContextualFlowInfo>;
  component?: Maybe<Scalars['String']['output']>;
  responseErrors?: Maybe<Scalars['JSON']['output']>;
  pendingUser: Scalars['String']['output'];
  pendingUserAvatar: Scalars['String']['output'];
  recoveryUrl?: Maybe<Scalars['String']['output']>;
};

/** Initial challenge being sent, define fields */
export type PromptChallenge = {
  type: ChallengeChoices;
  flowInfo?: Maybe<ContextualFlowInfo>;
  component?: Maybe<Scalars['String']['output']>;
  responseErrors?: Maybe<Scalars['JSON']['output']>;
  fields: Array<Maybe<StagePrompt>>;
};

/** Serializer for a single Prompt field */
export type StagePrompt = {
  fieldKey: Scalars['String']['output'];
  label: Scalars['String']['output'];
  type: PromptTypeEnum;
  required: Scalars['Boolean']['output'];
  placeholder: Scalars['String']['output'];
  initialValue: Scalars['String']['output'];
  order: Scalars['Int']['output'];
  subText: Scalars['String']['output'];
  choices?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

export type PromptTypeEnum =
  | 'TEXT'
  | 'TEXT_AREA'
  | 'TEXT_READ_ONLY'
  | 'TEXT_AREA_READ_ONLY'
  | 'USERNAME'
  | 'EMAIL'
  | 'PASSWORD'
  | 'NUMBER'
  | 'CHECKBOX'
  | 'RADIO_BUTTON_GROUP'
  | 'DROPDOWN'
  | 'DATE'
  | 'DATE_TIME'
  | 'FILE'
  | 'SEPARATOR'
  | 'HIDDEN'
  | 'STATIC'
  | 'AK_LOCALE';

/** challenge type to render HTML as-is */
export type ShellChallenge = {
  type: ChallengeChoices;
  flowInfo?: Maybe<ContextualFlowInfo>;
  component?: Maybe<Scalars['String']['output']>;
  responseErrors?: Maybe<Scalars['JSON']['output']>;
  body: Scalars['String']['output'];
};

/** Empty challenge */
export type UserLoginChallenge = {
  type: ChallengeChoices;
  flowInfo?: Maybe<ContextualFlowInfo>;
  component?: Maybe<Scalars['String']['output']>;
  responseErrors?: Maybe<Scalars['JSON']['output']>;
  pendingUser: Scalars['String']['output'];
  pendingUserAvatar: Scalars['String']['output'];
};

export type FlowsInspectorGetResponse = FlowInspection | GenericError;

/** Serializer for inspect endpoint */
export type FlowInspection = {
  plans: Array<Maybe<FlowInspectorPlan>>;
  currentPlan?: Maybe<FlowInspectorPlan>;
  isCompleted: Scalars['Boolean']['output'];
};

/** Serializer for an active FlowPlan */
export type FlowInspectorPlan = {
  currentStage: FlowStageBinding;
  nextPlannedStage: FlowStageBinding;
  /** Get the plan's context, sanitized */
  planContext: Scalars['JSON']['output'];
  /** Get a unique session ID */
  sessionId: Scalars['String']['output'];
};

export type FlowsInstancesListResponse = PaginatedFlowList | ValidationError | GenericError;

export type PaginatedFlowList = {
  pagination: Pagination;
  results: Array<Maybe<Flow>>;
};

/** Flow Serializer */
export type Flow = {
  pk: Scalars['UUID']['output'];
  policybindingmodelPtrId: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  slug: Scalars['QueryFlowsInstancesListOneOf_0ResultsItemsSlug']['output'];
  /** Shown as the Title in Flow pages. */
  title: Scalars['String']['output'];
  designation: FlowDesignationEnum;
  /**
   * Get the URL to the background image. If the name is /static or starts with http
   * it is returned as-is
   */
  background: Scalars['String']['output'];
  stages: Array<Maybe<Scalars['UUID']['output']>>;
  policies: Array<Maybe<Scalars['UUID']['output']>>;
  /** Get count of cached flows */
  cacheCount: Scalars['Int']['output'];
  policyEngineMode?: Maybe<PolicyEngineMode>;
  /** Enable compatibility mode, increases compatibility with password managers on mobile devices. */
  compatibilityMode?: Maybe<Scalars['Boolean']['output']>;
  /** Get export URL for flow */
  exportUrl: Scalars['String']['output'];
  layout?: Maybe<FlowLayoutEnum>;
  deniedAction?: Maybe<DeniedActionEnum>;
  authentication?: Maybe<AuthenticationEnum>;
  additionalProperties?: Maybe<Scalars['JSON']['output']>;
};

export type AuthenticationEnum =
  | 'NONE'
  | 'REQUIRE_AUTHENTICATED'
  | 'REQUIRE_UNAUTHENTICATED'
  | 'REQUIRE_SUPERUSER'
  | 'REQUIRE_OUTPOST';

/** Configure what should happen when a flow denies access to a user. */
export type QueryInputFlowsInstancesListDeniedAction =
  | 'CONTINUE'
  | 'MESSAGE'
  | 'MESSAGE_CONTINUE';

/** Decides what this Flow is used for. For example, the Authentication flow is redirect to when an un-authenticated user visits authentik. */
export type QueryInputFlowsInstancesListDesignation =
  | 'AUTHENTICATION'
  | 'AUTHORIZATION'
  | 'ENROLLMENT'
  | 'INVALIDATION'
  | 'RECOVERY'
  | 'STAGE_CONFIGURATION'
  | 'UNENROLLMENT';

export type FlowsInstancesRetrieveResponse = Flow | ValidationError | GenericError;

export type FlowsInstancesDiagramRetrieveResponse = FlowDiagram | ValidationError | GenericError;

/** response of the flow's diagram action */
export type FlowDiagram = {
  diagram: Scalars['String']['output'];
};

export type FlowsInstancesExecuteRetrieveResponse = Link | GenericError;

/** Returns a single link */
export type Link = {
  link: Scalars['String']['output'];
};

export type FlowsInstancesExportRetrieveResponse = FileContainer | ValidationError | GenericError;

export type FileContainer = {
  file?: Maybe<Scalars['File']['output']>;
};

export type FlowsInstancesUsedByListResponse = UsedBy | ValidationError | GenericError;

export type FlowsInstancesCacheInfoRetrieveResponse = Cache | ValidationError | GenericError;

/** Generic cache stats for an object */
export type Cache = {
  count: Scalars['Int']['output'];
};

export type ManagedBlueprintsListResponse = PaginatedBlueprintInstanceList | ValidationError | GenericError;

export type PaginatedBlueprintInstanceList = {
  pagination: Pagination;
  results: Array<Maybe<BlueprintInstance>>;
};

/** Info about a single blueprint instance file */
export type BlueprintInstance = {
  pk: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  path?: Maybe<Scalars['String']['output']>;
  context?: Maybe<Scalars['JSON']['output']>;
  lastApplied: Scalars['DateTime']['output'];
  lastAppliedHash: Scalars['String']['output'];
  status: BlueprintInstanceStatusEnum;
  enabled?: Maybe<Scalars['Boolean']['output']>;
  managedModels: Array<Maybe<Scalars['String']['output']>>;
  metadata: Scalars['JSON']['output'];
  content?: Maybe<Scalars['String']['output']>;
};

export type BlueprintInstanceStatusEnum =
  | 'SUCCESSFUL'
  | 'WARNING'
  | 'ERROR'
  | 'ORPHANED'
  | 'UNKNOWN';

export type ManagedBlueprintsRetrieveResponse = BlueprintInstance | ValidationError | GenericError;

export type ManagedBlueprintsUsedByListResponse = UsedBy | ValidationError | GenericError;

export type ManagedBlueprintsAvailableListResponse = BlueprintFile | ValidationError | GenericError;

export type BlueprintFile = {
  path: Scalars['String']['output'];
  lastM: Scalars['DateTime']['output'];
  hash: Scalars['String']['output'];
  meta: Metadata;
};

/** Serializer for blueprint metadata */
export type Metadata = {
  name: Scalars['String']['output'];
  labels: Scalars['JSON']['output'];
  additionalProperties?: Maybe<Scalars['JSON']['output']>;
};

export type Oauth2AccessTokensListResponse = PaginatedTokenModelList | ValidationError | GenericError;

export type PaginatedTokenModelList = {
  pagination: Pagination;
  results: Array<Maybe<TokenModel>>;
};

/** Serializer for BaseGrantModel and RefreshToken */
export type TokenModel = {
  pk: Scalars['Int']['output'];
  provider: OAuth2Provider;
  user: User;
  /** Check if token is expired yet. */
  isExpired: Scalars['Boolean']['output'];
  expires?: Maybe<Scalars['DateTime']['output']>;
  scope: Array<Maybe<Scalars['String']['output']>>;
  /** Get the token's id_token as JSON String */
  idToken: Scalars['String']['output'];
  revoked?: Maybe<Scalars['Boolean']['output']>;
};

/** OAuth2Provider Serializer */
export type OAuth2Provider = {
  pk: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  /** Flow used for authentication when the associated application is accessed by an un-authenticated user. */
  authenticationFlow?: Maybe<Scalars['UUID']['output']>;
  /** Flow used when authorizing this provider. */
  authorizationFlow: Scalars['UUID']['output'];
  propertyMappings?: Maybe<Array<Maybe<Scalars['UUID']['output']>>>;
  /** Get object component so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Internal application name, used in URLs. */
  assignedApplicationSlug: Scalars['String']['output'];
  /** Application's display Name. */
  assignedApplicationName: Scalars['String']['output'];
  /** Internal application name, used in URLs. */
  assignedBackchannelApplicationSlug: Scalars['String']['output'];
  /** Application's display Name. */
  assignedBackchannelApplicationName: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  clientType?: Maybe<ClientTypeEnum>;
  clientId?: Maybe<Scalars['QueryOauth2AccessTokensListOneOf_0ResultsItemsProviderClientId']['output']>;
  clientSecret?: Maybe<Scalars['QueryOauth2AccessTokensListOneOf_0ResultsItemsProviderClientSecret']['output']>;
  /** Access codes not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3). */
  accessCodeValidity?: Maybe<Scalars['String']['output']>;
  /** Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3). */
  accessTokenValidity?: Maybe<Scalars['String']['output']>;
  /** Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3). */
  refreshTokenValidity?: Maybe<Scalars['String']['output']>;
  /** Include User claims from scopes in the id_token, for applications that don't access the userinfo endpoint. */
  includeClaimsInIdToken?: Maybe<Scalars['Boolean']['output']>;
  /** Key used to sign the tokens. Only required when JWT Algorithm is set to RS256. */
  signingKey?: Maybe<Scalars['UUID']['output']>;
  /** Enter each URI on a new line. */
  redirectUris?: Maybe<Scalars['String']['output']>;
  subMode?: Maybe<SubModeEnum>;
  issuerMode?: Maybe<IssuerModeEnum>;
  jwksSources?: Maybe<Array<Maybe<Scalars['UUID']['output']>>>;
};

export type ClientTypeEnum =
  | 'CONFIDENTIAL'
  | 'PUBLIC';

export type SubModeEnum =
  | 'HASHED_USER_ID'
  | 'USER_ID'
  | 'USER_UUID'
  | 'USER_USERNAME'
  | 'USER_EMAIL'
  | 'USER_UPN';

export type IssuerModeEnum =
  | 'GLOBAL'
  | 'PER_PROVIDER';

export type Oauth2AccessTokensRetrieveResponse = TokenModel | ValidationError | GenericError;

export type Oauth2AccessTokensUsedByListResponse = UsedBy | ValidationError | GenericError;

export type Oauth2AuthorizationCodesListResponse = PaginatedExpiringBaseGrantModelList | ValidationError | GenericError;

export type PaginatedExpiringBaseGrantModelList = {
  pagination: Pagination;
  results: Array<Maybe<ExpiringBaseGrantModel>>;
};

/** Serializer for BaseGrantModel and ExpiringBaseGrant */
export type ExpiringBaseGrantModel = {
  pk: Scalars['Int']['output'];
  provider: OAuth2Provider;
  user: User;
  /** Check if token is expired yet. */
  isExpired: Scalars['Boolean']['output'];
  expires?: Maybe<Scalars['DateTime']['output']>;
  scope: Array<Maybe<Scalars['String']['output']>>;
};

export type Oauth2AuthorizationCodesRetrieveResponse = ExpiringBaseGrantModel | ValidationError | GenericError;

export type Oauth2AuthorizationCodesUsedByListResponse = UsedBy | ValidationError | GenericError;

export type Oauth2RefreshTokensListResponse = PaginatedTokenModelList | ValidationError | GenericError;

export type Oauth2RefreshTokensRetrieveResponse = TokenModel | ValidationError | GenericError;

export type Oauth2RefreshTokensUsedByListResponse = UsedBy | ValidationError | GenericError;

export type OutpostsInstancesListResponse = PaginatedOutpostList | ValidationError | GenericError;

export type PaginatedOutpostList = {
  pagination: Pagination;
  results: Array<Maybe<Outpost>>;
};

/** Outpost Serializer */
export type Outpost = {
  pk: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  type: OutpostTypeEnum;
  providers: Array<Maybe<Scalars['Int']['output']>>;
  providersObj: Array<Maybe<Provider>>;
  /** Select Service-Connection authentik should use to manage this outpost. Leave empty if authentik should not handle the deployment. */
  serviceConnection?: Maybe<Scalars['UUID']['output']>;
  serviceConnectionObj: ServiceConnection;
  /** Get Token identifier */
  tokenIdentifier: Scalars['String']['output'];
  config: Scalars['JSON']['output'];
  /** Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update. */
  managed?: Maybe<Scalars['String']['output']>;
};

export type OutpostTypeEnum =
  | 'PROXY'
  | 'LDAP'
  | 'RADIUS'
  | 'RAC';

/** ServiceConnection Serializer */
export type ServiceConnection = {
  pk: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  /** If enabled, use the local connection. Required Docker socket/Kubernetes Integration */
  local?: Maybe<Scalars['Boolean']['output']>;
  /** Return component used to edit this object */
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  additionalProperties?: Maybe<Scalars['JSON']['output']>;
};

export type OutpostsInstancesRetrieveResponse = Outpost | ValidationError | GenericError;

export type OutpostsInstancesHealthListResponse = OutpostHealth | ValidationError | GenericError;

/** Outpost health status */
export type OutpostHealth = {
  uid: Scalars['String']['output'];
  lastSeen: Scalars['DateTime']['output'];
  version: Scalars['String']['output'];
  versionShould: Scalars['String']['output'];
  versionOutdated: Scalars['Boolean']['output'];
  buildHash: Scalars['String']['output'];
  buildHashShould: Scalars['String']['output'];
  hostname: Scalars['String']['output'];
};

export type OutpostsInstancesUsedByListResponse = UsedBy | ValidationError | GenericError;

export type OutpostsInstancesDefaultSettingsRetrieveResponse = OutpostDefaultConfig | ValidationError | GenericError;

/** Global default outpost config */
export type OutpostDefaultConfig = {
  config: Scalars['JSON']['output'];
};

export type OutpostsLdapListResponse = PaginatedLdapOutpostConfigList | ValidationError | GenericError;

export type PaginatedLdapOutpostConfigList = {
  pagination: Pagination;
  results: Array<Maybe<LdapOutpostConfig>>;
};

/** LDAPProvider Serializer */
export type LdapOutpostConfig = {
  pk: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  /** DN under which objects are accessible. */
  baseDn?: Maybe<Scalars['String']['output']>;
  bindFlowSlug: Scalars['String']['output'];
  /** Prioritise backchannel slug over direct application slug */
  applicationSlug: Scalars['String']['output'];
  /** Users in this group can do search queries. If not set, every user can execute search queries. */
  searchGroup?: Maybe<Scalars['UUID']['output']>;
  certificate?: Maybe<Scalars['UUID']['output']>;
  tlsServerName?: Maybe<Scalars['String']['output']>;
  /** The start for uidNumbers, this number is added to the user.pk to make sure that the numbers aren't too low for POSIX users. Default is 2000 to ensure that we don't collide with local users uidNumber */
  uidStartNumber?: Maybe<Scalars['Int']['output']>;
  /** The start for gidNumbers, this number is added to a number generated from the group.pk to make sure that the numbers aren't too low for POSIX groups. Default is 4000 to ensure that we don't collide with local groups or users primary groups gidNumber */
  gidStartNumber?: Maybe<Scalars['Int']['output']>;
  searchMode?: Maybe<LdapapiAccessMode>;
  bindMode?: Maybe<LdapapiAccessMode>;
  /** When enabled, code-based multi-factor authentication can be used by appending a semicolon and the TOTP code to the password. This should only be enabled if all users that will bind to this provider have a TOTP device configured, as otherwise a password may incorrectly be rejected if it contains a semicolon. */
  mfaSupport?: Maybe<Scalars['Boolean']['output']>;
};

export type LdapapiAccessMode =
  | 'DIRECT'
  | 'CACHED';

export type OutpostsLdapRetrieveResponse = LdapOutpostConfig | ValidationError | GenericError;

export type OutpostsProxyListResponse = PaginatedProxyOutpostConfigList | ValidationError | GenericError;

export type PaginatedProxyOutpostConfigList = {
  pagination: Pagination;
  results: Array<Maybe<ProxyOutpostConfig>>;
};

/** Proxy provider serializer for outposts */
export type ProxyOutpostConfig = {
  pk: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  internalHost?: Maybe<Scalars['URL']['output']>;
  externalHost: Scalars['URL']['output'];
  /** Validate SSL Certificates of upstream servers */
  internalHostSslValidation?: Maybe<Scalars['Boolean']['output']>;
  clientId?: Maybe<Scalars['QueryOutpostsProxyListOneOf_0ResultsItemsClientId']['output']>;
  clientSecret?: Maybe<Scalars['QueryOutpostsProxyListOneOf_0ResultsItemsClientSecret']['output']>;
  oidcConfiguration: OpenIdConnectConfiguration;
  cookieSecret?: Maybe<Scalars['String']['output']>;
  certificate?: Maybe<Scalars['UUID']['output']>;
  /** Regular expressions for which authentication is not required. Each new line is interpreted as a new Regular Expression. */
  skipPathRegex?: Maybe<Scalars['String']['output']>;
  /** Set a custom HTTP-Basic Authentication header based on values from authentik. */
  basicAuthEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** User/Group Attribute used for the password part of the HTTP-Basic Header. */
  basicAuthPasswordAttribute?: Maybe<Scalars['String']['output']>;
  /** User/Group Attribute used for the user part of the HTTP-Basic Header. If not set, the user's Email address is used. */
  basicAuthUserAttribute?: Maybe<Scalars['String']['output']>;
  mode?: Maybe<ProxyMode>;
  cookieDomain?: Maybe<Scalars['String']['output']>;
  /** Get token validity as second count */
  accessTokenValidity?: Maybe<Scalars['Float']['output']>;
  /** When enabled, this provider will intercept the authorization header and authenticate requests based on its value. */
  interceptHeaderAuth?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Get all the scope names the outpost should request,
   * including custom-defined ones
   */
  scopesToRequest: Array<Maybe<Scalars['String']['output']>>;
  /** Internal application name, used in URLs. */
  assignedApplicationSlug: Scalars['String']['output'];
  /** Application's display Name. */
  assignedApplicationName: Scalars['String']['output'];
};

/** rest_framework Serializer for OIDC Configuration */
export type OpenIdConnectConfiguration = {
  issuer: Scalars['String']['output'];
  authorizationEndpoint: Scalars['String']['output'];
  tokenEndpoint: Scalars['String']['output'];
  userinfoEndpoint: Scalars['String']['output'];
  endSessionEndpoint: Scalars['String']['output'];
  introspectionEndpoint: Scalars['String']['output'];
  jwksUri: Scalars['String']['output'];
  responseTypesSupported: Array<Maybe<Scalars['String']['output']>>;
  idTokenSigningAlgValuesSupported: Array<Maybe<Scalars['String']['output']>>;
  subjectTypesSupported: Array<Maybe<Scalars['String']['output']>>;
  tokenEndpointAuthMethodsSupported: Array<Maybe<Scalars['String']['output']>>;
  additionalProperties?: Maybe<Scalars['JSON']['output']>;
};

export type ProxyMode =
  | 'PROXY'
  | 'FORWARD_SINGLE'
  | 'FORWARD_DOMAIN';

export type OutpostsProxyRetrieveResponse = ProxyOutpostConfig | ValidationError | GenericError;

export type OutpostsRadiusListResponse = PaginatedRadiusOutpostConfigList | ValidationError | GenericError;

export type PaginatedRadiusOutpostConfigList = {
  pagination: Pagination;
  results: Array<Maybe<RadiusOutpostConfig>>;
};

/** RadiusProvider Serializer */
export type RadiusOutpostConfig = {
  pk: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  applicationSlug: Scalars['String']['output'];
  authFlowSlug: Scalars['String']['output'];
  /** List of CIDRs (comma-separated) that clients can connect from. A more specific CIDR will match before a looser one. Clients connecting from a non-specified CIDR will be dropped. */
  clientNetworks?: Maybe<Scalars['String']['output']>;
  /** Shared secret between clients and server to hash packets. */
  sharedSecret?: Maybe<Scalars['String']['output']>;
  /** When enabled, code-based multi-factor authentication can be used by appending a semicolon and the TOTP code to the password. This should only be enabled if all users that will bind to this provider have a TOTP device configured, as otherwise a password may incorrectly be rejected if it contains a semicolon. */
  mfaSupport?: Maybe<Scalars['Boolean']['output']>;
};

export type OutpostsRadiusRetrieveResponse = RadiusOutpostConfig | ValidationError | GenericError;

export type OutpostsServiceConnectionsAllListResponse = PaginatedServiceConnectionList | ValidationError | GenericError;

export type PaginatedServiceConnectionList = {
  pagination: Pagination;
  results: Array<Maybe<ServiceConnection>>;
};

export type OutpostsServiceConnectionsAllRetrieveResponse = ServiceConnection | ValidationError | GenericError;

export type OutpostsServiceConnectionsAllStateRetrieveResponse = ServiceConnectionState | ValidationError | GenericError;

/** Serializer for Service connection state */
export type ServiceConnectionState = {
  healthy: Scalars['Boolean']['output'];
  version: Scalars['String']['output'];
};

export type OutpostsServiceConnectionsAllUsedByListResponse = UsedBy | ValidationError | GenericError;

export type OutpostsServiceConnectionsAllTypesListResponse = TypeCreate | ValidationError | GenericError;

export type OutpostsServiceConnectionsDockerListResponse = PaginatedDockerServiceConnectionList | ValidationError | GenericError;

export type PaginatedDockerServiceConnectionList = {
  pagination: Pagination;
  results: Array<Maybe<DockerServiceConnection>>;
};

/** DockerServiceConnection Serializer */
export type DockerServiceConnection = {
  pk: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  /** If enabled, use the local connection. Required Docker socket/Kubernetes Integration */
  local?: Maybe<Scalars['Boolean']['output']>;
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  /** Can be in the format of 'unix://<path>' when connecting to a local docker daemon, or 'https://<hostname>:2376' when connecting to a remote system. */
  url: Scalars['String']['output'];
  /** CA which the endpoint's Certificate is verified against. Can be left empty for no validation. */
  tlsVerification?: Maybe<Scalars['UUID']['output']>;
  /** Certificate/Key used for authentication. Can be left empty for no authentication. */
  tlsAuthentication?: Maybe<Scalars['UUID']['output']>;
};

export type OutpostsServiceConnectionsDockerRetrieveResponse = DockerServiceConnection | ValidationError | GenericError;

export type OutpostsServiceConnectionsDockerUsedByListResponse = UsedBy | ValidationError | GenericError;

export type OutpostsServiceConnectionsKubernetesListResponse = PaginatedKubernetesServiceConnectionList | ValidationError | GenericError;

export type PaginatedKubernetesServiceConnectionList = {
  pagination: Pagination;
  results: Array<Maybe<KubernetesServiceConnection>>;
};

/** KubernetesServiceConnection Serializer */
export type KubernetesServiceConnection = {
  pk: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  /** If enabled, use the local connection. Required Docker socket/Kubernetes Integration */
  local?: Maybe<Scalars['Boolean']['output']>;
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  /** Paste your kubeconfig here. authentik will automatically use the currently selected context. */
  kubeconfig?: Maybe<Scalars['JSON']['output']>;
  /** Verify SSL Certificates of the Kubernetes API endpoint */
  verifySsl?: Maybe<Scalars['Boolean']['output']>;
};

export type OutpostsServiceConnectionsKubernetesRetrieveResponse = KubernetesServiceConnection | ValidationError | GenericError;

export type OutpostsServiceConnectionsKubernetesUsedByListResponse = UsedBy | ValidationError | GenericError;

export type PoliciesAllListResponse = PaginatedPolicyList | ValidationError | GenericError;

export type PaginatedPolicyList = {
  pagination: Pagination;
  results: Array<Maybe<Policy>>;
};

/** Policy Serializer */
export type Policy = {
  pk: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  /** When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged. */
  executionLogging?: Maybe<Scalars['Boolean']['output']>;
  /** Get object component so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  /** Return objects policy is bound to */
  boundTo: Scalars['Int']['output'];
  additionalProperties?: Maybe<Scalars['JSON']['output']>;
};

export type PoliciesAllRetrieveResponse = Policy | ValidationError | GenericError;

export type PoliciesAllUsedByListResponse = UsedBy | ValidationError | GenericError;

export type PoliciesAllCacheInfoRetrieveResponse = Cache | ValidationError | GenericError;

export type PoliciesAllTypesListResponse = TypeCreate | ValidationError | GenericError;

export type PoliciesBindingsListResponse = PaginatedPolicyBindingList | ValidationError | GenericError;

export type PaginatedPolicyBindingList = {
  pagination: Pagination;
  results: Array<Maybe<PolicyBinding>>;
};

/** PolicyBinding Serializer */
export type PolicyBinding = {
  pk: Scalars['UUID']['output'];
  policy?: Maybe<Scalars['UUID']['output']>;
  group?: Maybe<Scalars['UUID']['output']>;
  user?: Maybe<Scalars['Int']['output']>;
  policyObj: Policy;
  groupObj: Group;
  userObj: User;
  target: Scalars['UUID']['output'];
  /** Negates the outcome of the policy. Messages are unaffected. */
  negate?: Maybe<Scalars['Boolean']['output']>;
  enabled?: Maybe<Scalars['Boolean']['output']>;
  order: Scalars['Int']['output'];
  /** Timeout after which Policy execution is terminated. */
  timeout?: Maybe<Scalars['NonNegativeInt']['output']>;
  /** Result if the Policy execution fails. */
  failureResult?: Maybe<Scalars['Boolean']['output']>;
};

export type PoliciesBindingsRetrieveResponse = PolicyBinding | ValidationError | GenericError;

export type PoliciesBindingsUsedByListResponse = UsedBy | ValidationError | GenericError;

export type PoliciesDummyListResponse = PaginatedDummyPolicyList | ValidationError | GenericError;

export type PaginatedDummyPolicyList = {
  pagination: Pagination;
  results: Array<Maybe<DummyPolicy>>;
};

/** Dummy Policy Serializer */
export type DummyPolicy = {
  pk: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  /** When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged. */
  executionLogging?: Maybe<Scalars['Boolean']['output']>;
  /** Get object component so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  /** Return objects policy is bound to */
  boundTo: Scalars['Int']['output'];
  result?: Maybe<Scalars['Boolean']['output']>;
  waitMin?: Maybe<Scalars['Int']['output']>;
  waitMax?: Maybe<Scalars['Int']['output']>;
};

export type PoliciesDummyRetrieveResponse = DummyPolicy | ValidationError | GenericError;

export type PoliciesDummyUsedByListResponse = UsedBy | ValidationError | GenericError;

export type PoliciesEventMatcherListResponse = PaginatedEventMatcherPolicyList | ValidationError | GenericError;

export type PaginatedEventMatcherPolicyList = {
  pagination: Pagination;
  results: Array<Maybe<EventMatcherPolicy>>;
};

/** Event Matcher Policy Serializer */
export type EventMatcherPolicy = {
  pk: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  /** When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged. */
  executionLogging?: Maybe<Scalars['Boolean']['output']>;
  /** Get object component so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  /** Return objects policy is bound to */
  boundTo: Scalars['Int']['output'];
  action?: Maybe<EventActions>;
  /** Matches Event's Client IP (strict matching, for network matching use an Expression Policy) */
  clientIp?: Maybe<Scalars['String']['output']>;
  app?: Maybe<AppEnum>;
  model?: Maybe<ModelEnum>;
};

export type AppEnum =
  | 'AUTHENTIK_TENANTS'
  | 'AUTHENTIK_ADMIN'
  | 'AUTHENTIK_API'
  | 'AUTHENTIK_CRYPTO'
  | 'AUTHENTIK_FLOWS'
  | 'AUTHENTIK_OUTPOSTS'
  | 'AUTHENTIK_POLICIES_DUMMY'
  | 'AUTHENTIK_POLICIES_EVENT_MATCHER'
  | 'AUTHENTIK_POLICIES_EXPIRY'
  | 'AUTHENTIK_POLICIES_EXPRESSION'
  | 'AUTHENTIK_POLICIES_PASSWORD'
  | 'AUTHENTIK_POLICIES_REPUTATION'
  | 'AUTHENTIK_POLICIES'
  | 'AUTHENTIK_PROVIDERS_LDAP'
  | 'AUTHENTIK_PROVIDERS_OAUTH2'
  | 'AUTHENTIK_PROVIDERS_PROXY'
  | 'AUTHENTIK_PROVIDERS_RADIUS'
  | 'AUTHENTIK_PROVIDERS_SAML'
  | 'AUTHENTIK_PROVIDERS_SCIM'
  | 'AUTHENTIK_RBAC'
  | 'AUTHENTIK_RECOVERY'
  | 'AUTHENTIK_SOURCES_LDAP'
  | 'AUTHENTIK_SOURCES_OAUTH'
  | 'AUTHENTIK_SOURCES_PLEX'
  | 'AUTHENTIK_SOURCES_SAML'
  | 'AUTHENTIK_SOURCES_SCIM'
  | 'AUTHENTIK_STAGES_AUTHENTICATOR'
  | 'AUTHENTIK_STAGES_AUTHENTICATOR_DUO'
  | 'AUTHENTIK_STAGES_AUTHENTICATOR_SMS'
  | 'AUTHENTIK_STAGES_AUTHENTICATOR_STATIC'
  | 'AUTHENTIK_STAGES_AUTHENTICATOR_TOTP'
  | 'AUTHENTIK_STAGES_AUTHENTICATOR_VALIDATE'
  | 'AUTHENTIK_STAGES_AUTHENTICATOR_WEBAUTHN'
  | 'AUTHENTIK_STAGES_CAPTCHA'
  | 'AUTHENTIK_STAGES_CONSENT'
  | 'AUTHENTIK_STAGES_DENY'
  | 'AUTHENTIK_STAGES_DUMMY'
  | 'AUTHENTIK_STAGES_EMAIL'
  | 'AUTHENTIK_STAGES_IDENTIFICATION'
  | 'AUTHENTIK_STAGES_INVITATION'
  | 'AUTHENTIK_STAGES_PASSWORD'
  | 'AUTHENTIK_STAGES_PROMPT'
  | 'AUTHENTIK_STAGES_USER_DELETE'
  | 'AUTHENTIK_STAGES_USER_LOGIN'
  | 'AUTHENTIK_STAGES_USER_LOGOUT'
  | 'AUTHENTIK_STAGES_USER_WRITE'
  | 'AUTHENTIK_BRANDS'
  | 'AUTHENTIK_BLUEPRINTS'
  | 'AUTHENTIK_CORE'
  | 'AUTHENTIK_ENTERPRISE'
  | 'AUTHENTIK_ENTERPRISE_AUDIT'
  | 'AUTHENTIK_ENTERPRISE_PROVIDERS_RAC'
  | 'AUTHENTIK_ENTERPRISE_STAGES_SOURCE'
  | 'AUTHENTIK_EVENTS';

export type ModelEnum =
  | 'AUTHENTIK_TENANTS_DOMAIN'
  | 'AUTHENTIK_CRYPTO_CERTIFICATEKEYPAIR'
  | 'AUTHENTIK_FLOWS_FLOW'
  | 'AUTHENTIK_FLOWS_FLOWSTAGEBINDING'
  | 'AUTHENTIK_OUTPOSTS_DOCKERSERVICECONNECTION'
  | 'AUTHENTIK_OUTPOSTS_KUBERNETESSERVICECONNECTION'
  | 'AUTHENTIK_OUTPOSTS_OUTPOST'
  | 'AUTHENTIK_POLICIES_DUMMY_DUMMYPOLICY'
  | 'AUTHENTIK_POLICIES_EVENT_MATCHER_EVENTMATCHERPOLICY'
  | 'AUTHENTIK_POLICIES_EXPIRY_PASSWORDEXPIRYPOLICY'
  | 'AUTHENTIK_POLICIES_EXPRESSION_EXPRESSIONPOLICY'
  | 'AUTHENTIK_POLICIES_PASSWORD_PASSWORDPOLICY'
  | 'AUTHENTIK_POLICIES_REPUTATION_REPUTATIONPOLICY'
  | 'AUTHENTIK_POLICIES_POLICYBINDING'
  | 'AUTHENTIK_PROVIDERS_LDAP_LDAPPROVIDER'
  | 'AUTHENTIK_PROVIDERS_OAUTH2_SCOPEMAPPING'
  | 'AUTHENTIK_PROVIDERS_OAUTH2_OAUTH2PROVIDER'
  | 'AUTHENTIK_PROVIDERS_PROXY_PROXYPROVIDER'
  | 'AUTHENTIK_PROVIDERS_RADIUS_RADIUSPROVIDER'
  | 'AUTHENTIK_PROVIDERS_SAML_SAMLPROVIDER'
  | 'AUTHENTIK_PROVIDERS_SAML_SAMLPROPERTYMAPPING'
  | 'AUTHENTIK_PROVIDERS_SCIM_SCIMPROVIDER'
  | 'AUTHENTIK_PROVIDERS_SCIM_SCIMMAPPING'
  | 'AUTHENTIK_RBAC_ROLE'
  | 'AUTHENTIK_SOURCES_LDAP_LDAPSOURCE'
  | 'AUTHENTIK_SOURCES_LDAP_LDAPPROPERTYMAPPING'
  | 'AUTHENTIK_SOURCES_OAUTH_OAUTHSOURCE'
  | 'AUTHENTIK_SOURCES_OAUTH_USEROAUTHSOURCECONNECTION'
  | 'AUTHENTIK_SOURCES_PLEX_PLEXSOURCE'
  | 'AUTHENTIK_SOURCES_PLEX_PLEXSOURCECONNECTION'
  | 'AUTHENTIK_SOURCES_SAML_SAMLSOURCE'
  | 'AUTHENTIK_SOURCES_SAML_USERSAMLSOURCECONNECTION'
  | 'AUTHENTIK_SOURCES_SCIM_SCIMSOURCE'
  | 'AUTHENTIK_STAGES_AUTHENTICATOR_DUO_AUTHENTICATORDUOSTAGE'
  | 'AUTHENTIK_STAGES_AUTHENTICATOR_DUO_DUODEVICE'
  | 'AUTHENTIK_STAGES_AUTHENTICATOR_SMS_AUTHENTICATORSMSSTAGE'
  | 'AUTHENTIK_STAGES_AUTHENTICATOR_SMS_SMSDEVICE'
  | 'AUTHENTIK_STAGES_AUTHENTICATOR_STATIC_AUTHENTICATORSTATICSTAGE'
  | 'AUTHENTIK_STAGES_AUTHENTICATOR_STATIC_STATICDEVICE'
  | 'AUTHENTIK_STAGES_AUTHENTICATOR_TOTP_AUTHENTICATORTOTPSTAGE'
  | 'AUTHENTIK_STAGES_AUTHENTICATOR_TOTP_TOTPDEVICE'
  | 'AUTHENTIK_STAGES_AUTHENTICATOR_VALIDATE_AUTHENTICATORVALIDATESTAGE'
  | 'AUTHENTIK_STAGES_AUTHENTICATOR_WEBAUTHN_AUTHENTICATORWEBAUTHNSTAGE'
  | 'AUTHENTIK_STAGES_AUTHENTICATOR_WEBAUTHN_WEBAUTHNDEVICE'
  | 'AUTHENTIK_STAGES_CAPTCHA_CAPTCHASTAGE'
  | 'AUTHENTIK_STAGES_CONSENT_CONSENTSTAGE'
  | 'AUTHENTIK_STAGES_CONSENT_USERCONSENT'
  | 'AUTHENTIK_STAGES_DENY_DENYSTAGE'
  | 'AUTHENTIK_STAGES_DUMMY_DUMMYSTAGE'
  | 'AUTHENTIK_STAGES_EMAIL_EMAILSTAGE'
  | 'AUTHENTIK_STAGES_IDENTIFICATION_IDENTIFICATIONSTAGE'
  | 'AUTHENTIK_STAGES_INVITATION_INVITATIONSTAGE'
  | 'AUTHENTIK_STAGES_INVITATION_INVITATION'
  | 'AUTHENTIK_STAGES_PASSWORD_PASSWORDSTAGE'
  | 'AUTHENTIK_STAGES_PROMPT_PROMPT'
  | 'AUTHENTIK_STAGES_PROMPT_PROMPTSTAGE'
  | 'AUTHENTIK_STAGES_USER_DELETE_USERDELETESTAGE'
  | 'AUTHENTIK_STAGES_USER_LOGIN_USERLOGINSTAGE'
  | 'AUTHENTIK_STAGES_USER_LOGOUT_USERLOGOUTSTAGE'
  | 'AUTHENTIK_STAGES_USER_WRITE_USERWRITESTAGE'
  | 'AUTHENTIK_BRANDS_BRAND'
  | 'AUTHENTIK_BLUEPRINTS_BLUEPRINTINSTANCE'
  | 'AUTHENTIK_CORE_GROUP'
  | 'AUTHENTIK_CORE_USER'
  | 'AUTHENTIK_CORE_APPLICATION'
  | 'AUTHENTIK_CORE_TOKEN'
  | 'AUTHENTIK_ENTERPRISE_LICENSE'
  | 'AUTHENTIK_PROVIDERS_RAC_RACPROVIDER'
  | 'AUTHENTIK_PROVIDERS_RAC_ENDPOINT'
  | 'AUTHENTIK_PROVIDERS_RAC_RACPROPERTYMAPPING'
  | 'AUTHENTIK_STAGES_SOURCE_SOURCESTAGE'
  | 'AUTHENTIK_EVENTS_EVENT'
  | 'AUTHENTIK_EVENTS_NOTIFICATIONTRANSPORT'
  | 'AUTHENTIK_EVENTS_NOTIFICATION'
  | 'AUTHENTIK_EVENTS_NOTIFICATIONRULE'
  | 'AUTHENTIK_EVENTS_NOTIFICATIONWEBHOOKMAPPING';

/** Match created events with this action type. When left empty, all action types will be matched. */
export type QueryInputPoliciesEventMatcherListAction =
  | 'AUTHORIZE_APPLICATION'
  | 'CONFIGURATION_ERROR'
  | 'CUSTOM_'
  | 'EMAIL_SENT'
  | 'FLOW_EXECUTION'
  | 'IMPERSONATION_ENDED'
  | 'IMPERSONATION_STARTED'
  | 'INVITATION_USED'
  | 'LOGIN'
  | 'LOGIN_FAILED'
  | 'LOGOUT'
  | 'MODEL_CREATED'
  | 'MODEL_DELETED'
  | 'MODEL_UPDATED'
  | 'PASSWORD_SET'
  | 'POLICY_EXCEPTION'
  | 'POLICY_EXECUTION'
  | 'PROPERTY_MAPPING_EXCEPTION'
  | 'SECRET_ROTATE'
  | 'SECRET_VIEW'
  | 'SOURCE_LINKED'
  | 'SUSPICIOUS_REQUEST'
  | 'SYSTEM_EXCEPTION'
  | 'SYSTEM_TASK_EXCEPTION'
  | 'SYSTEM_TASK_EXECUTION'
  | 'UPDATE_AVAILABLE'
  | 'USER_WRITE';

export type PoliciesEventMatcherRetrieveResponse = EventMatcherPolicy | ValidationError | GenericError;

export type PoliciesEventMatcherUsedByListResponse = UsedBy | ValidationError | GenericError;

export type PoliciesExpressionListResponse = PaginatedExpressionPolicyList | ValidationError | GenericError;

export type PaginatedExpressionPolicyList = {
  pagination: Pagination;
  results: Array<Maybe<ExpressionPolicy>>;
};

/** Group Membership Policy Serializer */
export type ExpressionPolicy = {
  pk: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  /** When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged. */
  executionLogging?: Maybe<Scalars['Boolean']['output']>;
  /** Get object component so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  /** Return objects policy is bound to */
  boundTo: Scalars['Int']['output'];
  expression: Scalars['String']['output'];
};

export type PoliciesExpressionRetrieveResponse = ExpressionPolicy | ValidationError | GenericError;

export type PoliciesExpressionUsedByListResponse = UsedBy | ValidationError | GenericError;

export type PoliciesPasswordListResponse = PaginatedPasswordPolicyList | ValidationError | GenericError;

export type PaginatedPasswordPolicyList = {
  pagination: Pagination;
  results: Array<Maybe<PasswordPolicy>>;
};

/** Password Policy Serializer */
export type PasswordPolicy = {
  pk: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  /** When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged. */
  executionLogging?: Maybe<Scalars['Boolean']['output']>;
  /** Get object component so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  /** Return objects policy is bound to */
  boundTo: Scalars['Int']['output'];
  /** Field key to check, field keys defined in Prompt stages are available. */
  passwordField?: Maybe<Scalars['String']['output']>;
  amountDigits?: Maybe<Scalars['NonNegativeInt']['output']>;
  amountUppercase?: Maybe<Scalars['NonNegativeInt']['output']>;
  amountLowercase?: Maybe<Scalars['NonNegativeInt']['output']>;
  amountSymbols?: Maybe<Scalars['NonNegativeInt']['output']>;
  lengthMin?: Maybe<Scalars['NonNegativeInt']['output']>;
  symbolCharset?: Maybe<Scalars['String']['output']>;
  errorMessage?: Maybe<Scalars['String']['output']>;
  checkStaticRules?: Maybe<Scalars['Boolean']['output']>;
  checkHaveIBeenPwned?: Maybe<Scalars['Boolean']['output']>;
  checkZxcvbn?: Maybe<Scalars['Boolean']['output']>;
  /** How many times the password hash is allowed to be on haveibeenpwned */
  hibpAllowedCount?: Maybe<Scalars['NonNegativeInt']['output']>;
  /** If the zxcvbn score is equal or less than this value, the policy will fail. */
  zxcvbnScoreThreshold?: Maybe<Scalars['NonNegativeInt']['output']>;
};

export type PoliciesPasswordRetrieveResponse = PasswordPolicy | ValidationError | GenericError;

export type PoliciesPasswordUsedByListResponse = UsedBy | ValidationError | GenericError;

export type PoliciesPasswordExpiryListResponse = PaginatedPasswordExpiryPolicyList | ValidationError | GenericError;

export type PaginatedPasswordExpiryPolicyList = {
  pagination: Pagination;
  results: Array<Maybe<PasswordExpiryPolicy>>;
};

/** Password Expiry Policy Serializer */
export type PasswordExpiryPolicy = {
  pk: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  /** When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged. */
  executionLogging?: Maybe<Scalars['Boolean']['output']>;
  /** Get object component so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  /** Return objects policy is bound to */
  boundTo: Scalars['Int']['output'];
  days: Scalars['Int']['output'];
  denyOnly?: Maybe<Scalars['Boolean']['output']>;
};

export type PoliciesPasswordExpiryRetrieveResponse = PasswordExpiryPolicy | ValidationError | GenericError;

export type PoliciesPasswordExpiryUsedByListResponse = UsedBy | ValidationError | GenericError;

export type PoliciesReputationListResponse = PaginatedReputationPolicyList | ValidationError | GenericError;

export type PaginatedReputationPolicyList = {
  pagination: Pagination;
  results: Array<Maybe<ReputationPolicy>>;
};

/** Reputation Policy Serializer */
export type ReputationPolicy = {
  pk: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  /** When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged. */
  executionLogging?: Maybe<Scalars['Boolean']['output']>;
  /** Get object component so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  /** Return objects policy is bound to */
  boundTo: Scalars['Int']['output'];
  checkIp?: Maybe<Scalars['Boolean']['output']>;
  checkUsername?: Maybe<Scalars['Boolean']['output']>;
  threshold?: Maybe<Scalars['Int']['output']>;
};

export type PoliciesReputationRetrieveResponse = ReputationPolicy | ValidationError | GenericError;

export type PoliciesReputationUsedByListResponse = UsedBy | ValidationError | GenericError;

export type PoliciesReputationScoresListResponse = PaginatedReputationList | ValidationError | GenericError;

export type PaginatedReputationList = {
  pagination: Pagination;
  results: Array<Maybe<Reputation>>;
};

/** Reputation Serializer */
export type Reputation = {
  pk?: Maybe<Scalars['UUID']['output']>;
  identifier: Scalars['String']['output'];
  ip: Scalars['String']['output'];
  ipGeoData?: Maybe<Scalars['JSON']['output']>;
  ipAsnData?: Maybe<Scalars['JSON']['output']>;
  score?: Maybe<Scalars['BigInt']['output']>;
  updated: Scalars['DateTime']['output'];
};

export type PoliciesReputationScoresRetrieveResponse = Reputation | ValidationError | GenericError;

export type PoliciesReputationScoresUsedByListResponse = UsedBy | ValidationError | GenericError;

export type PropertymappingsAllListResponse = PaginatedPropertyMappingList | ValidationError | GenericError;

export type PaginatedPropertyMappingList = {
  pagination: Pagination;
  results: Array<Maybe<PropertyMapping>>;
};

/** PropertyMapping Serializer */
export type PropertyMapping = {
  pk: Scalars['UUID']['output'];
  /** Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update. */
  managed?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  expression: Scalars['String']['output'];
  /** Get object's component so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
};

export type PropertymappingsAllRetrieveResponse = PropertyMapping | ValidationError | GenericError;

export type PropertymappingsAllUsedByListResponse = UsedBy | ValidationError | GenericError;

export type PropertymappingsAllTypesListResponse = TypeCreate | ValidationError | GenericError;

export type PropertymappingsLdapListResponse = PaginatedLdapPropertyMappingList | ValidationError | GenericError;

export type PaginatedLdapPropertyMappingList = {
  pagination: Pagination;
  results: Array<Maybe<LdapPropertyMapping>>;
};

/** LDAP PropertyMapping Serializer */
export type LdapPropertyMapping = {
  pk: Scalars['UUID']['output'];
  /** Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update. */
  managed?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  expression: Scalars['String']['output'];
  /** Get object's component so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  objectField: Scalars['String']['output'];
};

export type PropertymappingsLdapRetrieveResponse = LdapPropertyMapping | ValidationError | GenericError;

export type PropertymappingsLdapUsedByListResponse = UsedBy | ValidationError | GenericError;

export type PropertymappingsNotificationListResponse = PaginatedNotificationWebhookMappingList | ValidationError | GenericError;

export type PaginatedNotificationWebhookMappingList = {
  pagination: Pagination;
  results: Array<Maybe<NotificationWebhookMapping>>;
};

/** NotificationWebhookMapping Serializer */
export type NotificationWebhookMapping = {
  pk: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  expression: Scalars['String']['output'];
};

export type PropertymappingsNotificationRetrieveResponse = NotificationWebhookMapping | ValidationError | GenericError;

export type PropertymappingsNotificationUsedByListResponse = UsedBy | ValidationError | GenericError;

export type PropertymappingsRacListResponse = PaginatedRacPropertyMappingList | ValidationError | GenericError;

export type PaginatedRacPropertyMappingList = {
  pagination: Pagination;
  results: Array<Maybe<RacPropertyMapping>>;
};

/** RACPropertyMapping Serializer */
export type RacPropertyMapping = {
  pk: Scalars['UUID']['output'];
  /** Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update. */
  managed?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  expression?: Maybe<Scalars['String']['output']>;
  /** Get object's component so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  staticSettings: Scalars['JSON']['output'];
};

export type PropertymappingsRacRetrieveResponse = RacPropertyMapping | ValidationError | GenericError;

export type PropertymappingsRacUsedByListResponse = UsedBy | ValidationError | GenericError;

export type PropertymappingsSamlListResponse = PaginatedSamlPropertyMappingList | ValidationError | GenericError;

export type PaginatedSamlPropertyMappingList = {
  pagination: Pagination;
  results: Array<Maybe<SamlPropertyMapping>>;
};

/** SAMLPropertyMapping Serializer */
export type SamlPropertyMapping = {
  pk: Scalars['UUID']['output'];
  /** Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update. */
  managed?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  expression: Scalars['String']['output'];
  /** Get object's component so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  samlName: Scalars['String']['output'];
  friendlyName?: Maybe<Scalars['String']['output']>;
};

export type PropertymappingsSamlRetrieveResponse = SamlPropertyMapping | ValidationError | GenericError;

export type PropertymappingsSamlUsedByListResponse = UsedBy | ValidationError | GenericError;

export type PropertymappingsScimListResponse = PaginatedScimMappingList | ValidationError | GenericError;

export type PaginatedScimMappingList = {
  pagination: Pagination;
  results: Array<Maybe<ScimMapping>>;
};

/** SCIMMapping Serializer */
export type ScimMapping = {
  pk: Scalars['UUID']['output'];
  /** Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update. */
  managed?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  expression: Scalars['String']['output'];
  /** Get object's component so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
};

export type PropertymappingsScimRetrieveResponse = ScimMapping | ValidationError | GenericError;

export type PropertymappingsScimUsedByListResponse = UsedBy | ValidationError | GenericError;

export type PropertymappingsScopeListResponse = PaginatedScopeMappingList | ValidationError | GenericError;

export type PaginatedScopeMappingList = {
  pagination: Pagination;
  results: Array<Maybe<ScopeMapping>>;
};

/** ScopeMapping Serializer */
export type ScopeMapping = {
  pk: Scalars['UUID']['output'];
  /** Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update. */
  managed?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  expression: Scalars['String']['output'];
  /** Get object's component so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  /** Scope name requested by the client */
  scopeName: Scalars['String']['output'];
  /** Description shown to the user when consenting. If left empty, the user won't be informed. */
  description?: Maybe<Scalars['String']['output']>;
};

export type PropertymappingsScopeRetrieveResponse = ScopeMapping | ValidationError | GenericError;

export type PropertymappingsScopeUsedByListResponse = UsedBy | ValidationError | GenericError;

export type ProvidersAllListResponse = PaginatedProviderList | ValidationError | GenericError;

export type PaginatedProviderList = {
  pagination: Pagination;
  results: Array<Maybe<Provider>>;
};

export type ProvidersAllRetrieveResponse = Provider | ValidationError | GenericError;

export type ProvidersAllUsedByListResponse = UsedBy | ValidationError | GenericError;

export type ProvidersAllTypesListResponse = TypeCreate | ValidationError | GenericError;

export type ProvidersLdapListResponse = PaginatedLdapProviderList | ValidationError | GenericError;

export type PaginatedLdapProviderList = {
  pagination: Pagination;
  results: Array<Maybe<LdapProvider>>;
};

/** LDAPProvider Serializer */
export type LdapProvider = {
  pk: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  /** Flow used for authentication when the associated application is accessed by an un-authenticated user. */
  authenticationFlow?: Maybe<Scalars['UUID']['output']>;
  /** Flow used when authorizing this provider. */
  authorizationFlow: Scalars['UUID']['output'];
  propertyMappings?: Maybe<Array<Maybe<Scalars['UUID']['output']>>>;
  /** Get object component so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Internal application name, used in URLs. */
  assignedApplicationSlug: Scalars['String']['output'];
  /** Application's display Name. */
  assignedApplicationName: Scalars['String']['output'];
  /** Internal application name, used in URLs. */
  assignedBackchannelApplicationSlug: Scalars['String']['output'];
  /** Application's display Name. */
  assignedBackchannelApplicationName: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  /** DN under which objects are accessible. */
  baseDn?: Maybe<Scalars['String']['output']>;
  /** Users in this group can do search queries. If not set, every user can execute search queries. */
  searchGroup?: Maybe<Scalars['UUID']['output']>;
  certificate?: Maybe<Scalars['UUID']['output']>;
  tlsServerName?: Maybe<Scalars['String']['output']>;
  /** The start for uidNumbers, this number is added to the user.pk to make sure that the numbers aren't too low for POSIX users. Default is 2000 to ensure that we don't collide with local users uidNumber */
  uidStartNumber?: Maybe<Scalars['Int']['output']>;
  /** The start for gidNumbers, this number is added to a number generated from the group.pk to make sure that the numbers aren't too low for POSIX groups. Default is 4000 to ensure that we don't collide with local groups or users primary groups gidNumber */
  gidStartNumber?: Maybe<Scalars['Int']['output']>;
  outpostSet: Array<Maybe<Scalars['String']['output']>>;
  searchMode?: Maybe<LdapapiAccessMode>;
  bindMode?: Maybe<LdapapiAccessMode>;
  /** When enabled, code-based multi-factor authentication can be used by appending a semicolon and the TOTP code to the password. This should only be enabled if all users that will bind to this provider have a TOTP device configured, as otherwise a password may incorrectly be rejected if it contains a semicolon. */
  mfaSupport?: Maybe<Scalars['Boolean']['output']>;
};

export type ProvidersLdapRetrieveResponse = LdapProvider | ValidationError | GenericError;

export type ProvidersLdapUsedByListResponse = UsedBy | ValidationError | GenericError;

export type ProvidersOauth2ListResponse = PaginatedOAuth2ProviderList | ValidationError | GenericError;

export type PaginatedOAuth2ProviderList = {
  pagination: Pagination;
  results: Array<Maybe<OAuth2Provider>>;
};

/** Confidential clients are capable of maintaining the confidentiality of their credentials. Public clients are incapable */
export type QueryInputProvidersOauth2ListClientType =
  | 'CONFIDENTIAL'
  | 'PUBLIC';

/** Configure how the issuer field of the ID Token should be filled. */
export type QueryInputProvidersOauth2ListIssuerMode =
  | 'GLOBAL'
  | 'PER_PROVIDER';

/** Configure what data should be used as unique User Identifier. For most cases, the default should be fine. */
export type QueryInputProvidersOauth2ListSubMode =
  | 'HASHED_USER_ID'
  | 'USER_EMAIL'
  | 'USER_ID'
  | 'USER_UPN'
  | 'USER_USERNAME'
  | 'USER_UUID';

export type ProvidersOauth2RetrieveResponse = OAuth2Provider | ValidationError | GenericError;

export type ProvidersOauth2PreviewUserRetrieveResponse = PropertyMappingPreview | GenericError;

/** Preview how the current user is mapped via the property mappings selected in a provider */
export type PropertyMappingPreview = {
  preview: Scalars['JSON']['output'];
};

export type ProvidersOauth2SetupUrlsRetrieveResponse = OAuth2ProviderSetupUrLs | ValidationError | GenericError;

/** OAuth2 Provider Metadata serializer */
export type OAuth2ProviderSetupUrLs = {
  issuer: Scalars['String']['output'];
  authorize: Scalars['String']['output'];
  token: Scalars['String']['output'];
  userInfo: Scalars['String']['output'];
  providerInfo: Scalars['String']['output'];
  logout: Scalars['String']['output'];
  jwks: Scalars['String']['output'];
};

export type ProvidersOauth2UsedByListResponse = UsedBy | ValidationError | GenericError;

export type ProvidersProxyListResponse = PaginatedProxyProviderList | ValidationError | GenericError;

export type PaginatedProxyProviderList = {
  pagination: Pagination;
  results: Array<Maybe<ProxyProvider>>;
};

/** ProxyProvider Serializer */
export type ProxyProvider = {
  pk: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  /** Flow used for authentication when the associated application is accessed by an un-authenticated user. */
  authenticationFlow?: Maybe<Scalars['UUID']['output']>;
  /** Flow used when authorizing this provider. */
  authorizationFlow: Scalars['UUID']['output'];
  propertyMappings?: Maybe<Array<Maybe<Scalars['UUID']['output']>>>;
  /** Get object component so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Internal application name, used in URLs. */
  assignedApplicationSlug: Scalars['String']['output'];
  /** Application's display Name. */
  assignedApplicationName: Scalars['String']['output'];
  /** Internal application name, used in URLs. */
  assignedBackchannelApplicationSlug: Scalars['String']['output'];
  /** Application's display Name. */
  assignedBackchannelApplicationName: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  clientId: Scalars['String']['output'];
  internalHost?: Maybe<Scalars['URL']['output']>;
  externalHost: Scalars['URL']['output'];
  /** Validate SSL Certificates of upstream servers */
  internalHostSslValidation?: Maybe<Scalars['Boolean']['output']>;
  certificate?: Maybe<Scalars['UUID']['output']>;
  /** Regular expressions for which authentication is not required. Each new line is interpreted as a new Regular Expression. */
  skipPathRegex?: Maybe<Scalars['String']['output']>;
  /** Set a custom HTTP-Basic Authentication header based on values from authentik. */
  basicAuthEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** User/Group Attribute used for the password part of the HTTP-Basic Header. */
  basicAuthPasswordAttribute?: Maybe<Scalars['String']['output']>;
  /** User/Group Attribute used for the user part of the HTTP-Basic Header. If not set, the user's Email address is used. */
  basicAuthUserAttribute?: Maybe<Scalars['String']['output']>;
  mode?: Maybe<ProxyMode>;
  /** When enabled, this provider will intercept the authorization header and authenticate requests based on its value. */
  interceptHeaderAuth?: Maybe<Scalars['Boolean']['output']>;
  redirectUris: Scalars['String']['output'];
  cookieDomain?: Maybe<Scalars['String']['output']>;
  jwksSources?: Maybe<Array<Maybe<Scalars['UUID']['output']>>>;
  /** Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3). */
  accessTokenValidity?: Maybe<Scalars['String']['output']>;
  /** Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3). */
  refreshTokenValidity?: Maybe<Scalars['String']['output']>;
  outpostSet: Array<Maybe<Scalars['String']['output']>>;
};

export type ProvidersProxyRetrieveResponse = ProxyProvider | ValidationError | GenericError;

export type ProvidersProxyUsedByListResponse = UsedBy | ValidationError | GenericError;

export type ProvidersRacListResponse = PaginatedRacProviderList | ValidationError | GenericError;

export type PaginatedRacProviderList = {
  pagination: Pagination;
  results: Array<Maybe<RacProvider>>;
};

/** RACProvider Serializer */
export type RacProvider = {
  pk: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  /** Flow used for authentication when the associated application is accessed by an un-authenticated user. */
  authenticationFlow?: Maybe<Scalars['UUID']['output']>;
  /** Flow used when authorizing this provider. */
  authorizationFlow: Scalars['UUID']['output'];
  propertyMappings?: Maybe<Array<Maybe<Scalars['UUID']['output']>>>;
  /** Get object component so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Internal application name, used in URLs. */
  assignedApplicationSlug: Scalars['String']['output'];
  /** Application's display Name. */
  assignedApplicationName: Scalars['String']['output'];
  /** Internal application name, used in URLs. */
  assignedBackchannelApplicationSlug: Scalars['String']['output'];
  /** Application's display Name. */
  assignedBackchannelApplicationName: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  settings?: Maybe<Scalars['JSON']['output']>;
  outpostSet: Array<Maybe<Scalars['String']['output']>>;
  /** Determines how long a session lasts. Default of 0 means that the sessions lasts until the browser is closed. (Format: hours=-1;minutes=-2;seconds=-3) */
  connectionExpiry?: Maybe<Scalars['String']['output']>;
  /** When set to true, connection tokens will be deleted upon disconnect. */
  deleteTokenOnDisconnect?: Maybe<Scalars['Boolean']['output']>;
  additionalProperties?: Maybe<Scalars['JSON']['output']>;
};

export type ProvidersRacRetrieveResponse = RacProvider | ValidationError | GenericError;

export type ProvidersRacUsedByListResponse = UsedBy | ValidationError | GenericError;

export type ProvidersRadiusListResponse = PaginatedRadiusProviderList | ValidationError | GenericError;

export type PaginatedRadiusProviderList = {
  pagination: Pagination;
  results: Array<Maybe<RadiusProvider>>;
};

/** RadiusProvider Serializer */
export type RadiusProvider = {
  pk: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  /** Flow used for authentication when the associated application is accessed by an un-authenticated user. */
  authenticationFlow?: Maybe<Scalars['UUID']['output']>;
  /** Flow used when authorizing this provider. */
  authorizationFlow: Scalars['UUID']['output'];
  propertyMappings?: Maybe<Array<Maybe<Scalars['UUID']['output']>>>;
  /** Get object component so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Internal application name, used in URLs. */
  assignedApplicationSlug: Scalars['String']['output'];
  /** Application's display Name. */
  assignedApplicationName: Scalars['String']['output'];
  /** Internal application name, used in URLs. */
  assignedBackchannelApplicationSlug: Scalars['String']['output'];
  /** Application's display Name. */
  assignedBackchannelApplicationName: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  /** List of CIDRs (comma-separated) that clients can connect from. A more specific CIDR will match before a looser one. Clients connecting from a non-specified CIDR will be dropped. */
  clientNetworks?: Maybe<Scalars['String']['output']>;
  /** Shared secret between clients and server to hash packets. */
  sharedSecret?: Maybe<Scalars['String']['output']>;
  outpostSet: Array<Maybe<Scalars['String']['output']>>;
  /** When enabled, code-based multi-factor authentication can be used by appending a semicolon and the TOTP code to the password. This should only be enabled if all users that will bind to this provider have a TOTP device configured, as otherwise a password may incorrectly be rejected if it contains a semicolon. */
  mfaSupport?: Maybe<Scalars['Boolean']['output']>;
};

export type ProvidersRadiusRetrieveResponse = RadiusProvider | ValidationError | GenericError;

export type ProvidersRadiusUsedByListResponse = UsedBy | ValidationError | GenericError;

export type ProvidersSamlListResponse = PaginatedSamlProviderList | ValidationError | GenericError;

export type PaginatedSamlProviderList = {
  pagination: Pagination;
  results: Array<Maybe<SamlProvider>>;
};

/** SAMLProvider Serializer */
export type SamlProvider = {
  pk: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  /** Flow used for authentication when the associated application is accessed by an un-authenticated user. */
  authenticationFlow?: Maybe<Scalars['UUID']['output']>;
  /** Flow used when authorizing this provider. */
  authorizationFlow: Scalars['UUID']['output'];
  propertyMappings?: Maybe<Array<Maybe<Scalars['UUID']['output']>>>;
  /** Get object component so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Internal application name, used in URLs. */
  assignedApplicationSlug: Scalars['String']['output'];
  /** Application's display Name. */
  assignedApplicationName: Scalars['String']['output'];
  /** Internal application name, used in URLs. */
  assignedBackchannelApplicationSlug: Scalars['String']['output'];
  /** Application's display Name. */
  assignedBackchannelApplicationName: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  acsUrl: Scalars['URL']['output'];
  /** Value of the audience restriction field of the assertion. When left empty, no audience restriction will be added. */
  audience?: Maybe<Scalars['String']['output']>;
  /** Also known as EntityID */
  issuer?: Maybe<Scalars['String']['output']>;
  /** Assertion valid not before current time + this value (Format: hours=-1;minutes=-2;seconds=-3). */
  assertionValidNotBefore?: Maybe<Scalars['String']['output']>;
  /** Assertion not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3). */
  assertionValidNotOnOrAfter?: Maybe<Scalars['String']['output']>;
  /** Session not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3). */
  sessionValidNotOnOrAfter?: Maybe<Scalars['String']['output']>;
  /** Configure how the NameID value will be created. When left empty, the NameIDPolicy of the incoming request will be considered */
  nameIdMapping?: Maybe<Scalars['UUID']['output']>;
  digestAlgorithm?: Maybe<DigestAlgorithmEnum>;
  signatureAlgorithm?: Maybe<SignatureAlgorithmEnum>;
  /** Keypair used to sign outgoing Responses going to the Service Provider. */
  signingKp?: Maybe<Scalars['UUID']['output']>;
  /** When selected, incoming assertion's Signatures will be validated against this certificate. To allow unsigned Requests, leave on default. */
  verificationKp?: Maybe<Scalars['UUID']['output']>;
  /** This determines how authentik sends the response back to the Service Provider. */
  spBinding?: Maybe<ServiceProviderBinding>;
  /** Default relay_state value for IDP-initiated logins */
  defaultRelayState?: Maybe<Scalars['String']['output']>;
  /** Get metadata download URL */
  urlDownloadMetadata: Scalars['String']['output'];
  /** Get SSO Post URL */
  urlSsoPost: Scalars['String']['output'];
  /** Get SSO Redirect URL */
  urlSsoRedirect: Scalars['String']['output'];
  /** Get SSO IDP-Initiated URL */
  urlSsoInit: Scalars['String']['output'];
  /** Get SLO POST URL */
  urlSloPost: Scalars['String']['output'];
  /** Get SLO redirect URL */
  urlSloRedirect: Scalars['String']['output'];
};

export type DigestAlgorithmEnum =
  | 'HTTP___WWW_W3_ORG_2000_09_XMLDSIG_POUND_SHA1'
  | 'HTTP___WWW_W3_ORG_2001_04_XMLENC_POUND_SHA256'
  | 'HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_SHA384'
  | 'HTTP___WWW_W3_ORG_2001_04_XMLENC_POUND_SHA512';

export type SignatureAlgorithmEnum =
  | 'HTTP___WWW_W3_ORG_2000_09_XMLDSIG_POUND_RSA_SHA1'
  | 'HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_RSA_SHA256'
  | 'HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_RSA_SHA384'
  | 'HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_RSA_SHA512'
  | 'HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_ECDSA_SHA1'
  | 'HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_ECDSA_SHA256'
  | 'HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_ECDSA_SHA384'
  | 'HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_ECDSA_SHA512'
  | 'HTTP___WWW_W3_ORG_2000_09_XMLDSIG_POUND_DSA_SHA1';

/** This determines how authentik sends the response back to the Service Provider. */
export type ServiceProviderBinding = {
  spBindingEnum?: Maybe<SpBindingEnum>;
};

export type SpBindingEnum =
  | 'REDIRECT'
  | 'POST';

export type QueryInputProvidersSamlListDigestAlgorithm =
  | 'HTTP___WWW_W3_ORG_2000_09_XMLDSIG_POUND_SHA1'
  | 'HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_SHA384'
  | 'HTTP___WWW_W3_ORG_2001_04_XMLENC_POUND_SHA256'
  | 'HTTP___WWW_W3_ORG_2001_04_XMLENC_POUND_SHA512';

export type QueryInputProvidersSamlListSignatureAlgorithm =
  | 'HTTP___WWW_W3_ORG_2000_09_XMLDSIG_POUND_DSA_SHA1'
  | 'HTTP___WWW_W3_ORG_2000_09_XMLDSIG_POUND_RSA_SHA1'
  | 'HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_ECDSA_SHA1'
  | 'HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_ECDSA_SHA256'
  | 'HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_ECDSA_SHA384'
  | 'HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_ECDSA_SHA512'
  | 'HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_RSA_SHA256'
  | 'HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_RSA_SHA384'
  | 'HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_RSA_SHA512';

/** This determines how authentik sends the response back to the Service Provider. */
export type QueryInputProvidersSamlListSpBinding =
  | 'POST'
  | 'REDIRECT';

export type ProvidersSamlRetrieveResponse = SamlProvider | ValidationError | GenericError;

export type ProvidersSamlMetadataRetrieveResponse = SamlMetadata | ValidationError | GenericError;

/** SAML Provider Metadata serializer */
export type SamlMetadata = {
  metadata: Scalars['String']['output'];
  downloadUrl: Scalars['String']['output'];
};

/** Optionally force the metadata to only include one binding. */
export type QueryInputProvidersSamlMetadataRetrieveForceBinding =
  | 'URN_OASIS_NAMES_TC_SAML_2_0_BINDINGS_HTTP_POST'
  | 'URN_OASIS_NAMES_TC_SAML_2_0_BINDINGS_HTTP_REDIRECT';

export type ProvidersSamlPreviewUserRetrieveResponse = PropertyMappingPreview | GenericError;

export type ProvidersSamlUsedByListResponse = UsedBy | ValidationError | GenericError;

export type ProvidersScimListResponse = PaginatedScimProviderList | ValidationError | GenericError;

export type PaginatedScimProviderList = {
  pagination: Pagination;
  results: Array<Maybe<ScimProvider>>;
};

/** SCIMProvider Serializer */
export type ScimProvider = {
  pk: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  propertyMappings?: Maybe<Array<Maybe<Scalars['UUID']['output']>>>;
  /** Property mappings used for group creation/updating. */
  propertyMappingsGroup?: Maybe<Array<Maybe<Scalars['UUID']['output']>>>;
  /** Get object component so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Internal application name, used in URLs. */
  assignedBackchannelApplicationSlug: Scalars['String']['output'];
  /** Application's display Name. */
  assignedBackchannelApplicationName: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  /** Base URL to SCIM requests, usually ends in /v2 */
  url: Scalars['String']['output'];
  /** Authentication token */
  token: Scalars['String']['output'];
  excludeUsersServiceAccount?: Maybe<Scalars['Boolean']['output']>;
  filterGroup?: Maybe<Scalars['UUID']['output']>;
};

export type ProvidersScimRetrieveResponse = ScimProvider | ValidationError | GenericError;

export type ProvidersScimSyncStatusRetrieveResponse = ScimSyncStatus | ValidationError | GenericError;

/** SCIM Provider sync status */
export type ScimSyncStatus = {
  isRunning: Scalars['Boolean']['output'];
  tasks: Array<Maybe<SystemTask>>;
};

export type ProvidersScimUsedByListResponse = UsedBy | ValidationError | GenericError;

export type RacConnectionTokensListResponse = PaginatedConnectionTokenList | ValidationError | GenericError;

export type PaginatedConnectionTokenList = {
  pagination: Pagination;
  results: Array<Maybe<ConnectionToken>>;
};

/** ConnectionToken Serializer */
export type ConnectionToken = {
  pk?: Maybe<Scalars['UUID']['output']>;
  provider: Scalars['Int']['output'];
  providerObj: RacProvider;
  endpoint: Scalars['UUID']['output'];
  endpointObj: Endpoint;
  user: GroupMember;
};

/** Endpoint Serializer */
export type Endpoint = {
  pk: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  provider: Scalars['Int']['output'];
  providerObj: RacProvider;
  protocol: ProtocolEnum;
  host: Scalars['String']['output'];
  settings?: Maybe<Scalars['JSON']['output']>;
  propertyMappings?: Maybe<Array<Maybe<Scalars['UUID']['output']>>>;
  authMode: AuthModeEnum;
  /**
   * Build actual launch URL (the provider itself does not have one, just
   * individual endpoints)
   */
  launchUrl?: Maybe<Scalars['String']['output']>;
  maximumConnections?: Maybe<Scalars['Int']['output']>;
  additionalProperties?: Maybe<Scalars['JSON']['output']>;
};

export type ProtocolEnum =
  | 'RDP'
  | 'VNC'
  | 'SSH';

export type AuthModeEnum =
  | 'STATIC'
  | 'PROMPT';

export type RacConnectionTokensRetrieveResponse = ConnectionToken | ValidationError | GenericError;

export type RacConnectionTokensUsedByListResponse = UsedBy | ValidationError | GenericError;

export type RacEndpointsListResponse = PaginatedEndpointList | GenericError;

export type PaginatedEndpointList = {
  pagination: Pagination;
  results: Array<Maybe<Endpoint>>;
};

export type RacEndpointsRetrieveResponse = Endpoint | ValidationError | GenericError;

export type RacEndpointsUsedByListResponse = UsedBy | ValidationError | GenericError;

export type RbacPermissionsListResponse = PaginatedPermissionList | ValidationError | GenericError;

export type PaginatedPermissionList = {
  pagination: Pagination;
  results: Array<Maybe<Permission>>;
};

/** Global permission */
export type Permission = {
  id: Scalars['Int']['output'];
  name: Scalars['QueryRbacPermissionsListOneOf_0ResultsItemsName']['output'];
  codename: Scalars['QueryRbacPermissionsListOneOf_0ResultsItemsCodename']['output'];
  model: Scalars['String']['output'];
  appLabel: Scalars['String']['output'];
  /** Human-readable app label */
  appLabelVerbose: Scalars['String']['output'];
  /** Human-readable model name */
  modelVerbose: Scalars['String']['output'];
};

export type RbacPermissionsRetrieveResponse = Permission | ValidationError | GenericError;

export type RbacPermissionsAssignedByRolesListResponse = PaginatedRoleAssignedObjectPermissionList | ValidationError | GenericError;

export type PaginatedRoleAssignedObjectPermissionList = {
  pagination: Pagination;
  results: Array<Maybe<RoleAssignedObjectPermission>>;
};

/** Roles assigned object permission serializer */
export type RoleAssignedObjectPermission = {
  rolePk: Scalars['String']['output'];
  name: Scalars['String']['output'];
  permissions: Array<Maybe<RoleObjectPermission>>;
};

/** Role-bound object level permission */
export type RoleObjectPermission = {
  id: Scalars['Int']['output'];
  codename: Scalars['String']['output'];
  model: Scalars['String']['output'];
  appLabel: Scalars['String']['output'];
  objectPk: Scalars['String']['output'];
  name: Scalars['String']['output'];
};

export type QueryInputRbacPermissionsAssignedByRolesListModel =
  | 'AUTHENTIK_BLUEPRINTS_BLUEPRINTINSTANCE'
  | 'AUTHENTIK_BRANDS_BRAND'
  | 'AUTHENTIK_CORE_APPLICATION'
  | 'AUTHENTIK_CORE_GROUP'
  | 'AUTHENTIK_CORE_TOKEN'
  | 'AUTHENTIK_CORE_USER'
  | 'AUTHENTIK_CRYPTO_CERTIFICATEKEYPAIR'
  | 'AUTHENTIK_ENTERPRISE_LICENSE'
  | 'AUTHENTIK_EVENTS_EVENT'
  | 'AUTHENTIK_EVENTS_NOTIFICATION'
  | 'AUTHENTIK_EVENTS_NOTIFICATIONRULE'
  | 'AUTHENTIK_EVENTS_NOTIFICATIONTRANSPORT'
  | 'AUTHENTIK_EVENTS_NOTIFICATIONWEBHOOKMAPPING'
  | 'AUTHENTIK_FLOWS_FLOW'
  | 'AUTHENTIK_FLOWS_FLOWSTAGEBINDING'
  | 'AUTHENTIK_OUTPOSTS_DOCKERSERVICECONNECTION'
  | 'AUTHENTIK_OUTPOSTS_KUBERNETESSERVICECONNECTION'
  | 'AUTHENTIK_OUTPOSTS_OUTPOST'
  | 'AUTHENTIK_POLICIES_POLICYBINDING'
  | 'AUTHENTIK_POLICIES_DUMMY_DUMMYPOLICY'
  | 'AUTHENTIK_POLICIES_EVENT_MATCHER_EVENTMATCHERPOLICY'
  | 'AUTHENTIK_POLICIES_EXPIRY_PASSWORDEXPIRYPOLICY'
  | 'AUTHENTIK_POLICIES_EXPRESSION_EXPRESSIONPOLICY'
  | 'AUTHENTIK_POLICIES_PASSWORD_PASSWORDPOLICY'
  | 'AUTHENTIK_POLICIES_REPUTATION_REPUTATIONPOLICY'
  | 'AUTHENTIK_PROVIDERS_LDAP_LDAPPROVIDER'
  | 'AUTHENTIK_PROVIDERS_OAUTH2_OAUTH2PROVIDER'
  | 'AUTHENTIK_PROVIDERS_OAUTH2_SCOPEMAPPING'
  | 'AUTHENTIK_PROVIDERS_PROXY_PROXYPROVIDER'
  | 'AUTHENTIK_PROVIDERS_RAC_ENDPOINT'
  | 'AUTHENTIK_PROVIDERS_RAC_RACPROPERTYMAPPING'
  | 'AUTHENTIK_PROVIDERS_RAC_RACPROVIDER'
  | 'AUTHENTIK_PROVIDERS_RADIUS_RADIUSPROVIDER'
  | 'AUTHENTIK_PROVIDERS_SAML_SAMLPROPERTYMAPPING'
  | 'AUTHENTIK_PROVIDERS_SAML_SAMLPROVIDER'
  | 'AUTHENTIK_PROVIDERS_SCIM_SCIMMAPPING'
  | 'AUTHENTIK_PROVIDERS_SCIM_SCIMPROVIDER'
  | 'AUTHENTIK_RBAC_ROLE'
  | 'AUTHENTIK_SOURCES_LDAP_LDAPPROPERTYMAPPING'
  | 'AUTHENTIK_SOURCES_LDAP_LDAPSOURCE'
  | 'AUTHENTIK_SOURCES_OAUTH_OAUTHSOURCE'
  | 'AUTHENTIK_SOURCES_OAUTH_USEROAUTHSOURCECONNECTION'
  | 'AUTHENTIK_SOURCES_PLEX_PLEXSOURCE'
  | 'AUTHENTIK_SOURCES_PLEX_PLEXSOURCECONNECTION'
  | 'AUTHENTIK_SOURCES_SAML_SAMLSOURCE'
  | 'AUTHENTIK_SOURCES_SAML_USERSAMLSOURCECONNECTION'
  | 'AUTHENTIK_SOURCES_SCIM_SCIMSOURCE'
  | 'AUTHENTIK_STAGES_AUTHENTICATOR_DUO_AUTHENTICATORDUOSTAGE'
  | 'AUTHENTIK_STAGES_AUTHENTICATOR_DUO_DUODEVICE'
  | 'AUTHENTIK_STAGES_AUTHENTICATOR_SMS_AUTHENTICATORSMSSTAGE'
  | 'AUTHENTIK_STAGES_AUTHENTICATOR_SMS_SMSDEVICE'
  | 'AUTHENTIK_STAGES_AUTHENTICATOR_STATIC_AUTHENTICATORSTATICSTAGE'
  | 'AUTHENTIK_STAGES_AUTHENTICATOR_STATIC_STATICDEVICE'
  | 'AUTHENTIK_STAGES_AUTHENTICATOR_TOTP_AUTHENTICATORTOTPSTAGE'
  | 'AUTHENTIK_STAGES_AUTHENTICATOR_TOTP_TOTPDEVICE'
  | 'AUTHENTIK_STAGES_AUTHENTICATOR_VALIDATE_AUTHENTICATORVALIDATESTAGE'
  | 'AUTHENTIK_STAGES_AUTHENTICATOR_WEBAUTHN_AUTHENTICATORWEBAUTHNSTAGE'
  | 'AUTHENTIK_STAGES_AUTHENTICATOR_WEBAUTHN_WEBAUTHNDEVICE'
  | 'AUTHENTIK_STAGES_CAPTCHA_CAPTCHASTAGE'
  | 'AUTHENTIK_STAGES_CONSENT_CONSENTSTAGE'
  | 'AUTHENTIK_STAGES_CONSENT_USERCONSENT'
  | 'AUTHENTIK_STAGES_DENY_DENYSTAGE'
  | 'AUTHENTIK_STAGES_DUMMY_DUMMYSTAGE'
  | 'AUTHENTIK_STAGES_EMAIL_EMAILSTAGE'
  | 'AUTHENTIK_STAGES_IDENTIFICATION_IDENTIFICATIONSTAGE'
  | 'AUTHENTIK_STAGES_INVITATION_INVITATION'
  | 'AUTHENTIK_STAGES_INVITATION_INVITATIONSTAGE'
  | 'AUTHENTIK_STAGES_PASSWORD_PASSWORDSTAGE'
  | 'AUTHENTIK_STAGES_PROMPT_PROMPT'
  | 'AUTHENTIK_STAGES_PROMPT_PROMPTSTAGE'
  | 'AUTHENTIK_STAGES_SOURCE_SOURCESTAGE'
  | 'AUTHENTIK_STAGES_USER_DELETE_USERDELETESTAGE'
  | 'AUTHENTIK_STAGES_USER_LOGIN_USERLOGINSTAGE'
  | 'AUTHENTIK_STAGES_USER_LOGOUT_USERLOGOUTSTAGE'
  | 'AUTHENTIK_STAGES_USER_WRITE_USERWRITESTAGE'
  | 'AUTHENTIK_TENANTS_DOMAIN';

export type RbacPermissionsAssignedByUsersListResponse = PaginatedUserAssignedObjectPermissionList | ValidationError | GenericError;

export type PaginatedUserAssignedObjectPermissionList = {
  pagination: Pagination;
  results: Array<Maybe<UserAssignedObjectPermission>>;
};

/** Users assigned object permission serializer */
export type UserAssignedObjectPermission = {
  pk: Scalars['Int']['output'];
  username: Scalars['QueryRbacPermissionsAssignedByUsersListOneOf_0ResultsItemsUsername']['output'];
  /** User's display name. */
  name: Scalars['String']['output'];
  /** Designates whether this user should be treated as active. Unselect this instead of deleting accounts. */
  isActive?: Maybe<Scalars['Boolean']['output']>;
  lastLogin?: Maybe<Scalars['DateTime']['output']>;
  email?: Maybe<Scalars['EmailAddress']['output']>;
  attributes?: Maybe<Scalars['JSON']['output']>;
  uid: Scalars['String']['output'];
  permissions: Array<Maybe<UserObjectPermission>>;
  isSuperuser: Scalars['Boolean']['output'];
};

/** User-bound object level permission */
export type UserObjectPermission = {
  id: Scalars['Int']['output'];
  codename: Scalars['String']['output'];
  model: Scalars['String']['output'];
  appLabel: Scalars['String']['output'];
  objectPk: Scalars['String']['output'];
  name: Scalars['String']['output'];
};

export type QueryInputRbacPermissionsAssignedByUsersListModel =
  | 'AUTHENTIK_BLUEPRINTS_BLUEPRINTINSTANCE'
  | 'AUTHENTIK_BRANDS_BRAND'
  | 'AUTHENTIK_CORE_APPLICATION'
  | 'AUTHENTIK_CORE_GROUP'
  | 'AUTHENTIK_CORE_TOKEN'
  | 'AUTHENTIK_CORE_USER'
  | 'AUTHENTIK_CRYPTO_CERTIFICATEKEYPAIR'
  | 'AUTHENTIK_ENTERPRISE_LICENSE'
  | 'AUTHENTIK_EVENTS_EVENT'
  | 'AUTHENTIK_EVENTS_NOTIFICATION'
  | 'AUTHENTIK_EVENTS_NOTIFICATIONRULE'
  | 'AUTHENTIK_EVENTS_NOTIFICATIONTRANSPORT'
  | 'AUTHENTIK_EVENTS_NOTIFICATIONWEBHOOKMAPPING'
  | 'AUTHENTIK_FLOWS_FLOW'
  | 'AUTHENTIK_FLOWS_FLOWSTAGEBINDING'
  | 'AUTHENTIK_OUTPOSTS_DOCKERSERVICECONNECTION'
  | 'AUTHENTIK_OUTPOSTS_KUBERNETESSERVICECONNECTION'
  | 'AUTHENTIK_OUTPOSTS_OUTPOST'
  | 'AUTHENTIK_POLICIES_POLICYBINDING'
  | 'AUTHENTIK_POLICIES_DUMMY_DUMMYPOLICY'
  | 'AUTHENTIK_POLICIES_EVENT_MATCHER_EVENTMATCHERPOLICY'
  | 'AUTHENTIK_POLICIES_EXPIRY_PASSWORDEXPIRYPOLICY'
  | 'AUTHENTIK_POLICIES_EXPRESSION_EXPRESSIONPOLICY'
  | 'AUTHENTIK_POLICIES_PASSWORD_PASSWORDPOLICY'
  | 'AUTHENTIK_POLICIES_REPUTATION_REPUTATIONPOLICY'
  | 'AUTHENTIK_PROVIDERS_LDAP_LDAPPROVIDER'
  | 'AUTHENTIK_PROVIDERS_OAUTH2_OAUTH2PROVIDER'
  | 'AUTHENTIK_PROVIDERS_OAUTH2_SCOPEMAPPING'
  | 'AUTHENTIK_PROVIDERS_PROXY_PROXYPROVIDER'
  | 'AUTHENTIK_PROVIDERS_RAC_ENDPOINT'
  | 'AUTHENTIK_PROVIDERS_RAC_RACPROPERTYMAPPING'
  | 'AUTHENTIK_PROVIDERS_RAC_RACPROVIDER'
  | 'AUTHENTIK_PROVIDERS_RADIUS_RADIUSPROVIDER'
  | 'AUTHENTIK_PROVIDERS_SAML_SAMLPROPERTYMAPPING'
  | 'AUTHENTIK_PROVIDERS_SAML_SAMLPROVIDER'
  | 'AUTHENTIK_PROVIDERS_SCIM_SCIMMAPPING'
  | 'AUTHENTIK_PROVIDERS_SCIM_SCIMPROVIDER'
  | 'AUTHENTIK_RBAC_ROLE'
  | 'AUTHENTIK_SOURCES_LDAP_LDAPPROPERTYMAPPING'
  | 'AUTHENTIK_SOURCES_LDAP_LDAPSOURCE'
  | 'AUTHENTIK_SOURCES_OAUTH_OAUTHSOURCE'
  | 'AUTHENTIK_SOURCES_OAUTH_USEROAUTHSOURCECONNECTION'
  | 'AUTHENTIK_SOURCES_PLEX_PLEXSOURCE'
  | 'AUTHENTIK_SOURCES_PLEX_PLEXSOURCECONNECTION'
  | 'AUTHENTIK_SOURCES_SAML_SAMLSOURCE'
  | 'AUTHENTIK_SOURCES_SAML_USERSAMLSOURCECONNECTION'
  | 'AUTHENTIK_SOURCES_SCIM_SCIMSOURCE'
  | 'AUTHENTIK_STAGES_AUTHENTICATOR_DUO_AUTHENTICATORDUOSTAGE'
  | 'AUTHENTIK_STAGES_AUTHENTICATOR_DUO_DUODEVICE'
  | 'AUTHENTIK_STAGES_AUTHENTICATOR_SMS_AUTHENTICATORSMSSTAGE'
  | 'AUTHENTIK_STAGES_AUTHENTICATOR_SMS_SMSDEVICE'
  | 'AUTHENTIK_STAGES_AUTHENTICATOR_STATIC_AUTHENTICATORSTATICSTAGE'
  | 'AUTHENTIK_STAGES_AUTHENTICATOR_STATIC_STATICDEVICE'
  | 'AUTHENTIK_STAGES_AUTHENTICATOR_TOTP_AUTHENTICATORTOTPSTAGE'
  | 'AUTHENTIK_STAGES_AUTHENTICATOR_TOTP_TOTPDEVICE'
  | 'AUTHENTIK_STAGES_AUTHENTICATOR_VALIDATE_AUTHENTICATORVALIDATESTAGE'
  | 'AUTHENTIK_STAGES_AUTHENTICATOR_WEBAUTHN_AUTHENTICATORWEBAUTHNSTAGE'
  | 'AUTHENTIK_STAGES_AUTHENTICATOR_WEBAUTHN_WEBAUTHNDEVICE'
  | 'AUTHENTIK_STAGES_CAPTCHA_CAPTCHASTAGE'
  | 'AUTHENTIK_STAGES_CONSENT_CONSENTSTAGE'
  | 'AUTHENTIK_STAGES_CONSENT_USERCONSENT'
  | 'AUTHENTIK_STAGES_DENY_DENYSTAGE'
  | 'AUTHENTIK_STAGES_DUMMY_DUMMYSTAGE'
  | 'AUTHENTIK_STAGES_EMAIL_EMAILSTAGE'
  | 'AUTHENTIK_STAGES_IDENTIFICATION_IDENTIFICATIONSTAGE'
  | 'AUTHENTIK_STAGES_INVITATION_INVITATION'
  | 'AUTHENTIK_STAGES_INVITATION_INVITATIONSTAGE'
  | 'AUTHENTIK_STAGES_PASSWORD_PASSWORDSTAGE'
  | 'AUTHENTIK_STAGES_PROMPT_PROMPT'
  | 'AUTHENTIK_STAGES_PROMPT_PROMPTSTAGE'
  | 'AUTHENTIK_STAGES_SOURCE_SOURCESTAGE'
  | 'AUTHENTIK_STAGES_USER_DELETE_USERDELETESTAGE'
  | 'AUTHENTIK_STAGES_USER_LOGIN_USERLOGINSTAGE'
  | 'AUTHENTIK_STAGES_USER_LOGOUT_USERLOGOUTSTAGE'
  | 'AUTHENTIK_STAGES_USER_WRITE_USERWRITESTAGE'
  | 'AUTHENTIK_TENANTS_DOMAIN';

export type RbacPermissionsRolesListResponse = PaginatedExtraRoleObjectPermissionList | ValidationError | GenericError;

export type PaginatedExtraRoleObjectPermissionList = {
  pagination: Pagination;
  results: Array<Maybe<ExtraRoleObjectPermission>>;
};

/** User permission with additional object-related data */
export type ExtraRoleObjectPermission = {
  id: Scalars['Int']['output'];
  codename: Scalars['String']['output'];
  model: Scalars['String']['output'];
  appLabel: Scalars['String']['output'];
  objectPk: Scalars['String']['output'];
  name: Scalars['String']['output'];
  /** Get app label from permission's model */
  appLabelVerbose: Scalars['String']['output'];
  /** Get model label from permission's model */
  modelVerbose: Scalars['String']['output'];
  /**
   * Get model description from attached model. This operation takes at least
   * one additional query, and the description is only shown if the user/role has the
   * view_ permission on the object
   */
  objectDescription?: Maybe<Scalars['String']['output']>;
};

export type RbacPermissionsUsersListResponse = PaginatedExtraUserObjectPermissionList | ValidationError | GenericError;

export type PaginatedExtraUserObjectPermissionList = {
  pagination: Pagination;
  results: Array<Maybe<ExtraUserObjectPermission>>;
};

/** User permission with additional object-related data */
export type ExtraUserObjectPermission = {
  id: Scalars['Int']['output'];
  codename: Scalars['String']['output'];
  model: Scalars['String']['output'];
  appLabel: Scalars['String']['output'];
  objectPk: Scalars['String']['output'];
  name: Scalars['String']['output'];
  /** Get app label from permission's model */
  appLabelVerbose: Scalars['String']['output'];
  /** Get model label from permission's model */
  modelVerbose: Scalars['String']['output'];
  /**
   * Get model description from attached model. This operation takes at least
   * one additional query, and the description is only shown if the user/role has the
   * view_ permission on the object
   */
  objectDescription?: Maybe<Scalars['String']['output']>;
};

export type RbacRolesListResponse = PaginatedRoleList | ValidationError | GenericError;

export type PaginatedRoleList = {
  pagination: Pagination;
  results: Array<Maybe<Role>>;
};

export type RbacRolesRetrieveResponse = Role | ValidationError | GenericError;

export type RbacRolesUsedByListResponse = UsedBy | ValidationError | GenericError;

export type RootConfigRetrieveResponse = Config | ValidationError | GenericError;

/** Serialize authentik Config into DRF Object */
export type Config = {
  errorReporting: ErrorReportingConfig;
  capabilities: Array<Maybe<CapabilitiesEnum>>;
  cacheTimeout: Scalars['Int']['output'];
  cacheTimeoutFlows: Scalars['Int']['output'];
  cacheTimeoutPolicies: Scalars['Int']['output'];
  cacheTimeoutReputation: Scalars['Int']['output'];
};

/** Config for error reporting */
export type ErrorReportingConfig = {
  enabled: Scalars['Boolean']['output'];
  sentryDsn: Scalars['String']['output'];
  environment: Scalars['String']['output'];
  sendPii: Scalars['Boolean']['output'];
  tracesSampleRate: Scalars['Float']['output'];
};

export type CapabilitiesEnum =
  | 'CAN_SAVE_MEDIA'
  | 'CAN_GEO_IP'
  | 'CAN_ASN'
  | 'CAN_IMPERSONATE'
  | 'CAN_DEBUG'
  | 'IS_ENTERPRISE';

export type SchemaRetrieveResponse = JsonContainer | ValidationError | GenericError;

export type JsonContainer = {
  json?: Maybe<Scalars['JSON']['output']>;
};

export type QueryInputSchemaRetrieveFormat =
  | 'JSON'
  | 'YAML';

export type QueryInputSchemaRetrieveLang =
  | 'AF'
  | 'AR'
  | 'AR_DZ'
  | 'AST'
  | 'AZ'
  | 'BE'
  | 'BG'
  | 'BN'
  | 'BR'
  | 'BS'
  | 'CA'
  | 'CKB'
  | 'CS'
  | 'CY'
  | 'DA'
  | 'DE'
  | 'DSB'
  | 'EL'
  | 'EN'
  | 'EN_AU'
  | 'EN_GB'
  | 'EO'
  | 'ES'
  | 'ES_AR'
  | 'ES_CO'
  | 'ES_MX'
  | 'ES_NI'
  | 'ES_VE'
  | 'ET'
  | 'EU'
  | 'FA'
  | 'FI'
  | 'FR'
  | 'FY'
  | 'GA'
  | 'GD'
  | 'GL'
  | 'HE'
  | 'HI'
  | 'HR'
  | 'HSB'
  | 'HU'
  | 'HY'
  | 'IA'
  | 'ID'
  | 'IG'
  | 'IO'
  | 'IS'
  | 'IT'
  | 'JA'
  | 'KA'
  | 'KAB'
  | 'KK'
  | 'KM'
  | 'KN'
  | 'KO'
  | 'KY'
  | 'LB'
  | 'LT'
  | 'LV'
  | 'MK'
  | 'ML'
  | 'MN'
  | 'MR'
  | 'MS'
  | 'MY'
  | 'NB'
  | 'NE'
  | 'NL'
  | 'NN'
  | 'OS'
  | 'PA'
  | 'PL'
  | 'PT'
  | 'PT_BR'
  | 'RO'
  | 'RU'
  | 'SK'
  | 'SL'
  | 'SQ'
  | 'SR'
  | 'SR_LATN'
  | 'SV'
  | 'SW'
  | 'TA'
  | 'TE'
  | 'TG'
  | 'TH'
  | 'TK'
  | 'TR'
  | 'TT'
  | 'UDM'
  | 'UG'
  | 'UK'
  | 'UR'
  | 'UZ'
  | 'VI'
  | 'ZH_HANS'
  | 'ZH_HANT';

export type SourcesAllListResponse = PaginatedSourceList | ValidationError | GenericError;

export type PaginatedSourceList = {
  pagination: Pagination;
  results: Array<Maybe<Source>>;
};

/** Source Serializer */
export type Source = {
  pk: Scalars['UUID']['output'];
  /** Source's display Name. */
  name: Scalars['String']['output'];
  slug: Scalars['QuerySourcesAllListOneOf_0ResultsItemsSlug']['output'];
  enabled?: Maybe<Scalars['Boolean']['output']>;
  /** Flow to use when authenticating existing users. */
  authenticationFlow?: Maybe<Scalars['UUID']['output']>;
  /** Flow to use when enrolling new users. */
  enrollmentFlow?: Maybe<Scalars['UUID']['output']>;
  /** Get object component so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  policyEngineMode?: Maybe<PolicyEngineMode>;
  userMatchingMode?: Maybe<UserMatchingModeEnum>;
  /** Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update. */
  managed?: Maybe<Scalars['String']['output']>;
  userPathTemplate?: Maybe<Scalars['String']['output']>;
  /**
   * Get the URL to the Icon. If the name is /static or
   * starts with http it is returned as-is
   */
  icon?: Maybe<Scalars['String']['output']>;
  additionalProperties?: Maybe<Scalars['JSON']['output']>;
};

export type UserMatchingModeEnum =
  | 'IDENTIFIER'
  | 'EMAIL_LINK'
  | 'EMAIL_DENY'
  | 'USERNAME_LINK'
  | 'USERNAME_DENY';

export type SourcesAllRetrieveResponse = Source | ValidationError | GenericError;

export type SourcesAllUsedByListResponse = UsedBy | ValidationError | GenericError;

export type SourcesAllTypesListResponse = TypeCreate | ValidationError | GenericError;

export type SourcesAllUserSettingsListResponse = UserSetting | ValidationError | GenericError;

/** Serializer for User settings for stages and sources */
export type UserSetting = {
  objectUid: Scalars['String']['output'];
  component: Scalars['String']['output'];
  title: Scalars['String']['output'];
  configureUrl?: Maybe<Scalars['String']['output']>;
  iconUrl?: Maybe<Scalars['String']['output']>;
};

export type SourcesLdapListResponse = PaginatedLdapSourceList | ValidationError | GenericError;

export type PaginatedLdapSourceList = {
  pagination: Pagination;
  results: Array<Maybe<LdapSource>>;
};

/** LDAP Source Serializer */
export type LdapSource = {
  pk: Scalars['UUID']['output'];
  /** Source's display Name. */
  name: Scalars['String']['output'];
  slug: Scalars['QuerySourcesLdapListOneOf_0ResultsItemsSlug']['output'];
  enabled?: Maybe<Scalars['Boolean']['output']>;
  /** Flow to use when authenticating existing users. */
  authenticationFlow?: Maybe<Scalars['UUID']['output']>;
  /** Flow to use when enrolling new users. */
  enrollmentFlow?: Maybe<Scalars['UUID']['output']>;
  /** Get object component so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  policyEngineMode?: Maybe<PolicyEngineMode>;
  userMatchingMode?: Maybe<UserMatchingModeEnum>;
  /** Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update. */
  managed?: Maybe<Scalars['String']['output']>;
  userPathTemplate?: Maybe<Scalars['String']['output']>;
  /**
   * Get the URL to the Icon. If the name is /static or
   * starts with http it is returned as-is
   */
  icon?: Maybe<Scalars['String']['output']>;
  serverUri: Scalars['URL']['output'];
  /** Optionally verify the LDAP Server's Certificate against the CA Chain in this keypair. */
  peerCertificate?: Maybe<Scalars['UUID']['output']>;
  /** Client certificate to authenticate against the LDAP Server's Certificate. */
  clientCertificate?: Maybe<Scalars['UUID']['output']>;
  bindCn?: Maybe<Scalars['String']['output']>;
  startTls?: Maybe<Scalars['Boolean']['output']>;
  sni?: Maybe<Scalars['Boolean']['output']>;
  baseDn: Scalars['String']['output'];
  /** Prepended to Base DN for User-queries. */
  additionalUserDn?: Maybe<Scalars['String']['output']>;
  /** Prepended to Base DN for Group-queries. */
  additionalGroupDn?: Maybe<Scalars['String']['output']>;
  /** Consider Objects matching this filter to be Users. */
  userObjectFilter?: Maybe<Scalars['String']['output']>;
  /** Consider Objects matching this filter to be Groups. */
  groupObjectFilter?: Maybe<Scalars['String']['output']>;
  /** Field which contains members of a group. */
  groupMembershipField?: Maybe<Scalars['String']['output']>;
  /** Field which contains a unique Identifier. */
  objectUniquenessField?: Maybe<Scalars['String']['output']>;
  /** Update internal authentik password when login succeeds with LDAP */
  passwordLoginUpdateInternalPassword?: Maybe<Scalars['Boolean']['output']>;
  syncUsers?: Maybe<Scalars['Boolean']['output']>;
  /** When a user changes their password, sync it back to LDAP. This can only be enabled on a single LDAP source. */
  syncUsersPassword?: Maybe<Scalars['Boolean']['output']>;
  syncGroups?: Maybe<Scalars['Boolean']['output']>;
  syncParentGroup?: Maybe<Scalars['UUID']['output']>;
  propertyMappings?: Maybe<Array<Maybe<Scalars['UUID']['output']>>>;
  /** Property mappings used for group creation/updating. */
  propertyMappingsGroup?: Maybe<Array<Maybe<Scalars['UUID']['output']>>>;
  /** Get cached source connectivity */
  connectivity?: Maybe<Scalars['JSON']['output']>;
};

export type SourcesLdapRetrieveResponse = LdapSource | ValidationError | GenericError;

export type SourcesLdapDebugRetrieveResponse = LdapDebug | ValidationError | GenericError;

export type LdapDebug = {
  user: Array<Maybe<Scalars['JSON']['output']>>;
  group: Array<Maybe<Scalars['JSON']['output']>>;
  membership: Array<Maybe<Scalars['JSON']['output']>>;
};

export type SourcesLdapSyncStatusRetrieveResponse = LdapSyncStatus | ValidationError | GenericError;

/** LDAP Source sync status */
export type LdapSyncStatus = {
  isRunning: Scalars['Boolean']['output'];
  tasks: Array<Maybe<SystemTask>>;
};

export type SourcesLdapUsedByListResponse = UsedBy | ValidationError | GenericError;

export type SourcesOauthListResponse = PaginatedOAuthSourceList | ValidationError | GenericError;

export type PaginatedOAuthSourceList = {
  pagination: Pagination;
  results: Array<Maybe<OAuthSource>>;
};

/** OAuth Source Serializer */
export type OAuthSource = {
  pk: Scalars['UUID']['output'];
  /** Source's display Name. */
  name: Scalars['String']['output'];
  slug: Scalars['QuerySourcesOauthListOneOf_0ResultsItemsSlug']['output'];
  enabled?: Maybe<Scalars['Boolean']['output']>;
  /** Flow to use when authenticating existing users. */
  authenticationFlow?: Maybe<Scalars['UUID']['output']>;
  /** Flow to use when enrolling new users. */
  enrollmentFlow?: Maybe<Scalars['UUID']['output']>;
  /** Get object component so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  policyEngineMode?: Maybe<PolicyEngineMode>;
  userMatchingMode?: Maybe<UserMatchingModeEnum>;
  /** Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update. */
  managed?: Maybe<Scalars['String']['output']>;
  userPathTemplate?: Maybe<Scalars['String']['output']>;
  /**
   * Get the URL to the Icon. If the name is /static or
   * starts with http it is returned as-is
   */
  icon?: Maybe<Scalars['String']['output']>;
  providerType: ProviderTypeEnum;
  /** URL used to request the initial token. This URL is only required for OAuth 1. */
  requestTokenUrl?: Maybe<Scalars['QuerySourcesOauthListOneOf_0ResultsItemsRequestTokenUrl']['output']>;
  /** URL the user is redirect to to conest the flow. */
  authorizationUrl?: Maybe<Scalars['QuerySourcesOauthListOneOf_0ResultsItemsAuthorizationUrl']['output']>;
  /** URL used by authentik to retrieve tokens. */
  accessTokenUrl?: Maybe<Scalars['QuerySourcesOauthListOneOf_0ResultsItemsAccessTokenUrl']['output']>;
  /** URL used by authentik to get user information. */
  profileUrl?: Maybe<Scalars['QuerySourcesOauthListOneOf_0ResultsItemsProfileUrl']['output']>;
  consumerKey: Scalars['String']['output'];
  /** Get OAuth Callback URL */
  callbackUrl: Scalars['String']['output'];
  additionalScopes?: Maybe<Scalars['String']['output']>;
  type: SourceType;
  oidcWellKnownUrl?: Maybe<Scalars['String']['output']>;
  oidcJwksUrl?: Maybe<Scalars['String']['output']>;
  oidcJwks?: Maybe<Scalars['JSON']['output']>;
};

export type ProviderTypeEnum =
  | 'APPLE'
  | 'OPENIDCONNECT'
  | 'AZUREAD'
  | 'DISCORD'
  | 'FACEBOOK'
  | 'GITHUB'
  | 'GITLAB'
  | 'GOOGLE'
  | 'MAILCOW'
  | 'OKTA'
  | 'PATREON'
  | 'REDDIT'
  | 'TWITCH'
  | 'TWITTER';

/** Serializer for SourceType */
export type SourceType = {
  name: Scalars['String']['output'];
  verboseName: Scalars['String']['output'];
  urlsCustomizable: Scalars['Boolean']['output'];
  requestTokenUrl?: Maybe<Scalars['String']['output']>;
  authorizationUrl?: Maybe<Scalars['String']['output']>;
  accessTokenUrl?: Maybe<Scalars['String']['output']>;
  profileUrl?: Maybe<Scalars['String']['output']>;
  oidcWellKnownUrl?: Maybe<Scalars['String']['output']>;
  oidcJwksUrl?: Maybe<Scalars['String']['output']>;
  additionalProperties?: Maybe<Scalars['JSON']['output']>;
};

export type QueryInputSourcesOauthListPolicyEngineMode =
  | 'ALL'
  | 'ANY';

/** How the source determines if an existing user should be authenticated or a new user enrolled. */
export type QueryInputSourcesOauthListUserMatchingMode =
  | 'EMAIL_DENY'
  | 'EMAIL_LINK'
  | 'IDENTIFIER'
  | 'USERNAME_DENY'
  | 'USERNAME_LINK';

export type SourcesOauthRetrieveResponse = OAuthSource | ValidationError | GenericError;

export type SourcesOauthUsedByListResponse = UsedBy | ValidationError | GenericError;

export type SourcesOauthSourceTypesListResponse = SourceType | ValidationError | GenericError;

export type SourcesPlexListResponse = PaginatedPlexSourceList | ValidationError | GenericError;

export type PaginatedPlexSourceList = {
  pagination: Pagination;
  results: Array<Maybe<PlexSource>>;
};

/** Plex Source Serializer */
export type PlexSource = {
  pk: Scalars['UUID']['output'];
  /** Source's display Name. */
  name: Scalars['String']['output'];
  slug: Scalars['QuerySourcesPlexListOneOf_0ResultsItemsSlug']['output'];
  enabled?: Maybe<Scalars['Boolean']['output']>;
  /** Flow to use when authenticating existing users. */
  authenticationFlow?: Maybe<Scalars['UUID']['output']>;
  /** Flow to use when enrolling new users. */
  enrollmentFlow?: Maybe<Scalars['UUID']['output']>;
  /** Get object component so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  policyEngineMode?: Maybe<PolicyEngineMode>;
  userMatchingMode?: Maybe<UserMatchingModeEnum>;
  /** Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update. */
  managed?: Maybe<Scalars['String']['output']>;
  userPathTemplate?: Maybe<Scalars['String']['output']>;
  /**
   * Get the URL to the Icon. If the name is /static or
   * starts with http it is returned as-is
   */
  icon?: Maybe<Scalars['String']['output']>;
  /** Client identifier used to talk to Plex. */
  clientId?: Maybe<Scalars['String']['output']>;
  /** Which servers a user has to be a member of to be granted access. Empty list allows every server. */
  allowedServers?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** Allow friends to authenticate, even if you don't share a server. */
  allowFriends?: Maybe<Scalars['Boolean']['output']>;
  /** Plex token used to check friends */
  plexToken: Scalars['String']['output'];
};

export type QueryInputSourcesPlexListPolicyEngineMode =
  | 'ALL'
  | 'ANY';

/** How the source determines if an existing user should be authenticated or a new user enrolled. */
export type QueryInputSourcesPlexListUserMatchingMode =
  | 'EMAIL_DENY'
  | 'EMAIL_LINK'
  | 'IDENTIFIER'
  | 'USERNAME_DENY'
  | 'USERNAME_LINK';

export type SourcesPlexRetrieveResponse = PlexSource | ValidationError | GenericError;

export type SourcesPlexUsedByListResponse = UsedBy | ValidationError | GenericError;

export type SourcesSamlListResponse = PaginatedSamlSourceList | ValidationError | GenericError;

export type PaginatedSamlSourceList = {
  pagination: Pagination;
  results: Array<Maybe<SamlSource>>;
};

/** SAMLSource Serializer */
export type SamlSource = {
  pk: Scalars['UUID']['output'];
  /** Source's display Name. */
  name: Scalars['String']['output'];
  slug: Scalars['QuerySourcesSamlListOneOf_0ResultsItemsSlug']['output'];
  enabled?: Maybe<Scalars['Boolean']['output']>;
  /** Flow to use when authenticating existing users. */
  authenticationFlow?: Maybe<Scalars['UUID']['output']>;
  /** Flow to use when enrolling new users. */
  enrollmentFlow?: Maybe<Scalars['UUID']['output']>;
  /** Get object component so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  policyEngineMode?: Maybe<PolicyEngineMode>;
  userMatchingMode?: Maybe<UserMatchingModeEnum>;
  /** Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update. */
  managed?: Maybe<Scalars['String']['output']>;
  userPathTemplate?: Maybe<Scalars['String']['output']>;
  /**
   * Get the URL to the Icon. If the name is /static or
   * starts with http it is returned as-is
   */
  icon?: Maybe<Scalars['String']['output']>;
  /** Flow used before authentication. */
  preAuthenticationFlow: Scalars['UUID']['output'];
  /** Also known as Entity ID. Defaults the Metadata URL. */
  issuer?: Maybe<Scalars['String']['output']>;
  /** URL that the initial Login request is sent to. */
  ssoUrl: Scalars['URL']['output'];
  /** Optional URL if your IDP supports Single-Logout. */
  sloUrl?: Maybe<Scalars['URL']['output']>;
  /** Allows authentication flows initiated by the IdP. This can be a security risk, as no validation of the request ID is done. */
  allowIdpInitiated?: Maybe<Scalars['Boolean']['output']>;
  nameIdPolicy?: Maybe<NameIdPolicyEnum>;
  bindingType?: Maybe<BindingTypeEnum>;
  /** When selected, incoming assertion's Signatures will be validated against this certificate. To allow unsigned Requests, leave on default. */
  verificationKp?: Maybe<Scalars['UUID']['output']>;
  /** Keypair used to sign outgoing Responses going to the Identity Provider. */
  signingKp?: Maybe<Scalars['UUID']['output']>;
  digestAlgorithm?: Maybe<DigestAlgorithmEnum>;
  signatureAlgorithm?: Maybe<SignatureAlgorithmEnum>;
  /** Time offset when temporary users should be deleted. This only applies if your IDP uses the NameID Format 'transient', and the user doesn't log out manually. (Format: hours=1;minutes=2;seconds=3). */
  temporaryUserDeleteAfter?: Maybe<Scalars['String']['output']>;
};

export type NameIdPolicyEnum =
  | 'URN_OASIS_NAMES_TC_SAML_1_1_NAMEID_FORMAT_EMAILADDRESS'
  | 'URN_OASIS_NAMES_TC_SAML_2_0_NAMEID_FORMAT_PERSISTENT'
  | 'URN_OASIS_NAMES_TC_SAML_2_0_NAMEID_FORMAT_X509SUBJECTNAME'
  | 'URN_OASIS_NAMES_TC_SAML_2_0_NAMEID_FORMAT_WINDOWSDOMAINQUALIFIEDNAME'
  | 'URN_OASIS_NAMES_TC_SAML_2_0_NAMEID_FORMAT_TRANSIENT';

export type BindingTypeEnum =
  | 'REDIRECT'
  | 'POST'
  | 'POST_AUTO';

export type QueryInputSourcesSamlListBindingType =
  | 'POST'
  | 'POST_AUTO'
  | 'REDIRECT';

export type QueryInputSourcesSamlListDigestAlgorithm =
  | 'HTTP___WWW_W3_ORG_2000_09_XMLDSIG_POUND_SHA1'
  | 'HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_SHA384'
  | 'HTTP___WWW_W3_ORG_2001_04_XMLENC_POUND_SHA256'
  | 'HTTP___WWW_W3_ORG_2001_04_XMLENC_POUND_SHA512';

/** NameID Policy sent to the IdP. Can be unset, in which case no Policy is sent. */
export type QueryInputSourcesSamlListNameIdPolicy =
  | 'URN_OASIS_NAMES_TC_SAML_1_1_NAMEID_FORMAT_EMAILADDRESS'
  | 'URN_OASIS_NAMES_TC_SAML_2_0_NAMEID_FORMAT_WINDOWSDOMAINQUALIFIEDNAME'
  | 'URN_OASIS_NAMES_TC_SAML_2_0_NAMEID_FORMAT_X509SUBJECTNAME'
  | 'URN_OASIS_NAMES_TC_SAML_2_0_NAMEID_FORMAT_PERSISTENT'
  | 'URN_OASIS_NAMES_TC_SAML_2_0_NAMEID_FORMAT_TRANSIENT';

export type QueryInputSourcesSamlListPolicyEngineMode =
  | 'ALL'
  | 'ANY';

export type QueryInputSourcesSamlListSignatureAlgorithm =
  | 'HTTP___WWW_W3_ORG_2000_09_XMLDSIG_POUND_DSA_SHA1'
  | 'HTTP___WWW_W3_ORG_2000_09_XMLDSIG_POUND_RSA_SHA1'
  | 'HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_ECDSA_SHA1'
  | 'HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_ECDSA_SHA256'
  | 'HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_ECDSA_SHA384'
  | 'HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_ECDSA_SHA512'
  | 'HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_RSA_SHA256'
  | 'HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_RSA_SHA384'
  | 'HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_RSA_SHA512';

/** How the source determines if an existing user should be authenticated or a new user enrolled. */
export type QueryInputSourcesSamlListUserMatchingMode =
  | 'EMAIL_DENY'
  | 'EMAIL_LINK'
  | 'IDENTIFIER'
  | 'USERNAME_DENY'
  | 'USERNAME_LINK';

export type SourcesSamlRetrieveResponse = SamlSource | ValidationError | GenericError;

export type SourcesSamlMetadataRetrieveResponse = SamlMetadata | ValidationError | GenericError;

export type SourcesSamlUsedByListResponse = UsedBy | ValidationError | GenericError;

export type SourcesScimListResponse = PaginatedScimSourceList | ValidationError | GenericError;

export type PaginatedScimSourceList = {
  pagination: Pagination;
  results: Array<Maybe<ScimSource>>;
};

/** SCIMSource Serializer */
export type ScimSource = {
  pk: Scalars['UUID']['output'];
  /** Source's display Name. */
  name: Scalars['String']['output'];
  slug: Scalars['QuerySourcesScimListOneOf_0ResultsItemsSlug']['output'];
  enabled?: Maybe<Scalars['Boolean']['output']>;
  /** Get object component so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  userMatchingMode?: Maybe<UserMatchingModeEnum>;
  /** Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update. */
  managed?: Maybe<Scalars['String']['output']>;
  userPathTemplate?: Maybe<Scalars['String']['output']>;
  /** Get Root URL */
  rootUrl: Scalars['String']['output'];
  tokenObj: Token;
};

export type SourcesScimRetrieveResponse = ScimSource | ValidationError | GenericError;

export type SourcesScimUsedByListResponse = UsedBy | ValidationError | GenericError;

export type SourcesScimGroupsListResponse = PaginatedScimSourceGroupList | ValidationError | GenericError;

export type PaginatedScimSourceGroupList = {
  pagination: Pagination;
  results: Array<Maybe<ScimSourceGroup>>;
};

/** SCIMSourceGroup Serializer */
export type ScimSourceGroup = {
  id: Scalars['String']['output'];
  group: Scalars['UUID']['output'];
  groupObj: UserGroup;
  source: Scalars['UUID']['output'];
  attributes?: Maybe<Scalars['JSON']['output']>;
};

export type SourcesScimGroupsRetrieveResponse = ScimSourceGroup | ValidationError | GenericError;

export type SourcesScimGroupsUsedByListResponse = UsedBy | ValidationError | GenericError;

export type SourcesScimUsersListResponse = PaginatedScimSourceUserList | ValidationError | GenericError;

export type PaginatedScimSourceUserList = {
  pagination: Pagination;
  results: Array<Maybe<ScimSourceUser>>;
};

/** SCIMSourceUser Serializer */
export type ScimSourceUser = {
  id: Scalars['String']['output'];
  user: Scalars['Int']['output'];
  userObj: GroupMember;
  source: Scalars['UUID']['output'];
  attributes?: Maybe<Scalars['JSON']['output']>;
};

export type SourcesScimUsersRetrieveResponse = ScimSourceUser | ValidationError | GenericError;

export type SourcesScimUsersUsedByListResponse = UsedBy | ValidationError | GenericError;

export type SourcesUserConnectionsAllListResponse = PaginatedUserSourceConnectionList | ValidationError | GenericError;

export type PaginatedUserSourceConnectionList = {
  pagination: Pagination;
  results: Array<Maybe<UserSourceConnection>>;
};

/** OAuth Source Serializer */
export type UserSourceConnection = {
  pk: Scalars['Int']['output'];
  user: Scalars['Int']['output'];
  source: Source;
  created: Scalars['DateTime']['output'];
};

export type SourcesUserConnectionsAllRetrieveResponse = UserSourceConnection | ValidationError | GenericError;

export type SourcesUserConnectionsAllUsedByListResponse = UsedBy | ValidationError | GenericError;

export type SourcesUserConnectionsOauthListResponse = PaginatedUserOAuthSourceConnectionList | ValidationError | GenericError;

export type PaginatedUserOAuthSourceConnectionList = {
  pagination: Pagination;
  results: Array<Maybe<UserOAuthSourceConnection>>;
};

/** OAuth Source Serializer */
export type UserOAuthSourceConnection = {
  pk: Scalars['Int']['output'];
  user: Scalars['Int']['output'];
  source: Source;
  identifier: Scalars['QuerySourcesUserConnectionsOauthListOneOf_0ResultsItemsIdentifier']['output'];
};

export type SourcesUserConnectionsOauthRetrieveResponse = UserOAuthSourceConnection | ValidationError | GenericError;

export type SourcesUserConnectionsOauthUsedByListResponse = UsedBy | ValidationError | GenericError;

export type SourcesUserConnectionsPlexListResponse = PaginatedPlexSourceConnectionList | ValidationError | GenericError;

export type PaginatedPlexSourceConnectionList = {
  pagination: Pagination;
  results: Array<Maybe<PlexSourceConnection>>;
};

/** Plex Source connection Serializer */
export type PlexSourceConnection = {
  pk: Scalars['Int']['output'];
  user: Scalars['Int']['output'];
  source: Source;
  identifier: Scalars['String']['output'];
  plexToken: Scalars['String']['output'];
};

export type SourcesUserConnectionsPlexRetrieveResponse = PlexSourceConnection | ValidationError | GenericError;

export type SourcesUserConnectionsPlexUsedByListResponse = UsedBy | ValidationError | GenericError;

export type SourcesUserConnectionsSamlListResponse = PaginatedUserSamlSourceConnectionList | ValidationError | GenericError;

export type PaginatedUserSamlSourceConnectionList = {
  pagination: Pagination;
  results: Array<Maybe<UserSamlSourceConnection>>;
};

/** SAML Source Serializer */
export type UserSamlSourceConnection = {
  pk: Scalars['Int']['output'];
  user: Scalars['Int']['output'];
  source: Source;
  identifier: Scalars['String']['output'];
};

export type SourcesUserConnectionsSamlRetrieveResponse = UserSamlSourceConnection | ValidationError | GenericError;

export type SourcesUserConnectionsSamlUsedByListResponse = UsedBy | ValidationError | GenericError;

export type StagesAllListResponse = PaginatedStageList | ValidationError | GenericError;

export type PaginatedStageList = {
  pagination: Pagination;
  results: Array<Maybe<Stage>>;
};

export type StagesAllRetrieveResponse = Stage | ValidationError | GenericError;

export type StagesAllUsedByListResponse = UsedBy | ValidationError | GenericError;

export type StagesAllTypesListResponse = TypeCreate | ValidationError | GenericError;

export type StagesAllUserSettingsListResponse = UserSetting | ValidationError | GenericError;

export type StagesAuthenticatorDuoListResponse = PaginatedAuthenticatorDuoStageList | ValidationError | GenericError;

export type PaginatedAuthenticatorDuoStageList = {
  pagination: Pagination;
  results: Array<Maybe<AuthenticatorDuoStage>>;
};

/** AuthenticatorDuoStage Serializer */
export type AuthenticatorDuoStage = {
  pk: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  /** Get object type so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  flowSet?: Maybe<Array<Maybe<FlowSet>>>;
  /** Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage. */
  configureFlow?: Maybe<Scalars['UUID']['output']>;
  friendlyName?: Maybe<Scalars['String']['output']>;
  clientId: Scalars['String']['output'];
  apiHostname: Scalars['String']['output'];
  adminIntegrationKey?: Maybe<Scalars['String']['output']>;
};

export type StagesAuthenticatorDuoRetrieveResponse = AuthenticatorDuoStage | ValidationError | GenericError;

export type StagesAuthenticatorDuoUsedByListResponse = UsedBy | ValidationError | GenericError;

export type StagesAuthenticatorSmsListResponse = PaginatedAuthenticatorSmsStageList | ValidationError | GenericError;

export type PaginatedAuthenticatorSmsStageList = {
  pagination: Pagination;
  results: Array<Maybe<AuthenticatorSmsStage>>;
};

/** AuthenticatorSMSStage Serializer */
export type AuthenticatorSmsStage = {
  pk: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  /** Get object type so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  flowSet?: Maybe<Array<Maybe<FlowSet>>>;
  /** Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage. */
  configureFlow?: Maybe<Scalars['UUID']['output']>;
  friendlyName?: Maybe<Scalars['String']['output']>;
  provider: ProviderEnum;
  fromNumber: Scalars['String']['output'];
  accountSid: Scalars['String']['output'];
  auth: Scalars['String']['output'];
  authPassword?: Maybe<Scalars['String']['output']>;
  authType?: Maybe<AuthTypeEnum>;
  /** When enabled, the Phone number is only used during enrollment to verify the users authenticity. Only a hash of the phone number is saved to ensure it is not reused in the future. */
  verifyOnly?: Maybe<Scalars['Boolean']['output']>;
  /** Optionally modify the payload being sent to custom providers. */
  mapping?: Maybe<Scalars['UUID']['output']>;
};

export type ProviderEnum =
  | 'TWILIO'
  | 'GENERIC';

export type AuthTypeEnum =
  | 'BASIC'
  | 'BEARER';

export type QueryInputStagesAuthenticatorSmsListAuthType =
  | 'BASIC'
  | 'BEARER';

export type QueryInputStagesAuthenticatorSmsListProvider =
  | 'GENERIC'
  | 'TWILIO';

export type StagesAuthenticatorSmsRetrieveResponse = AuthenticatorSmsStage | ValidationError | GenericError;

export type StagesAuthenticatorSmsUsedByListResponse = UsedBy | ValidationError | GenericError;

export type StagesAuthenticatorStaticListResponse = PaginatedAuthenticatorStaticStageList | ValidationError | GenericError;

export type PaginatedAuthenticatorStaticStageList = {
  pagination: Pagination;
  results: Array<Maybe<AuthenticatorStaticStage>>;
};

/** AuthenticatorStaticStage Serializer */
export type AuthenticatorStaticStage = {
  pk: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  /** Get object type so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  flowSet?: Maybe<Array<Maybe<FlowSet>>>;
  /** Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage. */
  configureFlow?: Maybe<Scalars['UUID']['output']>;
  friendlyName?: Maybe<Scalars['String']['output']>;
  tokenCount?: Maybe<Scalars['NonNegativeInt']['output']>;
  tokenLength?: Maybe<Scalars['NonNegativeInt']['output']>;
};

export type StagesAuthenticatorStaticRetrieveResponse = AuthenticatorStaticStage | ValidationError | GenericError;

export type StagesAuthenticatorStaticUsedByListResponse = UsedBy | ValidationError | GenericError;

export type StagesAuthenticatorTotpListResponse = PaginatedAuthenticatorTotpStageList | ValidationError | GenericError;

export type PaginatedAuthenticatorTotpStageList = {
  pagination: Pagination;
  results: Array<Maybe<AuthenticatorTotpStage>>;
};

/** AuthenticatorTOTPStage Serializer */
export type AuthenticatorTotpStage = {
  pk: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  /** Get object type so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  flowSet?: Maybe<Array<Maybe<FlowSet>>>;
  /** Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage. */
  configureFlow?: Maybe<Scalars['UUID']['output']>;
  friendlyName?: Maybe<Scalars['String']['output']>;
  digits: DigitsEnum;
};

export type DigitsEnum =
  | '_6'
  | '_8';

export type QueryInputStagesAuthenticatorTotpListDigits =
  | '_6'
  | '_8';

export type StagesAuthenticatorTotpRetrieveResponse = AuthenticatorTotpStage | ValidationError | GenericError;

export type StagesAuthenticatorTotpUsedByListResponse = UsedBy | ValidationError | GenericError;

export type StagesAuthenticatorValidateListResponse = PaginatedAuthenticatorValidateStageList | ValidationError | GenericError;

export type PaginatedAuthenticatorValidateStageList = {
  pagination: Pagination;
  results: Array<Maybe<AuthenticatorValidateStage>>;
};

/** AuthenticatorValidateStage Serializer */
export type AuthenticatorValidateStage = {
  pk: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  /** Get object type so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  flowSet?: Maybe<Array<Maybe<FlowSet>>>;
  notConfiguredAction?: Maybe<NotConfiguredActionEnum>;
  /** Device classes which can be used to authenticate */
  deviceClasses?: Maybe<Array<Maybe<DeviceClassesEnum>>>;
  /** Stages used to configure Authenticator when user doesn't have any compatible devices. After this configuration Stage passes, the user is not prompted again. */
  configurationStages?: Maybe<Array<Maybe<Scalars['UUID']['output']>>>;
  /** If any of the user's device has been used within this threshold, this stage will be skipped */
  lastAuthThreshold?: Maybe<Scalars['String']['output']>;
  webauthnUserVerification?: Maybe<UserVerificationEnum>;
  webauthnAllowedDeviceTypes?: Maybe<Array<Maybe<Scalars['UUID']['output']>>>;
  webauthnAllowedDeviceTypesObj: Array<Maybe<WebAuthnDeviceType>>;
};

export type NotConfiguredActionEnum =
  | 'SKIP'
  | 'DENY'
  | 'CONFIGURE';

export type DeviceClassesEnum =
  | 'STATIC'
  | 'TOTP'
  | 'WEBAUTHN'
  | 'DUO'
  | 'SMS';

export type UserVerificationEnum =
  | 'REQUIRED'
  | 'PREFERRED'
  | 'DISCOURAGED';

export type QueryInputStagesAuthenticatorValidateListNotConfiguredAction =
  | 'CONFIGURE'
  | 'DENY'
  | 'SKIP';

export type StagesAuthenticatorValidateRetrieveResponse = AuthenticatorValidateStage | ValidationError | GenericError;

export type StagesAuthenticatorValidateUsedByListResponse = UsedBy | ValidationError | GenericError;

export type StagesAuthenticatorWebauthnListResponse = PaginatedAuthenticatorWebAuthnStageList | ValidationError | GenericError;

export type PaginatedAuthenticatorWebAuthnStageList = {
  pagination: Pagination;
  results: Array<Maybe<AuthenticatorWebAuthnStage>>;
};

/** AuthenticatorWebAuthnStage Serializer */
export type AuthenticatorWebAuthnStage = {
  pk: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  /** Get object type so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  flowSet?: Maybe<Array<Maybe<FlowSet>>>;
  /** Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage. */
  configureFlow?: Maybe<Scalars['UUID']['output']>;
  friendlyName?: Maybe<Scalars['String']['output']>;
  userVerification?: Maybe<UserVerificationEnum>;
  authenticatorAttachment?: Maybe<AuthenticatorAttachmentEnum>;
  residentKeyRequirement?: Maybe<ResidentKeyRequirementEnum>;
  deviceTypeRestrictions?: Maybe<Array<Maybe<Scalars['UUID']['output']>>>;
  deviceTypeRestrictionsObj: Array<Maybe<WebAuthnDeviceType>>;
};

export type AuthenticatorAttachmentEnum =
  | 'PLATFORM'
  | 'CROSS_PLATFORM';

export type ResidentKeyRequirementEnum =
  | 'DISCOURAGED'
  | 'PREFERRED'
  | 'REQUIRED';

export type QueryInputStagesAuthenticatorWebauthnListAuthenticatorAttachment =
  | 'CROSS_PLATFORM'
  | 'PLATFORM';

export type QueryInputStagesAuthenticatorWebauthnListResidentKeyRequirement =
  | 'DISCOURAGED'
  | 'PREFERRED'
  | 'REQUIRED';

export type QueryInputStagesAuthenticatorWebauthnListUserVerification =
  | 'DISCOURAGED'
  | 'PREFERRED'
  | 'REQUIRED';

export type StagesAuthenticatorWebauthnRetrieveResponse = AuthenticatorWebAuthnStage | ValidationError | GenericError;

export type StagesAuthenticatorWebauthnUsedByListResponse = UsedBy | ValidationError | GenericError;

export type StagesAuthenticatorWebauthnDeviceTypesListResponse = PaginatedWebAuthnDeviceTypeList | ValidationError | GenericError;

export type PaginatedWebAuthnDeviceTypeList = {
  pagination: Pagination;
  results: Array<Maybe<WebAuthnDeviceType>>;
};

export type StagesAuthenticatorWebauthnDeviceTypesRetrieveResponse = WebAuthnDeviceType | ValidationError | GenericError;

export type StagesCaptchaListResponse = PaginatedCaptchaStageList | ValidationError | GenericError;

export type PaginatedCaptchaStageList = {
  pagination: Pagination;
  results: Array<Maybe<CaptchaStage>>;
};

/** CaptchaStage Serializer */
export type CaptchaStage = {
  pk: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  /** Get object type so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  flowSet?: Maybe<Array<Maybe<FlowSet>>>;
  /** Public key, acquired your captcha Provider. */
  publicKey: Scalars['String']['output'];
  jsUrl?: Maybe<Scalars['String']['output']>;
  apiUrl?: Maybe<Scalars['String']['output']>;
};

export type StagesCaptchaRetrieveResponse = CaptchaStage | ValidationError | GenericError;

export type StagesCaptchaUsedByListResponse = UsedBy | ValidationError | GenericError;

export type StagesConsentListResponse = PaginatedConsentStageList | ValidationError | GenericError;

export type PaginatedConsentStageList = {
  pagination: Pagination;
  results: Array<Maybe<ConsentStage>>;
};

/** ConsentStage Serializer */
export type ConsentStage = {
  pk: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  /** Get object type so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  flowSet?: Maybe<Array<Maybe<FlowSet>>>;
  mode?: Maybe<ConsentStageModeEnum>;
  /** Offset after which consent expires. (Format: hours=1;minutes=2;seconds=3). */
  consentExpireIn?: Maybe<Scalars['String']['output']>;
};

export type ConsentStageModeEnum =
  | 'ALWAYS_REQUIRE'
  | 'PERMANENT'
  | 'EXPIRING';

export type QueryInputStagesConsentListMode =
  | 'ALWAYS_REQUIRE'
  | 'EXPIRING'
  | 'PERMANENT';

export type StagesConsentRetrieveResponse = ConsentStage | ValidationError | GenericError;

export type StagesConsentUsedByListResponse = UsedBy | ValidationError | GenericError;

export type StagesDenyListResponse = PaginatedDenyStageList | ValidationError | GenericError;

export type PaginatedDenyStageList = {
  pagination: Pagination;
  results: Array<Maybe<DenyStage>>;
};

/** DenyStage Serializer */
export type DenyStage = {
  pk: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  /** Get object type so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  flowSet?: Maybe<Array<Maybe<FlowSet>>>;
  denyMessage?: Maybe<Scalars['String']['output']>;
};

export type StagesDenyRetrieveResponse = DenyStage | ValidationError | GenericError;

export type StagesDenyUsedByListResponse = UsedBy | ValidationError | GenericError;

export type StagesDummyListResponse = PaginatedDummyStageList | ValidationError | GenericError;

export type PaginatedDummyStageList = {
  pagination: Pagination;
  results: Array<Maybe<DummyStage>>;
};

/** DummyStage Serializer */
export type DummyStage = {
  pk: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  /** Get object type so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  flowSet?: Maybe<Array<Maybe<FlowSet>>>;
  throwError?: Maybe<Scalars['Boolean']['output']>;
};

export type StagesDummyRetrieveResponse = DummyStage | ValidationError | GenericError;

export type StagesDummyUsedByListResponse = UsedBy | ValidationError | GenericError;

export type StagesEmailListResponse = PaginatedEmailStageList | ValidationError | GenericError;

export type PaginatedEmailStageList = {
  pagination: Pagination;
  results: Array<Maybe<EmailStage>>;
};

/** EmailStage Serializer */
export type EmailStage = {
  pk: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  /** Get object type so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  flowSet?: Maybe<Array<Maybe<FlowSet>>>;
  /** When enabled, global Email connection settings will be used and connection settings below will be ignored. */
  useGlobalSettings?: Maybe<Scalars['Boolean']['output']>;
  host?: Maybe<Scalars['String']['output']>;
  port?: Maybe<Scalars['Int']['output']>;
  username?: Maybe<Scalars['String']['output']>;
  useTls?: Maybe<Scalars['Boolean']['output']>;
  useSsl?: Maybe<Scalars['Boolean']['output']>;
  timeout?: Maybe<Scalars['Int']['output']>;
  fromAddress?: Maybe<Scalars['EmailAddress']['output']>;
  /** Time in minutes the token sent is valid. */
  tokenExpiry?: Maybe<Scalars['Int']['output']>;
  subject?: Maybe<Scalars['String']['output']>;
  template?: Maybe<Scalars['String']['output']>;
  /** Activate users upon completion of stage. */
  activateUserOnSuccess?: Maybe<Scalars['Boolean']['output']>;
};

export type StagesEmailRetrieveResponse = EmailStage | ValidationError | GenericError;

export type StagesEmailUsedByListResponse = UsedBy | ValidationError | GenericError;

export type StagesEmailTemplatesListResponse = TypeCreate | ValidationError | GenericError;

export type StagesIdentificationListResponse = PaginatedIdentificationStageList | ValidationError | GenericError;

export type PaginatedIdentificationStageList = {
  pagination: Pagination;
  results: Array<Maybe<IdentificationStage>>;
};

/** IdentificationStage Serializer */
export type IdentificationStage = {
  pk: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  /** Get object type so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  flowSet?: Maybe<Array<Maybe<FlowSet>>>;
  /** Fields of the user object to match against. (Hold shift to select multiple options) */
  userFields?: Maybe<Array<Maybe<UserFieldsEnum>>>;
  /** When set, shows a password field, instead of showing the password field as seaprate step. */
  passwordStage?: Maybe<Scalars['UUID']['output']>;
  /** When enabled, user fields are matched regardless of their casing. */
  caseInsensitiveMatching?: Maybe<Scalars['Boolean']['output']>;
  /** When a valid username/email has been entered, and this option is enabled, the user's username and avatar will be shown. Otherwise, the text that the user entered will be shown */
  showMatchedUser?: Maybe<Scalars['Boolean']['output']>;
  /** Optional enrollment flow, which is linked at the bottom of the page. */
  enrollmentFlow?: Maybe<Scalars['UUID']['output']>;
  /** Optional recovery flow, which is linked at the bottom of the page. */
  recoveryFlow?: Maybe<Scalars['UUID']['output']>;
  /** Optional passwordless flow, which is linked at the bottom of the page. */
  passwordlessFlow?: Maybe<Scalars['UUID']['output']>;
  /** Specify which sources should be shown. */
  sources?: Maybe<Array<Maybe<Scalars['UUID']['output']>>>;
  showSourceLabels?: Maybe<Scalars['Boolean']['output']>;
  /** When enabled, the stage will succeed and continue even when incorrect user info is entered. */
  pretendUserExists?: Maybe<Scalars['Boolean']['output']>;
};

export type UserFieldsEnum =
  | 'EMAIL'
  | 'USERNAME'
  | 'UPN';

export type StagesIdentificationRetrieveResponse = IdentificationStage | ValidationError | GenericError;

export type StagesIdentificationUsedByListResponse = UsedBy | ValidationError | GenericError;

export type StagesInvitationInvitationsListResponse = PaginatedInvitationList | ValidationError | GenericError;

export type PaginatedInvitationList = {
  pagination: Pagination;
  results: Array<Maybe<Invitation>>;
};

/** Invitation Serializer */
export type Invitation = {
  pk: Scalars['UUID']['output'];
  name: Scalars['QueryStagesInvitationInvitationsListOneOf_0ResultsItemsName']['output'];
  expires?: Maybe<Scalars['DateTime']['output']>;
  fixedData?: Maybe<Scalars['JSON']['output']>;
  createdBy: GroupMember;
  /** When enabled, the invitation will be deleted after usage. */
  singleUse?: Maybe<Scalars['Boolean']['output']>;
  /** When set, only the configured flow can use this invitation. */
  flow?: Maybe<Scalars['UUID']['output']>;
  flowObj: Flow;
};

export type StagesInvitationInvitationsRetrieveResponse = Invitation | ValidationError | GenericError;

export type StagesInvitationInvitationsUsedByListResponse = UsedBy | ValidationError | GenericError;

export type StagesInvitationStagesListResponse = PaginatedInvitationStageList | ValidationError | GenericError;

export type PaginatedInvitationStageList = {
  pagination: Pagination;
  results: Array<Maybe<InvitationStage>>;
};

/** InvitationStage Serializer */
export type InvitationStage = {
  pk: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  /** Get object type so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  flowSet?: Maybe<Array<Maybe<FlowSet>>>;
  /** If this flag is set, this Stage will jump to the next Stage when no Invitation is given. By default this Stage will cancel the Flow when no invitation is given. */
  continueFlowWithoutInvitation?: Maybe<Scalars['Boolean']['output']>;
};

export type StagesInvitationStagesRetrieveResponse = InvitationStage | ValidationError | GenericError;

export type StagesInvitationStagesUsedByListResponse = UsedBy | ValidationError | GenericError;

export type StagesPasswordListResponse = PaginatedPasswordStageList | ValidationError | GenericError;

export type PaginatedPasswordStageList = {
  pagination: Pagination;
  results: Array<Maybe<PasswordStage>>;
};

/** PasswordStage Serializer */
export type PasswordStage = {
  pk: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  /** Get object type so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  flowSet?: Maybe<Array<Maybe<FlowSet>>>;
  /** Selection of backends to test the password against. */
  backends: Array<Maybe<BackendsEnum>>;
  /** Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage. */
  configureFlow?: Maybe<Scalars['UUID']['output']>;
  /** How many attempts a user has before the flow is canceled. To lock the user out, use a reputation policy and a user_write stage. */
  failedAttemptsBeforeCancel?: Maybe<Scalars['Int']['output']>;
};

export type BackendsEnum =
  | 'AUTHENTIK_CORE_AUTH_INBUILTBACKEND'
  | 'AUTHENTIK_CORE_AUTH_TOKENBACKEND'
  | 'AUTHENTIK_SOURCES_LDAP_AUTH_LDAPBACKEND';

export type StagesPasswordRetrieveResponse = PasswordStage | ValidationError | GenericError;

export type StagesPasswordUsedByListResponse = UsedBy | ValidationError | GenericError;

export type StagesPromptPromptsListResponse = PaginatedPromptList | ValidationError | GenericError;

export type PaginatedPromptList = {
  pagination: Pagination;
  results: Array<Maybe<Prompt>>;
};

/** Prompt Serializer */
export type Prompt = {
  pk: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  /** Name of the form field, also used to store the value */
  fieldKey: Scalars['String']['output'];
  label: Scalars['String']['output'];
  type: PromptTypeEnum;
  required?: Maybe<Scalars['Boolean']['output']>;
  /** Optionally provide a short hint that describes the expected input value. When creating a fixed choice field, enable interpreting as expression and return a list to return multiple choices. */
  placeholder?: Maybe<Scalars['String']['output']>;
  /** Optionally pre-fill the input with an initial value. When creating a fixed choice field, enable interpreting as expression and return a list to return multiple default choices. */
  initialValue?: Maybe<Scalars['String']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
  promptstageSet?: Maybe<Array<Maybe<Stage>>>;
  subText?: Maybe<Scalars['String']['output']>;
  placeholderExpression?: Maybe<Scalars['Boolean']['output']>;
  initialValueExpression?: Maybe<Scalars['Boolean']['output']>;
};

export type QueryInputStagesPromptPromptsListType =
  | 'AK_LOCALE'
  | 'CHECKBOX'
  | 'DATE'
  | 'DATE_TIME'
  | 'DROPDOWN'
  | 'EMAIL'
  | 'FILE'
  | 'HIDDEN'
  | 'NUMBER'
  | 'PASSWORD'
  | 'RADIO_BUTTON_GROUP'
  | 'SEPARATOR'
  | 'STATIC'
  | 'TEXT'
  | 'TEXT_AREA'
  | 'TEXT_AREA_READ_ONLY'
  | 'TEXT_READ_ONLY'
  | 'USERNAME';

export type StagesPromptPromptsRetrieveResponse = Prompt | ValidationError | GenericError;

export type StagesPromptPromptsUsedByListResponse = UsedBy | ValidationError | GenericError;

export type StagesPromptStagesListResponse = PaginatedPromptStageList | ValidationError | GenericError;

export type PaginatedPromptStageList = {
  pagination: Pagination;
  results: Array<Maybe<PromptStage>>;
};

/** PromptStage Serializer */
export type PromptStage = {
  pk: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  /** Get object type so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  flowSet?: Maybe<Array<Maybe<FlowSet>>>;
  fields: Array<Maybe<Scalars['UUID']['output']>>;
  validationPolicies?: Maybe<Array<Maybe<Scalars['UUID']['output']>>>;
};

export type StagesPromptStagesRetrieveResponse = PromptStage | ValidationError | GenericError;

export type StagesPromptStagesUsedByListResponse = UsedBy | ValidationError | GenericError;

export type StagesSourceListResponse = PaginatedSourceStageList | ValidationError | GenericError;

export type PaginatedSourceStageList = {
  pagination: Pagination;
  results: Array<Maybe<SourceStage>>;
};

/** SourceStage Serializer */
export type SourceStage = {
  pk: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  /** Get object type so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  flowSet?: Maybe<Array<Maybe<FlowSet>>>;
  source: Scalars['UUID']['output'];
  /** Amount of time a user can take to return from the source to continue the flow (Format: hours=-1;minutes=-2;seconds=-3) */
  resumeTimeout?: Maybe<Scalars['String']['output']>;
};

export type StagesSourceRetrieveResponse = SourceStage | ValidationError | GenericError;

export type StagesSourceUsedByListResponse = UsedBy | ValidationError | GenericError;

export type StagesUserDeleteListResponse = PaginatedUserDeleteStageList | ValidationError | GenericError;

export type PaginatedUserDeleteStageList = {
  pagination: Pagination;
  results: Array<Maybe<UserDeleteStage>>;
};

/** UserDeleteStage Serializer */
export type UserDeleteStage = {
  pk: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  /** Get object type so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  flowSet?: Maybe<Array<Maybe<FlowSet>>>;
};

export type StagesUserDeleteRetrieveResponse = UserDeleteStage | ValidationError | GenericError;

export type StagesUserDeleteUsedByListResponse = UsedBy | ValidationError | GenericError;

export type StagesUserLoginListResponse = PaginatedUserLoginStageList | ValidationError | GenericError;

export type PaginatedUserLoginStageList = {
  pagination: Pagination;
  results: Array<Maybe<UserLoginStage>>;
};

/** UserLoginStage Serializer */
export type UserLoginStage = {
  pk: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  /** Get object type so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  flowSet?: Maybe<Array<Maybe<FlowSet>>>;
  /** Determines how long a session lasts. Default of 0 means that the sessions lasts until the browser is closed. (Format: hours=-1;minutes=-2;seconds=-3) */
  sessionDuration?: Maybe<Scalars['String']['output']>;
  /** Terminate all other sessions of the user logging in. */
  terminateOtherSessions?: Maybe<Scalars['Boolean']['output']>;
  /** Offset the session will be extended by when the user picks the remember me option. Default of 0 means that the remember me option will not be shown. (Format: hours=-1;minutes=-2;seconds=-3) */
  rememberMeOffset?: Maybe<Scalars['String']['output']>;
  networkBinding?: Maybe<NetworkBindingEnum>;
  geoipBinding?: Maybe<GeoipBindingEnum>;
};

export type NetworkBindingEnum =
  | 'NO_BINDING'
  | 'BIND_ASN'
  | 'BIND_ASN_NETWORK'
  | 'BIND_ASN_NETWORK_IP';

export type GeoipBindingEnum =
  | 'NO_BINDING'
  | 'BIND_CONTINENT'
  | 'BIND_CONTINENT_COUNTRY'
  | 'BIND_CONTINENT_COUNTRY_CITY';

/** Bind sessions created by this stage to the configured GeoIP location */
export type QueryInputStagesUserLoginListGeoipBinding =
  | 'BIND_CONTINENT'
  | 'BIND_CONTINENT_COUNTRY'
  | 'BIND_CONTINENT_COUNTRY_CITY'
  | 'NO_BINDING';

/** Bind sessions created by this stage to the configured network */
export type QueryInputStagesUserLoginListNetworkBinding =
  | 'BIND_ASN'
  | 'BIND_ASN_NETWORK'
  | 'BIND_ASN_NETWORK_IP'
  | 'NO_BINDING';

export type StagesUserLoginRetrieveResponse = UserLoginStage | ValidationError | GenericError;

export type StagesUserLoginUsedByListResponse = UsedBy | ValidationError | GenericError;

export type StagesUserLogoutListResponse = PaginatedUserLogoutStageList | ValidationError | GenericError;

export type PaginatedUserLogoutStageList = {
  pagination: Pagination;
  results: Array<Maybe<UserLogoutStage>>;
};

/** UserLogoutStage Serializer */
export type UserLogoutStage = {
  pk: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  /** Get object type so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  flowSet?: Maybe<Array<Maybe<FlowSet>>>;
};

export type StagesUserLogoutRetrieveResponse = UserLogoutStage | ValidationError | GenericError;

export type StagesUserLogoutUsedByListResponse = UsedBy | ValidationError | GenericError;

export type StagesUserWriteListResponse = PaginatedUserWriteStageList | ValidationError | GenericError;

export type PaginatedUserWriteStageList = {
  pagination: Pagination;
  results: Array<Maybe<UserWriteStage>>;
};

/** UserWriteStage Serializer */
export type UserWriteStage = {
  pk: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  /** Get object type so that we know how to edit the object */
  component: Scalars['String']['output'];
  /** Return object's verbose_name */
  verboseName: Scalars['String']['output'];
  /** Return object's plural verbose_name */
  verboseNamePlural: Scalars['String']['output'];
  /** Return internal model name */
  metaModelName: Scalars['String']['output'];
  flowSet?: Maybe<Array<Maybe<FlowSet>>>;
  userCreationMode?: Maybe<UserCreationModeEnum>;
  /** When set, newly created users are inactive and cannot login. */
  createUsersAsInactive?: Maybe<Scalars['Boolean']['output']>;
  /** Optionally add newly created users to this group. */
  createUsersGroup?: Maybe<Scalars['UUID']['output']>;
  userType?: Maybe<UserTypeEnum>;
  userPathTemplate?: Maybe<Scalars['String']['output']>;
};

export type UserCreationModeEnum =
  | 'NEVER_CREATE'
  | 'CREATE_WHEN_REQUIRED'
  | 'ALWAYS_CREATE';

export type QueryInputStagesUserWriteListUserCreationMode =
  | 'ALWAYS_CREATE'
  | 'CREATE_WHEN_REQUIRED'
  | 'NEVER_CREATE';

export type QueryInputStagesUserWriteListUserType =
  | 'EXTERNAL'
  | 'INTERNAL'
  | 'INTERNAL_SERVICE_ACCOUNT'
  | 'SERVICE_ACCOUNT';

export type StagesUserWriteRetrieveResponse = UserWriteStage | ValidationError | GenericError;

export type StagesUserWriteUsedByListResponse = UsedBy | ValidationError | GenericError;

export type AdminSettingsUpdateResponse = Settings | ValidationError | GenericError;

/** Settings Serializer */
export type SettingsRequestInput = {
  /** Configure how authentik should show avatars for users. */
  avatars?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Enable the ability for users to change their name. */
  defaultUserChangeName?: InputMaybe<Scalars['Boolean']['input']>;
  /** Enable the ability for users to change their email address. */
  defaultUserChangeEmail?: InputMaybe<Scalars['Boolean']['input']>;
  /** Enable the ability for users to change their username. */
  defaultUserChangeUsername?: InputMaybe<Scalars['Boolean']['input']>;
  /** Events will be deleted after this duration.(Format: weeks=3;days=2;hours=3,seconds=2). */
  eventRetention?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** The option configures the footer links on the flow executor pages. */
  footerLinks?: InputMaybe<Scalars['JSON']['input']>;
  /** When enabled, all the events caused by a user will be deleted upon the user's deletion. */
  gdprCompliance?: InputMaybe<Scalars['Boolean']['input']>;
  /** Globally enable/disable impersonation. */
  impersonation?: InputMaybe<Scalars['Boolean']['input']>;
  /** Default token duration */
  defaultTokenDuration?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Default token length */
  defaultTokenLength?: InputMaybe<Scalars['PositiveInt']['input']>;
};

export type AdminSettingsPartialUpdateResponse = Settings | ValidationError | GenericError;

/** Settings Serializer */
export type PatchedSettingsRequestInput = {
  /** Configure how authentik should show avatars for users. */
  avatars?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Enable the ability for users to change their name. */
  defaultUserChangeName?: InputMaybe<Scalars['Boolean']['input']>;
  /** Enable the ability for users to change their email address. */
  defaultUserChangeEmail?: InputMaybe<Scalars['Boolean']['input']>;
  /** Enable the ability for users to change their username. */
  defaultUserChangeUsername?: InputMaybe<Scalars['Boolean']['input']>;
  /** Events will be deleted after this duration.(Format: weeks=3;days=2;hours=3,seconds=2). */
  eventRetention?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** The option configures the footer links on the flow executor pages. */
  footerLinks?: InputMaybe<Scalars['JSON']['input']>;
  /** When enabled, all the events caused by a user will be deleted upon the user's deletion. */
  gdprCompliance?: InputMaybe<Scalars['Boolean']['input']>;
  /** Globally enable/disable impersonation. */
  impersonation?: InputMaybe<Scalars['Boolean']['input']>;
  /** Default token duration */
  defaultTokenDuration?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Default token length */
  defaultTokenLength?: InputMaybe<Scalars['PositiveInt']['input']>;
};

export type AdminSystemCreateResponse = SystemInfo | ValidationError | GenericError;

export type AuthenticatorsAdminDuoCreateResponse = DuoDevice | ValidationError | GenericError;

/** Serializer for Duo authenticator devices */
export type DuoDeviceRequestInput = {
  /** The human-readable name of this device. */
  name: Scalars['MutationInputAuthenticatorsAdminDuoCreateInputName']['input'];
};

export type AuthenticatorsAdminDuoUpdateResponse = DuoDevice | ValidationError | GenericError;

export type AuthenticatorsAdminDuoPartialUpdateResponse = DuoDevice | ValidationError | GenericError;

/** Serializer for Duo authenticator devices */
export type PatchedDuoDeviceRequestInput = {
  /** The human-readable name of this device. */
  name?: InputMaybe<Scalars['MutationInputAuthenticatorsAdminDuoPartialUpdateInputName']['input']>;
};

export type AuthenticatorsAdminDuoDestroyResponse = VoidContainer | ValidationError | GenericError;

export type AuthenticatorsAdminSmsCreateResponse = SmsDevice | ValidationError | GenericError;

/** Serializer for sms authenticator devices */
export type SmsDeviceRequestInput = {
  /** The human-readable name of this device. */
  name: Scalars['MutationInputAuthenticatorsAdminSmsCreateInputName']['input'];
};

export type AuthenticatorsAdminSmsUpdateResponse = SmsDevice | ValidationError | GenericError;

export type AuthenticatorsAdminSmsPartialUpdateResponse = SmsDevice | ValidationError | GenericError;

/** Serializer for sms authenticator devices */
export type PatchedSmsDeviceRequestInput = {
  /** The human-readable name of this device. */
  name?: InputMaybe<Scalars['MutationInputAuthenticatorsAdminSmsPartialUpdateInputName']['input']>;
};

export type AuthenticatorsAdminSmsDestroyResponse = VoidContainer | ValidationError | GenericError;

export type AuthenticatorsAdminStaticCreateResponse = StaticDevice | ValidationError | GenericError;

/** Serializer for static authenticator devices */
export type StaticDeviceRequestInput = {
  /** The human-readable name of this device. */
  name: Scalars['MutationInputAuthenticatorsAdminStaticCreateInputName']['input'];
};

export type AuthenticatorsAdminStaticUpdateResponse = StaticDevice | ValidationError | GenericError;

export type AuthenticatorsAdminStaticPartialUpdateResponse = StaticDevice | ValidationError | GenericError;

/** Serializer for static authenticator devices */
export type PatchedStaticDeviceRequestInput = {
  /** The human-readable name of this device. */
  name?: InputMaybe<Scalars['MutationInputAuthenticatorsAdminStaticPartialUpdateInputName']['input']>;
};

export type AuthenticatorsAdminStaticDestroyResponse = VoidContainer | ValidationError | GenericError;

export type AuthenticatorsAdminTotpCreateResponse = TotpDevice | ValidationError | GenericError;

/** Serializer for totp authenticator devices */
export type TotpDeviceRequestInput = {
  /** The human-readable name of this device. */
  name: Scalars['MutationInputAuthenticatorsAdminTotpCreateInputName']['input'];
};

export type AuthenticatorsAdminTotpUpdateResponse = TotpDevice | ValidationError | GenericError;

export type AuthenticatorsAdminTotpPartialUpdateResponse = TotpDevice | ValidationError | GenericError;

/** Serializer for totp authenticator devices */
export type PatchedTotpDeviceRequestInput = {
  /** The human-readable name of this device. */
  name?: InputMaybe<Scalars['MutationInputAuthenticatorsAdminTotpPartialUpdateInputName']['input']>;
};

export type AuthenticatorsAdminTotpDestroyResponse = VoidContainer | ValidationError | GenericError;

export type AuthenticatorsAdminWebauthnCreateResponse = WebAuthnDevice | ValidationError | GenericError;

/** Serializer for WebAuthn authenticator devices */
export type WebAuthnDeviceRequestInput = {
  name: Scalars['MutationInputAuthenticatorsAdminWebauthnCreateInputName']['input'];
};

export type AuthenticatorsAdminWebauthnUpdateResponse = WebAuthnDevice | ValidationError | GenericError;

export type AuthenticatorsAdminWebauthnPartialUpdateResponse = WebAuthnDevice | ValidationError | GenericError;

/** Serializer for WebAuthn authenticator devices */
export type PatchedWebAuthnDeviceRequestInput = {
  name?: InputMaybe<Scalars['MutationInputAuthenticatorsAdminWebauthnPartialUpdateInputName']['input']>;
};

export type AuthenticatorsAdminWebauthnDestroyResponse = VoidContainer | ValidationError | GenericError;

export type AuthenticatorsDuoUpdateResponse = DuoDevice | ValidationError | GenericError;

export type AuthenticatorsDuoPartialUpdateResponse = DuoDevice | ValidationError | GenericError;

export type AuthenticatorsDuoDestroyResponse = VoidContainer | ValidationError | GenericError;

export type AuthenticatorsSmsUpdateResponse = SmsDevice | ValidationError | GenericError;

export type AuthenticatorsSmsPartialUpdateResponse = SmsDevice | ValidationError | GenericError;

export type AuthenticatorsSmsDestroyResponse = VoidContainer | ValidationError | GenericError;

export type AuthenticatorsStaticUpdateResponse = StaticDevice | ValidationError | GenericError;

export type AuthenticatorsStaticPartialUpdateResponse = StaticDevice | ValidationError | GenericError;

export type AuthenticatorsStaticDestroyResponse = VoidContainer | ValidationError | GenericError;

export type AuthenticatorsTotpUpdateResponse = TotpDevice | ValidationError | GenericError;

export type AuthenticatorsTotpPartialUpdateResponse = TotpDevice | ValidationError | GenericError;

export type AuthenticatorsTotpDestroyResponse = VoidContainer | ValidationError | GenericError;

export type AuthenticatorsWebauthnUpdateResponse = WebAuthnDevice | ValidationError | GenericError;

export type AuthenticatorsWebauthnPartialUpdateResponse = WebAuthnDevice | ValidationError | GenericError;

export type AuthenticatorsWebauthnDestroyResponse = VoidContainer | ValidationError | GenericError;

export type CoreApplicationsCreateResponse = Application | ValidationError | GenericError;

/** Application Serializer */
export type ApplicationRequestInput = {
  /** Application's display Name. */
  name: Scalars['NonEmptyString']['input'];
  slug: Scalars['MutationInputCoreApplicationsCreateInputSlug']['input'];
  provider?: InputMaybe<Scalars['Int']['input']>;
  backchannelProviders?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  /** Open launch URL in a new browser tab or window. */
  openInNewTab?: InputMaybe<Scalars['Boolean']['input']>;
  metaLaunchUrl?: InputMaybe<Scalars['URL']['input']>;
  metaDescription?: InputMaybe<Scalars['String']['input']>;
  metaPublisher?: InputMaybe<Scalars['String']['input']>;
  policyEngineMode?: InputMaybe<PolicyEngineMode>;
  group?: InputMaybe<Scalars['String']['input']>;
};

export type CoreApplicationsUpdateResponse = Application | ValidationError | GenericError;

export type CoreApplicationsPartialUpdateResponse = Application | ValidationError | GenericError;

/** Application Serializer */
export type PatchedApplicationRequestInput = {
  /** Application's display Name. */
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  slug?: InputMaybe<Scalars['MutationInputCoreApplicationsPartialUpdateInputSlug']['input']>;
  provider?: InputMaybe<Scalars['Int']['input']>;
  backchannelProviders?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  /** Open launch URL in a new browser tab or window. */
  openInNewTab?: InputMaybe<Scalars['Boolean']['input']>;
  metaLaunchUrl?: InputMaybe<Scalars['URL']['input']>;
  metaDescription?: InputMaybe<Scalars['String']['input']>;
  metaPublisher?: InputMaybe<Scalars['String']['input']>;
  policyEngineMode?: InputMaybe<PolicyEngineMode>;
  group?: InputMaybe<Scalars['String']['input']>;
};

export type CoreApplicationsDestroyResponse = VoidContainer | ValidationError | GenericError;

/** Serializer to upload file */
export type FileUploadRequestInput = {
  file?: InputMaybe<Scalars['File']['input']>;
  clear?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Serializer to upload file */
export type FilePathRequestInput = {
  url: Scalars['NonEmptyString']['input'];
};

export type CoreAuthenticatedSessionsDestroyResponse = VoidContainer | ValidationError | GenericError;

export type CoreBrandsCreateResponse = Brand | ValidationError | GenericError;

/** Brand Serializer */
export type BrandRequestInput = {
  /** Domain that activates this brand. Can be a superset, i.e. `a.b` for `aa.b` and `ba.b` */
  domain: Scalars['NonEmptyString']['input'];
  default?: InputMaybe<Scalars['Boolean']['input']>;
  brandingTitle?: InputMaybe<Scalars['NonEmptyString']['input']>;
  brandingLogo?: InputMaybe<Scalars['NonEmptyString']['input']>;
  brandingFavicon?: InputMaybe<Scalars['NonEmptyString']['input']>;
  flowAuthentication?: InputMaybe<Scalars['UUID']['input']>;
  flowInvalidation?: InputMaybe<Scalars['UUID']['input']>;
  flowRecovery?: InputMaybe<Scalars['UUID']['input']>;
  flowUnenrollment?: InputMaybe<Scalars['UUID']['input']>;
  flowUserSettings?: InputMaybe<Scalars['UUID']['input']>;
  flowDeviceCode?: InputMaybe<Scalars['UUID']['input']>;
  /** Web Certificate used by the authentik Core webserver. */
  webCertificate?: InputMaybe<Scalars['UUID']['input']>;
  attributes?: InputMaybe<Scalars['JSON']['input']>;
};

export type CoreBrandsUpdateResponse = Brand | ValidationError | GenericError;

export type CoreBrandsPartialUpdateResponse = Brand | ValidationError | GenericError;

/** Brand Serializer */
export type PatchedBrandRequestInput = {
  /** Domain that activates this brand. Can be a superset, i.e. `a.b` for `aa.b` and `ba.b` */
  domain?: InputMaybe<Scalars['NonEmptyString']['input']>;
  default?: InputMaybe<Scalars['Boolean']['input']>;
  brandingTitle?: InputMaybe<Scalars['NonEmptyString']['input']>;
  brandingLogo?: InputMaybe<Scalars['NonEmptyString']['input']>;
  brandingFavicon?: InputMaybe<Scalars['NonEmptyString']['input']>;
  flowAuthentication?: InputMaybe<Scalars['UUID']['input']>;
  flowInvalidation?: InputMaybe<Scalars['UUID']['input']>;
  flowRecovery?: InputMaybe<Scalars['UUID']['input']>;
  flowUnenrollment?: InputMaybe<Scalars['UUID']['input']>;
  flowUserSettings?: InputMaybe<Scalars['UUID']['input']>;
  flowDeviceCode?: InputMaybe<Scalars['UUID']['input']>;
  /** Web Certificate used by the authentik Core webserver. */
  webCertificate?: InputMaybe<Scalars['UUID']['input']>;
  attributes?: InputMaybe<Scalars['JSON']['input']>;
};

export type CoreBrandsDestroyResponse = VoidContainer | ValidationError | GenericError;

export type CoreGroupsCreateResponse = Group | ValidationError | GenericError;

/** Group Serializer */
export type GroupRequestInput = {
  name: Scalars['MutationInputCoreGroupsCreateInputName']['input'];
  /** Users added to this group will be superusers. */
  isSuperuser?: InputMaybe<Scalars['Boolean']['input']>;
  parent?: InputMaybe<Scalars['UUID']['input']>;
  users?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  attributes?: InputMaybe<Scalars['JSON']['input']>;
  roles?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
};

export type CoreGroupsUpdateResponse = Group | ValidationError | GenericError;

export type CoreGroupsPartialUpdateResponse = Group | ValidationError | GenericError;

/** Group Serializer */
export type PatchedGroupRequestInput = {
  name?: InputMaybe<Scalars['MutationInputCoreGroupsPartialUpdateInputName']['input']>;
  /** Users added to this group will be superusers. */
  isSuperuser?: InputMaybe<Scalars['Boolean']['input']>;
  parent?: InputMaybe<Scalars['UUID']['input']>;
  users?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  attributes?: InputMaybe<Scalars['JSON']['input']>;
  roles?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
};

export type CoreGroupsDestroyResponse = VoidContainer | ValidationError | GenericError;

export type CoreGroupsAddUserCreateResponse = VoidContainer | ValidationError | GenericError;

/** Account adding/removing operations */
export type UserAccountRequestInput = {
  pk: Scalars['Int']['input'];
};

export type CoreGroupsRemoveUserCreateResponse = VoidContainer | ValidationError | GenericError;

export type CoreTokensCreateResponse = Token | ValidationError | GenericError;

/** Token Serializer */
export type TokenRequestInput = {
  /** Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update. */
  managed?: InputMaybe<Scalars['NonEmptyString']['input']>;
  identifier: Scalars['MutationInputCoreTokensCreateInputIdentifier']['input'];
  intent?: InputMaybe<IntentEnum>;
  user?: InputMaybe<Scalars['Int']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['DateTime']['input']>;
  expiring?: InputMaybe<Scalars['Boolean']['input']>;
};

export type CoreTokensUpdateResponse = Token | ValidationError | GenericError;

export type CoreTokensPartialUpdateResponse = Token | ValidationError | GenericError;

/** Token Serializer */
export type PatchedTokenRequestInput = {
  /** Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update. */
  managed?: InputMaybe<Scalars['NonEmptyString']['input']>;
  identifier?: InputMaybe<Scalars['MutationInputCoreTokensPartialUpdateInputIdentifier']['input']>;
  intent?: InputMaybe<IntentEnum>;
  user?: InputMaybe<Scalars['Int']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['DateTime']['input']>;
  expiring?: InputMaybe<Scalars['Boolean']['input']>;
};

export type CoreTokensDestroyResponse = VoidContainer | ValidationError | GenericError;

export type CoreTokensSetKeyCreateResponse = VoidContainer | GenericError;

export type TokenSetKeyRequestInput = {
  key: Scalars['NonEmptyString']['input'];
};

export type CoreTransactionalApplicationsUpdateResponse = TransactionApplicationResponse | ValidationError | GenericError;

/** Transactional creation response */
export type TransactionApplicationResponse = {
  applied: Scalars['Boolean']['output'];
  logs: Array<Maybe<Scalars['String']['output']>>;
};

/** Serializer for creating a provider and an application in one transaction */
export type TransactionApplicationRequestInput = {
  app: ApplicationRequestInput;
  providerModel: ProviderModelEnum;
  provider: ModelRequestInput;
};

export type ProviderModelEnum =
  | 'AUTHENTIK_PROVIDERS_LDAP_LDAPPROVIDER'
  | 'AUTHENTIK_PROVIDERS_OAUTH2_OAUTH2PROVIDER'
  | 'AUTHENTIK_PROVIDERS_PROXY_PROXYPROVIDER'
  | 'AUTHENTIK_PROVIDERS_RAC_RACPROVIDER'
  | 'AUTHENTIK_PROVIDERS_RADIUS_RADIUSPROVIDER'
  | 'AUTHENTIK_PROVIDERS_SAML_SAMLPROVIDER'
  | 'AUTHENTIK_PROVIDERS_SCIM_SCIMPROVIDER';

export type ModelRequestInput =
  { ldapProviderRequestInput: LdapProviderRequestInput; oAuth2ProviderRequestInput?: never; proxyProviderRequestInput?: never; racProviderRequestInput?: never; radiusProviderRequestInput?: never; samlProviderRequestInput?: never; scimProviderRequestInput?: never; }
  |  { ldapProviderRequestInput?: never; oAuth2ProviderRequestInput: OAuth2ProviderRequestInput; proxyProviderRequestInput?: never; racProviderRequestInput?: never; radiusProviderRequestInput?: never; samlProviderRequestInput?: never; scimProviderRequestInput?: never; }
  |  { ldapProviderRequestInput?: never; oAuth2ProviderRequestInput?: never; proxyProviderRequestInput: ProxyProviderRequestInput; racProviderRequestInput?: never; radiusProviderRequestInput?: never; samlProviderRequestInput?: never; scimProviderRequestInput?: never; }
  |  { ldapProviderRequestInput?: never; oAuth2ProviderRequestInput?: never; proxyProviderRequestInput?: never; racProviderRequestInput: RacProviderRequestInput; radiusProviderRequestInput?: never; samlProviderRequestInput?: never; scimProviderRequestInput?: never; }
  |  { ldapProviderRequestInput?: never; oAuth2ProviderRequestInput?: never; proxyProviderRequestInput?: never; racProviderRequestInput?: never; radiusProviderRequestInput: RadiusProviderRequestInput; samlProviderRequestInput?: never; scimProviderRequestInput?: never; }
  |  { ldapProviderRequestInput?: never; oAuth2ProviderRequestInput?: never; proxyProviderRequestInput?: never; racProviderRequestInput?: never; radiusProviderRequestInput?: never; samlProviderRequestInput: SamlProviderRequestInput; scimProviderRequestInput?: never; }
  |  { ldapProviderRequestInput?: never; oAuth2ProviderRequestInput?: never; proxyProviderRequestInput?: never; racProviderRequestInput?: never; radiusProviderRequestInput?: never; samlProviderRequestInput?: never; scimProviderRequestInput: ScimProviderRequestInput; };

/** LDAPProvider Serializer */
export type LdapProviderRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  /** Flow used for authentication when the associated application is accessed by an un-authenticated user. */
  authenticationFlow?: InputMaybe<Scalars['UUID']['input']>;
  /** Flow used when authorizing this provider. */
  authorizationFlow: Scalars['UUID']['input'];
  propertyMappings?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  /** DN under which objects are accessible. */
  baseDn?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Users in this group can do search queries. If not set, every user can execute search queries. */
  searchGroup?: InputMaybe<Scalars['UUID']['input']>;
  certificate?: InputMaybe<Scalars['UUID']['input']>;
  tlsServerName?: InputMaybe<Scalars['String']['input']>;
  /** The start for uidNumbers, this number is added to the user.pk to make sure that the numbers aren't too low for POSIX users. Default is 2000 to ensure that we don't collide with local users uidNumber */
  uidStartNumber?: InputMaybe<Scalars['Int']['input']>;
  /** The start for gidNumbers, this number is added to a number generated from the group.pk to make sure that the numbers aren't too low for POSIX groups. Default is 4000 to ensure that we don't collide with local groups or users primary groups gidNumber */
  gidStartNumber?: InputMaybe<Scalars['Int']['input']>;
  searchMode?: InputMaybe<LdapapiAccessMode>;
  bindMode?: InputMaybe<LdapapiAccessMode>;
  /** When enabled, code-based multi-factor authentication can be used by appending a semicolon and the TOTP code to the password. This should only be enabled if all users that will bind to this provider have a TOTP device configured, as otherwise a password may incorrectly be rejected if it contains a semicolon. */
  mfaSupport?: InputMaybe<Scalars['Boolean']['input']>;
};

/** OAuth2Provider Serializer */
export type OAuth2ProviderRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  /** Flow used for authentication when the associated application is accessed by an un-authenticated user. */
  authenticationFlow?: InputMaybe<Scalars['UUID']['input']>;
  /** Flow used when authorizing this provider. */
  authorizationFlow: Scalars['UUID']['input'];
  propertyMappings?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  clientType?: InputMaybe<ClientTypeEnum>;
  clientId?: InputMaybe<Scalars['MutationInputCoreTransactionalApplicationsUpdateInputProviderOneOf_1ClientId']['input']>;
  clientSecret?: InputMaybe<Scalars['MutationInputCoreTransactionalApplicationsUpdateInputProviderOneOf_1ClientSecret']['input']>;
  /** Access codes not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3). */
  accessCodeValidity?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3). */
  accessTokenValidity?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3). */
  refreshTokenValidity?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Include User claims from scopes in the id_token, for applications that don't access the userinfo endpoint. */
  includeClaimsInIdToken?: InputMaybe<Scalars['Boolean']['input']>;
  /** Key used to sign the tokens. Only required when JWT Algorithm is set to RS256. */
  signingKey?: InputMaybe<Scalars['UUID']['input']>;
  /** Enter each URI on a new line. */
  redirectUris?: InputMaybe<Scalars['String']['input']>;
  subMode?: InputMaybe<SubModeEnum>;
  issuerMode?: InputMaybe<IssuerModeEnum>;
  jwksSources?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
};

/** ProxyProvider Serializer */
export type ProxyProviderRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  /** Flow used for authentication when the associated application is accessed by an un-authenticated user. */
  authenticationFlow?: InputMaybe<Scalars['UUID']['input']>;
  /** Flow used when authorizing this provider. */
  authorizationFlow: Scalars['UUID']['input'];
  propertyMappings?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  internalHost?: InputMaybe<Scalars['URL']['input']>;
  externalHost: Scalars['URL']['input'];
  /** Validate SSL Certificates of upstream servers */
  internalHostSslValidation?: InputMaybe<Scalars['Boolean']['input']>;
  certificate?: InputMaybe<Scalars['UUID']['input']>;
  /** Regular expressions for which authentication is not required. Each new line is interpreted as a new Regular Expression. */
  skipPathRegex?: InputMaybe<Scalars['String']['input']>;
  /** Set a custom HTTP-Basic Authentication header based on values from authentik. */
  basicAuthEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** User/Group Attribute used for the password part of the HTTP-Basic Header. */
  basicAuthPasswordAttribute?: InputMaybe<Scalars['String']['input']>;
  /** User/Group Attribute used for the user part of the HTTP-Basic Header. If not set, the user's Email address is used. */
  basicAuthUserAttribute?: InputMaybe<Scalars['String']['input']>;
  mode?: InputMaybe<ProxyMode>;
  /** When enabled, this provider will intercept the authorization header and authenticate requests based on its value. */
  interceptHeaderAuth?: InputMaybe<Scalars['Boolean']['input']>;
  cookieDomain?: InputMaybe<Scalars['String']['input']>;
  jwksSources?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  /** Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3). */
  accessTokenValidity?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3). */
  refreshTokenValidity?: InputMaybe<Scalars['NonEmptyString']['input']>;
};

/** RACProvider Serializer */
export type RacProviderRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  /** Flow used for authentication when the associated application is accessed by an un-authenticated user. */
  authenticationFlow?: InputMaybe<Scalars['UUID']['input']>;
  /** Flow used when authorizing this provider. */
  authorizationFlow: Scalars['UUID']['input'];
  propertyMappings?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  settings?: InputMaybe<Scalars['JSON']['input']>;
  /** Determines how long a session lasts. Default of 0 means that the sessions lasts until the browser is closed. (Format: hours=-1;minutes=-2;seconds=-3) */
  connectionExpiry?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** When set to true, connection tokens will be deleted upon disconnect. */
  deleteTokenOnDisconnect?: InputMaybe<Scalars['Boolean']['input']>;
};

/** RadiusProvider Serializer */
export type RadiusProviderRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  /** Flow used for authentication when the associated application is accessed by an un-authenticated user. */
  authenticationFlow?: InputMaybe<Scalars['UUID']['input']>;
  /** Flow used when authorizing this provider. */
  authorizationFlow: Scalars['UUID']['input'];
  propertyMappings?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  /** List of CIDRs (comma-separated) that clients can connect from. A more specific CIDR will match before a looser one. Clients connecting from a non-specified CIDR will be dropped. */
  clientNetworks?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Shared secret between clients and server to hash packets. */
  sharedSecret?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** When enabled, code-based multi-factor authentication can be used by appending a semicolon and the TOTP code to the password. This should only be enabled if all users that will bind to this provider have a TOTP device configured, as otherwise a password may incorrectly be rejected if it contains a semicolon. */
  mfaSupport?: InputMaybe<Scalars['Boolean']['input']>;
};

/** SAMLProvider Serializer */
export type SamlProviderRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  /** Flow used for authentication when the associated application is accessed by an un-authenticated user. */
  authenticationFlow?: InputMaybe<Scalars['UUID']['input']>;
  /** Flow used when authorizing this provider. */
  authorizationFlow: Scalars['UUID']['input'];
  propertyMappings?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  acsUrl: Scalars['URL']['input'];
  /** Value of the audience restriction field of the assertion. When left empty, no audience restriction will be added. */
  audience?: InputMaybe<Scalars['String']['input']>;
  /** Also known as EntityID */
  issuer?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Assertion valid not before current time + this value (Format: hours=-1;minutes=-2;seconds=-3). */
  assertionValidNotBefore?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Assertion not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3). */
  assertionValidNotOnOrAfter?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Session not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3). */
  sessionValidNotOnOrAfter?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Configure how the NameID value will be created. When left empty, the NameIDPolicy of the incoming request will be considered */
  nameIdMapping?: InputMaybe<Scalars['UUID']['input']>;
  digestAlgorithm?: InputMaybe<DigestAlgorithmEnum>;
  signatureAlgorithm?: InputMaybe<SignatureAlgorithmEnum>;
  /** Keypair used to sign outgoing Responses going to the Service Provider. */
  signingKp?: InputMaybe<Scalars['UUID']['input']>;
  /** When selected, incoming assertion's Signatures will be validated against this certificate. To allow unsigned Requests, leave on default. */
  verificationKp?: InputMaybe<Scalars['UUID']['input']>;
  /** This determines how authentik sends the response back to the Service Provider. */
  spBinding?: InputMaybe<Scalars['JSON']['input']>;
  /** Default relay_state value for IDP-initiated logins */
  defaultRelayState?: InputMaybe<Scalars['String']['input']>;
};

/** SCIMProvider Serializer */
export type ScimProviderRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  propertyMappings?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  /** Property mappings used for group creation/updating. */
  propertyMappingsGroup?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  /** Base URL to SCIM requests, usually ends in /v2 */
  url: Scalars['NonEmptyString']['input'];
  /** Authentication token */
  token: Scalars['NonEmptyString']['input'];
  excludeUsersServiceAccount?: InputMaybe<Scalars['Boolean']['input']>;
  filterGroup?: InputMaybe<Scalars['UUID']['input']>;
};

export type CoreUserConsentDestroyResponse = VoidContainer | ValidationError | GenericError;

export type CoreUsersCreateResponse = User | ValidationError | GenericError;

/** User Serializer */
export type UserRequestInput = {
  username: Scalars['MutationInputCoreUsersCreateInputUsername']['input'];
  /** User's display name. */
  name: Scalars['String']['input'];
  /** Designates whether this user should be treated as active. Unselect this instead of deleting accounts. */
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  lastLogin?: InputMaybe<Scalars['DateTime']['input']>;
  groups?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  email?: InputMaybe<Scalars['EmailAddress']['input']>;
  attributes?: InputMaybe<Scalars['JSON']['input']>;
  path?: InputMaybe<Scalars['NonEmptyString']['input']>;
  type?: InputMaybe<UserTypeEnum>;
};

export type CoreUsersUpdateResponse = User | ValidationError | GenericError;

export type CoreUsersPartialUpdateResponse = User | ValidationError | GenericError;

/** User Serializer */
export type PatchedUserRequestInput = {
  username?: InputMaybe<Scalars['MutationInputCoreUsersPartialUpdateInputUsername']['input']>;
  /** User's display name. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Designates whether this user should be treated as active. Unselect this instead of deleting accounts. */
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  lastLogin?: InputMaybe<Scalars['DateTime']['input']>;
  groups?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  email?: InputMaybe<Scalars['EmailAddress']['input']>;
  attributes?: InputMaybe<Scalars['JSON']['input']>;
  path?: InputMaybe<Scalars['NonEmptyString']['input']>;
  type?: InputMaybe<UserTypeEnum>;
};

export type CoreUsersDestroyResponse = VoidContainer | ValidationError | GenericError;

export type CoreUsersImpersonateCreateResponse = VoidContainer | ValidationError | GenericError;

export type CoreUsersRecoveryCreateResponse = Link | ValidationError | GenericError;

export type CoreUsersRecoveryEmailCreateResponse = VoidContainer | ValidationError | GenericError;

export type CoreUsersSetPasswordCreateResponse = VoidContainer | GenericError;

export type UserPasswordSetRequestInput = {
  password: Scalars['NonEmptyString']['input'];
};

export type CoreUsersServiceAccountCreateResponse = UserServiceAccountResponse | ValidationError | GenericError;

export type UserServiceAccountResponse = {
  username: Scalars['String']['output'];
  token: Scalars['String']['output'];
  userUid: Scalars['String']['output'];
  userPk: Scalars['Int']['output'];
  groupPk?: Maybe<Scalars['String']['output']>;
};

export type UserServiceAccountRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  createGroup?: InputMaybe<Scalars['Boolean']['input']>;
  expiring?: InputMaybe<Scalars['Boolean']['input']>;
  /** If not provided, valid for 360 days */
  expires?: InputMaybe<Scalars['DateTime']['input']>;
};

export type CryptoCertificatekeypairsCreateResponse = CertificateKeyPair | ValidationError | GenericError;

/** CertificateKeyPair Serializer */
export type CertificateKeyPairRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  /** PEM-encoded Certificate data */
  certificateData: Scalars['NonEmptyString']['input'];
  /** Optional Private Key. If this is set, you can use this keypair for encryption. */
  keyData?: InputMaybe<Scalars['String']['input']>;
};

export type CryptoCertificatekeypairsUpdateResponse = CertificateKeyPair | ValidationError | GenericError;

export type CryptoCertificatekeypairsPartialUpdateResponse = CertificateKeyPair | ValidationError | GenericError;

/** CertificateKeyPair Serializer */
export type PatchedCertificateKeyPairRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** PEM-encoded Certificate data */
  certificateData?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Optional Private Key. If this is set, you can use this keypair for encryption. */
  keyData?: InputMaybe<Scalars['String']['input']>;
};

export type CryptoCertificatekeypairsDestroyResponse = VoidContainer | ValidationError | GenericError;

export type CryptoCertificatekeypairsGenerateCreateResponse = CertificateKeyPair | GenericError;

/** Certificate generation parameters */
export type CertificateGenerationRequestInput = {
  commonName: Scalars['NonEmptyString']['input'];
  subjectAltName?: InputMaybe<Scalars['String']['input']>;
  validityDays: Scalars['Int']['input'];
  alg?: InputMaybe<AlgEnum>;
};

export type AlgEnum =
  | 'RSA'
  | 'ECDSA';

export type EnterpriseLicenseCreateResponse = License | ValidationError | GenericError;

/** License Serializer */
export type LicenseRequestInput = {
  key: Scalars['NonEmptyString']['input'];
};

export type EnterpriseLicenseUpdateResponse = License | ValidationError | GenericError;

export type EnterpriseLicensePartialUpdateResponse = License | ValidationError | GenericError;

/** License Serializer */
export type PatchedLicenseRequestInput = {
  key?: InputMaybe<Scalars['NonEmptyString']['input']>;
};

export type EnterpriseLicenseDestroyResponse = VoidContainer | ValidationError | GenericError;

export type EventsEventsCreateResponse = Event | ValidationError | GenericError;

/** Event Serializer */
export type EventRequestInput = {
  user?: InputMaybe<Scalars['JSON']['input']>;
  action: EventActions;
  app: Scalars['NonEmptyString']['input'];
  context?: InputMaybe<Scalars['JSON']['input']>;
  clientIp?: InputMaybe<Scalars['NonEmptyString']['input']>;
  expires?: InputMaybe<Scalars['DateTime']['input']>;
  brand?: InputMaybe<Scalars['JSON']['input']>;
};

export type EventsEventsUpdateResponse = Event | ValidationError | GenericError;

export type EventsEventsPartialUpdateResponse = Event | ValidationError | GenericError;

/** Event Serializer */
export type PatchedEventRequestInput = {
  user?: InputMaybe<Scalars['JSON']['input']>;
  action?: InputMaybe<EventActions>;
  app?: InputMaybe<Scalars['NonEmptyString']['input']>;
  context?: InputMaybe<Scalars['JSON']['input']>;
  clientIp?: InputMaybe<Scalars['NonEmptyString']['input']>;
  expires?: InputMaybe<Scalars['DateTime']['input']>;
  brand?: InputMaybe<Scalars['JSON']['input']>;
};

export type EventsEventsDestroyResponse = VoidContainer | ValidationError | GenericError;

export type EventsNotificationsUpdateResponse = Notification | ValidationError | GenericError;

/** Notification Serializer */
export type NotificationRequestInput = {
  event?: InputMaybe<EventRequestInput>;
  seen?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EventsNotificationsPartialUpdateResponse = Notification | ValidationError | GenericError;

/** Notification Serializer */
export type PatchedNotificationRequestInput = {
  event?: InputMaybe<EventRequestInput>;
  seen?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EventsNotificationsDestroyResponse = VoidContainer | ValidationError | GenericError;

export type EventsNotificationsMarkAllSeenCreateResponse = VoidContainer | ValidationError | GenericError;

export type EventsRulesCreateResponse = NotificationRule | ValidationError | GenericError;

/** NotificationRule Serializer */
export type NotificationRuleRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  /** Select which transports should be used to notify the user. If none are selected, the notification will only be shown in the authentik UI. */
  transports?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  severity?: InputMaybe<SeverityEnum>;
  /** Define which group of users this notification should be sent and shown to. If left empty, Notification won't ben sent. */
  group?: InputMaybe<Scalars['UUID']['input']>;
};

export type EventsRulesUpdateResponse = NotificationRule | ValidationError | GenericError;

export type EventsRulesPartialUpdateResponse = NotificationRule | ValidationError | GenericError;

/** NotificationRule Serializer */
export type PatchedNotificationRuleRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Select which transports should be used to notify the user. If none are selected, the notification will only be shown in the authentik UI. */
  transports?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  severity?: InputMaybe<SeverityEnum>;
  /** Define which group of users this notification should be sent and shown to. If left empty, Notification won't ben sent. */
  group?: InputMaybe<Scalars['UUID']['input']>;
};

export type EventsRulesDestroyResponse = VoidContainer | ValidationError | GenericError;

export type EventsSystemTasksRunCreateResponse = VoidContainer | ValidationError | GenericError;

export type EventsTransportsCreateResponse = NotificationTransport | ValidationError | GenericError;

/** NotificationTransport Serializer */
export type NotificationTransportRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  mode?: InputMaybe<NotificationTransportModeEnum>;
  webhookUrl?: InputMaybe<Scalars['URL']['input']>;
  webhookMapping?: InputMaybe<Scalars['UUID']['input']>;
  /** Only send notification once, for example when sending a webhook into a chat channel. */
  sendOnce?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EventsTransportsUpdateResponse = NotificationTransport | ValidationError | GenericError;

export type EventsTransportsPartialUpdateResponse = NotificationTransport | ValidationError | GenericError;

/** NotificationTransport Serializer */
export type PatchedNotificationTransportRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  mode?: InputMaybe<NotificationTransportModeEnum>;
  webhookUrl?: InputMaybe<Scalars['URL']['input']>;
  webhookMapping?: InputMaybe<Scalars['UUID']['input']>;
  /** Only send notification once, for example when sending a webhook into a chat channel. */
  sendOnce?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EventsTransportsDestroyResponse = VoidContainer | ValidationError | GenericError;

export type EventsTransportsTestCreateResponse = NotificationTransportTest | ValidationError | GenericError;

/** Notification test serializer */
export type NotificationTransportTest = {
  messages: Array<Maybe<Scalars['String']['output']>>;
};

export type FlowsBindingsCreateResponse = FlowStageBinding | ValidationError | GenericError;

/** FlowStageBinding Serializer */
export type FlowStageBindingRequestInput = {
  target: Scalars['UUID']['input'];
  stage: Scalars['UUID']['input'];
  /** Evaluate policies during the Flow planning process. */
  evaluateOnPlan?: InputMaybe<Scalars['Boolean']['input']>;
  /** Evaluate policies when the Stage is present to the user. */
  reEvaluatePolicies?: InputMaybe<Scalars['Boolean']['input']>;
  order: Scalars['Int']['input'];
  policyEngineMode?: InputMaybe<PolicyEngineMode>;
  invalidResponseAction?: InputMaybe<InvalidResponseActionEnum>;
};

export type FlowsBindingsUpdateResponse = FlowStageBinding | ValidationError | GenericError;

export type FlowsBindingsPartialUpdateResponse = FlowStageBinding | ValidationError | GenericError;

/** FlowStageBinding Serializer */
export type PatchedFlowStageBindingRequestInput = {
  target?: InputMaybe<Scalars['UUID']['input']>;
  stage?: InputMaybe<Scalars['UUID']['input']>;
  /** Evaluate policies during the Flow planning process. */
  evaluateOnPlan?: InputMaybe<Scalars['Boolean']['input']>;
  /** Evaluate policies when the Stage is present to the user. */
  reEvaluatePolicies?: InputMaybe<Scalars['Boolean']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  policyEngineMode?: InputMaybe<PolicyEngineMode>;
  invalidResponseAction?: InputMaybe<InvalidResponseActionEnum>;
};

export type FlowsBindingsDestroyResponse = VoidContainer | ValidationError | GenericError;

export type FlowsExecutorSolveResponse = AccessDeniedChallenge | AppleLoginChallenge | AuthenticatorDuoChallenge | AuthenticatorSmsChallenge | AuthenticatorStaticChallenge | AuthenticatorTotpChallenge | AuthenticatorValidationChallenge | AuthenticatorWebAuthnChallenge | AutosubmitChallenge | CaptchaChallenge | ConsentChallenge | EmailChallenge | FlowErrorChallenge | IdentificationChallenge | OAuthDeviceCodeChallenge | OAuthDeviceCodeFinishChallenge | PasswordChallenge | PlexAuthenticationChallenge | PromptChallenge | RedirectChallenge | ShellChallenge | UserLoginChallenge | ValidationError | GenericError;

export type FlowChallengeResponseRequestInput =
  { appleChallengeResponseRequestInput: AppleChallengeResponseRequestInput; authenticatorDuoChallengeResponseRequestInput?: never; authenticatorSmsChallengeResponseRequestInput?: never; authenticatorStaticChallengeResponseRequestInput?: never; authenticatorTotpChallengeResponseRequestInput?: never; authenticatorValidationChallengeResponseRequestInput?: never; authenticatorWebAuthnChallengeResponseRequestInput?: never; autoSubmitChallengeResponseRequestInput?: never; captchaChallengeResponseRequestInput?: never; consentChallengeResponseRequestInput?: never; emailChallengeResponseRequestInput?: never; identificationChallengeResponseRequestInput?: never; oAuthDeviceCodeChallengeResponseRequestInput?: never; oAuthDeviceCodeFinishChallengeResponseRequestInput?: never; passwordChallengeResponseRequestInput?: never; plexAuthenticationChallengeResponseRequestInput?: never; promptChallengeResponseRequestInput?: never; userLoginChallengeResponseRequestInput?: never; }
  |  { appleChallengeResponseRequestInput?: never; authenticatorDuoChallengeResponseRequestInput: AuthenticatorDuoChallengeResponseRequestInput; authenticatorSmsChallengeResponseRequestInput?: never; authenticatorStaticChallengeResponseRequestInput?: never; authenticatorTotpChallengeResponseRequestInput?: never; authenticatorValidationChallengeResponseRequestInput?: never; authenticatorWebAuthnChallengeResponseRequestInput?: never; autoSubmitChallengeResponseRequestInput?: never; captchaChallengeResponseRequestInput?: never; consentChallengeResponseRequestInput?: never; emailChallengeResponseRequestInput?: never; identificationChallengeResponseRequestInput?: never; oAuthDeviceCodeChallengeResponseRequestInput?: never; oAuthDeviceCodeFinishChallengeResponseRequestInput?: never; passwordChallengeResponseRequestInput?: never; plexAuthenticationChallengeResponseRequestInput?: never; promptChallengeResponseRequestInput?: never; userLoginChallengeResponseRequestInput?: never; }
  |  { appleChallengeResponseRequestInput?: never; authenticatorDuoChallengeResponseRequestInput?: never; authenticatorSmsChallengeResponseRequestInput: AuthenticatorSmsChallengeResponseRequestInput; authenticatorStaticChallengeResponseRequestInput?: never; authenticatorTotpChallengeResponseRequestInput?: never; authenticatorValidationChallengeResponseRequestInput?: never; authenticatorWebAuthnChallengeResponseRequestInput?: never; autoSubmitChallengeResponseRequestInput?: never; captchaChallengeResponseRequestInput?: never; consentChallengeResponseRequestInput?: never; emailChallengeResponseRequestInput?: never; identificationChallengeResponseRequestInput?: never; oAuthDeviceCodeChallengeResponseRequestInput?: never; oAuthDeviceCodeFinishChallengeResponseRequestInput?: never; passwordChallengeResponseRequestInput?: never; plexAuthenticationChallengeResponseRequestInput?: never; promptChallengeResponseRequestInput?: never; userLoginChallengeResponseRequestInput?: never; }
  |  { appleChallengeResponseRequestInput?: never; authenticatorDuoChallengeResponseRequestInput?: never; authenticatorSmsChallengeResponseRequestInput?: never; authenticatorStaticChallengeResponseRequestInput: AuthenticatorStaticChallengeResponseRequestInput; authenticatorTotpChallengeResponseRequestInput?: never; authenticatorValidationChallengeResponseRequestInput?: never; authenticatorWebAuthnChallengeResponseRequestInput?: never; autoSubmitChallengeResponseRequestInput?: never; captchaChallengeResponseRequestInput?: never; consentChallengeResponseRequestInput?: never; emailChallengeResponseRequestInput?: never; identificationChallengeResponseRequestInput?: never; oAuthDeviceCodeChallengeResponseRequestInput?: never; oAuthDeviceCodeFinishChallengeResponseRequestInput?: never; passwordChallengeResponseRequestInput?: never; plexAuthenticationChallengeResponseRequestInput?: never; promptChallengeResponseRequestInput?: never; userLoginChallengeResponseRequestInput?: never; }
  |  { appleChallengeResponseRequestInput?: never; authenticatorDuoChallengeResponseRequestInput?: never; authenticatorSmsChallengeResponseRequestInput?: never; authenticatorStaticChallengeResponseRequestInput?: never; authenticatorTotpChallengeResponseRequestInput: AuthenticatorTotpChallengeResponseRequestInput; authenticatorValidationChallengeResponseRequestInput?: never; authenticatorWebAuthnChallengeResponseRequestInput?: never; autoSubmitChallengeResponseRequestInput?: never; captchaChallengeResponseRequestInput?: never; consentChallengeResponseRequestInput?: never; emailChallengeResponseRequestInput?: never; identificationChallengeResponseRequestInput?: never; oAuthDeviceCodeChallengeResponseRequestInput?: never; oAuthDeviceCodeFinishChallengeResponseRequestInput?: never; passwordChallengeResponseRequestInput?: never; plexAuthenticationChallengeResponseRequestInput?: never; promptChallengeResponseRequestInput?: never; userLoginChallengeResponseRequestInput?: never; }
  |  { appleChallengeResponseRequestInput?: never; authenticatorDuoChallengeResponseRequestInput?: never; authenticatorSmsChallengeResponseRequestInput?: never; authenticatorStaticChallengeResponseRequestInput?: never; authenticatorTotpChallengeResponseRequestInput?: never; authenticatorValidationChallengeResponseRequestInput: AuthenticatorValidationChallengeResponseRequestInput; authenticatorWebAuthnChallengeResponseRequestInput?: never; autoSubmitChallengeResponseRequestInput?: never; captchaChallengeResponseRequestInput?: never; consentChallengeResponseRequestInput?: never; emailChallengeResponseRequestInput?: never; identificationChallengeResponseRequestInput?: never; oAuthDeviceCodeChallengeResponseRequestInput?: never; oAuthDeviceCodeFinishChallengeResponseRequestInput?: never; passwordChallengeResponseRequestInput?: never; plexAuthenticationChallengeResponseRequestInput?: never; promptChallengeResponseRequestInput?: never; userLoginChallengeResponseRequestInput?: never; }
  |  { appleChallengeResponseRequestInput?: never; authenticatorDuoChallengeResponseRequestInput?: never; authenticatorSmsChallengeResponseRequestInput?: never; authenticatorStaticChallengeResponseRequestInput?: never; authenticatorTotpChallengeResponseRequestInput?: never; authenticatorValidationChallengeResponseRequestInput?: never; authenticatorWebAuthnChallengeResponseRequestInput: AuthenticatorWebAuthnChallengeResponseRequestInput; autoSubmitChallengeResponseRequestInput?: never; captchaChallengeResponseRequestInput?: never; consentChallengeResponseRequestInput?: never; emailChallengeResponseRequestInput?: never; identificationChallengeResponseRequestInput?: never; oAuthDeviceCodeChallengeResponseRequestInput?: never; oAuthDeviceCodeFinishChallengeResponseRequestInput?: never; passwordChallengeResponseRequestInput?: never; plexAuthenticationChallengeResponseRequestInput?: never; promptChallengeResponseRequestInput?: never; userLoginChallengeResponseRequestInput?: never; }
  |  { appleChallengeResponseRequestInput?: never; authenticatorDuoChallengeResponseRequestInput?: never; authenticatorSmsChallengeResponseRequestInput?: never; authenticatorStaticChallengeResponseRequestInput?: never; authenticatorTotpChallengeResponseRequestInput?: never; authenticatorValidationChallengeResponseRequestInput?: never; authenticatorWebAuthnChallengeResponseRequestInput?: never; autoSubmitChallengeResponseRequestInput: AutoSubmitChallengeResponseRequestInput; captchaChallengeResponseRequestInput?: never; consentChallengeResponseRequestInput?: never; emailChallengeResponseRequestInput?: never; identificationChallengeResponseRequestInput?: never; oAuthDeviceCodeChallengeResponseRequestInput?: never; oAuthDeviceCodeFinishChallengeResponseRequestInput?: never; passwordChallengeResponseRequestInput?: never; plexAuthenticationChallengeResponseRequestInput?: never; promptChallengeResponseRequestInput?: never; userLoginChallengeResponseRequestInput?: never; }
  |  { appleChallengeResponseRequestInput?: never; authenticatorDuoChallengeResponseRequestInput?: never; authenticatorSmsChallengeResponseRequestInput?: never; authenticatorStaticChallengeResponseRequestInput?: never; authenticatorTotpChallengeResponseRequestInput?: never; authenticatorValidationChallengeResponseRequestInput?: never; authenticatorWebAuthnChallengeResponseRequestInput?: never; autoSubmitChallengeResponseRequestInput?: never; captchaChallengeResponseRequestInput: CaptchaChallengeResponseRequestInput; consentChallengeResponseRequestInput?: never; emailChallengeResponseRequestInput?: never; identificationChallengeResponseRequestInput?: never; oAuthDeviceCodeChallengeResponseRequestInput?: never; oAuthDeviceCodeFinishChallengeResponseRequestInput?: never; passwordChallengeResponseRequestInput?: never; plexAuthenticationChallengeResponseRequestInput?: never; promptChallengeResponseRequestInput?: never; userLoginChallengeResponseRequestInput?: never; }
  |  { appleChallengeResponseRequestInput?: never; authenticatorDuoChallengeResponseRequestInput?: never; authenticatorSmsChallengeResponseRequestInput?: never; authenticatorStaticChallengeResponseRequestInput?: never; authenticatorTotpChallengeResponseRequestInput?: never; authenticatorValidationChallengeResponseRequestInput?: never; authenticatorWebAuthnChallengeResponseRequestInput?: never; autoSubmitChallengeResponseRequestInput?: never; captchaChallengeResponseRequestInput?: never; consentChallengeResponseRequestInput: ConsentChallengeResponseRequestInput; emailChallengeResponseRequestInput?: never; identificationChallengeResponseRequestInput?: never; oAuthDeviceCodeChallengeResponseRequestInput?: never; oAuthDeviceCodeFinishChallengeResponseRequestInput?: never; passwordChallengeResponseRequestInput?: never; plexAuthenticationChallengeResponseRequestInput?: never; promptChallengeResponseRequestInput?: never; userLoginChallengeResponseRequestInput?: never; }
  |  { appleChallengeResponseRequestInput?: never; authenticatorDuoChallengeResponseRequestInput?: never; authenticatorSmsChallengeResponseRequestInput?: never; authenticatorStaticChallengeResponseRequestInput?: never; authenticatorTotpChallengeResponseRequestInput?: never; authenticatorValidationChallengeResponseRequestInput?: never; authenticatorWebAuthnChallengeResponseRequestInput?: never; autoSubmitChallengeResponseRequestInput?: never; captchaChallengeResponseRequestInput?: never; consentChallengeResponseRequestInput?: never; emailChallengeResponseRequestInput: EmailChallengeResponseRequestInput; identificationChallengeResponseRequestInput?: never; oAuthDeviceCodeChallengeResponseRequestInput?: never; oAuthDeviceCodeFinishChallengeResponseRequestInput?: never; passwordChallengeResponseRequestInput?: never; plexAuthenticationChallengeResponseRequestInput?: never; promptChallengeResponseRequestInput?: never; userLoginChallengeResponseRequestInput?: never; }
  |  { appleChallengeResponseRequestInput?: never; authenticatorDuoChallengeResponseRequestInput?: never; authenticatorSmsChallengeResponseRequestInput?: never; authenticatorStaticChallengeResponseRequestInput?: never; authenticatorTotpChallengeResponseRequestInput?: never; authenticatorValidationChallengeResponseRequestInput?: never; authenticatorWebAuthnChallengeResponseRequestInput?: never; autoSubmitChallengeResponseRequestInput?: never; captchaChallengeResponseRequestInput?: never; consentChallengeResponseRequestInput?: never; emailChallengeResponseRequestInput?: never; identificationChallengeResponseRequestInput: IdentificationChallengeResponseRequestInput; oAuthDeviceCodeChallengeResponseRequestInput?: never; oAuthDeviceCodeFinishChallengeResponseRequestInput?: never; passwordChallengeResponseRequestInput?: never; plexAuthenticationChallengeResponseRequestInput?: never; promptChallengeResponseRequestInput?: never; userLoginChallengeResponseRequestInput?: never; }
  |  { appleChallengeResponseRequestInput?: never; authenticatorDuoChallengeResponseRequestInput?: never; authenticatorSmsChallengeResponseRequestInput?: never; authenticatorStaticChallengeResponseRequestInput?: never; authenticatorTotpChallengeResponseRequestInput?: never; authenticatorValidationChallengeResponseRequestInput?: never; authenticatorWebAuthnChallengeResponseRequestInput?: never; autoSubmitChallengeResponseRequestInput?: never; captchaChallengeResponseRequestInput?: never; consentChallengeResponseRequestInput?: never; emailChallengeResponseRequestInput?: never; identificationChallengeResponseRequestInput?: never; oAuthDeviceCodeChallengeResponseRequestInput: OAuthDeviceCodeChallengeResponseRequestInput; oAuthDeviceCodeFinishChallengeResponseRequestInput?: never; passwordChallengeResponseRequestInput?: never; plexAuthenticationChallengeResponseRequestInput?: never; promptChallengeResponseRequestInput?: never; userLoginChallengeResponseRequestInput?: never; }
  |  { appleChallengeResponseRequestInput?: never; authenticatorDuoChallengeResponseRequestInput?: never; authenticatorSmsChallengeResponseRequestInput?: never; authenticatorStaticChallengeResponseRequestInput?: never; authenticatorTotpChallengeResponseRequestInput?: never; authenticatorValidationChallengeResponseRequestInput?: never; authenticatorWebAuthnChallengeResponseRequestInput?: never; autoSubmitChallengeResponseRequestInput?: never; captchaChallengeResponseRequestInput?: never; consentChallengeResponseRequestInput?: never; emailChallengeResponseRequestInput?: never; identificationChallengeResponseRequestInput?: never; oAuthDeviceCodeChallengeResponseRequestInput?: never; oAuthDeviceCodeFinishChallengeResponseRequestInput: OAuthDeviceCodeFinishChallengeResponseRequestInput; passwordChallengeResponseRequestInput?: never; plexAuthenticationChallengeResponseRequestInput?: never; promptChallengeResponseRequestInput?: never; userLoginChallengeResponseRequestInput?: never; }
  |  { appleChallengeResponseRequestInput?: never; authenticatorDuoChallengeResponseRequestInput?: never; authenticatorSmsChallengeResponseRequestInput?: never; authenticatorStaticChallengeResponseRequestInput?: never; authenticatorTotpChallengeResponseRequestInput?: never; authenticatorValidationChallengeResponseRequestInput?: never; authenticatorWebAuthnChallengeResponseRequestInput?: never; autoSubmitChallengeResponseRequestInput?: never; captchaChallengeResponseRequestInput?: never; consentChallengeResponseRequestInput?: never; emailChallengeResponseRequestInput?: never; identificationChallengeResponseRequestInput?: never; oAuthDeviceCodeChallengeResponseRequestInput?: never; oAuthDeviceCodeFinishChallengeResponseRequestInput?: never; passwordChallengeResponseRequestInput: PasswordChallengeResponseRequestInput; plexAuthenticationChallengeResponseRequestInput?: never; promptChallengeResponseRequestInput?: never; userLoginChallengeResponseRequestInput?: never; }
  |  { appleChallengeResponseRequestInput?: never; authenticatorDuoChallengeResponseRequestInput?: never; authenticatorSmsChallengeResponseRequestInput?: never; authenticatorStaticChallengeResponseRequestInput?: never; authenticatorTotpChallengeResponseRequestInput?: never; authenticatorValidationChallengeResponseRequestInput?: never; authenticatorWebAuthnChallengeResponseRequestInput?: never; autoSubmitChallengeResponseRequestInput?: never; captchaChallengeResponseRequestInput?: never; consentChallengeResponseRequestInput?: never; emailChallengeResponseRequestInput?: never; identificationChallengeResponseRequestInput?: never; oAuthDeviceCodeChallengeResponseRequestInput?: never; oAuthDeviceCodeFinishChallengeResponseRequestInput?: never; passwordChallengeResponseRequestInput?: never; plexAuthenticationChallengeResponseRequestInput: PlexAuthenticationChallengeResponseRequestInput; promptChallengeResponseRequestInput?: never; userLoginChallengeResponseRequestInput?: never; }
  |  { appleChallengeResponseRequestInput?: never; authenticatorDuoChallengeResponseRequestInput?: never; authenticatorSmsChallengeResponseRequestInput?: never; authenticatorStaticChallengeResponseRequestInput?: never; authenticatorTotpChallengeResponseRequestInput?: never; authenticatorValidationChallengeResponseRequestInput?: never; authenticatorWebAuthnChallengeResponseRequestInput?: never; autoSubmitChallengeResponseRequestInput?: never; captchaChallengeResponseRequestInput?: never; consentChallengeResponseRequestInput?: never; emailChallengeResponseRequestInput?: never; identificationChallengeResponseRequestInput?: never; oAuthDeviceCodeChallengeResponseRequestInput?: never; oAuthDeviceCodeFinishChallengeResponseRequestInput?: never; passwordChallengeResponseRequestInput?: never; plexAuthenticationChallengeResponseRequestInput?: never; promptChallengeResponseRequestInput: PromptChallengeResponseRequestInput; userLoginChallengeResponseRequestInput?: never; }
  |  { appleChallengeResponseRequestInput?: never; authenticatorDuoChallengeResponseRequestInput?: never; authenticatorSmsChallengeResponseRequestInput?: never; authenticatorStaticChallengeResponseRequestInput?: never; authenticatorTotpChallengeResponseRequestInput?: never; authenticatorValidationChallengeResponseRequestInput?: never; authenticatorWebAuthnChallengeResponseRequestInput?: never; autoSubmitChallengeResponseRequestInput?: never; captchaChallengeResponseRequestInput?: never; consentChallengeResponseRequestInput?: never; emailChallengeResponseRequestInput?: never; identificationChallengeResponseRequestInput?: never; oAuthDeviceCodeChallengeResponseRequestInput?: never; oAuthDeviceCodeFinishChallengeResponseRequestInput?: never; passwordChallengeResponseRequestInput?: never; plexAuthenticationChallengeResponseRequestInput?: never; promptChallengeResponseRequestInput?: never; userLoginChallengeResponseRequestInput: UserLoginChallengeResponseRequestInput; };

/** Pseudo class for apple response */
export type AppleChallengeResponseRequestInput = {
  component?: InputMaybe<Scalars['NonEmptyString']['input']>;
};

/** Pseudo class for duo response */
export type AuthenticatorDuoChallengeResponseRequestInput = {
  component?: InputMaybe<Scalars['NonEmptyString']['input']>;
};

/** SMS Challenge response, device is set by get_response_instance */
export type AuthenticatorSmsChallengeResponseRequestInput = {
  component?: InputMaybe<Scalars['NonEmptyString']['input']>;
  code?: InputMaybe<Scalars['Int']['input']>;
  phoneNumber?: InputMaybe<Scalars['NonEmptyString']['input']>;
};

/** Pseudo class for static response */
export type AuthenticatorStaticChallengeResponseRequestInput = {
  component?: InputMaybe<Scalars['NonEmptyString']['input']>;
};

/** TOTP Challenge response, device is set by get_response_instance */
export type AuthenticatorTotpChallengeResponseRequestInput = {
  component?: InputMaybe<Scalars['NonEmptyString']['input']>;
  code: Scalars['Int']['input'];
};

/** Challenge used for Code-based and WebAuthn authenticators */
export type AuthenticatorValidationChallengeResponseRequestInput = {
  component?: InputMaybe<Scalars['NonEmptyString']['input']>;
  selectedChallenge?: InputMaybe<DeviceChallengeRequestInput>;
  selectedStage?: InputMaybe<Scalars['NonEmptyString']['input']>;
  code?: InputMaybe<Scalars['NonEmptyString']['input']>;
  webauthn?: InputMaybe<Scalars['JSON']['input']>;
  duo?: InputMaybe<Scalars['Int']['input']>;
};

/** Single device challenge */
export type DeviceChallengeRequestInput = {
  deviceClass: Scalars['NonEmptyString']['input'];
  deviceUid: Scalars['NonEmptyString']['input'];
  challenge: Scalars['JSON']['input'];
};

/** WebAuthn Challenge response */
export type AuthenticatorWebAuthnChallengeResponseRequestInput = {
  component?: InputMaybe<Scalars['NonEmptyString']['input']>;
  response: Scalars['JSON']['input'];
};

/** Pseudo class for autosubmit response */
export type AutoSubmitChallengeResponseRequestInput = {
  component?: InputMaybe<Scalars['NonEmptyString']['input']>;
};

/** Validate captcha token */
export type CaptchaChallengeResponseRequestInput = {
  component?: InputMaybe<Scalars['NonEmptyString']['input']>;
  token: Scalars['NonEmptyString']['input'];
};

/** Consent challenge response, any valid response request is valid */
export type ConsentChallengeResponseRequestInput = {
  component?: InputMaybe<Scalars['NonEmptyString']['input']>;
  token: Scalars['NonEmptyString']['input'];
};

/**
 * Email challenge resposen. No fields. This challenge is
 * always declared invalid to give the user a chance to retry
 */
export type EmailChallengeResponseRequestInput = {
  component?: InputMaybe<Scalars['NonEmptyString']['input']>;
};

/** Identification challenge */
export type IdentificationChallengeResponseRequestInput = {
  component?: InputMaybe<Scalars['NonEmptyString']['input']>;
  uidField: Scalars['NonEmptyString']['input'];
  password?: InputMaybe<Scalars['String']['input']>;
};

/** Response that includes the user-entered device code */
export type OAuthDeviceCodeChallengeResponseRequestInput = {
  component?: InputMaybe<Scalars['NonEmptyString']['input']>;
  code: Scalars['Int']['input'];
};

/** Response that device has been authenticated and tab can be closed */
export type OAuthDeviceCodeFinishChallengeResponseRequestInput = {
  component?: InputMaybe<Scalars['NonEmptyString']['input']>;
};

/** Password challenge response */
export type PasswordChallengeResponseRequestInput = {
  component?: InputMaybe<Scalars['NonEmptyString']['input']>;
  password: Scalars['NonEmptyString']['input'];
};

/** Pseudo class for plex response */
export type PlexAuthenticationChallengeResponseRequestInput = {
  component?: InputMaybe<Scalars['NonEmptyString']['input']>;
};

/**
 * Validate response, fields are dynamically created based
 * on the stage
 */
export type PromptChallengeResponseRequestInput = {
  component?: InputMaybe<Scalars['NonEmptyString']['input']>;
};

/** User login challenge */
export type UserLoginChallengeResponseRequestInput = {
  component?: InputMaybe<Scalars['NonEmptyString']['input']>;
  rememberMe: Scalars['Boolean']['input'];
};

export type FlowsInstancesCreateResponse = Flow | ValidationError | GenericError;

/** Flow Serializer */
export type FlowRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  slug: Scalars['MutationInputFlowsInstancesCreateInputSlug']['input'];
  /** Shown as the Title in Flow pages. */
  title: Scalars['NonEmptyString']['input'];
  designation: FlowDesignationEnum;
  policyEngineMode?: InputMaybe<PolicyEngineMode>;
  /** Enable compatibility mode, increases compatibility with password managers on mobile devices. */
  compatibilityMode?: InputMaybe<Scalars['Boolean']['input']>;
  layout?: InputMaybe<FlowLayoutEnum>;
  deniedAction?: InputMaybe<DeniedActionEnum>;
  authentication?: InputMaybe<AuthenticationEnum>;
};

export type FlowsInstancesUpdateResponse = Flow | ValidationError | GenericError;

export type FlowsInstancesPartialUpdateResponse = Flow | ValidationError | GenericError;

/** Flow Serializer */
export type PatchedFlowRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  slug?: InputMaybe<Scalars['MutationInputFlowsInstancesPartialUpdateInputSlug']['input']>;
  /** Shown as the Title in Flow pages. */
  title?: InputMaybe<Scalars['NonEmptyString']['input']>;
  designation?: InputMaybe<FlowDesignationEnum>;
  policyEngineMode?: InputMaybe<PolicyEngineMode>;
  /** Enable compatibility mode, increases compatibility with password managers on mobile devices. */
  compatibilityMode?: InputMaybe<Scalars['Boolean']['input']>;
  layout?: InputMaybe<FlowLayoutEnum>;
  deniedAction?: InputMaybe<DeniedActionEnum>;
  authentication?: InputMaybe<AuthenticationEnum>;
};

export type FlowsInstancesDestroyResponse = VoidContainer | ValidationError | GenericError;

export type FlowsInstancesCacheClearCreateResponse = VoidContainer | GenericError;

export type FlowsInstancesImportCreateResponse = FlowImportResult | GenericError;

/** Logs of an attempted flow import */
export type FlowImportResult = {
  logs: Array<Maybe<LogEvent>>;
  success: Scalars['Boolean']['output'];
};

export type ManagedBlueprintsCreateResponse = BlueprintInstance | ValidationError | GenericError;

/** Info about a single blueprint instance file */
export type BlueprintInstanceRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  path?: InputMaybe<Scalars['String']['input']>;
  context?: InputMaybe<Scalars['JSON']['input']>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  content?: InputMaybe<Scalars['String']['input']>;
};

export type ManagedBlueprintsUpdateResponse = BlueprintInstance | ValidationError | GenericError;

export type ManagedBlueprintsPartialUpdateResponse = BlueprintInstance | ValidationError | GenericError;

/** Info about a single blueprint instance file */
export type PatchedBlueprintInstanceRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  path?: InputMaybe<Scalars['String']['input']>;
  context?: InputMaybe<Scalars['JSON']['input']>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  content?: InputMaybe<Scalars['String']['input']>;
};

export type ManagedBlueprintsDestroyResponse = VoidContainer | ValidationError | GenericError;

export type ManagedBlueprintsApplyCreateResponse = BlueprintInstance | ValidationError | GenericError;

export type Oauth2AccessTokensDestroyResponse = VoidContainer | ValidationError | GenericError;

export type Oauth2AuthorizationCodesDestroyResponse = VoidContainer | ValidationError | GenericError;

export type Oauth2RefreshTokensDestroyResponse = VoidContainer | ValidationError | GenericError;

export type OutpostsInstancesCreateResponse = Outpost | ValidationError | GenericError;

/** Outpost Serializer */
export type OutpostRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  type: OutpostTypeEnum;
  providers: Array<InputMaybe<Scalars['Int']['input']>>;
  /** Select Service-Connection authentik should use to manage this outpost. Leave empty if authentik should not handle the deployment. */
  serviceConnection?: InputMaybe<Scalars['UUID']['input']>;
  config: Scalars['JSON']['input'];
  /** Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update. */
  managed?: InputMaybe<Scalars['NonEmptyString']['input']>;
};

export type OutpostsInstancesUpdateResponse = Outpost | ValidationError | GenericError;

export type OutpostsInstancesPartialUpdateResponse = Outpost | ValidationError | GenericError;

/** Outpost Serializer */
export type PatchedOutpostRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  type?: InputMaybe<OutpostTypeEnum>;
  providers?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  /** Select Service-Connection authentik should use to manage this outpost. Leave empty if authentik should not handle the deployment. */
  serviceConnection?: InputMaybe<Scalars['UUID']['input']>;
  config?: InputMaybe<Scalars['JSON']['input']>;
  /** Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update. */
  managed?: InputMaybe<Scalars['NonEmptyString']['input']>;
};

export type OutpostsInstancesDestroyResponse = VoidContainer | ValidationError | GenericError;

export type OutpostsServiceConnectionsAllDestroyResponse = VoidContainer | ValidationError | GenericError;

export type OutpostsServiceConnectionsDockerCreateResponse = DockerServiceConnection | ValidationError | GenericError;

/** DockerServiceConnection Serializer */
export type DockerServiceConnectionRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  /** If enabled, use the local connection. Required Docker socket/Kubernetes Integration */
  local?: InputMaybe<Scalars['Boolean']['input']>;
  /** Can be in the format of 'unix://<path>' when connecting to a local docker daemon, or 'https://<hostname>:2376' when connecting to a remote system. */
  url: Scalars['NonEmptyString']['input'];
  /** CA which the endpoint's Certificate is verified against. Can be left empty for no validation. */
  tlsVerification?: InputMaybe<Scalars['UUID']['input']>;
  /** Certificate/Key used for authentication. Can be left empty for no authentication. */
  tlsAuthentication?: InputMaybe<Scalars['UUID']['input']>;
};

export type OutpostsServiceConnectionsDockerUpdateResponse = DockerServiceConnection | ValidationError | GenericError;

export type OutpostsServiceConnectionsDockerPartialUpdateResponse = DockerServiceConnection | ValidationError | GenericError;

/** DockerServiceConnection Serializer */
export type PatchedDockerServiceConnectionRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** If enabled, use the local connection. Required Docker socket/Kubernetes Integration */
  local?: InputMaybe<Scalars['Boolean']['input']>;
  /** Can be in the format of 'unix://<path>' when connecting to a local docker daemon, or 'https://<hostname>:2376' when connecting to a remote system. */
  url?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** CA which the endpoint's Certificate is verified against. Can be left empty for no validation. */
  tlsVerification?: InputMaybe<Scalars['UUID']['input']>;
  /** Certificate/Key used for authentication. Can be left empty for no authentication. */
  tlsAuthentication?: InputMaybe<Scalars['UUID']['input']>;
};

export type OutpostsServiceConnectionsDockerDestroyResponse = VoidContainer | ValidationError | GenericError;

export type OutpostsServiceConnectionsKubernetesCreateResponse = KubernetesServiceConnection | ValidationError | GenericError;

/** KubernetesServiceConnection Serializer */
export type KubernetesServiceConnectionRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  /** If enabled, use the local connection. Required Docker socket/Kubernetes Integration */
  local?: InputMaybe<Scalars['Boolean']['input']>;
  /** Paste your kubeconfig here. authentik will automatically use the currently selected context. */
  kubeconfig?: InputMaybe<Scalars['JSON']['input']>;
  /** Verify SSL Certificates of the Kubernetes API endpoint */
  verifySsl?: InputMaybe<Scalars['Boolean']['input']>;
};

export type OutpostsServiceConnectionsKubernetesUpdateResponse = KubernetesServiceConnection | ValidationError | GenericError;

export type OutpostsServiceConnectionsKubernetesPartialUpdateResponse = KubernetesServiceConnection | ValidationError | GenericError;

/** KubernetesServiceConnection Serializer */
export type PatchedKubernetesServiceConnectionRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** If enabled, use the local connection. Required Docker socket/Kubernetes Integration */
  local?: InputMaybe<Scalars['Boolean']['input']>;
  /** Paste your kubeconfig here. authentik will automatically use the currently selected context. */
  kubeconfig?: InputMaybe<Scalars['JSON']['input']>;
  /** Verify SSL Certificates of the Kubernetes API endpoint */
  verifySsl?: InputMaybe<Scalars['Boolean']['input']>;
};

export type OutpostsServiceConnectionsKubernetesDestroyResponse = VoidContainer | ValidationError | GenericError;

export type PoliciesAllDestroyResponse = VoidContainer | ValidationError | GenericError;

export type PoliciesAllTestCreateResponse = PolicyTestResult | GenericError;

/** Test policy execution for a user with context */
export type PolicyTestRequestInput = {
  user: Scalars['Int']['input'];
  context?: InputMaybe<Scalars['JSON']['input']>;
};

export type PoliciesAllCacheClearCreateResponse = VoidContainer | GenericError;

export type PoliciesBindingsCreateResponse = PolicyBinding | ValidationError | GenericError;

/** PolicyBinding Serializer */
export type PolicyBindingRequestInput = {
  policy?: InputMaybe<Scalars['UUID']['input']>;
  group?: InputMaybe<Scalars['UUID']['input']>;
  user?: InputMaybe<Scalars['Int']['input']>;
  target: Scalars['UUID']['input'];
  /** Negates the outcome of the policy. Messages are unaffected. */
  negate?: InputMaybe<Scalars['Boolean']['input']>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  order: Scalars['Int']['input'];
  /** Timeout after which Policy execution is terminated. */
  timeout?: InputMaybe<Scalars['NonNegativeInt']['input']>;
  /** Result if the Policy execution fails. */
  failureResult?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PoliciesBindingsUpdateResponse = PolicyBinding | ValidationError | GenericError;

export type PoliciesBindingsPartialUpdateResponse = PolicyBinding | ValidationError | GenericError;

/** PolicyBinding Serializer */
export type PatchedPolicyBindingRequestInput = {
  policy?: InputMaybe<Scalars['UUID']['input']>;
  group?: InputMaybe<Scalars['UUID']['input']>;
  user?: InputMaybe<Scalars['Int']['input']>;
  target?: InputMaybe<Scalars['UUID']['input']>;
  /** Negates the outcome of the policy. Messages are unaffected. */
  negate?: InputMaybe<Scalars['Boolean']['input']>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  /** Timeout after which Policy execution is terminated. */
  timeout?: InputMaybe<Scalars['NonNegativeInt']['input']>;
  /** Result if the Policy execution fails. */
  failureResult?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PoliciesBindingsDestroyResponse = VoidContainer | ValidationError | GenericError;

export type PoliciesDummyCreateResponse = DummyPolicy | ValidationError | GenericError;

/** Dummy Policy Serializer */
export type DummyPolicyRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  /** When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged. */
  executionLogging?: InputMaybe<Scalars['Boolean']['input']>;
  result?: InputMaybe<Scalars['Boolean']['input']>;
  waitMin?: InputMaybe<Scalars['Int']['input']>;
  waitMax?: InputMaybe<Scalars['Int']['input']>;
};

export type PoliciesDummyUpdateResponse = DummyPolicy | ValidationError | GenericError;

export type PoliciesDummyPartialUpdateResponse = DummyPolicy | ValidationError | GenericError;

/** Dummy Policy Serializer */
export type PatchedDummyPolicyRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged. */
  executionLogging?: InputMaybe<Scalars['Boolean']['input']>;
  result?: InputMaybe<Scalars['Boolean']['input']>;
  waitMin?: InputMaybe<Scalars['Int']['input']>;
  waitMax?: InputMaybe<Scalars['Int']['input']>;
};

export type PoliciesDummyDestroyResponse = VoidContainer | ValidationError | GenericError;

export type PoliciesEventMatcherCreateResponse = EventMatcherPolicy | ValidationError | GenericError;

/** Event Matcher Policy Serializer */
export type EventMatcherPolicyRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  /** When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged. */
  executionLogging?: InputMaybe<Scalars['Boolean']['input']>;
  action?: InputMaybe<EventActions>;
  /** Matches Event's Client IP (strict matching, for network matching use an Expression Policy) */
  clientIp?: InputMaybe<Scalars['NonEmptyString']['input']>;
  app?: InputMaybe<AppEnum>;
  model?: InputMaybe<ModelEnum>;
};

export type PoliciesEventMatcherUpdateResponse = EventMatcherPolicy | ValidationError | GenericError;

export type PoliciesEventMatcherPartialUpdateResponse = EventMatcherPolicy | ValidationError | GenericError;

/** Event Matcher Policy Serializer */
export type PatchedEventMatcherPolicyRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged. */
  executionLogging?: InputMaybe<Scalars['Boolean']['input']>;
  action?: InputMaybe<EventActions>;
  /** Matches Event's Client IP (strict matching, for network matching use an Expression Policy) */
  clientIp?: InputMaybe<Scalars['NonEmptyString']['input']>;
  app?: InputMaybe<AppEnum>;
  model?: InputMaybe<ModelEnum>;
};

export type PoliciesEventMatcherDestroyResponse = VoidContainer | ValidationError | GenericError;

export type PoliciesExpressionCreateResponse = ExpressionPolicy | ValidationError | GenericError;

/** Group Membership Policy Serializer */
export type ExpressionPolicyRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  /** When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged. */
  executionLogging?: InputMaybe<Scalars['Boolean']['input']>;
  expression: Scalars['NonEmptyString']['input'];
};

export type PoliciesExpressionUpdateResponse = ExpressionPolicy | ValidationError | GenericError;

export type PoliciesExpressionPartialUpdateResponse = ExpressionPolicy | ValidationError | GenericError;

/** Group Membership Policy Serializer */
export type PatchedExpressionPolicyRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged. */
  executionLogging?: InputMaybe<Scalars['Boolean']['input']>;
  expression?: InputMaybe<Scalars['NonEmptyString']['input']>;
};

export type PoliciesExpressionDestroyResponse = VoidContainer | ValidationError | GenericError;

export type PoliciesPasswordCreateResponse = PasswordPolicy | ValidationError | GenericError;

/** Password Policy Serializer */
export type PasswordPolicyRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  /** When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged. */
  executionLogging?: InputMaybe<Scalars['Boolean']['input']>;
  /** Field key to check, field keys defined in Prompt stages are available. */
  passwordField?: InputMaybe<Scalars['NonEmptyString']['input']>;
  amountDigits?: InputMaybe<Scalars['NonNegativeInt']['input']>;
  amountUppercase?: InputMaybe<Scalars['NonNegativeInt']['input']>;
  amountLowercase?: InputMaybe<Scalars['NonNegativeInt']['input']>;
  amountSymbols?: InputMaybe<Scalars['NonNegativeInt']['input']>;
  lengthMin?: InputMaybe<Scalars['NonNegativeInt']['input']>;
  symbolCharset?: InputMaybe<Scalars['NonEmptyString']['input']>;
  errorMessage?: InputMaybe<Scalars['String']['input']>;
  checkStaticRules?: InputMaybe<Scalars['Boolean']['input']>;
  checkHaveIBeenPwned?: InputMaybe<Scalars['Boolean']['input']>;
  checkZxcvbn?: InputMaybe<Scalars['Boolean']['input']>;
  /** How many times the password hash is allowed to be on haveibeenpwned */
  hibpAllowedCount?: InputMaybe<Scalars['NonNegativeInt']['input']>;
  /** If the zxcvbn score is equal or less than this value, the policy will fail. */
  zxcvbnScoreThreshold?: InputMaybe<Scalars['NonNegativeInt']['input']>;
};

export type PoliciesPasswordUpdateResponse = PasswordPolicy | ValidationError | GenericError;

export type PoliciesPasswordPartialUpdateResponse = PasswordPolicy | ValidationError | GenericError;

/** Password Policy Serializer */
export type PatchedPasswordPolicyRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged. */
  executionLogging?: InputMaybe<Scalars['Boolean']['input']>;
  /** Field key to check, field keys defined in Prompt stages are available. */
  passwordField?: InputMaybe<Scalars['NonEmptyString']['input']>;
  amountDigits?: InputMaybe<Scalars['NonNegativeInt']['input']>;
  amountUppercase?: InputMaybe<Scalars['NonNegativeInt']['input']>;
  amountLowercase?: InputMaybe<Scalars['NonNegativeInt']['input']>;
  amountSymbols?: InputMaybe<Scalars['NonNegativeInt']['input']>;
  lengthMin?: InputMaybe<Scalars['NonNegativeInt']['input']>;
  symbolCharset?: InputMaybe<Scalars['NonEmptyString']['input']>;
  errorMessage?: InputMaybe<Scalars['String']['input']>;
  checkStaticRules?: InputMaybe<Scalars['Boolean']['input']>;
  checkHaveIBeenPwned?: InputMaybe<Scalars['Boolean']['input']>;
  checkZxcvbn?: InputMaybe<Scalars['Boolean']['input']>;
  /** How many times the password hash is allowed to be on haveibeenpwned */
  hibpAllowedCount?: InputMaybe<Scalars['NonNegativeInt']['input']>;
  /** If the zxcvbn score is equal or less than this value, the policy will fail. */
  zxcvbnScoreThreshold?: InputMaybe<Scalars['NonNegativeInt']['input']>;
};

export type PoliciesPasswordDestroyResponse = VoidContainer | ValidationError | GenericError;

export type PoliciesPasswordExpiryCreateResponse = PasswordExpiryPolicy | ValidationError | GenericError;

/** Password Expiry Policy Serializer */
export type PasswordExpiryPolicyRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  /** When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged. */
  executionLogging?: InputMaybe<Scalars['Boolean']['input']>;
  days: Scalars['Int']['input'];
  denyOnly?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PoliciesPasswordExpiryUpdateResponse = PasswordExpiryPolicy | ValidationError | GenericError;

export type PoliciesPasswordExpiryPartialUpdateResponse = PasswordExpiryPolicy | ValidationError | GenericError;

/** Password Expiry Policy Serializer */
export type PatchedPasswordExpiryPolicyRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged. */
  executionLogging?: InputMaybe<Scalars['Boolean']['input']>;
  days?: InputMaybe<Scalars['Int']['input']>;
  denyOnly?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PoliciesPasswordExpiryDestroyResponse = VoidContainer | ValidationError | GenericError;

export type PoliciesReputationCreateResponse = ReputationPolicy | ValidationError | GenericError;

/** Reputation Policy Serializer */
export type ReputationPolicyRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  /** When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged. */
  executionLogging?: InputMaybe<Scalars['Boolean']['input']>;
  checkIp?: InputMaybe<Scalars['Boolean']['input']>;
  checkUsername?: InputMaybe<Scalars['Boolean']['input']>;
  threshold?: InputMaybe<Scalars['Int']['input']>;
};

export type PoliciesReputationUpdateResponse = ReputationPolicy | ValidationError | GenericError;

export type PoliciesReputationPartialUpdateResponse = ReputationPolicy | ValidationError | GenericError;

/** Reputation Policy Serializer */
export type PatchedReputationPolicyRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged. */
  executionLogging?: InputMaybe<Scalars['Boolean']['input']>;
  checkIp?: InputMaybe<Scalars['Boolean']['input']>;
  checkUsername?: InputMaybe<Scalars['Boolean']['input']>;
  threshold?: InputMaybe<Scalars['Int']['input']>;
};

export type PoliciesReputationDestroyResponse = VoidContainer | ValidationError | GenericError;

export type PoliciesReputationScoresDestroyResponse = VoidContainer | ValidationError | GenericError;

export type PropertymappingsAllDestroyResponse = VoidContainer | ValidationError | GenericError;

export type PropertymappingsAllTestCreateResponse = PropertyMappingTestResult | GenericError;

/** Result of a Property-mapping test */
export type PropertyMappingTestResult = {
  result: Scalars['String']['output'];
  successful: Scalars['Boolean']['output'];
};

export type PropertymappingsLdapCreateResponse = LdapPropertyMapping | ValidationError | GenericError;

/** LDAP PropertyMapping Serializer */
export type LdapPropertyMappingRequestInput = {
  /** Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update. */
  managed?: InputMaybe<Scalars['NonEmptyString']['input']>;
  name: Scalars['NonEmptyString']['input'];
  expression: Scalars['NonEmptyString']['input'];
  objectField: Scalars['NonEmptyString']['input'];
};

export type PropertymappingsLdapUpdateResponse = LdapPropertyMapping | ValidationError | GenericError;

export type PropertymappingsLdapPartialUpdateResponse = LdapPropertyMapping | ValidationError | GenericError;

/** LDAP PropertyMapping Serializer */
export type PatchedLdapPropertyMappingRequestInput = {
  /** Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update. */
  managed?: InputMaybe<Scalars['NonEmptyString']['input']>;
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  expression?: InputMaybe<Scalars['NonEmptyString']['input']>;
  objectField?: InputMaybe<Scalars['NonEmptyString']['input']>;
};

export type PropertymappingsLdapDestroyResponse = VoidContainer | ValidationError | GenericError;

export type PropertymappingsNotificationCreateResponse = NotificationWebhookMapping | ValidationError | GenericError;

/** NotificationWebhookMapping Serializer */
export type NotificationWebhookMappingRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  expression: Scalars['NonEmptyString']['input'];
};

export type PropertymappingsNotificationUpdateResponse = NotificationWebhookMapping | ValidationError | GenericError;

export type PropertymappingsNotificationPartialUpdateResponse = NotificationWebhookMapping | ValidationError | GenericError;

/** NotificationWebhookMapping Serializer */
export type PatchedNotificationWebhookMappingRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  expression?: InputMaybe<Scalars['NonEmptyString']['input']>;
};

export type PropertymappingsNotificationDestroyResponse = VoidContainer | ValidationError | GenericError;

export type PropertymappingsRacCreateResponse = RacPropertyMapping | ValidationError | GenericError;

/** RACPropertyMapping Serializer */
export type RacPropertyMappingRequestInput = {
  /** Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update. */
  managed?: InputMaybe<Scalars['NonEmptyString']['input']>;
  name: Scalars['NonEmptyString']['input'];
  expression?: InputMaybe<Scalars['String']['input']>;
  staticSettings: Scalars['JSON']['input'];
};

export type PropertymappingsRacUpdateResponse = RacPropertyMapping | ValidationError | GenericError;

export type PropertymappingsRacPartialUpdateResponse = RacPropertyMapping | ValidationError | GenericError;

/** RACPropertyMapping Serializer */
export type PatchedRacPropertyMappingRequestInput = {
  /** Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update. */
  managed?: InputMaybe<Scalars['NonEmptyString']['input']>;
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  expression?: InputMaybe<Scalars['String']['input']>;
  staticSettings?: InputMaybe<Scalars['JSON']['input']>;
};

export type PropertymappingsRacDestroyResponse = VoidContainer | ValidationError | GenericError;

export type PropertymappingsSamlCreateResponse = SamlPropertyMapping | ValidationError | GenericError;

/** SAMLPropertyMapping Serializer */
export type SamlPropertyMappingRequestInput = {
  /** Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update. */
  managed?: InputMaybe<Scalars['NonEmptyString']['input']>;
  name: Scalars['NonEmptyString']['input'];
  expression: Scalars['NonEmptyString']['input'];
  samlName: Scalars['NonEmptyString']['input'];
  friendlyName?: InputMaybe<Scalars['String']['input']>;
};

export type PropertymappingsSamlUpdateResponse = SamlPropertyMapping | ValidationError | GenericError;

export type PropertymappingsSamlPartialUpdateResponse = SamlPropertyMapping | ValidationError | GenericError;

/** SAMLPropertyMapping Serializer */
export type PatchedSamlPropertyMappingRequestInput = {
  /** Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update. */
  managed?: InputMaybe<Scalars['NonEmptyString']['input']>;
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  expression?: InputMaybe<Scalars['NonEmptyString']['input']>;
  samlName?: InputMaybe<Scalars['NonEmptyString']['input']>;
  friendlyName?: InputMaybe<Scalars['String']['input']>;
};

export type PropertymappingsSamlDestroyResponse = VoidContainer | ValidationError | GenericError;

export type PropertymappingsScimCreateResponse = ScimMapping | ValidationError | GenericError;

/** SCIMMapping Serializer */
export type ScimMappingRequestInput = {
  /** Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update. */
  managed?: InputMaybe<Scalars['NonEmptyString']['input']>;
  name: Scalars['NonEmptyString']['input'];
  expression: Scalars['NonEmptyString']['input'];
};

export type PropertymappingsScimUpdateResponse = ScimMapping | ValidationError | GenericError;

export type PropertymappingsScimPartialUpdateResponse = ScimMapping | ValidationError | GenericError;

/** SCIMMapping Serializer */
export type PatchedScimMappingRequestInput = {
  /** Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update. */
  managed?: InputMaybe<Scalars['NonEmptyString']['input']>;
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  expression?: InputMaybe<Scalars['NonEmptyString']['input']>;
};

export type PropertymappingsScimDestroyResponse = VoidContainer | ValidationError | GenericError;

export type PropertymappingsScopeCreateResponse = ScopeMapping | ValidationError | GenericError;

/** ScopeMapping Serializer */
export type ScopeMappingRequestInput = {
  /** Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update. */
  managed?: InputMaybe<Scalars['NonEmptyString']['input']>;
  name: Scalars['NonEmptyString']['input'];
  expression: Scalars['NonEmptyString']['input'];
  /** Scope name requested by the client */
  scopeName: Scalars['NonEmptyString']['input'];
  /** Description shown to the user when consenting. If left empty, the user won't be informed. */
  description?: InputMaybe<Scalars['String']['input']>;
};

export type PropertymappingsScopeUpdateResponse = ScopeMapping | ValidationError | GenericError;

export type PropertymappingsScopePartialUpdateResponse = ScopeMapping | ValidationError | GenericError;

/** ScopeMapping Serializer */
export type PatchedScopeMappingRequestInput = {
  /** Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update. */
  managed?: InputMaybe<Scalars['NonEmptyString']['input']>;
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  expression?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Scope name requested by the client */
  scopeName?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Description shown to the user when consenting. If left empty, the user won't be informed. */
  description?: InputMaybe<Scalars['String']['input']>;
};

export type PropertymappingsScopeDestroyResponse = VoidContainer | ValidationError | GenericError;

export type ProvidersAllDestroyResponse = VoidContainer | ValidationError | GenericError;

export type ProvidersLdapCreateResponse = LdapProvider | ValidationError | GenericError;

export type ProvidersLdapUpdateResponse = LdapProvider | ValidationError | GenericError;

export type ProvidersLdapPartialUpdateResponse = LdapProvider | ValidationError | GenericError;

/** LDAPProvider Serializer */
export type PatchedLdapProviderRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Flow used for authentication when the associated application is accessed by an un-authenticated user. */
  authenticationFlow?: InputMaybe<Scalars['UUID']['input']>;
  /** Flow used when authorizing this provider. */
  authorizationFlow?: InputMaybe<Scalars['UUID']['input']>;
  propertyMappings?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  /** DN under which objects are accessible. */
  baseDn?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Users in this group can do search queries. If not set, every user can execute search queries. */
  searchGroup?: InputMaybe<Scalars['UUID']['input']>;
  certificate?: InputMaybe<Scalars['UUID']['input']>;
  tlsServerName?: InputMaybe<Scalars['String']['input']>;
  /** The start for uidNumbers, this number is added to the user.pk to make sure that the numbers aren't too low for POSIX users. Default is 2000 to ensure that we don't collide with local users uidNumber */
  uidStartNumber?: InputMaybe<Scalars['Int']['input']>;
  /** The start for gidNumbers, this number is added to a number generated from the group.pk to make sure that the numbers aren't too low for POSIX groups. Default is 4000 to ensure that we don't collide with local groups or users primary groups gidNumber */
  gidStartNumber?: InputMaybe<Scalars['Int']['input']>;
  searchMode?: InputMaybe<LdapapiAccessMode>;
  bindMode?: InputMaybe<LdapapiAccessMode>;
  /** When enabled, code-based multi-factor authentication can be used by appending a semicolon and the TOTP code to the password. This should only be enabled if all users that will bind to this provider have a TOTP device configured, as otherwise a password may incorrectly be rejected if it contains a semicolon. */
  mfaSupport?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ProvidersLdapDestroyResponse = VoidContainer | ValidationError | GenericError;

export type ProvidersOauth2CreateResponse = OAuth2Provider | ValidationError | GenericError;

export type ProvidersOauth2UpdateResponse = OAuth2Provider | ValidationError | GenericError;

export type ProvidersOauth2PartialUpdateResponse = OAuth2Provider | ValidationError | GenericError;

/** OAuth2Provider Serializer */
export type PatchedOAuth2ProviderRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Flow used for authentication when the associated application is accessed by an un-authenticated user. */
  authenticationFlow?: InputMaybe<Scalars['UUID']['input']>;
  /** Flow used when authorizing this provider. */
  authorizationFlow?: InputMaybe<Scalars['UUID']['input']>;
  propertyMappings?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  clientType?: InputMaybe<ClientTypeEnum>;
  clientId?: InputMaybe<Scalars['MutationInputProvidersOauth2PartialUpdateInputClientId']['input']>;
  clientSecret?: InputMaybe<Scalars['MutationInputProvidersOauth2PartialUpdateInputClientSecret']['input']>;
  /** Access codes not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3). */
  accessCodeValidity?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3). */
  accessTokenValidity?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3). */
  refreshTokenValidity?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Include User claims from scopes in the id_token, for applications that don't access the userinfo endpoint. */
  includeClaimsInIdToken?: InputMaybe<Scalars['Boolean']['input']>;
  /** Key used to sign the tokens. Only required when JWT Algorithm is set to RS256. */
  signingKey?: InputMaybe<Scalars['UUID']['input']>;
  /** Enter each URI on a new line. */
  redirectUris?: InputMaybe<Scalars['String']['input']>;
  subMode?: InputMaybe<SubModeEnum>;
  issuerMode?: InputMaybe<IssuerModeEnum>;
  jwksSources?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
};

export type ProvidersOauth2DestroyResponse = VoidContainer | ValidationError | GenericError;

export type ProvidersProxyCreateResponse = ProxyProvider | ValidationError | GenericError;

export type ProvidersProxyUpdateResponse = ProxyProvider | ValidationError | GenericError;

export type ProvidersProxyPartialUpdateResponse = ProxyProvider | ValidationError | GenericError;

/** ProxyProvider Serializer */
export type PatchedProxyProviderRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Flow used for authentication when the associated application is accessed by an un-authenticated user. */
  authenticationFlow?: InputMaybe<Scalars['UUID']['input']>;
  /** Flow used when authorizing this provider. */
  authorizationFlow?: InputMaybe<Scalars['UUID']['input']>;
  propertyMappings?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  internalHost?: InputMaybe<Scalars['URL']['input']>;
  externalHost?: InputMaybe<Scalars['URL']['input']>;
  /** Validate SSL Certificates of upstream servers */
  internalHostSslValidation?: InputMaybe<Scalars['Boolean']['input']>;
  certificate?: InputMaybe<Scalars['UUID']['input']>;
  /** Regular expressions for which authentication is not required. Each new line is interpreted as a new Regular Expression. */
  skipPathRegex?: InputMaybe<Scalars['String']['input']>;
  /** Set a custom HTTP-Basic Authentication header based on values from authentik. */
  basicAuthEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** User/Group Attribute used for the password part of the HTTP-Basic Header. */
  basicAuthPasswordAttribute?: InputMaybe<Scalars['String']['input']>;
  /** User/Group Attribute used for the user part of the HTTP-Basic Header. If not set, the user's Email address is used. */
  basicAuthUserAttribute?: InputMaybe<Scalars['String']['input']>;
  mode?: InputMaybe<ProxyMode>;
  /** When enabled, this provider will intercept the authorization header and authenticate requests based on its value. */
  interceptHeaderAuth?: InputMaybe<Scalars['Boolean']['input']>;
  cookieDomain?: InputMaybe<Scalars['String']['input']>;
  jwksSources?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  /** Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3). */
  accessTokenValidity?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3). */
  refreshTokenValidity?: InputMaybe<Scalars['NonEmptyString']['input']>;
};

export type ProvidersProxyDestroyResponse = VoidContainer | ValidationError | GenericError;

export type ProvidersRacCreateResponse = RacProvider | ValidationError | GenericError;

export type ProvidersRacUpdateResponse = RacProvider | ValidationError | GenericError;

export type ProvidersRacPartialUpdateResponse = RacProvider | ValidationError | GenericError;

/** RACProvider Serializer */
export type PatchedRacProviderRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Flow used for authentication when the associated application is accessed by an un-authenticated user. */
  authenticationFlow?: InputMaybe<Scalars['UUID']['input']>;
  /** Flow used when authorizing this provider. */
  authorizationFlow?: InputMaybe<Scalars['UUID']['input']>;
  propertyMappings?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  settings?: InputMaybe<Scalars['JSON']['input']>;
  /** Determines how long a session lasts. Default of 0 means that the sessions lasts until the browser is closed. (Format: hours=-1;minutes=-2;seconds=-3) */
  connectionExpiry?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** When set to true, connection tokens will be deleted upon disconnect. */
  deleteTokenOnDisconnect?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ProvidersRacDestroyResponse = VoidContainer | ValidationError | GenericError;

export type ProvidersRadiusCreateResponse = RadiusProvider | ValidationError | GenericError;

export type ProvidersRadiusUpdateResponse = RadiusProvider | ValidationError | GenericError;

export type ProvidersRadiusPartialUpdateResponse = RadiusProvider | ValidationError | GenericError;

/** RadiusProvider Serializer */
export type PatchedRadiusProviderRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Flow used for authentication when the associated application is accessed by an un-authenticated user. */
  authenticationFlow?: InputMaybe<Scalars['UUID']['input']>;
  /** Flow used when authorizing this provider. */
  authorizationFlow?: InputMaybe<Scalars['UUID']['input']>;
  propertyMappings?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  /** List of CIDRs (comma-separated) that clients can connect from. A more specific CIDR will match before a looser one. Clients connecting from a non-specified CIDR will be dropped. */
  clientNetworks?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Shared secret between clients and server to hash packets. */
  sharedSecret?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** When enabled, code-based multi-factor authentication can be used by appending a semicolon and the TOTP code to the password. This should only be enabled if all users that will bind to this provider have a TOTP device configured, as otherwise a password may incorrectly be rejected if it contains a semicolon. */
  mfaSupport?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ProvidersRadiusDestroyResponse = VoidContainer | ValidationError | GenericError;

export type ProvidersSamlCreateResponse = SamlProvider | ValidationError | GenericError;

export type ProvidersSamlUpdateResponse = SamlProvider | ValidationError | GenericError;

export type ProvidersSamlPartialUpdateResponse = SamlProvider | ValidationError | GenericError;

/** SAMLProvider Serializer */
export type PatchedSamlProviderRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Flow used for authentication when the associated application is accessed by an un-authenticated user. */
  authenticationFlow?: InputMaybe<Scalars['UUID']['input']>;
  /** Flow used when authorizing this provider. */
  authorizationFlow?: InputMaybe<Scalars['UUID']['input']>;
  propertyMappings?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  acsUrl?: InputMaybe<Scalars['URL']['input']>;
  /** Value of the audience restriction field of the assertion. When left empty, no audience restriction will be added. */
  audience?: InputMaybe<Scalars['String']['input']>;
  /** Also known as EntityID */
  issuer?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Assertion valid not before current time + this value (Format: hours=-1;minutes=-2;seconds=-3). */
  assertionValidNotBefore?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Assertion not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3). */
  assertionValidNotOnOrAfter?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Session not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3). */
  sessionValidNotOnOrAfter?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Configure how the NameID value will be created. When left empty, the NameIDPolicy of the incoming request will be considered */
  nameIdMapping?: InputMaybe<Scalars['UUID']['input']>;
  digestAlgorithm?: InputMaybe<DigestAlgorithmEnum>;
  signatureAlgorithm?: InputMaybe<SignatureAlgorithmEnum>;
  /** Keypair used to sign outgoing Responses going to the Service Provider. */
  signingKp?: InputMaybe<Scalars['UUID']['input']>;
  /** When selected, incoming assertion's Signatures will be validated against this certificate. To allow unsigned Requests, leave on default. */
  verificationKp?: InputMaybe<Scalars['UUID']['input']>;
  /** This determines how authentik sends the response back to the Service Provider. */
  spBinding?: InputMaybe<Scalars['JSON']['input']>;
  /** Default relay_state value for IDP-initiated logins */
  defaultRelayState?: InputMaybe<Scalars['String']['input']>;
};

export type ProvidersSamlDestroyResponse = VoidContainer | ValidationError | GenericError;

export type ProvidersSamlImportMetadataCreateResponse = VoidContainer | GenericError;

/** Import saml provider from XML Metadata */
export type SamlProviderImportRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  authorizationFlow: Scalars['UUID']['input'];
  file: Scalars['File']['input'];
};

export type ProvidersScimCreateResponse = ScimProvider | ValidationError | GenericError;

export type ProvidersScimUpdateResponse = ScimProvider | ValidationError | GenericError;

export type ProvidersScimPartialUpdateResponse = ScimProvider | ValidationError | GenericError;

/** SCIMProvider Serializer */
export type PatchedScimProviderRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  propertyMappings?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  /** Property mappings used for group creation/updating. */
  propertyMappingsGroup?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  /** Base URL to SCIM requests, usually ends in /v2 */
  url?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Authentication token */
  token?: InputMaybe<Scalars['NonEmptyString']['input']>;
  excludeUsersServiceAccount?: InputMaybe<Scalars['Boolean']['input']>;
  filterGroup?: InputMaybe<Scalars['UUID']['input']>;
};

export type ProvidersScimDestroyResponse = VoidContainer | ValidationError | GenericError;

export type RacConnectionTokensUpdateResponse = ConnectionToken | ValidationError | GenericError;

/** ConnectionToken Serializer */
export type ConnectionTokenRequestInput = {
  pk?: InputMaybe<Scalars['UUID']['input']>;
  provider: Scalars['Int']['input'];
  endpoint: Scalars['UUID']['input'];
};

export type RacConnectionTokensPartialUpdateResponse = ConnectionToken | ValidationError | GenericError;

/** ConnectionToken Serializer */
export type PatchedConnectionTokenRequestInput = {
  pk?: InputMaybe<Scalars['UUID']['input']>;
  provider?: InputMaybe<Scalars['Int']['input']>;
  endpoint?: InputMaybe<Scalars['UUID']['input']>;
};

export type RacConnectionTokensDestroyResponse = VoidContainer | ValidationError | GenericError;

export type RacEndpointsCreateResponse = Endpoint | ValidationError | GenericError;

/** Endpoint Serializer */
export type EndpointRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  provider: Scalars['Int']['input'];
  protocol: ProtocolEnum;
  host: Scalars['NonEmptyString']['input'];
  settings?: InputMaybe<Scalars['JSON']['input']>;
  propertyMappings?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  authMode: AuthModeEnum;
  maximumConnections?: InputMaybe<Scalars['Int']['input']>;
};

export type RacEndpointsUpdateResponse = Endpoint | ValidationError | GenericError;

export type RacEndpointsPartialUpdateResponse = Endpoint | ValidationError | GenericError;

/** Endpoint Serializer */
export type PatchedEndpointRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  provider?: InputMaybe<Scalars['Int']['input']>;
  protocol?: InputMaybe<ProtocolEnum>;
  host?: InputMaybe<Scalars['NonEmptyString']['input']>;
  settings?: InputMaybe<Scalars['JSON']['input']>;
  propertyMappings?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  authMode?: InputMaybe<AuthModeEnum>;
  maximumConnections?: InputMaybe<Scalars['Int']['input']>;
};

export type RacEndpointsDestroyResponse = VoidContainer | ValidationError | GenericError;

export type RbacPermissionsAssignedByRolesAssignCreateResponse = VoidContainer | ValidationError | GenericError;

/** Request to assign a new permission */
export type PermissionAssignRequestInput = {
  permissions: Array<InputMaybe<Scalars['NonEmptyString']['input']>>;
  model?: InputMaybe<ModelEnum>;
  objectPk?: InputMaybe<Scalars['NonEmptyString']['input']>;
};

export type RbacPermissionsAssignedByRolesUnassignPartialUpdateResponse = VoidContainer | ValidationError | GenericError;

/** Request to assign a new permission */
export type PatchedPermissionAssignRequestInput = {
  permissions?: InputMaybe<Array<InputMaybe<Scalars['NonEmptyString']['input']>>>;
  model?: InputMaybe<ModelEnum>;
  objectPk?: InputMaybe<Scalars['NonEmptyString']['input']>;
};

export type RbacPermissionsAssignedByUsersAssignCreateResponse = VoidContainer | ValidationError | GenericError;

export type RbacPermissionsAssignedByUsersUnassignPartialUpdateResponse = VoidContainer | ValidationError | GenericError;

export type RbacRolesCreateResponse = Role | ValidationError | GenericError;

/** Role serializer */
export type RoleRequestInput = {
  name: Scalars['MutationInputRbacRolesCreateInputName']['input'];
};

export type RbacRolesUpdateResponse = Role | ValidationError | GenericError;

export type RbacRolesPartialUpdateResponse = Role | ValidationError | GenericError;

/** Role serializer */
export type PatchedRoleRequestInput = {
  name?: InputMaybe<Scalars['MutationInputRbacRolesPartialUpdateInputName']['input']>;
};

export type RbacRolesDestroyResponse = VoidContainer | ValidationError | GenericError;

export type SourcesAllDestroyResponse = VoidContainer | ValidationError | GenericError;

export type SourcesLdapCreateResponse = LdapSource | ValidationError | GenericError;

/** LDAP Source Serializer */
export type LdapSourceRequestInput = {
  /** Source's display Name. */
  name: Scalars['NonEmptyString']['input'];
  slug: Scalars['MutationInputSourcesLdapCreateInputSlug']['input'];
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Flow to use when authenticating existing users. */
  authenticationFlow?: InputMaybe<Scalars['UUID']['input']>;
  /** Flow to use when enrolling new users. */
  enrollmentFlow?: InputMaybe<Scalars['UUID']['input']>;
  policyEngineMode?: InputMaybe<PolicyEngineMode>;
  userMatchingMode?: InputMaybe<UserMatchingModeEnum>;
  userPathTemplate?: InputMaybe<Scalars['NonEmptyString']['input']>;
  serverUri: Scalars['URL']['input'];
  /** Optionally verify the LDAP Server's Certificate against the CA Chain in this keypair. */
  peerCertificate?: InputMaybe<Scalars['UUID']['input']>;
  /** Client certificate to authenticate against the LDAP Server's Certificate. */
  clientCertificate?: InputMaybe<Scalars['UUID']['input']>;
  bindCn?: InputMaybe<Scalars['String']['input']>;
  bindPassword?: InputMaybe<Scalars['String']['input']>;
  startTls?: InputMaybe<Scalars['Boolean']['input']>;
  sni?: InputMaybe<Scalars['Boolean']['input']>;
  baseDn: Scalars['NonEmptyString']['input'];
  /** Prepended to Base DN for User-queries. */
  additionalUserDn?: InputMaybe<Scalars['String']['input']>;
  /** Prepended to Base DN for Group-queries. */
  additionalGroupDn?: InputMaybe<Scalars['String']['input']>;
  /** Consider Objects matching this filter to be Users. */
  userObjectFilter?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Consider Objects matching this filter to be Groups. */
  groupObjectFilter?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Field which contains members of a group. */
  groupMembershipField?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Field which contains a unique Identifier. */
  objectUniquenessField?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Update internal authentik password when login succeeds with LDAP */
  passwordLoginUpdateInternalPassword?: InputMaybe<Scalars['Boolean']['input']>;
  syncUsers?: InputMaybe<Scalars['Boolean']['input']>;
  /** When a user changes their password, sync it back to LDAP. This can only be enabled on a single LDAP source. */
  syncUsersPassword?: InputMaybe<Scalars['Boolean']['input']>;
  syncGroups?: InputMaybe<Scalars['Boolean']['input']>;
  syncParentGroup?: InputMaybe<Scalars['UUID']['input']>;
  propertyMappings?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  /** Property mappings used for group creation/updating. */
  propertyMappingsGroup?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
};

export type SourcesLdapUpdateResponse = LdapSource | ValidationError | GenericError;

export type SourcesLdapPartialUpdateResponse = LdapSource | ValidationError | GenericError;

/** LDAP Source Serializer */
export type PatchedLdapSourceRequestInput = {
  /** Source's display Name. */
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  slug?: InputMaybe<Scalars['MutationInputSourcesLdapPartialUpdateInputSlug']['input']>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Flow to use when authenticating existing users. */
  authenticationFlow?: InputMaybe<Scalars['UUID']['input']>;
  /** Flow to use when enrolling new users. */
  enrollmentFlow?: InputMaybe<Scalars['UUID']['input']>;
  policyEngineMode?: InputMaybe<PolicyEngineMode>;
  userMatchingMode?: InputMaybe<UserMatchingModeEnum>;
  userPathTemplate?: InputMaybe<Scalars['NonEmptyString']['input']>;
  serverUri?: InputMaybe<Scalars['URL']['input']>;
  /** Optionally verify the LDAP Server's Certificate against the CA Chain in this keypair. */
  peerCertificate?: InputMaybe<Scalars['UUID']['input']>;
  /** Client certificate to authenticate against the LDAP Server's Certificate. */
  clientCertificate?: InputMaybe<Scalars['UUID']['input']>;
  bindCn?: InputMaybe<Scalars['String']['input']>;
  bindPassword?: InputMaybe<Scalars['String']['input']>;
  startTls?: InputMaybe<Scalars['Boolean']['input']>;
  sni?: InputMaybe<Scalars['Boolean']['input']>;
  baseDn?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Prepended to Base DN for User-queries. */
  additionalUserDn?: InputMaybe<Scalars['String']['input']>;
  /** Prepended to Base DN for Group-queries. */
  additionalGroupDn?: InputMaybe<Scalars['String']['input']>;
  /** Consider Objects matching this filter to be Users. */
  userObjectFilter?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Consider Objects matching this filter to be Groups. */
  groupObjectFilter?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Field which contains members of a group. */
  groupMembershipField?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Field which contains a unique Identifier. */
  objectUniquenessField?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Update internal authentik password when login succeeds with LDAP */
  passwordLoginUpdateInternalPassword?: InputMaybe<Scalars['Boolean']['input']>;
  syncUsers?: InputMaybe<Scalars['Boolean']['input']>;
  /** When a user changes their password, sync it back to LDAP. This can only be enabled on a single LDAP source. */
  syncUsersPassword?: InputMaybe<Scalars['Boolean']['input']>;
  syncGroups?: InputMaybe<Scalars['Boolean']['input']>;
  syncParentGroup?: InputMaybe<Scalars['UUID']['input']>;
  propertyMappings?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  /** Property mappings used for group creation/updating. */
  propertyMappingsGroup?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
};

export type SourcesLdapDestroyResponse = VoidContainer | ValidationError | GenericError;

export type SourcesOauthCreateResponse = OAuthSource | ValidationError | GenericError;

/** OAuth Source Serializer */
export type OAuthSourceRequestInput = {
  /** Source's display Name. */
  name: Scalars['NonEmptyString']['input'];
  slug: Scalars['MutationInputSourcesOauthCreateInputSlug']['input'];
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Flow to use when authenticating existing users. */
  authenticationFlow?: InputMaybe<Scalars['UUID']['input']>;
  /** Flow to use when enrolling new users. */
  enrollmentFlow?: InputMaybe<Scalars['UUID']['input']>;
  policyEngineMode?: InputMaybe<PolicyEngineMode>;
  userMatchingMode?: InputMaybe<UserMatchingModeEnum>;
  userPathTemplate?: InputMaybe<Scalars['NonEmptyString']['input']>;
  providerType: ProviderTypeEnum;
  /** URL used to request the initial token. This URL is only required for OAuth 1. */
  requestTokenUrl?: InputMaybe<Scalars['MutationInputSourcesOauthCreateInputRequestTokenUrl']['input']>;
  /** URL the user is redirect to to conest the flow. */
  authorizationUrl?: InputMaybe<Scalars['MutationInputSourcesOauthCreateInputAuthorizationUrl']['input']>;
  /** URL used by authentik to retrieve tokens. */
  accessTokenUrl?: InputMaybe<Scalars['MutationInputSourcesOauthCreateInputAccessTokenUrl']['input']>;
  /** URL used by authentik to get user information. */
  profileUrl?: InputMaybe<Scalars['MutationInputSourcesOauthCreateInputProfileUrl']['input']>;
  consumerKey: Scalars['NonEmptyString']['input'];
  consumerSecret: Scalars['NonEmptyString']['input'];
  additionalScopes?: InputMaybe<Scalars['String']['input']>;
  oidcWellKnownUrl?: InputMaybe<Scalars['String']['input']>;
  oidcJwksUrl?: InputMaybe<Scalars['String']['input']>;
  oidcJwks?: InputMaybe<Scalars['JSON']['input']>;
};

export type SourcesOauthUpdateResponse = OAuthSource | ValidationError | GenericError;

export type SourcesOauthPartialUpdateResponse = OAuthSource | ValidationError | GenericError;

/** OAuth Source Serializer */
export type PatchedOAuthSourceRequestInput = {
  /** Source's display Name. */
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  slug?: InputMaybe<Scalars['MutationInputSourcesOauthPartialUpdateInputSlug']['input']>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Flow to use when authenticating existing users. */
  authenticationFlow?: InputMaybe<Scalars['UUID']['input']>;
  /** Flow to use when enrolling new users. */
  enrollmentFlow?: InputMaybe<Scalars['UUID']['input']>;
  policyEngineMode?: InputMaybe<PolicyEngineMode>;
  userMatchingMode?: InputMaybe<UserMatchingModeEnum>;
  userPathTemplate?: InputMaybe<Scalars['NonEmptyString']['input']>;
  providerType?: InputMaybe<ProviderTypeEnum>;
  /** URL used to request the initial token. This URL is only required for OAuth 1. */
  requestTokenUrl?: InputMaybe<Scalars['MutationInputSourcesOauthPartialUpdateInputRequestTokenUrl']['input']>;
  /** URL the user is redirect to to conest the flow. */
  authorizationUrl?: InputMaybe<Scalars['MutationInputSourcesOauthPartialUpdateInputAuthorizationUrl']['input']>;
  /** URL used by authentik to retrieve tokens. */
  accessTokenUrl?: InputMaybe<Scalars['MutationInputSourcesOauthPartialUpdateInputAccessTokenUrl']['input']>;
  /** URL used by authentik to get user information. */
  profileUrl?: InputMaybe<Scalars['MutationInputSourcesOauthPartialUpdateInputProfileUrl']['input']>;
  consumerKey?: InputMaybe<Scalars['NonEmptyString']['input']>;
  consumerSecret?: InputMaybe<Scalars['NonEmptyString']['input']>;
  additionalScopes?: InputMaybe<Scalars['String']['input']>;
  oidcWellKnownUrl?: InputMaybe<Scalars['String']['input']>;
  oidcJwksUrl?: InputMaybe<Scalars['String']['input']>;
  oidcJwks?: InputMaybe<Scalars['JSON']['input']>;
};

export type SourcesOauthDestroyResponse = VoidContainer | ValidationError | GenericError;

export type SourcesPlexCreateResponse = PlexSource | ValidationError | GenericError;

/** Plex Source Serializer */
export type PlexSourceRequestInput = {
  /** Source's display Name. */
  name: Scalars['NonEmptyString']['input'];
  slug: Scalars['MutationInputSourcesPlexCreateInputSlug']['input'];
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Flow to use when authenticating existing users. */
  authenticationFlow?: InputMaybe<Scalars['UUID']['input']>;
  /** Flow to use when enrolling new users. */
  enrollmentFlow?: InputMaybe<Scalars['UUID']['input']>;
  policyEngineMode?: InputMaybe<PolicyEngineMode>;
  userMatchingMode?: InputMaybe<UserMatchingModeEnum>;
  userPathTemplate?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Client identifier used to talk to Plex. */
  clientId?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Which servers a user has to be a member of to be granted access. Empty list allows every server. */
  allowedServers?: InputMaybe<Array<InputMaybe<Scalars['NonEmptyString']['input']>>>;
  /** Allow friends to authenticate, even if you don't share a server. */
  allowFriends?: InputMaybe<Scalars['Boolean']['input']>;
  /** Plex token used to check friends */
  plexToken: Scalars['NonEmptyString']['input'];
};

export type SourcesPlexUpdateResponse = PlexSource | ValidationError | GenericError;

export type SourcesPlexPartialUpdateResponse = PlexSource | ValidationError | GenericError;

/** Plex Source Serializer */
export type PatchedPlexSourceRequestInput = {
  /** Source's display Name. */
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  slug?: InputMaybe<Scalars['MutationInputSourcesPlexPartialUpdateInputSlug']['input']>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Flow to use when authenticating existing users. */
  authenticationFlow?: InputMaybe<Scalars['UUID']['input']>;
  /** Flow to use when enrolling new users. */
  enrollmentFlow?: InputMaybe<Scalars['UUID']['input']>;
  policyEngineMode?: InputMaybe<PolicyEngineMode>;
  userMatchingMode?: InputMaybe<UserMatchingModeEnum>;
  userPathTemplate?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Client identifier used to talk to Plex. */
  clientId?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Which servers a user has to be a member of to be granted access. Empty list allows every server. */
  allowedServers?: InputMaybe<Array<InputMaybe<Scalars['NonEmptyString']['input']>>>;
  /** Allow friends to authenticate, even if you don't share a server. */
  allowFriends?: InputMaybe<Scalars['Boolean']['input']>;
  /** Plex token used to check friends */
  plexToken?: InputMaybe<Scalars['NonEmptyString']['input']>;
};

export type SourcesPlexDestroyResponse = VoidContainer | ValidationError | GenericError;

/** Serializer to redeem a plex token */
export type PlexTokenRedeemRequestInput = {
  plexToken: Scalars['NonEmptyString']['input'];
};

export type SourcesSamlCreateResponse = SamlSource | ValidationError | GenericError;

/** SAMLSource Serializer */
export type SamlSourceRequestInput = {
  /** Source's display Name. */
  name: Scalars['NonEmptyString']['input'];
  slug: Scalars['MutationInputSourcesSamlCreateInputSlug']['input'];
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Flow to use when authenticating existing users. */
  authenticationFlow?: InputMaybe<Scalars['UUID']['input']>;
  /** Flow to use when enrolling new users. */
  enrollmentFlow?: InputMaybe<Scalars['UUID']['input']>;
  policyEngineMode?: InputMaybe<PolicyEngineMode>;
  userMatchingMode?: InputMaybe<UserMatchingModeEnum>;
  userPathTemplate?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Flow used before authentication. */
  preAuthenticationFlow: Scalars['UUID']['input'];
  /** Also known as Entity ID. Defaults the Metadata URL. */
  issuer?: InputMaybe<Scalars['String']['input']>;
  /** URL that the initial Login request is sent to. */
  ssoUrl: Scalars['URL']['input'];
  /** Optional URL if your IDP supports Single-Logout. */
  sloUrl?: InputMaybe<Scalars['URL']['input']>;
  /** Allows authentication flows initiated by the IdP. This can be a security risk, as no validation of the request ID is done. */
  allowIdpInitiated?: InputMaybe<Scalars['Boolean']['input']>;
  nameIdPolicy?: InputMaybe<NameIdPolicyEnum>;
  bindingType?: InputMaybe<BindingTypeEnum>;
  /** When selected, incoming assertion's Signatures will be validated against this certificate. To allow unsigned Requests, leave on default. */
  verificationKp?: InputMaybe<Scalars['UUID']['input']>;
  /** Keypair used to sign outgoing Responses going to the Identity Provider. */
  signingKp?: InputMaybe<Scalars['UUID']['input']>;
  digestAlgorithm?: InputMaybe<DigestAlgorithmEnum>;
  signatureAlgorithm?: InputMaybe<SignatureAlgorithmEnum>;
  /** Time offset when temporary users should be deleted. This only applies if your IDP uses the NameID Format 'transient', and the user doesn't log out manually. (Format: hours=1;minutes=2;seconds=3). */
  temporaryUserDeleteAfter?: InputMaybe<Scalars['NonEmptyString']['input']>;
};

export type SourcesSamlUpdateResponse = SamlSource | ValidationError | GenericError;

export type SourcesSamlPartialUpdateResponse = SamlSource | ValidationError | GenericError;

/** SAMLSource Serializer */
export type PatchedSamlSourceRequestInput = {
  /** Source's display Name. */
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  slug?: InputMaybe<Scalars['MutationInputSourcesSamlPartialUpdateInputSlug']['input']>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Flow to use when authenticating existing users. */
  authenticationFlow?: InputMaybe<Scalars['UUID']['input']>;
  /** Flow to use when enrolling new users. */
  enrollmentFlow?: InputMaybe<Scalars['UUID']['input']>;
  policyEngineMode?: InputMaybe<PolicyEngineMode>;
  userMatchingMode?: InputMaybe<UserMatchingModeEnum>;
  userPathTemplate?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Flow used before authentication. */
  preAuthenticationFlow?: InputMaybe<Scalars['UUID']['input']>;
  /** Also known as Entity ID. Defaults the Metadata URL. */
  issuer?: InputMaybe<Scalars['String']['input']>;
  /** URL that the initial Login request is sent to. */
  ssoUrl?: InputMaybe<Scalars['URL']['input']>;
  /** Optional URL if your IDP supports Single-Logout. */
  sloUrl?: InputMaybe<Scalars['URL']['input']>;
  /** Allows authentication flows initiated by the IdP. This can be a security risk, as no validation of the request ID is done. */
  allowIdpInitiated?: InputMaybe<Scalars['Boolean']['input']>;
  nameIdPolicy?: InputMaybe<NameIdPolicyEnum>;
  bindingType?: InputMaybe<BindingTypeEnum>;
  /** When selected, incoming assertion's Signatures will be validated against this certificate. To allow unsigned Requests, leave on default. */
  verificationKp?: InputMaybe<Scalars['UUID']['input']>;
  /** Keypair used to sign outgoing Responses going to the Identity Provider. */
  signingKp?: InputMaybe<Scalars['UUID']['input']>;
  digestAlgorithm?: InputMaybe<DigestAlgorithmEnum>;
  signatureAlgorithm?: InputMaybe<SignatureAlgorithmEnum>;
  /** Time offset when temporary users should be deleted. This only applies if your IDP uses the NameID Format 'transient', and the user doesn't log out manually. (Format: hours=1;minutes=2;seconds=3). */
  temporaryUserDeleteAfter?: InputMaybe<Scalars['NonEmptyString']['input']>;
};

export type SourcesSamlDestroyResponse = VoidContainer | ValidationError | GenericError;

export type SourcesScimCreateResponse = ScimSource | ValidationError | GenericError;

/** SCIMSource Serializer */
export type ScimSourceRequestInput = {
  /** Source's display Name. */
  name: Scalars['NonEmptyString']['input'];
  slug: Scalars['MutationInputSourcesScimCreateInputSlug']['input'];
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  userMatchingMode?: InputMaybe<UserMatchingModeEnum>;
  userPathTemplate?: InputMaybe<Scalars['NonEmptyString']['input']>;
};

export type SourcesScimUpdateResponse = ScimSource | ValidationError | GenericError;

export type SourcesScimPartialUpdateResponse = ScimSource | ValidationError | GenericError;

/** SCIMSource Serializer */
export type PatchedScimSourceRequestInput = {
  /** Source's display Name. */
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  slug?: InputMaybe<Scalars['MutationInputSourcesScimPartialUpdateInputSlug']['input']>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  userMatchingMode?: InputMaybe<UserMatchingModeEnum>;
  userPathTemplate?: InputMaybe<Scalars['NonEmptyString']['input']>;
};

export type SourcesScimDestroyResponse = VoidContainer | ValidationError | GenericError;

export type SourcesScimGroupsCreateResponse = ScimSourceGroup | ValidationError | GenericError;

/** SCIMSourceGroup Serializer */
export type ScimSourceGroupRequestInput = {
  id: Scalars['NonEmptyString']['input'];
  group: Scalars['UUID']['input'];
  source: Scalars['UUID']['input'];
  attributes?: InputMaybe<Scalars['JSON']['input']>;
};

export type SourcesScimGroupsUpdateResponse = ScimSourceGroup | ValidationError | GenericError;

export type SourcesScimGroupsPartialUpdateResponse = ScimSourceGroup | ValidationError | GenericError;

/** SCIMSourceGroup Serializer */
export type PatchedScimSourceGroupRequestInput = {
  id?: InputMaybe<Scalars['NonEmptyString']['input']>;
  group?: InputMaybe<Scalars['UUID']['input']>;
  source?: InputMaybe<Scalars['UUID']['input']>;
  attributes?: InputMaybe<Scalars['JSON']['input']>;
};

export type SourcesScimGroupsDestroyResponse = VoidContainer | ValidationError | GenericError;

export type SourcesScimUsersCreateResponse = ScimSourceUser | ValidationError | GenericError;

/** SCIMSourceUser Serializer */
export type ScimSourceUserRequestInput = {
  id: Scalars['NonEmptyString']['input'];
  user: Scalars['Int']['input'];
  source: Scalars['UUID']['input'];
  attributes?: InputMaybe<Scalars['JSON']['input']>;
};

export type SourcesScimUsersUpdateResponse = ScimSourceUser | ValidationError | GenericError;

export type SourcesScimUsersPartialUpdateResponse = ScimSourceUser | ValidationError | GenericError;

/** SCIMSourceUser Serializer */
export type PatchedScimSourceUserRequestInput = {
  id?: InputMaybe<Scalars['NonEmptyString']['input']>;
  user?: InputMaybe<Scalars['Int']['input']>;
  source?: InputMaybe<Scalars['UUID']['input']>;
  attributes?: InputMaybe<Scalars['JSON']['input']>;
};

export type SourcesScimUsersDestroyResponse = VoidContainer | ValidationError | GenericError;

export type SourcesUserConnectionsAllUpdateResponse = UserSourceConnection | ValidationError | GenericError;

export type SourcesUserConnectionsAllPartialUpdateResponse = UserSourceConnection | ValidationError | GenericError;

export type SourcesUserConnectionsAllDestroyResponse = VoidContainer | ValidationError | GenericError;

export type SourcesUserConnectionsOauthCreateResponse = UserOAuthSourceConnection | ValidationError | GenericError;

/** OAuth Source Serializer */
export type UserOAuthSourceConnectionRequestInput = {
  user: Scalars['Int']['input'];
  identifier: Scalars['MutationInputSourcesUserConnectionsOauthCreateInputIdentifier']['input'];
  accessToken?: InputMaybe<Scalars['String']['input']>;
};

export type SourcesUserConnectionsOauthUpdateResponse = UserOAuthSourceConnection | ValidationError | GenericError;

export type SourcesUserConnectionsOauthPartialUpdateResponse = UserOAuthSourceConnection | ValidationError | GenericError;

/** OAuth Source Serializer */
export type PatchedUserOAuthSourceConnectionRequestInput = {
  user?: InputMaybe<Scalars['Int']['input']>;
  identifier?: InputMaybe<Scalars['MutationInputSourcesUserConnectionsOauthPartialUpdateInputIdentifier']['input']>;
  accessToken?: InputMaybe<Scalars['String']['input']>;
};

export type SourcesUserConnectionsOauthDestroyResponse = VoidContainer | ValidationError | GenericError;

export type SourcesUserConnectionsPlexCreateResponse = PlexSourceConnection | ValidationError | GenericError;

/** Plex Source connection Serializer */
export type PlexSourceConnectionRequestInput = {
  identifier: Scalars['NonEmptyString']['input'];
  plexToken: Scalars['NonEmptyString']['input'];
};

export type SourcesUserConnectionsPlexUpdateResponse = PlexSourceConnection | ValidationError | GenericError;

export type SourcesUserConnectionsPlexPartialUpdateResponse = PlexSourceConnection | ValidationError | GenericError;

/** Plex Source connection Serializer */
export type PatchedPlexSourceConnectionRequestInput = {
  identifier?: InputMaybe<Scalars['NonEmptyString']['input']>;
  plexToken?: InputMaybe<Scalars['NonEmptyString']['input']>;
};

export type SourcesUserConnectionsPlexDestroyResponse = VoidContainer | ValidationError | GenericError;

export type SourcesUserConnectionsSamlCreateResponse = UserSamlSourceConnection | ValidationError | GenericError;

/** SAML Source Serializer */
export type UserSamlSourceConnectionRequestInput = {
  user: Scalars['Int']['input'];
  identifier: Scalars['NonEmptyString']['input'];
};

export type SourcesUserConnectionsSamlUpdateResponse = UserSamlSourceConnection | ValidationError | GenericError;

export type SourcesUserConnectionsSamlPartialUpdateResponse = UserSamlSourceConnection | ValidationError | GenericError;

/** SAML Source Serializer */
export type PatchedUserSamlSourceConnectionRequestInput = {
  user?: InputMaybe<Scalars['Int']['input']>;
  identifier?: InputMaybe<Scalars['NonEmptyString']['input']>;
};

export type SourcesUserConnectionsSamlDestroyResponse = VoidContainer | ValidationError | GenericError;

export type StagesAllDestroyResponse = VoidContainer | ValidationError | GenericError;

export type StagesAuthenticatorDuoCreateResponse = AuthenticatorDuoStage | ValidationError | GenericError;

/** AuthenticatorDuoStage Serializer */
export type AuthenticatorDuoStageRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  flowSet?: InputMaybe<Array<InputMaybe<FlowSetRequestInput>>>;
  /** Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage. */
  configureFlow?: InputMaybe<Scalars['UUID']['input']>;
  friendlyName?: InputMaybe<Scalars['NonEmptyString']['input']>;
  clientId: Scalars['NonEmptyString']['input'];
  clientSecret: Scalars['NonEmptyString']['input'];
  apiHostname: Scalars['NonEmptyString']['input'];
  adminIntegrationKey?: InputMaybe<Scalars['String']['input']>;
  adminSecretKey?: InputMaybe<Scalars['String']['input']>;
};

/** Stripped down flow serializer */
export type FlowSetRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  slug: Scalars['MutationInputStagesAuthenticatorDuoCreateInputFlowSetItemsSlug']['input'];
  /** Shown as the Title in Flow pages. */
  title: Scalars['NonEmptyString']['input'];
  designation: FlowDesignationEnum;
  policyEngineMode?: InputMaybe<PolicyEngineMode>;
  /** Enable compatibility mode, increases compatibility with password managers on mobile devices. */
  compatibilityMode?: InputMaybe<Scalars['Boolean']['input']>;
  layout?: InputMaybe<FlowLayoutEnum>;
  deniedAction?: InputMaybe<DeniedActionEnum>;
};

export type StagesAuthenticatorDuoUpdateResponse = AuthenticatorDuoStage | ValidationError | GenericError;

export type StagesAuthenticatorDuoPartialUpdateResponse = AuthenticatorDuoStage | ValidationError | GenericError;

/** AuthenticatorDuoStage Serializer */
export type PatchedAuthenticatorDuoStageRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  flowSet?: InputMaybe<Array<InputMaybe<FlowSetRequestInput>>>;
  /** Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage. */
  configureFlow?: InputMaybe<Scalars['UUID']['input']>;
  friendlyName?: InputMaybe<Scalars['NonEmptyString']['input']>;
  clientId?: InputMaybe<Scalars['NonEmptyString']['input']>;
  clientSecret?: InputMaybe<Scalars['NonEmptyString']['input']>;
  apiHostname?: InputMaybe<Scalars['NonEmptyString']['input']>;
  adminIntegrationKey?: InputMaybe<Scalars['String']['input']>;
  adminSecretKey?: InputMaybe<Scalars['String']['input']>;
};

export type StagesAuthenticatorDuoDestroyResponse = VoidContainer | ValidationError | GenericError;

export type StagesAuthenticatorDuoEnrollmentStatusCreateResponse = DuoDeviceEnrollmentStatus | ValidationError | GenericError;

export type DuoDeviceEnrollmentStatus = {
  duoResponse: DuoResponseEnum;
};

export type DuoResponseEnum =
  | 'SUCCESS'
  | 'WAITING'
  | 'INVALID';

export type StagesAuthenticatorDuoImportDeviceManualCreateResponse = VoidContainer | GenericError;

export type AuthenticatorDuoStageManualDeviceImportRequestInput = {
  duoUserId: Scalars['NonEmptyString']['input'];
  username: Scalars['NonEmptyString']['input'];
};

export type StagesAuthenticatorDuoImportDevicesAutomaticCreateResponse = AuthenticatorDuoStageDeviceImportResponse | GenericError;

export type AuthenticatorDuoStageDeviceImportResponse = {
  count: Scalars['Int']['output'];
  error: Scalars['String']['output'];
};

export type StagesAuthenticatorSmsCreateResponse = AuthenticatorSmsStage | ValidationError | GenericError;

/** AuthenticatorSMSStage Serializer */
export type AuthenticatorSmsStageRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  flowSet?: InputMaybe<Array<InputMaybe<FlowSetRequestInput>>>;
  /** Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage. */
  configureFlow?: InputMaybe<Scalars['UUID']['input']>;
  friendlyName?: InputMaybe<Scalars['NonEmptyString']['input']>;
  provider: ProviderEnum;
  fromNumber: Scalars['NonEmptyString']['input'];
  accountSid: Scalars['NonEmptyString']['input'];
  auth: Scalars['NonEmptyString']['input'];
  authPassword?: InputMaybe<Scalars['String']['input']>;
  authType?: InputMaybe<AuthTypeEnum>;
  /** When enabled, the Phone number is only used during enrollment to verify the users authenticity. Only a hash of the phone number is saved to ensure it is not reused in the future. */
  verifyOnly?: InputMaybe<Scalars['Boolean']['input']>;
  /** Optionally modify the payload being sent to custom providers. */
  mapping?: InputMaybe<Scalars['UUID']['input']>;
};

export type StagesAuthenticatorSmsUpdateResponse = AuthenticatorSmsStage | ValidationError | GenericError;

export type StagesAuthenticatorSmsPartialUpdateResponse = AuthenticatorSmsStage | ValidationError | GenericError;

/** AuthenticatorSMSStage Serializer */
export type PatchedAuthenticatorSmsStageRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  flowSet?: InputMaybe<Array<InputMaybe<FlowSetRequestInput>>>;
  /** Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage. */
  configureFlow?: InputMaybe<Scalars['UUID']['input']>;
  friendlyName?: InputMaybe<Scalars['NonEmptyString']['input']>;
  provider?: InputMaybe<ProviderEnum>;
  fromNumber?: InputMaybe<Scalars['NonEmptyString']['input']>;
  accountSid?: InputMaybe<Scalars['NonEmptyString']['input']>;
  auth?: InputMaybe<Scalars['NonEmptyString']['input']>;
  authPassword?: InputMaybe<Scalars['String']['input']>;
  authType?: InputMaybe<AuthTypeEnum>;
  /** When enabled, the Phone number is only used during enrollment to verify the users authenticity. Only a hash of the phone number is saved to ensure it is not reused in the future. */
  verifyOnly?: InputMaybe<Scalars['Boolean']['input']>;
  /** Optionally modify the payload being sent to custom providers. */
  mapping?: InputMaybe<Scalars['UUID']['input']>;
};

export type StagesAuthenticatorSmsDestroyResponse = VoidContainer | ValidationError | GenericError;

export type StagesAuthenticatorStaticCreateResponse = AuthenticatorStaticStage | ValidationError | GenericError;

/** AuthenticatorStaticStage Serializer */
export type AuthenticatorStaticStageRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  flowSet?: InputMaybe<Array<InputMaybe<FlowSetRequestInput>>>;
  /** Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage. */
  configureFlow?: InputMaybe<Scalars['UUID']['input']>;
  friendlyName?: InputMaybe<Scalars['NonEmptyString']['input']>;
  tokenCount?: InputMaybe<Scalars['NonNegativeInt']['input']>;
  tokenLength?: InputMaybe<Scalars['NonNegativeInt']['input']>;
};

export type StagesAuthenticatorStaticUpdateResponse = AuthenticatorStaticStage | ValidationError | GenericError;

export type StagesAuthenticatorStaticPartialUpdateResponse = AuthenticatorStaticStage | ValidationError | GenericError;

/** AuthenticatorStaticStage Serializer */
export type PatchedAuthenticatorStaticStageRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  flowSet?: InputMaybe<Array<InputMaybe<FlowSetRequestInput>>>;
  /** Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage. */
  configureFlow?: InputMaybe<Scalars['UUID']['input']>;
  friendlyName?: InputMaybe<Scalars['NonEmptyString']['input']>;
  tokenCount?: InputMaybe<Scalars['NonNegativeInt']['input']>;
  tokenLength?: InputMaybe<Scalars['NonNegativeInt']['input']>;
};

export type StagesAuthenticatorStaticDestroyResponse = VoidContainer | ValidationError | GenericError;

export type StagesAuthenticatorTotpCreateResponse = AuthenticatorTotpStage | ValidationError | GenericError;

/** AuthenticatorTOTPStage Serializer */
export type AuthenticatorTotpStageRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  flowSet?: InputMaybe<Array<InputMaybe<FlowSetRequestInput>>>;
  /** Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage. */
  configureFlow?: InputMaybe<Scalars['UUID']['input']>;
  friendlyName?: InputMaybe<Scalars['NonEmptyString']['input']>;
  digits: DigitsEnum;
};

export type StagesAuthenticatorTotpUpdateResponse = AuthenticatorTotpStage | ValidationError | GenericError;

export type StagesAuthenticatorTotpPartialUpdateResponse = AuthenticatorTotpStage | ValidationError | GenericError;

/** AuthenticatorTOTPStage Serializer */
export type PatchedAuthenticatorTotpStageRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  flowSet?: InputMaybe<Array<InputMaybe<FlowSetRequestInput>>>;
  /** Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage. */
  configureFlow?: InputMaybe<Scalars['UUID']['input']>;
  friendlyName?: InputMaybe<Scalars['NonEmptyString']['input']>;
  digits?: InputMaybe<DigitsEnum>;
};

export type StagesAuthenticatorTotpDestroyResponse = VoidContainer | ValidationError | GenericError;

export type StagesAuthenticatorValidateCreateResponse = AuthenticatorValidateStage | ValidationError | GenericError;

/** AuthenticatorValidateStage Serializer */
export type AuthenticatorValidateStageRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  flowSet?: InputMaybe<Array<InputMaybe<FlowSetRequestInput>>>;
  notConfiguredAction?: InputMaybe<NotConfiguredActionEnum>;
  /** Device classes which can be used to authenticate */
  deviceClasses?: InputMaybe<Array<InputMaybe<DeviceClassesEnum>>>;
  /** Stages used to configure Authenticator when user doesn't have any compatible devices. After this configuration Stage passes, the user is not prompted again. */
  configurationStages?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  /** If any of the user's device has been used within this threshold, this stage will be skipped */
  lastAuthThreshold?: InputMaybe<Scalars['NonEmptyString']['input']>;
  webauthnUserVerification?: InputMaybe<UserVerificationEnum>;
  webauthnAllowedDeviceTypes?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
};

export type StagesAuthenticatorValidateUpdateResponse = AuthenticatorValidateStage | ValidationError | GenericError;

export type StagesAuthenticatorValidatePartialUpdateResponse = AuthenticatorValidateStage | ValidationError | GenericError;

/** AuthenticatorValidateStage Serializer */
export type PatchedAuthenticatorValidateStageRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  flowSet?: InputMaybe<Array<InputMaybe<FlowSetRequestInput>>>;
  notConfiguredAction?: InputMaybe<NotConfiguredActionEnum>;
  /** Device classes which can be used to authenticate */
  deviceClasses?: InputMaybe<Array<InputMaybe<DeviceClassesEnum>>>;
  /** Stages used to configure Authenticator when user doesn't have any compatible devices. After this configuration Stage passes, the user is not prompted again. */
  configurationStages?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  /** If any of the user's device has been used within this threshold, this stage will be skipped */
  lastAuthThreshold?: InputMaybe<Scalars['NonEmptyString']['input']>;
  webauthnUserVerification?: InputMaybe<UserVerificationEnum>;
  webauthnAllowedDeviceTypes?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
};

export type StagesAuthenticatorValidateDestroyResponse = VoidContainer | ValidationError | GenericError;

export type StagesAuthenticatorWebauthnCreateResponse = AuthenticatorWebAuthnStage | ValidationError | GenericError;

/** AuthenticatorWebAuthnStage Serializer */
export type AuthenticatorWebAuthnStageRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  flowSet?: InputMaybe<Array<InputMaybe<FlowSetRequestInput>>>;
  /** Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage. */
  configureFlow?: InputMaybe<Scalars['UUID']['input']>;
  friendlyName?: InputMaybe<Scalars['NonEmptyString']['input']>;
  userVerification?: InputMaybe<UserVerificationEnum>;
  authenticatorAttachment?: InputMaybe<AuthenticatorAttachmentEnum>;
  residentKeyRequirement?: InputMaybe<ResidentKeyRequirementEnum>;
  deviceTypeRestrictions?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
};

export type StagesAuthenticatorWebauthnUpdateResponse = AuthenticatorWebAuthnStage | ValidationError | GenericError;

export type StagesAuthenticatorWebauthnPartialUpdateResponse = AuthenticatorWebAuthnStage | ValidationError | GenericError;

/** AuthenticatorWebAuthnStage Serializer */
export type PatchedAuthenticatorWebAuthnStageRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  flowSet?: InputMaybe<Array<InputMaybe<FlowSetRequestInput>>>;
  /** Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage. */
  configureFlow?: InputMaybe<Scalars['UUID']['input']>;
  friendlyName?: InputMaybe<Scalars['NonEmptyString']['input']>;
  userVerification?: InputMaybe<UserVerificationEnum>;
  authenticatorAttachment?: InputMaybe<AuthenticatorAttachmentEnum>;
  residentKeyRequirement?: InputMaybe<ResidentKeyRequirementEnum>;
  deviceTypeRestrictions?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
};

export type StagesAuthenticatorWebauthnDestroyResponse = VoidContainer | ValidationError | GenericError;

export type StagesCaptchaCreateResponse = CaptchaStage | ValidationError | GenericError;

/** CaptchaStage Serializer */
export type CaptchaStageRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  flowSet?: InputMaybe<Array<InputMaybe<FlowSetRequestInput>>>;
  /** Public key, acquired your captcha Provider. */
  publicKey: Scalars['NonEmptyString']['input'];
  /** Private key, acquired your captcha Provider. */
  privateKey: Scalars['NonEmptyString']['input'];
  jsUrl?: InputMaybe<Scalars['NonEmptyString']['input']>;
  apiUrl?: InputMaybe<Scalars['NonEmptyString']['input']>;
};

export type StagesCaptchaUpdateResponse = CaptchaStage | ValidationError | GenericError;

export type StagesCaptchaPartialUpdateResponse = CaptchaStage | ValidationError | GenericError;

/** CaptchaStage Serializer */
export type PatchedCaptchaStageRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  flowSet?: InputMaybe<Array<InputMaybe<FlowSetRequestInput>>>;
  /** Public key, acquired your captcha Provider. */
  publicKey?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Private key, acquired your captcha Provider. */
  privateKey?: InputMaybe<Scalars['NonEmptyString']['input']>;
  jsUrl?: InputMaybe<Scalars['NonEmptyString']['input']>;
  apiUrl?: InputMaybe<Scalars['NonEmptyString']['input']>;
};

export type StagesCaptchaDestroyResponse = VoidContainer | ValidationError | GenericError;

export type StagesConsentCreateResponse = ConsentStage | ValidationError | GenericError;

/** ConsentStage Serializer */
export type ConsentStageRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  flowSet?: InputMaybe<Array<InputMaybe<FlowSetRequestInput>>>;
  mode?: InputMaybe<ConsentStageModeEnum>;
  /** Offset after which consent expires. (Format: hours=1;minutes=2;seconds=3). */
  consentExpireIn?: InputMaybe<Scalars['NonEmptyString']['input']>;
};

export type StagesConsentUpdateResponse = ConsentStage | ValidationError | GenericError;

export type StagesConsentPartialUpdateResponse = ConsentStage | ValidationError | GenericError;

/** ConsentStage Serializer */
export type PatchedConsentStageRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  flowSet?: InputMaybe<Array<InputMaybe<FlowSetRequestInput>>>;
  mode?: InputMaybe<ConsentStageModeEnum>;
  /** Offset after which consent expires. (Format: hours=1;minutes=2;seconds=3). */
  consentExpireIn?: InputMaybe<Scalars['NonEmptyString']['input']>;
};

export type StagesConsentDestroyResponse = VoidContainer | ValidationError | GenericError;

export type StagesDenyCreateResponse = DenyStage | ValidationError | GenericError;

/** DenyStage Serializer */
export type DenyStageRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  flowSet?: InputMaybe<Array<InputMaybe<FlowSetRequestInput>>>;
  denyMessage?: InputMaybe<Scalars['String']['input']>;
};

export type StagesDenyUpdateResponse = DenyStage | ValidationError | GenericError;

export type StagesDenyPartialUpdateResponse = DenyStage | ValidationError | GenericError;

/** DenyStage Serializer */
export type PatchedDenyStageRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  flowSet?: InputMaybe<Array<InputMaybe<FlowSetRequestInput>>>;
  denyMessage?: InputMaybe<Scalars['String']['input']>;
};

export type StagesDenyDestroyResponse = VoidContainer | ValidationError | GenericError;

export type StagesDummyCreateResponse = DummyStage | ValidationError | GenericError;

/** DummyStage Serializer */
export type DummyStageRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  flowSet?: InputMaybe<Array<InputMaybe<FlowSetRequestInput>>>;
  throwError?: InputMaybe<Scalars['Boolean']['input']>;
};

export type StagesDummyUpdateResponse = DummyStage | ValidationError | GenericError;

export type StagesDummyPartialUpdateResponse = DummyStage | ValidationError | GenericError;

/** DummyStage Serializer */
export type PatchedDummyStageRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  flowSet?: InputMaybe<Array<InputMaybe<FlowSetRequestInput>>>;
  throwError?: InputMaybe<Scalars['Boolean']['input']>;
};

export type StagesDummyDestroyResponse = VoidContainer | ValidationError | GenericError;

export type StagesEmailCreateResponse = EmailStage | ValidationError | GenericError;

/** EmailStage Serializer */
export type EmailStageRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  flowSet?: InputMaybe<Array<InputMaybe<FlowSetRequestInput>>>;
  /** When enabled, global Email connection settings will be used and connection settings below will be ignored. */
  useGlobalSettings?: InputMaybe<Scalars['Boolean']['input']>;
  host?: InputMaybe<Scalars['NonEmptyString']['input']>;
  port?: InputMaybe<Scalars['Int']['input']>;
  username?: InputMaybe<Scalars['String']['input']>;
  password?: InputMaybe<Scalars['String']['input']>;
  useTls?: InputMaybe<Scalars['Boolean']['input']>;
  useSsl?: InputMaybe<Scalars['Boolean']['input']>;
  timeout?: InputMaybe<Scalars['Int']['input']>;
  fromAddress?: InputMaybe<Scalars['EmailAddress']['input']>;
  /** Time in minutes the token sent is valid. */
  tokenExpiry?: InputMaybe<Scalars['Int']['input']>;
  subject?: InputMaybe<Scalars['NonEmptyString']['input']>;
  template?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Activate users upon completion of stage. */
  activateUserOnSuccess?: InputMaybe<Scalars['Boolean']['input']>;
};

export type StagesEmailUpdateResponse = EmailStage | ValidationError | GenericError;

export type StagesEmailPartialUpdateResponse = EmailStage | ValidationError | GenericError;

/** EmailStage Serializer */
export type PatchedEmailStageRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  flowSet?: InputMaybe<Array<InputMaybe<FlowSetRequestInput>>>;
  /** When enabled, global Email connection settings will be used and connection settings below will be ignored. */
  useGlobalSettings?: InputMaybe<Scalars['Boolean']['input']>;
  host?: InputMaybe<Scalars['NonEmptyString']['input']>;
  port?: InputMaybe<Scalars['Int']['input']>;
  username?: InputMaybe<Scalars['String']['input']>;
  password?: InputMaybe<Scalars['String']['input']>;
  useTls?: InputMaybe<Scalars['Boolean']['input']>;
  useSsl?: InputMaybe<Scalars['Boolean']['input']>;
  timeout?: InputMaybe<Scalars['Int']['input']>;
  fromAddress?: InputMaybe<Scalars['EmailAddress']['input']>;
  /** Time in minutes the token sent is valid. */
  tokenExpiry?: InputMaybe<Scalars['Int']['input']>;
  subject?: InputMaybe<Scalars['NonEmptyString']['input']>;
  template?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Activate users upon completion of stage. */
  activateUserOnSuccess?: InputMaybe<Scalars['Boolean']['input']>;
};

export type StagesEmailDestroyResponse = VoidContainer | ValidationError | GenericError;

export type StagesIdentificationCreateResponse = IdentificationStage | ValidationError | GenericError;

/** IdentificationStage Serializer */
export type IdentificationStageRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  flowSet?: InputMaybe<Array<InputMaybe<FlowSetRequestInput>>>;
  /** Fields of the user object to match against. (Hold shift to select multiple options) */
  userFields?: InputMaybe<Array<InputMaybe<UserFieldsEnum>>>;
  /** When set, shows a password field, instead of showing the password field as seaprate step. */
  passwordStage?: InputMaybe<Scalars['UUID']['input']>;
  /** When enabled, user fields are matched regardless of their casing. */
  caseInsensitiveMatching?: InputMaybe<Scalars['Boolean']['input']>;
  /** When a valid username/email has been entered, and this option is enabled, the user's username and avatar will be shown. Otherwise, the text that the user entered will be shown */
  showMatchedUser?: InputMaybe<Scalars['Boolean']['input']>;
  /** Optional enrollment flow, which is linked at the bottom of the page. */
  enrollmentFlow?: InputMaybe<Scalars['UUID']['input']>;
  /** Optional recovery flow, which is linked at the bottom of the page. */
  recoveryFlow?: InputMaybe<Scalars['UUID']['input']>;
  /** Optional passwordless flow, which is linked at the bottom of the page. */
  passwordlessFlow?: InputMaybe<Scalars['UUID']['input']>;
  /** Specify which sources should be shown. */
  sources?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  showSourceLabels?: InputMaybe<Scalars['Boolean']['input']>;
  /** When enabled, the stage will succeed and continue even when incorrect user info is entered. */
  pretendUserExists?: InputMaybe<Scalars['Boolean']['input']>;
};

export type StagesIdentificationUpdateResponse = IdentificationStage | ValidationError | GenericError;

export type StagesIdentificationPartialUpdateResponse = IdentificationStage | ValidationError | GenericError;

/** IdentificationStage Serializer */
export type PatchedIdentificationStageRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  flowSet?: InputMaybe<Array<InputMaybe<FlowSetRequestInput>>>;
  /** Fields of the user object to match against. (Hold shift to select multiple options) */
  userFields?: InputMaybe<Array<InputMaybe<UserFieldsEnum>>>;
  /** When set, shows a password field, instead of showing the password field as seaprate step. */
  passwordStage?: InputMaybe<Scalars['UUID']['input']>;
  /** When enabled, user fields are matched regardless of their casing. */
  caseInsensitiveMatching?: InputMaybe<Scalars['Boolean']['input']>;
  /** When a valid username/email has been entered, and this option is enabled, the user's username and avatar will be shown. Otherwise, the text that the user entered will be shown */
  showMatchedUser?: InputMaybe<Scalars['Boolean']['input']>;
  /** Optional enrollment flow, which is linked at the bottom of the page. */
  enrollmentFlow?: InputMaybe<Scalars['UUID']['input']>;
  /** Optional recovery flow, which is linked at the bottom of the page. */
  recoveryFlow?: InputMaybe<Scalars['UUID']['input']>;
  /** Optional passwordless flow, which is linked at the bottom of the page. */
  passwordlessFlow?: InputMaybe<Scalars['UUID']['input']>;
  /** Specify which sources should be shown. */
  sources?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  showSourceLabels?: InputMaybe<Scalars['Boolean']['input']>;
  /** When enabled, the stage will succeed and continue even when incorrect user info is entered. */
  pretendUserExists?: InputMaybe<Scalars['Boolean']['input']>;
};

export type StagesIdentificationDestroyResponse = VoidContainer | ValidationError | GenericError;

export type StagesInvitationInvitationsCreateResponse = Invitation | ValidationError | GenericError;

/** Invitation Serializer */
export type InvitationRequestInput = {
  name: Scalars['MutationInputStagesInvitationInvitationsCreateInputName']['input'];
  expires?: InputMaybe<Scalars['DateTime']['input']>;
  fixedData?: InputMaybe<Scalars['JSON']['input']>;
  /** When enabled, the invitation will be deleted after usage. */
  singleUse?: InputMaybe<Scalars['Boolean']['input']>;
  /** When set, only the configured flow can use this invitation. */
  flow?: InputMaybe<Scalars['UUID']['input']>;
};

export type StagesInvitationInvitationsUpdateResponse = Invitation | ValidationError | GenericError;

export type StagesInvitationInvitationsPartialUpdateResponse = Invitation | ValidationError | GenericError;

/** Invitation Serializer */
export type PatchedInvitationRequestInput = {
  name?: InputMaybe<Scalars['MutationInputStagesInvitationInvitationsPartialUpdateInputName']['input']>;
  expires?: InputMaybe<Scalars['DateTime']['input']>;
  fixedData?: InputMaybe<Scalars['JSON']['input']>;
  /** When enabled, the invitation will be deleted after usage. */
  singleUse?: InputMaybe<Scalars['Boolean']['input']>;
  /** When set, only the configured flow can use this invitation. */
  flow?: InputMaybe<Scalars['UUID']['input']>;
};

export type StagesInvitationInvitationsDestroyResponse = VoidContainer | ValidationError | GenericError;

export type StagesInvitationStagesCreateResponse = InvitationStage | ValidationError | GenericError;

/** InvitationStage Serializer */
export type InvitationStageRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  flowSet?: InputMaybe<Array<InputMaybe<FlowSetRequestInput>>>;
  /** If this flag is set, this Stage will jump to the next Stage when no Invitation is given. By default this Stage will cancel the Flow when no invitation is given. */
  continueFlowWithoutInvitation?: InputMaybe<Scalars['Boolean']['input']>;
};

export type StagesInvitationStagesUpdateResponse = InvitationStage | ValidationError | GenericError;

export type StagesInvitationStagesPartialUpdateResponse = InvitationStage | ValidationError | GenericError;

/** InvitationStage Serializer */
export type PatchedInvitationStageRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  flowSet?: InputMaybe<Array<InputMaybe<FlowSetRequestInput>>>;
  /** If this flag is set, this Stage will jump to the next Stage when no Invitation is given. By default this Stage will cancel the Flow when no invitation is given. */
  continueFlowWithoutInvitation?: InputMaybe<Scalars['Boolean']['input']>;
};

export type StagesInvitationStagesDestroyResponse = VoidContainer | ValidationError | GenericError;

export type StagesPasswordCreateResponse = PasswordStage | ValidationError | GenericError;

/** PasswordStage Serializer */
export type PasswordStageRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  flowSet?: InputMaybe<Array<InputMaybe<FlowSetRequestInput>>>;
  /** Selection of backends to test the password against. */
  backends: Array<InputMaybe<BackendsEnum>>;
  /** Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage. */
  configureFlow?: InputMaybe<Scalars['UUID']['input']>;
  /** How many attempts a user has before the flow is canceled. To lock the user out, use a reputation policy and a user_write stage. */
  failedAttemptsBeforeCancel?: InputMaybe<Scalars['Int']['input']>;
};

export type StagesPasswordUpdateResponse = PasswordStage | ValidationError | GenericError;

export type StagesPasswordPartialUpdateResponse = PasswordStage | ValidationError | GenericError;

/** PasswordStage Serializer */
export type PatchedPasswordStageRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  flowSet?: InputMaybe<Array<InputMaybe<FlowSetRequestInput>>>;
  /** Selection of backends to test the password against. */
  backends?: InputMaybe<Array<InputMaybe<BackendsEnum>>>;
  /** Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage. */
  configureFlow?: InputMaybe<Scalars['UUID']['input']>;
  /** How many attempts a user has before the flow is canceled. To lock the user out, use a reputation policy and a user_write stage. */
  failedAttemptsBeforeCancel?: InputMaybe<Scalars['Int']['input']>;
};

export type StagesPasswordDestroyResponse = VoidContainer | ValidationError | GenericError;

export type StagesPromptPromptsCreateResponse = Prompt | ValidationError | GenericError;

/** Prompt Serializer */
export type PromptRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  /** Name of the form field, also used to store the value */
  fieldKey: Scalars['NonEmptyString']['input'];
  label: Scalars['NonEmptyString']['input'];
  type: PromptTypeEnum;
  required?: InputMaybe<Scalars['Boolean']['input']>;
  /** Optionally provide a short hint that describes the expected input value. When creating a fixed choice field, enable interpreting as expression and return a list to return multiple choices. */
  placeholder?: InputMaybe<Scalars['String']['input']>;
  /** Optionally pre-fill the input with an initial value. When creating a fixed choice field, enable interpreting as expression and return a list to return multiple default choices. */
  initialValue?: InputMaybe<Scalars['String']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  promptstageSet?: InputMaybe<Array<InputMaybe<StageRequestInput>>>;
  subText?: InputMaybe<Scalars['String']['input']>;
  placeholderExpression?: InputMaybe<Scalars['Boolean']['input']>;
  initialValueExpression?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Stage Serializer */
export type StageRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  flowSet?: InputMaybe<Array<InputMaybe<FlowSetRequestInput>>>;
};

export type StagesPromptPromptsUpdateResponse = Prompt | ValidationError | GenericError;

export type StagesPromptPromptsPartialUpdateResponse = Prompt | ValidationError | GenericError;

/** Prompt Serializer */
export type PatchedPromptRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Name of the form field, also used to store the value */
  fieldKey?: InputMaybe<Scalars['NonEmptyString']['input']>;
  label?: InputMaybe<Scalars['NonEmptyString']['input']>;
  type?: InputMaybe<PromptTypeEnum>;
  required?: InputMaybe<Scalars['Boolean']['input']>;
  /** Optionally provide a short hint that describes the expected input value. When creating a fixed choice field, enable interpreting as expression and return a list to return multiple choices. */
  placeholder?: InputMaybe<Scalars['String']['input']>;
  /** Optionally pre-fill the input with an initial value. When creating a fixed choice field, enable interpreting as expression and return a list to return multiple default choices. */
  initialValue?: InputMaybe<Scalars['String']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  promptstageSet?: InputMaybe<Array<InputMaybe<StageRequestInput>>>;
  subText?: InputMaybe<Scalars['String']['input']>;
  placeholderExpression?: InputMaybe<Scalars['Boolean']['input']>;
  initialValueExpression?: InputMaybe<Scalars['Boolean']['input']>;
};

export type StagesPromptPromptsDestroyResponse = VoidContainer | ValidationError | GenericError;

export type StagesPromptPromptsPreviewCreateResponse = PromptChallenge | ValidationError | GenericError;

export type StagesPromptStagesCreateResponse = PromptStage | ValidationError | GenericError;

/** PromptStage Serializer */
export type PromptStageRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  flowSet?: InputMaybe<Array<InputMaybe<FlowSetRequestInput>>>;
  fields: Array<InputMaybe<Scalars['UUID']['input']>>;
  validationPolicies?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
};

export type StagesPromptStagesUpdateResponse = PromptStage | ValidationError | GenericError;

export type StagesPromptStagesPartialUpdateResponse = PromptStage | ValidationError | GenericError;

/** PromptStage Serializer */
export type PatchedPromptStageRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  flowSet?: InputMaybe<Array<InputMaybe<FlowSetRequestInput>>>;
  fields?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  validationPolicies?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
};

export type StagesPromptStagesDestroyResponse = VoidContainer | ValidationError | GenericError;

export type StagesSourceCreateResponse = SourceStage | ValidationError | GenericError;

/** SourceStage Serializer */
export type SourceStageRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  flowSet?: InputMaybe<Array<InputMaybe<FlowSetRequestInput>>>;
  source: Scalars['UUID']['input'];
  /** Amount of time a user can take to return from the source to continue the flow (Format: hours=-1;minutes=-2;seconds=-3) */
  resumeTimeout?: InputMaybe<Scalars['NonEmptyString']['input']>;
};

export type StagesSourceUpdateResponse = SourceStage | ValidationError | GenericError;

export type StagesSourcePartialUpdateResponse = SourceStage | ValidationError | GenericError;

/** SourceStage Serializer */
export type PatchedSourceStageRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  flowSet?: InputMaybe<Array<InputMaybe<FlowSetRequestInput>>>;
  source?: InputMaybe<Scalars['UUID']['input']>;
  /** Amount of time a user can take to return from the source to continue the flow (Format: hours=-1;minutes=-2;seconds=-3) */
  resumeTimeout?: InputMaybe<Scalars['NonEmptyString']['input']>;
};

export type StagesSourceDestroyResponse = VoidContainer | ValidationError | GenericError;

export type StagesUserDeleteCreateResponse = UserDeleteStage | ValidationError | GenericError;

/** UserDeleteStage Serializer */
export type UserDeleteStageRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  flowSet?: InputMaybe<Array<InputMaybe<FlowSetRequestInput>>>;
};

export type StagesUserDeleteUpdateResponse = UserDeleteStage | ValidationError | GenericError;

export type StagesUserDeletePartialUpdateResponse = UserDeleteStage | ValidationError | GenericError;

/** UserDeleteStage Serializer */
export type PatchedUserDeleteStageRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  flowSet?: InputMaybe<Array<InputMaybe<FlowSetRequestInput>>>;
};

export type StagesUserDeleteDestroyResponse = VoidContainer | ValidationError | GenericError;

export type StagesUserLoginCreateResponse = UserLoginStage | ValidationError | GenericError;

/** UserLoginStage Serializer */
export type UserLoginStageRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  flowSet?: InputMaybe<Array<InputMaybe<FlowSetRequestInput>>>;
  /** Determines how long a session lasts. Default of 0 means that the sessions lasts until the browser is closed. (Format: hours=-1;minutes=-2;seconds=-3) */
  sessionDuration?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Terminate all other sessions of the user logging in. */
  terminateOtherSessions?: InputMaybe<Scalars['Boolean']['input']>;
  /** Offset the session will be extended by when the user picks the remember me option. Default of 0 means that the remember me option will not be shown. (Format: hours=-1;minutes=-2;seconds=-3) */
  rememberMeOffset?: InputMaybe<Scalars['NonEmptyString']['input']>;
  networkBinding?: InputMaybe<NetworkBindingEnum>;
  geoipBinding?: InputMaybe<GeoipBindingEnum>;
};

export type StagesUserLoginUpdateResponse = UserLoginStage | ValidationError | GenericError;

export type StagesUserLoginPartialUpdateResponse = UserLoginStage | ValidationError | GenericError;

/** UserLoginStage Serializer */
export type PatchedUserLoginStageRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  flowSet?: InputMaybe<Array<InputMaybe<FlowSetRequestInput>>>;
  /** Determines how long a session lasts. Default of 0 means that the sessions lasts until the browser is closed. (Format: hours=-1;minutes=-2;seconds=-3) */
  sessionDuration?: InputMaybe<Scalars['NonEmptyString']['input']>;
  /** Terminate all other sessions of the user logging in. */
  terminateOtherSessions?: InputMaybe<Scalars['Boolean']['input']>;
  /** Offset the session will be extended by when the user picks the remember me option. Default of 0 means that the remember me option will not be shown. (Format: hours=-1;minutes=-2;seconds=-3) */
  rememberMeOffset?: InputMaybe<Scalars['NonEmptyString']['input']>;
  networkBinding?: InputMaybe<NetworkBindingEnum>;
  geoipBinding?: InputMaybe<GeoipBindingEnum>;
};

export type StagesUserLoginDestroyResponse = VoidContainer | ValidationError | GenericError;

export type StagesUserLogoutCreateResponse = UserLogoutStage | ValidationError | GenericError;

/** UserLogoutStage Serializer */
export type UserLogoutStageRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  flowSet?: InputMaybe<Array<InputMaybe<FlowSetRequestInput>>>;
};

export type StagesUserLogoutUpdateResponse = UserLogoutStage | ValidationError | GenericError;

export type StagesUserLogoutPartialUpdateResponse = UserLogoutStage | ValidationError | GenericError;

/** UserLogoutStage Serializer */
export type PatchedUserLogoutStageRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  flowSet?: InputMaybe<Array<InputMaybe<FlowSetRequestInput>>>;
};

export type StagesUserLogoutDestroyResponse = VoidContainer | ValidationError | GenericError;

export type StagesUserWriteCreateResponse = UserWriteStage | ValidationError | GenericError;

/** UserWriteStage Serializer */
export type UserWriteStageRequestInput = {
  name: Scalars['NonEmptyString']['input'];
  flowSet?: InputMaybe<Array<InputMaybe<FlowSetRequestInput>>>;
  userCreationMode?: InputMaybe<UserCreationModeEnum>;
  /** When set, newly created users are inactive and cannot login. */
  createUsersAsInactive?: InputMaybe<Scalars['Boolean']['input']>;
  /** Optionally add newly created users to this group. */
  createUsersGroup?: InputMaybe<Scalars['UUID']['input']>;
  userType?: InputMaybe<UserTypeEnum>;
  userPathTemplate?: InputMaybe<Scalars['String']['input']>;
};

export type StagesUserWriteUpdateResponse = UserWriteStage | ValidationError | GenericError;

export type StagesUserWritePartialUpdateResponse = UserWriteStage | ValidationError | GenericError;

/** UserWriteStage Serializer */
export type PatchedUserWriteStageRequestInput = {
  name?: InputMaybe<Scalars['NonEmptyString']['input']>;
  flowSet?: InputMaybe<Array<InputMaybe<FlowSetRequestInput>>>;
  userCreationMode?: InputMaybe<UserCreationModeEnum>;
  /** When set, newly created users are inactive and cannot login. */
  createUsersAsInactive?: InputMaybe<Scalars['Boolean']['input']>;
  /** Optionally add newly created users to this group. */
  createUsersGroup?: InputMaybe<Scalars['UUID']['input']>;
  userType?: InputMaybe<UserTypeEnum>;
  userPathTemplate?: InputMaybe<Scalars['String']['input']>;
};

export type StagesUserWriteDestroyResponse = VoidContainer | ValidationError | GenericError;

export type HttpMethod =
  | 'GET'
  | 'HEAD'
  | 'POST'
  | 'PUT'
  | 'DELETE'
  | 'CONNECT'
  | 'OPTIONS'
  | 'TRACE'
  | 'PATCH';

export type WithIndex<TObject> = TObject & Record<string, any>;
export type ResolversObject<TObject> = WithIndex<TObject>;

export type ResolverTypeWrapper<T> = Promise<T> | T;


export type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};

export type LegacyStitchingResolver<TResult, TParent, TContext, TArgs> = {
  fragment: string;
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};

export type NewStitchingResolver<TResult, TParent, TContext, TArgs> = {
  selectionSet: string | ((fieldNode: FieldNode) => SelectionSetNode);
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type StitchingResolver<TResult, TParent, TContext, TArgs> = LegacyStitchingResolver<TResult, TParent, TContext, TArgs> | NewStitchingResolver<TResult, TParent, TContext, TArgs>;
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
  | ResolverFn<TResult, TParent, TContext, TArgs>
  | ResolverWithResolve<TResult, TParent, TContext, TArgs>
  | StitchingResolver<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;
  resolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =
  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =
  | ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
  parent: TParent,
  context: TContext,
  info: GraphQLResolveInfo
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}, TContext = {}> = (obj: T, context: TContext, info: GraphQLResolveInfo) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (
  next: NextResolverFn<TResult>,
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

/** Mapping of union types */
export type ResolversUnionTypes<_RefType extends Record<string, unknown>> = ResolversObject<{
  ChurrosCompleteSignupResult: ( Omit<ChurrosUser, 'allowedApps' | 'answeredForms' | 'articles' | 'authorizedApps' | 'boardMemberships' | 'canCreatePostsOn' | 'credentials' | 'emailChangeRequests' | 'familyTree' | 'godchildren' | 'godparent' | 'groups' | 'incomingGodparentRequests' | 'managedEvents' | 'outgoingGodparentRequests' | 'partiallyAnsweredForms'> & { allowedApps: Array<_RefType['ChurrosThirdPartyApp']>, answeredForms: _RefType['ChurrosUserAnsweredFormsConnection'], articles: _RefType['ChurrosUserArticlesConnection'], authorizedApps: Array<_RefType['ChurrosThirdPartyApp']>, boardMemberships: Array<_RefType['ChurrosGroupMember']>, canCreatePostsOn: Array<_RefType['ChurrosGroup']>, credentials: Array<_RefType['ChurrosCredential']>, emailChangeRequests: Array<_RefType['ChurrosEmailChange']>, familyTree: _RefType['ChurrosFamilyTree'], godchildren: Array<_RefType['ChurrosUser']>, godparent?: Maybe<_RefType['ChurrosUser']>, groups: Array<_RefType['ChurrosGroupMember']>, incomingGodparentRequests: Array<_RefType['ChurrosGodparentRequest']>, managedEvents: Array<_RefType['ChurrosEventManager']>, outgoingGodparentRequests: Array<_RefType['ChurrosGodparentRequest']>, partiallyAnsweredForms: _RefType['ChurrosUserPartiallyAnsweredFormsConnection'] } ) | ( ChurrosUserCandidate );
  ChurrosEventBookingsCsvResult: ( ChurrosError ) | ( ChurrosEventBookingsCsvSuccess );
  ChurrosEventMyBookingsResult: ( ChurrosError ) | ( ChurrosEventMyBookingsSuccess );
  ChurrosMutationAcceptRegistrationResult: ( ChurrosError ) | ( Omit<ChurrosMutationAcceptRegistrationSuccess, 'data'> & { data: _RefType['ChurrosUser'] } );
  ChurrosMutationAddFileToPageResult: ( ChurrosError ) | ( ChurrosMutationAddFileToPageSuccess ) | ( ChurrosZodError );
  ChurrosMutationAddGroupMemberResult: ( ChurrosError ) | ( Omit<ChurrosMutationAddGroupMemberSuccess, 'data'> & { data: _RefType['ChurrosGroupMember'] } );
  ChurrosMutationAnswerFormSectionResult: ( ChurrosError ) | ( Omit<ChurrosMutationAnswerFormSectionSuccess, 'data'> & { data: Array<_RefType['ChurrosAnswer']> } );
  ChurrosMutationAuthorizeResult: ( ChurrosError ) | ( ChurrosMutationAuthorizeSuccess ) | ( ChurrosOAuth2Error );
  ChurrosMutationCancelRegistrationResult: ( ChurrosError ) | ( ChurrosMutationCancelRegistrationSuccess );
  ChurrosMutationCompleteRegistrationResult: ( ChurrosError ) | ( Omit<ChurrosMutationCompleteRegistrationSuccess, 'data'> & { data: _RefType['ChurrosCompleteSignupResult'] } ) | ( ChurrosZodError );
  ChurrosMutationContributeResult: ( ChurrosError ) | ( ChurrosMutationContributeSuccess );
  ChurrosMutationCreatePasswordResetResult: ( ChurrosError ) | ( ChurrosMutationCreatePasswordResetSuccess );
  ChurrosMutationDeletePageResult: ( ChurrosError ) | ( ChurrosMutationDeletePageSuccess ) | ( ChurrosZodError );
  ChurrosMutationDeleteShopItemResult: ( ChurrosError ) | ( ChurrosMutationDeleteShopItemSuccess );
  ChurrosMutationFinishPaypalRegistrationPaymentResult: ( ChurrosError ) | ( ChurrosMutationFinishPaypalRegistrationPaymentSuccess );
  ChurrosMutationLoginResult: ( ChurrosAwaitingValidationError ) | ( ChurrosError ) | ( Omit<ChurrosMutationLoginSuccess, 'data'> & { data: _RefType['ChurrosCredential'] } );
  ChurrosMutationMailFormAnswersResult: ( ChurrosError ) | ( ChurrosMutationMailFormAnswersSuccess );
  ChurrosMutationOpposeRegistrationResult: ( ChurrosError ) | ( ChurrosMutationOpposeRegistrationSuccess );
  ChurrosMutationPaidRegistrationResult: ( ChurrosError ) | ( ChurrosMutationPaidRegistrationSuccess );
  ChurrosMutationPaidShopPaymentResult: ( ChurrosError ) | ( Omit<ChurrosMutationPaidShopPaymentSuccess, 'data'> & { data: _RefType['ChurrosShopPayment'] } );
  ChurrosMutationRegisterGoogleCredentialResult: ( ChurrosError ) | ( ChurrosMutationRegisterGoogleCredentialSuccess );
  ChurrosMutationRemoveFileFromPageResult: ( ChurrosError ) | ( ChurrosMutationRemoveFileFromPageSuccess ) | ( ChurrosZodError );
  ChurrosMutationRequestEmailChangeResult: ( ChurrosError ) | ( ChurrosMutationRequestEmailChangeSuccess );
  ChurrosMutationResetPasswordResult: ( ChurrosError ) | ( ChurrosMutationResetPasswordSuccess );
  ChurrosMutationStartRegistrationResult: ( ChurrosError ) | ( ChurrosMutationStartRegistrationSuccess ) | ( ChurrosZodError );
  ChurrosMutationUpdateUserCandidateResult: ( ChurrosError ) | ( ChurrosMutationUpdateUserCandidateSuccess ) | ( ChurrosZodError );
  ChurrosMutationUpdateUserResult: ( ChurrosError ) | ( Omit<ChurrosMutationUpdateUserSuccess, 'data'> & { data: _RefType['ChurrosUser'] } );
  ChurrosMutationUpsertAnnouncementResult: ( ChurrosError ) | ( Omit<ChurrosMutationUpsertAnnouncementSuccess, 'data'> & { data: _RefType['ChurrosAnnouncement'] } ) | ( ChurrosZodError );
  ChurrosMutationUpsertArticleResult: ( ChurrosError ) | ( Omit<ChurrosMutationUpsertArticleSuccess, 'data'> & { data: _RefType['ChurrosArticle'] } ) | ( ChurrosZodError );
  ChurrosMutationUpsertBarWeekResult: ( ChurrosError ) | ( Omit<ChurrosMutationUpsertBarWeekSuccess, 'data'> & { data: _RefType['ChurrosBarWeek'] } );
  ChurrosMutationUpsertDocumentResult: ( ChurrosError ) | ( ChurrosMutationUpsertDocumentSuccess );
  ChurrosMutationUpsertEventResult: ( ChurrosError ) | ( Omit<ChurrosMutationUpsertEventSuccess, 'data'> & { data: _RefType['ChurrosEvent'] } );
  ChurrosMutationUpsertGodparentRequestResult: ( ChurrosError ) | ( Omit<ChurrosMutationUpsertGodparentRequestSuccess, 'data'> & { data: _RefType['ChurrosGodparentRequest'] } );
  ChurrosMutationUpsertGroupResult: ( ChurrosError ) | ( Omit<ChurrosMutationUpsertGroupSuccess, 'data'> & { data: _RefType['ChurrosGroup'] } ) | ( ChurrosZodError );
  ChurrosMutationUpsertPageResult: ( ChurrosError ) | ( ChurrosMutationUpsertPageSuccess ) | ( ChurrosZodError );
  ChurrosMutationUpsertRegistrationResult: ( ChurrosError ) | ( ChurrosMutationUpsertRegistrationSuccess );
  ChurrosMutationUpsertServiceResult: ( ChurrosError ) | ( ChurrosMutationUpsertServiceSuccess );
  ChurrosMutationUpsertShopItemResult: ( ChurrosError ) | ( Omit<ChurrosMutationUpsertShopItemSuccess, 'data'> & { data: _RefType['ChurrosShopItem'] } );
  ChurrosMutationUpsertShopPaymentResult: ( ChurrosError ) | ( Omit<ChurrosMutationUpsertShopPaymentSuccess, 'data'> & { data: _RefType['ChurrosShopPayment'] } );
  ChurrosMutationUsePasswordResetResult: ( ChurrosError ) | ( ChurrosMutationUsePasswordResetSuccess );
  ChurrosMutationValidateEmailResult: ( ChurrosError ) | ( ChurrosMutationValidateEmailSuccess );
  ChurrosMutationVerifyBookingResult: ( ChurrosError ) | ( ChurrosMutationVerifyBookingSuccess );
  ChurrosQueryCodeContributorsResult: ( ChurrosError ) | ( Omit<ChurrosQueryCodeContributorsSuccess, 'data'> & { data: Array<_RefType['ChurrosUser']> } );
  ChurrosQueryCombinedChangelogResult: ( ChurrosError ) | ( ChurrosQueryCombinedChangelogSuccess );
  ChurrosQueryGroupMembersCsvResult: ( ChurrosError ) | ( ChurrosQueryGroupMembersCsvSuccess );
  ChurrosQueryRegistrationResult: ( ChurrosError ) | ( ChurrosQueryRegistrationSuccess );
  ChurrosQueryUpcomingChangelogResult: ( ChurrosError ) | ( ChurrosQueryUpcomingChangelogSuccess );
  ChurrosSubscriptionRegistrationResult: ( ChurrosError ) | ( ChurrosSubscriptionRegistrationSuccess );
  AdminAppsListResponse: ( App ) | ( ValidationError ) | ( GenericError );
  AdminMetricsRetrieveResponse: ( LoginMetrics ) | ( ValidationError ) | ( GenericError );
  AdminModelsListResponse: ( App ) | ( ValidationError ) | ( GenericError );
  AdminSettingsRetrieveResponse: ( Settings ) | ( ValidationError ) | ( GenericError );
  AdminSystemRetrieveResponse: ( SystemInfo ) | ( ValidationError ) | ( GenericError );
  AdminVersionRetrieveResponse: ( Version ) | ( ValidationError ) | ( GenericError );
  AdminWorkersRetrieveResponse: ( Workers ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsAdminAllListResponse: ( Device ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsAdminDuoListResponse: ( PaginatedDuoDeviceList ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsAdminDuoRetrieveResponse: ( DuoDevice ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsAdminSmsListResponse: ( PaginatedSmsDeviceList ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsAdminSmsRetrieveResponse: ( SmsDevice ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsAdminStaticListResponse: ( PaginatedStaticDeviceList ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsAdminStaticRetrieveResponse: ( StaticDevice ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsAdminTotpListResponse: ( PaginatedTotpDeviceList ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsAdminTotpRetrieveResponse: ( TotpDevice ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsAdminWebauthnListResponse: ( PaginatedWebAuthnDeviceList ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsAdminWebauthnRetrieveResponse: ( WebAuthnDevice ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsAllListResponse: ( Device ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsDuoListResponse: ( PaginatedDuoDeviceList ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsDuoRetrieveResponse: ( DuoDevice ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsDuoUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsSmsListResponse: ( PaginatedSmsDeviceList ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsSmsRetrieveResponse: ( SmsDevice ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsSmsUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsStaticListResponse: ( PaginatedStaticDeviceList ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsStaticRetrieveResponse: ( StaticDevice ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsStaticUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsTotpListResponse: ( PaginatedTotpDeviceList ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsTotpRetrieveResponse: ( TotpDevice ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsTotpUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsWebauthnListResponse: ( PaginatedWebAuthnDeviceList ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsWebauthnRetrieveResponse: ( WebAuthnDevice ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsWebauthnUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  CoreApplicationsListResponse: ( Omit<PaginatedApplicationList, 'results'> & { results: Array<Maybe<_RefType['Application']>> } ) | ( ValidationError ) | ( GenericError );
  CoreApplicationsRetrieveResponse: ( Omit<Application, 'providerObj' | 'backchannelProvidersObj' | 'churrosGroup' | 'metrics'> & { providerObj: _RefType['Provider'], backchannelProvidersObj: Array<Maybe<_RefType['Provider']>>, churrosGroup: _RefType['ChurrosGroup'], metrics?: Maybe<Array<Maybe<_RefType['CoreApplicationsMetricsListResponse']>>> } ) | ( ValidationError ) | ( GenericError );
  CoreApplicationsCheckAccessRetrieveResponse: ( PolicyTestResult ) | ( ValidationError ) | ( GenericError );
  CoreApplicationsMetricsListResponse: ( Coordinate ) | ( ValidationError ) | ( GenericError );
  CoreApplicationsUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  CoreAuthenticatedSessionsListResponse: ( PaginatedAuthenticatedSessionList ) | ( ValidationError ) | ( GenericError );
  CoreAuthenticatedSessionsRetrieveResponse: ( AuthenticatedSession ) | ( ValidationError ) | ( GenericError );
  CoreAuthenticatedSessionsUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  CoreBrandsListResponse: ( PaginatedBrandList ) | ( ValidationError ) | ( GenericError );
  CoreBrandsRetrieveResponse: ( Brand ) | ( ValidationError ) | ( GenericError );
  CoreBrandsUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  CoreBrandsCurrentRetrieveResponse: ( CurrentBrand ) | ( ValidationError ) | ( GenericError );
  CoreGroupsListResponse: ( PaginatedGroupList ) | ( ValidationError ) | ( GenericError );
  CoreGroupsRetrieveResponse: ( Group ) | ( ValidationError ) | ( GenericError );
  CoreGroupsUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  CoreTokensListResponse: ( PaginatedTokenList ) | ( ValidationError ) | ( GenericError );
  CoreTokensRetrieveResponse: ( Token ) | ( ValidationError ) | ( GenericError );
  CoreTokensUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  CoreTokensViewKeyRetrieveResponse: ( TokenView ) | ( ValidationError ) | ( GenericError );
  CoreUserConsentListResponse: ( Omit<PaginatedUserConsentList, 'results'> & { results: Array<Maybe<_RefType['UserConsent']>> } ) | ( ValidationError ) | ( GenericError );
  CoreUserConsentRetrieveResponse: ( Omit<UserConsent, 'application'> & { application: _RefType['Application'] } ) | ( ValidationError ) | ( GenericError );
  CoreUserConsentUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  CoreUsersListResponse: ( PaginatedUserList ) | ( ValidationError ) | ( GenericError );
  CoreUsersRetrieveResponse: ( User ) | ( ValidationError ) | ( GenericError );
  CoreUsersMetricsRetrieveResponse: ( UserMetrics ) | ( ValidationError ) | ( GenericError );
  CoreUsersUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  CoreUsersImpersonateEndRetrieveResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  CoreUsersMeRetrieveResponse: ( SessionUser ) | ( ValidationError ) | ( GenericError );
  CoreUsersPathsRetrieveResponse: ( UserPath ) | ( ValidationError ) | ( GenericError );
  CryptoCertificatekeypairsListResponse: ( PaginatedCertificateKeyPairList ) | ( ValidationError ) | ( GenericError );
  CryptoCertificatekeypairsRetrieveResponse: ( CertificateKeyPair ) | ( ValidationError ) | ( GenericError );
  CryptoCertificatekeypairsUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  CryptoCertificatekeypairsViewCertificateRetrieveResponse: ( CertificateData ) | ( ValidationError ) | ( GenericError );
  CryptoCertificatekeypairsViewPrivateKeyRetrieveResponse: ( CertificateData ) | ( ValidationError ) | ( GenericError );
  EnterpriseLicenseListResponse: ( PaginatedLicenseList ) | ( ValidationError ) | ( GenericError );
  EnterpriseLicenseRetrieveResponse: ( License ) | ( ValidationError ) | ( GenericError );
  EnterpriseLicenseUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  EnterpriseLicenseForecastRetrieveResponse: ( LicenseForecast ) | ( ValidationError ) | ( GenericError );
  EnterpriseLicenseGetInstallIdRetrieveResponse: ( InstallId ) | ( ValidationError ) | ( GenericError );
  EnterpriseLicenseSummaryRetrieveResponse: ( LicenseSummary ) | ( ValidationError ) | ( GenericError );
  EventsEventsListResponse: ( PaginatedEventList ) | ( ValidationError ) | ( GenericError );
  EventsEventsRetrieveResponse: ( Event ) | ( ValidationError ) | ( GenericError );
  EventsEventsActionsListResponse: ( TypeCreate ) | ( ValidationError ) | ( GenericError );
  EventsEventsPerMonthListResponse: ( Coordinate ) | ( ValidationError ) | ( GenericError );
  EventsEventsTopPerUserListResponse: ( EventTopPerUser ) | ( ValidationError ) | ( GenericError );
  EventsEventsVolumeListResponse: ( Coordinate ) | ( ValidationError ) | ( GenericError );
  EventsNotificationsListResponse: ( PaginatedNotificationList ) | ( ValidationError ) | ( GenericError );
  EventsNotificationsRetrieveResponse: ( Notification ) | ( ValidationError ) | ( GenericError );
  EventsNotificationsUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  EventsRulesListResponse: ( PaginatedNotificationRuleList ) | ( ValidationError ) | ( GenericError );
  EventsRulesRetrieveResponse: ( NotificationRule ) | ( ValidationError ) | ( GenericError );
  EventsRulesUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  EventsSystemTasksListResponse: ( PaginatedSystemTaskList ) | ( ValidationError ) | ( GenericError );
  EventsSystemTasksRetrieveResponse: ( SystemTask ) | ( ValidationError ) | ( GenericError );
  EventsTransportsListResponse: ( PaginatedNotificationTransportList ) | ( ValidationError ) | ( GenericError );
  EventsTransportsRetrieveResponse: ( NotificationTransport ) | ( ValidationError ) | ( GenericError );
  EventsTransportsUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  FlowsBindingsListResponse: ( PaginatedFlowStageBindingList ) | ( ValidationError ) | ( GenericError );
  FlowsBindingsRetrieveResponse: ( FlowStageBinding ) | ( ValidationError ) | ( GenericError );
  FlowsBindingsUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  FlowsExecutorGetResponse: ( AccessDeniedChallenge ) | ( AppleLoginChallenge ) | ( AuthenticatorDuoChallenge ) | ( AuthenticatorSmsChallenge ) | ( AuthenticatorStaticChallenge ) | ( AuthenticatorTotpChallenge ) | ( AuthenticatorValidationChallenge ) | ( AuthenticatorWebAuthnChallenge ) | ( AutosubmitChallenge ) | ( CaptchaChallenge ) | ( ConsentChallenge ) | ( EmailChallenge ) | ( FlowErrorChallenge ) | ( Omit<IdentificationChallenge, 'sources'> & { sources?: Maybe<Array<Maybe<_RefType['LoginSource']>>> } ) | ( OAuthDeviceCodeChallenge ) | ( OAuthDeviceCodeFinishChallenge ) | ( PasswordChallenge ) | ( PlexAuthenticationChallenge ) | ( PromptChallenge ) | ( RedirectChallenge ) | ( ShellChallenge ) | ( UserLoginChallenge ) | ( ValidationError ) | ( GenericError );
  LoginChallengeTypes: ( RedirectChallenge ) | ( PlexAuthenticationChallenge ) | ( AppleLoginChallenge );
  FlowsInspectorGetResponse: ( FlowInspection ) | ( GenericError );
  FlowsInstancesListResponse: ( PaginatedFlowList ) | ( ValidationError ) | ( GenericError );
  FlowsInstancesRetrieveResponse: ( Flow ) | ( ValidationError ) | ( GenericError );
  FlowsInstancesDiagramRetrieveResponse: ( FlowDiagram ) | ( ValidationError ) | ( GenericError );
  FlowsInstancesExecuteRetrieveResponse: ( Link ) | ( GenericError );
  FlowsInstancesExportRetrieveResponse: ( FileContainer ) | ( ValidationError ) | ( GenericError );
  FlowsInstancesUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  FlowsInstancesCacheInfoRetrieveResponse: ( Cache ) | ( ValidationError ) | ( GenericError );
  ManagedBlueprintsListResponse: ( PaginatedBlueprintInstanceList ) | ( ValidationError ) | ( GenericError );
  ManagedBlueprintsRetrieveResponse: ( BlueprintInstance ) | ( ValidationError ) | ( GenericError );
  ManagedBlueprintsUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  ManagedBlueprintsAvailableListResponse: ( BlueprintFile ) | ( ValidationError ) | ( GenericError );
  Oauth2AccessTokensListResponse: ( PaginatedTokenModelList ) | ( ValidationError ) | ( GenericError );
  Oauth2AccessTokensRetrieveResponse: ( TokenModel ) | ( ValidationError ) | ( GenericError );
  Oauth2AccessTokensUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  Oauth2AuthorizationCodesListResponse: ( PaginatedExpiringBaseGrantModelList ) | ( ValidationError ) | ( GenericError );
  Oauth2AuthorizationCodesRetrieveResponse: ( ExpiringBaseGrantModel ) | ( ValidationError ) | ( GenericError );
  Oauth2AuthorizationCodesUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  Oauth2RefreshTokensListResponse: ( PaginatedTokenModelList ) | ( ValidationError ) | ( GenericError );
  Oauth2RefreshTokensRetrieveResponse: ( TokenModel ) | ( ValidationError ) | ( GenericError );
  Oauth2RefreshTokensUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  OutpostsInstancesListResponse: ( Omit<PaginatedOutpostList, 'results'> & { results: Array<Maybe<_RefType['Outpost']>> } ) | ( ValidationError ) | ( GenericError );
  OutpostsInstancesRetrieveResponse: ( Omit<Outpost, 'providersObj'> & { providersObj: Array<Maybe<_RefType['Provider']>> } ) | ( ValidationError ) | ( GenericError );
  OutpostsInstancesHealthListResponse: ( OutpostHealth ) | ( ValidationError ) | ( GenericError );
  OutpostsInstancesUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  OutpostsInstancesDefaultSettingsRetrieveResponse: ( OutpostDefaultConfig ) | ( ValidationError ) | ( GenericError );
  OutpostsLdapListResponse: ( PaginatedLdapOutpostConfigList ) | ( ValidationError ) | ( GenericError );
  OutpostsLdapRetrieveResponse: ( LdapOutpostConfig ) | ( ValidationError ) | ( GenericError );
  OutpostsProxyListResponse: ( PaginatedProxyOutpostConfigList ) | ( ValidationError ) | ( GenericError );
  OutpostsProxyRetrieveResponse: ( ProxyOutpostConfig ) | ( ValidationError ) | ( GenericError );
  OutpostsRadiusListResponse: ( PaginatedRadiusOutpostConfigList ) | ( ValidationError ) | ( GenericError );
  OutpostsRadiusRetrieveResponse: ( RadiusOutpostConfig ) | ( ValidationError ) | ( GenericError );
  OutpostsServiceConnectionsAllListResponse: ( PaginatedServiceConnectionList ) | ( ValidationError ) | ( GenericError );
  OutpostsServiceConnectionsAllRetrieveResponse: ( ServiceConnection ) | ( ValidationError ) | ( GenericError );
  OutpostsServiceConnectionsAllStateRetrieveResponse: ( ServiceConnectionState ) | ( ValidationError ) | ( GenericError );
  OutpostsServiceConnectionsAllUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  OutpostsServiceConnectionsAllTypesListResponse: ( TypeCreate ) | ( ValidationError ) | ( GenericError );
  OutpostsServiceConnectionsDockerListResponse: ( PaginatedDockerServiceConnectionList ) | ( ValidationError ) | ( GenericError );
  OutpostsServiceConnectionsDockerRetrieveResponse: ( DockerServiceConnection ) | ( ValidationError ) | ( GenericError );
  OutpostsServiceConnectionsDockerUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  OutpostsServiceConnectionsKubernetesListResponse: ( PaginatedKubernetesServiceConnectionList ) | ( ValidationError ) | ( GenericError );
  OutpostsServiceConnectionsKubernetesRetrieveResponse: ( KubernetesServiceConnection ) | ( ValidationError ) | ( GenericError );
  OutpostsServiceConnectionsKubernetesUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  PoliciesAllListResponse: ( PaginatedPolicyList ) | ( ValidationError ) | ( GenericError );
  PoliciesAllRetrieveResponse: ( Policy ) | ( ValidationError ) | ( GenericError );
  PoliciesAllUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  PoliciesAllCacheInfoRetrieveResponse: ( Cache ) | ( ValidationError ) | ( GenericError );
  PoliciesAllTypesListResponse: ( TypeCreate ) | ( ValidationError ) | ( GenericError );
  PoliciesBindingsListResponse: ( PaginatedPolicyBindingList ) | ( ValidationError ) | ( GenericError );
  PoliciesBindingsRetrieveResponse: ( PolicyBinding ) | ( ValidationError ) | ( GenericError );
  PoliciesBindingsUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  PoliciesDummyListResponse: ( PaginatedDummyPolicyList ) | ( ValidationError ) | ( GenericError );
  PoliciesDummyRetrieveResponse: ( DummyPolicy ) | ( ValidationError ) | ( GenericError );
  PoliciesDummyUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  PoliciesEventMatcherListResponse: ( PaginatedEventMatcherPolicyList ) | ( ValidationError ) | ( GenericError );
  PoliciesEventMatcherRetrieveResponse: ( EventMatcherPolicy ) | ( ValidationError ) | ( GenericError );
  PoliciesEventMatcherUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  PoliciesExpressionListResponse: ( PaginatedExpressionPolicyList ) | ( ValidationError ) | ( GenericError );
  PoliciesExpressionRetrieveResponse: ( ExpressionPolicy ) | ( ValidationError ) | ( GenericError );
  PoliciesExpressionUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  PoliciesPasswordListResponse: ( PaginatedPasswordPolicyList ) | ( ValidationError ) | ( GenericError );
  PoliciesPasswordRetrieveResponse: ( PasswordPolicy ) | ( ValidationError ) | ( GenericError );
  PoliciesPasswordUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  PoliciesPasswordExpiryListResponse: ( PaginatedPasswordExpiryPolicyList ) | ( ValidationError ) | ( GenericError );
  PoliciesPasswordExpiryRetrieveResponse: ( PasswordExpiryPolicy ) | ( ValidationError ) | ( GenericError );
  PoliciesPasswordExpiryUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  PoliciesReputationListResponse: ( PaginatedReputationPolicyList ) | ( ValidationError ) | ( GenericError );
  PoliciesReputationRetrieveResponse: ( ReputationPolicy ) | ( ValidationError ) | ( GenericError );
  PoliciesReputationUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  PoliciesReputationScoresListResponse: ( PaginatedReputationList ) | ( ValidationError ) | ( GenericError );
  PoliciesReputationScoresRetrieveResponse: ( Reputation ) | ( ValidationError ) | ( GenericError );
  PoliciesReputationScoresUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  PropertymappingsAllListResponse: ( PaginatedPropertyMappingList ) | ( ValidationError ) | ( GenericError );
  PropertymappingsAllRetrieveResponse: ( PropertyMapping ) | ( ValidationError ) | ( GenericError );
  PropertymappingsAllUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  PropertymappingsAllTypesListResponse: ( TypeCreate ) | ( ValidationError ) | ( GenericError );
  PropertymappingsLdapListResponse: ( PaginatedLdapPropertyMappingList ) | ( ValidationError ) | ( GenericError );
  PropertymappingsLdapRetrieveResponse: ( LdapPropertyMapping ) | ( ValidationError ) | ( GenericError );
  PropertymappingsLdapUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  PropertymappingsNotificationListResponse: ( PaginatedNotificationWebhookMappingList ) | ( ValidationError ) | ( GenericError );
  PropertymappingsNotificationRetrieveResponse: ( NotificationWebhookMapping ) | ( ValidationError ) | ( GenericError );
  PropertymappingsNotificationUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  PropertymappingsRacListResponse: ( PaginatedRacPropertyMappingList ) | ( ValidationError ) | ( GenericError );
  PropertymappingsRacRetrieveResponse: ( RacPropertyMapping ) | ( ValidationError ) | ( GenericError );
  PropertymappingsRacUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  PropertymappingsSamlListResponse: ( PaginatedSamlPropertyMappingList ) | ( ValidationError ) | ( GenericError );
  PropertymappingsSamlRetrieveResponse: ( SamlPropertyMapping ) | ( ValidationError ) | ( GenericError );
  PropertymappingsSamlUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  PropertymappingsScimListResponse: ( PaginatedScimMappingList ) | ( ValidationError ) | ( GenericError );
  PropertymappingsScimRetrieveResponse: ( ScimMapping ) | ( ValidationError ) | ( GenericError );
  PropertymappingsScimUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  PropertymappingsScopeListResponse: ( PaginatedScopeMappingList ) | ( ValidationError ) | ( GenericError );
  PropertymappingsScopeRetrieveResponse: ( ScopeMapping ) | ( ValidationError ) | ( GenericError );
  PropertymappingsScopeUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  ProvidersAllListResponse: ( Omit<PaginatedProviderList, 'results'> & { results: Array<Maybe<_RefType['Provider']>> } ) | ( ValidationError ) | ( GenericError );
  ProvidersAllRetrieveResponse: ( Omit<Provider, 'application'> & { application?: Maybe<_RefType['CoreApplicationsRetrieveResponse']> } ) | ( ValidationError ) | ( GenericError );
  ProvidersAllUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  ProvidersAllTypesListResponse: ( TypeCreate ) | ( ValidationError ) | ( GenericError );
  ProvidersLdapListResponse: ( PaginatedLdapProviderList ) | ( ValidationError ) | ( GenericError );
  ProvidersLdapRetrieveResponse: ( LdapProvider ) | ( ValidationError ) | ( GenericError );
  ProvidersLdapUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  ProvidersOauth2ListResponse: ( PaginatedOAuth2ProviderList ) | ( ValidationError ) | ( GenericError );
  ProvidersOauth2RetrieveResponse: ( OAuth2Provider ) | ( ValidationError ) | ( GenericError );
  ProvidersOauth2PreviewUserRetrieveResponse: ( PropertyMappingPreview ) | ( GenericError );
  ProvidersOauth2SetupUrlsRetrieveResponse: ( OAuth2ProviderSetupUrLs ) | ( ValidationError ) | ( GenericError );
  ProvidersOauth2UsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  ProvidersProxyListResponse: ( PaginatedProxyProviderList ) | ( ValidationError ) | ( GenericError );
  ProvidersProxyRetrieveResponse: ( ProxyProvider ) | ( ValidationError ) | ( GenericError );
  ProvidersProxyUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  ProvidersRacListResponse: ( PaginatedRacProviderList ) | ( ValidationError ) | ( GenericError );
  ProvidersRacRetrieveResponse: ( RacProvider ) | ( ValidationError ) | ( GenericError );
  ProvidersRacUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  ProvidersRadiusListResponse: ( PaginatedRadiusProviderList ) | ( ValidationError ) | ( GenericError );
  ProvidersRadiusRetrieveResponse: ( RadiusProvider ) | ( ValidationError ) | ( GenericError );
  ProvidersRadiusUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  ProvidersSamlListResponse: ( PaginatedSamlProviderList ) | ( ValidationError ) | ( GenericError );
  ProvidersSamlRetrieveResponse: ( SamlProvider ) | ( ValidationError ) | ( GenericError );
  ProvidersSamlMetadataRetrieveResponse: ( SamlMetadata ) | ( ValidationError ) | ( GenericError );
  ProvidersSamlPreviewUserRetrieveResponse: ( PropertyMappingPreview ) | ( GenericError );
  ProvidersSamlUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  ProvidersScimListResponse: ( PaginatedScimProviderList ) | ( ValidationError ) | ( GenericError );
  ProvidersScimRetrieveResponse: ( ScimProvider ) | ( ValidationError ) | ( GenericError );
  ProvidersScimSyncStatusRetrieveResponse: ( ScimSyncStatus ) | ( ValidationError ) | ( GenericError );
  ProvidersScimUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  RacConnectionTokensListResponse: ( PaginatedConnectionTokenList ) | ( ValidationError ) | ( GenericError );
  RacConnectionTokensRetrieveResponse: ( ConnectionToken ) | ( ValidationError ) | ( GenericError );
  RacConnectionTokensUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  RacEndpointsListResponse: ( PaginatedEndpointList ) | ( GenericError );
  RacEndpointsRetrieveResponse: ( Endpoint ) | ( ValidationError ) | ( GenericError );
  RacEndpointsUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  RbacPermissionsListResponse: ( PaginatedPermissionList ) | ( ValidationError ) | ( GenericError );
  RbacPermissionsRetrieveResponse: ( Permission ) | ( ValidationError ) | ( GenericError );
  RbacPermissionsAssignedByRolesListResponse: ( PaginatedRoleAssignedObjectPermissionList ) | ( ValidationError ) | ( GenericError );
  RbacPermissionsAssignedByUsersListResponse: ( PaginatedUserAssignedObjectPermissionList ) | ( ValidationError ) | ( GenericError );
  RbacPermissionsRolesListResponse: ( PaginatedExtraRoleObjectPermissionList ) | ( ValidationError ) | ( GenericError );
  RbacPermissionsUsersListResponse: ( PaginatedExtraUserObjectPermissionList ) | ( ValidationError ) | ( GenericError );
  RbacRolesListResponse: ( PaginatedRoleList ) | ( ValidationError ) | ( GenericError );
  RbacRolesRetrieveResponse: ( Role ) | ( ValidationError ) | ( GenericError );
  RbacRolesUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  RootConfigRetrieveResponse: ( Config ) | ( ValidationError ) | ( GenericError );
  SchemaRetrieveResponse: ( JsonContainer ) | ( ValidationError ) | ( GenericError );
  SourcesAllListResponse: ( PaginatedSourceList ) | ( ValidationError ) | ( GenericError );
  SourcesAllRetrieveResponse: ( Source ) | ( ValidationError ) | ( GenericError );
  SourcesAllUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  SourcesAllTypesListResponse: ( TypeCreate ) | ( ValidationError ) | ( GenericError );
  SourcesAllUserSettingsListResponse: ( UserSetting ) | ( ValidationError ) | ( GenericError );
  SourcesLdapListResponse: ( PaginatedLdapSourceList ) | ( ValidationError ) | ( GenericError );
  SourcesLdapRetrieveResponse: ( LdapSource ) | ( ValidationError ) | ( GenericError );
  SourcesLdapDebugRetrieveResponse: ( LdapDebug ) | ( ValidationError ) | ( GenericError );
  SourcesLdapSyncStatusRetrieveResponse: ( LdapSyncStatus ) | ( ValidationError ) | ( GenericError );
  SourcesLdapUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  SourcesOauthListResponse: ( PaginatedOAuthSourceList ) | ( ValidationError ) | ( GenericError );
  SourcesOauthRetrieveResponse: ( OAuthSource ) | ( ValidationError ) | ( GenericError );
  SourcesOauthUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  SourcesOauthSourceTypesListResponse: ( SourceType ) | ( ValidationError ) | ( GenericError );
  SourcesPlexListResponse: ( PaginatedPlexSourceList ) | ( ValidationError ) | ( GenericError );
  SourcesPlexRetrieveResponse: ( PlexSource ) | ( ValidationError ) | ( GenericError );
  SourcesPlexUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  SourcesSamlListResponse: ( PaginatedSamlSourceList ) | ( ValidationError ) | ( GenericError );
  SourcesSamlRetrieveResponse: ( SamlSource ) | ( ValidationError ) | ( GenericError );
  SourcesSamlMetadataRetrieveResponse: ( SamlMetadata ) | ( ValidationError ) | ( GenericError );
  SourcesSamlUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  SourcesScimListResponse: ( PaginatedScimSourceList ) | ( ValidationError ) | ( GenericError );
  SourcesScimRetrieveResponse: ( ScimSource ) | ( ValidationError ) | ( GenericError );
  SourcesScimUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  SourcesScimGroupsListResponse: ( PaginatedScimSourceGroupList ) | ( ValidationError ) | ( GenericError );
  SourcesScimGroupsRetrieveResponse: ( ScimSourceGroup ) | ( ValidationError ) | ( GenericError );
  SourcesScimGroupsUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  SourcesScimUsersListResponse: ( PaginatedScimSourceUserList ) | ( ValidationError ) | ( GenericError );
  SourcesScimUsersRetrieveResponse: ( ScimSourceUser ) | ( ValidationError ) | ( GenericError );
  SourcesScimUsersUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  SourcesUserConnectionsAllListResponse: ( PaginatedUserSourceConnectionList ) | ( ValidationError ) | ( GenericError );
  SourcesUserConnectionsAllRetrieveResponse: ( UserSourceConnection ) | ( ValidationError ) | ( GenericError );
  SourcesUserConnectionsAllUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  SourcesUserConnectionsOauthListResponse: ( PaginatedUserOAuthSourceConnectionList ) | ( ValidationError ) | ( GenericError );
  SourcesUserConnectionsOauthRetrieveResponse: ( UserOAuthSourceConnection ) | ( ValidationError ) | ( GenericError );
  SourcesUserConnectionsOauthUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  SourcesUserConnectionsPlexListResponse: ( PaginatedPlexSourceConnectionList ) | ( ValidationError ) | ( GenericError );
  SourcesUserConnectionsPlexRetrieveResponse: ( PlexSourceConnection ) | ( ValidationError ) | ( GenericError );
  SourcesUserConnectionsPlexUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  SourcesUserConnectionsSamlListResponse: ( PaginatedUserSamlSourceConnectionList ) | ( ValidationError ) | ( GenericError );
  SourcesUserConnectionsSamlRetrieveResponse: ( UserSamlSourceConnection ) | ( ValidationError ) | ( GenericError );
  SourcesUserConnectionsSamlUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  StagesAllListResponse: ( PaginatedStageList ) | ( ValidationError ) | ( GenericError );
  StagesAllRetrieveResponse: ( Stage ) | ( ValidationError ) | ( GenericError );
  StagesAllUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  StagesAllTypesListResponse: ( TypeCreate ) | ( ValidationError ) | ( GenericError );
  StagesAllUserSettingsListResponse: ( UserSetting ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorDuoListResponse: ( PaginatedAuthenticatorDuoStageList ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorDuoRetrieveResponse: ( AuthenticatorDuoStage ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorDuoUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorSmsListResponse: ( PaginatedAuthenticatorSmsStageList ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorSmsRetrieveResponse: ( AuthenticatorSmsStage ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorSmsUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorStaticListResponse: ( PaginatedAuthenticatorStaticStageList ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorStaticRetrieveResponse: ( AuthenticatorStaticStage ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorStaticUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorTotpListResponse: ( PaginatedAuthenticatorTotpStageList ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorTotpRetrieveResponse: ( AuthenticatorTotpStage ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorTotpUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorValidateListResponse: ( PaginatedAuthenticatorValidateStageList ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorValidateRetrieveResponse: ( AuthenticatorValidateStage ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorValidateUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorWebauthnListResponse: ( PaginatedAuthenticatorWebAuthnStageList ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorWebauthnRetrieveResponse: ( AuthenticatorWebAuthnStage ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorWebauthnUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorWebauthnDeviceTypesListResponse: ( PaginatedWebAuthnDeviceTypeList ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorWebauthnDeviceTypesRetrieveResponse: ( WebAuthnDeviceType ) | ( ValidationError ) | ( GenericError );
  StagesCaptchaListResponse: ( PaginatedCaptchaStageList ) | ( ValidationError ) | ( GenericError );
  StagesCaptchaRetrieveResponse: ( CaptchaStage ) | ( ValidationError ) | ( GenericError );
  StagesCaptchaUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  StagesConsentListResponse: ( PaginatedConsentStageList ) | ( ValidationError ) | ( GenericError );
  StagesConsentRetrieveResponse: ( ConsentStage ) | ( ValidationError ) | ( GenericError );
  StagesConsentUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  StagesDenyListResponse: ( PaginatedDenyStageList ) | ( ValidationError ) | ( GenericError );
  StagesDenyRetrieveResponse: ( DenyStage ) | ( ValidationError ) | ( GenericError );
  StagesDenyUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  StagesDummyListResponse: ( PaginatedDummyStageList ) | ( ValidationError ) | ( GenericError );
  StagesDummyRetrieveResponse: ( DummyStage ) | ( ValidationError ) | ( GenericError );
  StagesDummyUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  StagesEmailListResponse: ( PaginatedEmailStageList ) | ( ValidationError ) | ( GenericError );
  StagesEmailRetrieveResponse: ( EmailStage ) | ( ValidationError ) | ( GenericError );
  StagesEmailUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  StagesEmailTemplatesListResponse: ( TypeCreate ) | ( ValidationError ) | ( GenericError );
  StagesIdentificationListResponse: ( PaginatedIdentificationStageList ) | ( ValidationError ) | ( GenericError );
  StagesIdentificationRetrieveResponse: ( IdentificationStage ) | ( ValidationError ) | ( GenericError );
  StagesIdentificationUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  StagesInvitationInvitationsListResponse: ( PaginatedInvitationList ) | ( ValidationError ) | ( GenericError );
  StagesInvitationInvitationsRetrieveResponse: ( Invitation ) | ( ValidationError ) | ( GenericError );
  StagesInvitationInvitationsUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  StagesInvitationStagesListResponse: ( PaginatedInvitationStageList ) | ( ValidationError ) | ( GenericError );
  StagesInvitationStagesRetrieveResponse: ( InvitationStage ) | ( ValidationError ) | ( GenericError );
  StagesInvitationStagesUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  StagesPasswordListResponse: ( PaginatedPasswordStageList ) | ( ValidationError ) | ( GenericError );
  StagesPasswordRetrieveResponse: ( PasswordStage ) | ( ValidationError ) | ( GenericError );
  StagesPasswordUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  StagesPromptPromptsListResponse: ( PaginatedPromptList ) | ( ValidationError ) | ( GenericError );
  StagesPromptPromptsRetrieveResponse: ( Prompt ) | ( ValidationError ) | ( GenericError );
  StagesPromptPromptsUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  StagesPromptStagesListResponse: ( PaginatedPromptStageList ) | ( ValidationError ) | ( GenericError );
  StagesPromptStagesRetrieveResponse: ( PromptStage ) | ( ValidationError ) | ( GenericError );
  StagesPromptStagesUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  StagesSourceListResponse: ( PaginatedSourceStageList ) | ( ValidationError ) | ( GenericError );
  StagesSourceRetrieveResponse: ( SourceStage ) | ( ValidationError ) | ( GenericError );
  StagesSourceUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  StagesUserDeleteListResponse: ( PaginatedUserDeleteStageList ) | ( ValidationError ) | ( GenericError );
  StagesUserDeleteRetrieveResponse: ( UserDeleteStage ) | ( ValidationError ) | ( GenericError );
  StagesUserDeleteUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  StagesUserLoginListResponse: ( PaginatedUserLoginStageList ) | ( ValidationError ) | ( GenericError );
  StagesUserLoginRetrieveResponse: ( UserLoginStage ) | ( ValidationError ) | ( GenericError );
  StagesUserLoginUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  StagesUserLogoutListResponse: ( PaginatedUserLogoutStageList ) | ( ValidationError ) | ( GenericError );
  StagesUserLogoutRetrieveResponse: ( UserLogoutStage ) | ( ValidationError ) | ( GenericError );
  StagesUserLogoutUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  StagesUserWriteListResponse: ( PaginatedUserWriteStageList ) | ( ValidationError ) | ( GenericError );
  StagesUserWriteRetrieveResponse: ( UserWriteStage ) | ( ValidationError ) | ( GenericError );
  StagesUserWriteUsedByListResponse: ( UsedBy ) | ( ValidationError ) | ( GenericError );
  AdminSettingsUpdateResponse: ( Settings ) | ( ValidationError ) | ( GenericError );
  AdminSettingsPartialUpdateResponse: ( Settings ) | ( ValidationError ) | ( GenericError );
  AdminSystemCreateResponse: ( SystemInfo ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsAdminDuoCreateResponse: ( DuoDevice ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsAdminDuoUpdateResponse: ( DuoDevice ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsAdminDuoPartialUpdateResponse: ( DuoDevice ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsAdminDuoDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsAdminSmsCreateResponse: ( SmsDevice ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsAdminSmsUpdateResponse: ( SmsDevice ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsAdminSmsPartialUpdateResponse: ( SmsDevice ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsAdminSmsDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsAdminStaticCreateResponse: ( StaticDevice ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsAdminStaticUpdateResponse: ( StaticDevice ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsAdminStaticPartialUpdateResponse: ( StaticDevice ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsAdminStaticDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsAdminTotpCreateResponse: ( TotpDevice ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsAdminTotpUpdateResponse: ( TotpDevice ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsAdminTotpPartialUpdateResponse: ( TotpDevice ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsAdminTotpDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsAdminWebauthnCreateResponse: ( WebAuthnDevice ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsAdminWebauthnUpdateResponse: ( WebAuthnDevice ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsAdminWebauthnPartialUpdateResponse: ( WebAuthnDevice ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsAdminWebauthnDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsDuoUpdateResponse: ( DuoDevice ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsDuoPartialUpdateResponse: ( DuoDevice ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsDuoDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsSmsUpdateResponse: ( SmsDevice ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsSmsPartialUpdateResponse: ( SmsDevice ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsSmsDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsStaticUpdateResponse: ( StaticDevice ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsStaticPartialUpdateResponse: ( StaticDevice ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsStaticDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsTotpUpdateResponse: ( TotpDevice ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsTotpPartialUpdateResponse: ( TotpDevice ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsTotpDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsWebauthnUpdateResponse: ( WebAuthnDevice ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsWebauthnPartialUpdateResponse: ( WebAuthnDevice ) | ( ValidationError ) | ( GenericError );
  AuthenticatorsWebauthnDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  CoreApplicationsCreateResponse: ( Omit<Application, 'providerObj' | 'backchannelProvidersObj' | 'churrosGroup' | 'metrics'> & { providerObj: _RefType['Provider'], backchannelProvidersObj: Array<Maybe<_RefType['Provider']>>, churrosGroup: _RefType['ChurrosGroup'], metrics?: Maybe<Array<Maybe<_RefType['CoreApplicationsMetricsListResponse']>>> } ) | ( ValidationError ) | ( GenericError );
  CoreApplicationsUpdateResponse: ( Omit<Application, 'providerObj' | 'backchannelProvidersObj' | 'churrosGroup' | 'metrics'> & { providerObj: _RefType['Provider'], backchannelProvidersObj: Array<Maybe<_RefType['Provider']>>, churrosGroup: _RefType['ChurrosGroup'], metrics?: Maybe<Array<Maybe<_RefType['CoreApplicationsMetricsListResponse']>>> } ) | ( ValidationError ) | ( GenericError );
  CoreApplicationsPartialUpdateResponse: ( Omit<Application, 'providerObj' | 'backchannelProvidersObj' | 'churrosGroup' | 'metrics'> & { providerObj: _RefType['Provider'], backchannelProvidersObj: Array<Maybe<_RefType['Provider']>>, churrosGroup: _RefType['ChurrosGroup'], metrics?: Maybe<Array<Maybe<_RefType['CoreApplicationsMetricsListResponse']>>> } ) | ( ValidationError ) | ( GenericError );
  CoreApplicationsDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  CoreAuthenticatedSessionsDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  CoreBrandsCreateResponse: ( Brand ) | ( ValidationError ) | ( GenericError );
  CoreBrandsUpdateResponse: ( Brand ) | ( ValidationError ) | ( GenericError );
  CoreBrandsPartialUpdateResponse: ( Brand ) | ( ValidationError ) | ( GenericError );
  CoreBrandsDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  CoreGroupsCreateResponse: ( Group ) | ( ValidationError ) | ( GenericError );
  CoreGroupsUpdateResponse: ( Group ) | ( ValidationError ) | ( GenericError );
  CoreGroupsPartialUpdateResponse: ( Group ) | ( ValidationError ) | ( GenericError );
  CoreGroupsDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  CoreGroupsAddUserCreateResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  CoreGroupsRemoveUserCreateResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  CoreTokensCreateResponse: ( Token ) | ( ValidationError ) | ( GenericError );
  CoreTokensUpdateResponse: ( Token ) | ( ValidationError ) | ( GenericError );
  CoreTokensPartialUpdateResponse: ( Token ) | ( ValidationError ) | ( GenericError );
  CoreTokensDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  CoreTokensSetKeyCreateResponse: ( VoidContainer ) | ( GenericError );
  CoreTransactionalApplicationsUpdateResponse: ( TransactionApplicationResponse ) | ( ValidationError ) | ( GenericError );
  CoreUserConsentDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  CoreUsersCreateResponse: ( User ) | ( ValidationError ) | ( GenericError );
  CoreUsersUpdateResponse: ( User ) | ( ValidationError ) | ( GenericError );
  CoreUsersPartialUpdateResponse: ( User ) | ( ValidationError ) | ( GenericError );
  CoreUsersDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  CoreUsersImpersonateCreateResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  CoreUsersRecoveryCreateResponse: ( Link ) | ( ValidationError ) | ( GenericError );
  CoreUsersRecoveryEmailCreateResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  CoreUsersSetPasswordCreateResponse: ( VoidContainer ) | ( GenericError );
  CoreUsersServiceAccountCreateResponse: ( UserServiceAccountResponse ) | ( ValidationError ) | ( GenericError );
  CryptoCertificatekeypairsCreateResponse: ( CertificateKeyPair ) | ( ValidationError ) | ( GenericError );
  CryptoCertificatekeypairsUpdateResponse: ( CertificateKeyPair ) | ( ValidationError ) | ( GenericError );
  CryptoCertificatekeypairsPartialUpdateResponse: ( CertificateKeyPair ) | ( ValidationError ) | ( GenericError );
  CryptoCertificatekeypairsDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  CryptoCertificatekeypairsGenerateCreateResponse: ( CertificateKeyPair ) | ( GenericError );
  EnterpriseLicenseCreateResponse: ( License ) | ( ValidationError ) | ( GenericError );
  EnterpriseLicenseUpdateResponse: ( License ) | ( ValidationError ) | ( GenericError );
  EnterpriseLicensePartialUpdateResponse: ( License ) | ( ValidationError ) | ( GenericError );
  EnterpriseLicenseDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  EventsEventsCreateResponse: ( Event ) | ( ValidationError ) | ( GenericError );
  EventsEventsUpdateResponse: ( Event ) | ( ValidationError ) | ( GenericError );
  EventsEventsPartialUpdateResponse: ( Event ) | ( ValidationError ) | ( GenericError );
  EventsEventsDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  EventsNotificationsUpdateResponse: ( Notification ) | ( ValidationError ) | ( GenericError );
  EventsNotificationsPartialUpdateResponse: ( Notification ) | ( ValidationError ) | ( GenericError );
  EventsNotificationsDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  EventsNotificationsMarkAllSeenCreateResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  EventsRulesCreateResponse: ( NotificationRule ) | ( ValidationError ) | ( GenericError );
  EventsRulesUpdateResponse: ( NotificationRule ) | ( ValidationError ) | ( GenericError );
  EventsRulesPartialUpdateResponse: ( NotificationRule ) | ( ValidationError ) | ( GenericError );
  EventsRulesDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  EventsSystemTasksRunCreateResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  EventsTransportsCreateResponse: ( NotificationTransport ) | ( ValidationError ) | ( GenericError );
  EventsTransportsUpdateResponse: ( NotificationTransport ) | ( ValidationError ) | ( GenericError );
  EventsTransportsPartialUpdateResponse: ( NotificationTransport ) | ( ValidationError ) | ( GenericError );
  EventsTransportsDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  EventsTransportsTestCreateResponse: ( NotificationTransportTest ) | ( ValidationError ) | ( GenericError );
  FlowsBindingsCreateResponse: ( FlowStageBinding ) | ( ValidationError ) | ( GenericError );
  FlowsBindingsUpdateResponse: ( FlowStageBinding ) | ( ValidationError ) | ( GenericError );
  FlowsBindingsPartialUpdateResponse: ( FlowStageBinding ) | ( ValidationError ) | ( GenericError );
  FlowsBindingsDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  FlowsExecutorSolveResponse: ( AccessDeniedChallenge ) | ( AppleLoginChallenge ) | ( AuthenticatorDuoChallenge ) | ( AuthenticatorSmsChallenge ) | ( AuthenticatorStaticChallenge ) | ( AuthenticatorTotpChallenge ) | ( AuthenticatorValidationChallenge ) | ( AuthenticatorWebAuthnChallenge ) | ( AutosubmitChallenge ) | ( CaptchaChallenge ) | ( ConsentChallenge ) | ( EmailChallenge ) | ( FlowErrorChallenge ) | ( Omit<IdentificationChallenge, 'sources'> & { sources?: Maybe<Array<Maybe<_RefType['LoginSource']>>> } ) | ( OAuthDeviceCodeChallenge ) | ( OAuthDeviceCodeFinishChallenge ) | ( PasswordChallenge ) | ( PlexAuthenticationChallenge ) | ( PromptChallenge ) | ( RedirectChallenge ) | ( ShellChallenge ) | ( UserLoginChallenge ) | ( ValidationError ) | ( GenericError );
  FlowsInstancesCreateResponse: ( Flow ) | ( ValidationError ) | ( GenericError );
  FlowsInstancesUpdateResponse: ( Flow ) | ( ValidationError ) | ( GenericError );
  FlowsInstancesPartialUpdateResponse: ( Flow ) | ( ValidationError ) | ( GenericError );
  FlowsInstancesDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  FlowsInstancesCacheClearCreateResponse: ( VoidContainer ) | ( GenericError );
  FlowsInstancesImportCreateResponse: ( FlowImportResult ) | ( GenericError );
  ManagedBlueprintsCreateResponse: ( BlueprintInstance ) | ( ValidationError ) | ( GenericError );
  ManagedBlueprintsUpdateResponse: ( BlueprintInstance ) | ( ValidationError ) | ( GenericError );
  ManagedBlueprintsPartialUpdateResponse: ( BlueprintInstance ) | ( ValidationError ) | ( GenericError );
  ManagedBlueprintsDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  ManagedBlueprintsApplyCreateResponse: ( BlueprintInstance ) | ( ValidationError ) | ( GenericError );
  Oauth2AccessTokensDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  Oauth2AuthorizationCodesDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  Oauth2RefreshTokensDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  OutpostsInstancesCreateResponse: ( Omit<Outpost, 'providersObj'> & { providersObj: Array<Maybe<_RefType['Provider']>> } ) | ( ValidationError ) | ( GenericError );
  OutpostsInstancesUpdateResponse: ( Omit<Outpost, 'providersObj'> & { providersObj: Array<Maybe<_RefType['Provider']>> } ) | ( ValidationError ) | ( GenericError );
  OutpostsInstancesPartialUpdateResponse: ( Omit<Outpost, 'providersObj'> & { providersObj: Array<Maybe<_RefType['Provider']>> } ) | ( ValidationError ) | ( GenericError );
  OutpostsInstancesDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  OutpostsServiceConnectionsAllDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  OutpostsServiceConnectionsDockerCreateResponse: ( DockerServiceConnection ) | ( ValidationError ) | ( GenericError );
  OutpostsServiceConnectionsDockerUpdateResponse: ( DockerServiceConnection ) | ( ValidationError ) | ( GenericError );
  OutpostsServiceConnectionsDockerPartialUpdateResponse: ( DockerServiceConnection ) | ( ValidationError ) | ( GenericError );
  OutpostsServiceConnectionsDockerDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  OutpostsServiceConnectionsKubernetesCreateResponse: ( KubernetesServiceConnection ) | ( ValidationError ) | ( GenericError );
  OutpostsServiceConnectionsKubernetesUpdateResponse: ( KubernetesServiceConnection ) | ( ValidationError ) | ( GenericError );
  OutpostsServiceConnectionsKubernetesPartialUpdateResponse: ( KubernetesServiceConnection ) | ( ValidationError ) | ( GenericError );
  OutpostsServiceConnectionsKubernetesDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  PoliciesAllDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  PoliciesAllTestCreateResponse: ( PolicyTestResult ) | ( GenericError );
  PoliciesAllCacheClearCreateResponse: ( VoidContainer ) | ( GenericError );
  PoliciesBindingsCreateResponse: ( PolicyBinding ) | ( ValidationError ) | ( GenericError );
  PoliciesBindingsUpdateResponse: ( PolicyBinding ) | ( ValidationError ) | ( GenericError );
  PoliciesBindingsPartialUpdateResponse: ( PolicyBinding ) | ( ValidationError ) | ( GenericError );
  PoliciesBindingsDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  PoliciesDummyCreateResponse: ( DummyPolicy ) | ( ValidationError ) | ( GenericError );
  PoliciesDummyUpdateResponse: ( DummyPolicy ) | ( ValidationError ) | ( GenericError );
  PoliciesDummyPartialUpdateResponse: ( DummyPolicy ) | ( ValidationError ) | ( GenericError );
  PoliciesDummyDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  PoliciesEventMatcherCreateResponse: ( EventMatcherPolicy ) | ( ValidationError ) | ( GenericError );
  PoliciesEventMatcherUpdateResponse: ( EventMatcherPolicy ) | ( ValidationError ) | ( GenericError );
  PoliciesEventMatcherPartialUpdateResponse: ( EventMatcherPolicy ) | ( ValidationError ) | ( GenericError );
  PoliciesEventMatcherDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  PoliciesExpressionCreateResponse: ( ExpressionPolicy ) | ( ValidationError ) | ( GenericError );
  PoliciesExpressionUpdateResponse: ( ExpressionPolicy ) | ( ValidationError ) | ( GenericError );
  PoliciesExpressionPartialUpdateResponse: ( ExpressionPolicy ) | ( ValidationError ) | ( GenericError );
  PoliciesExpressionDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  PoliciesPasswordCreateResponse: ( PasswordPolicy ) | ( ValidationError ) | ( GenericError );
  PoliciesPasswordUpdateResponse: ( PasswordPolicy ) | ( ValidationError ) | ( GenericError );
  PoliciesPasswordPartialUpdateResponse: ( PasswordPolicy ) | ( ValidationError ) | ( GenericError );
  PoliciesPasswordDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  PoliciesPasswordExpiryCreateResponse: ( PasswordExpiryPolicy ) | ( ValidationError ) | ( GenericError );
  PoliciesPasswordExpiryUpdateResponse: ( PasswordExpiryPolicy ) | ( ValidationError ) | ( GenericError );
  PoliciesPasswordExpiryPartialUpdateResponse: ( PasswordExpiryPolicy ) | ( ValidationError ) | ( GenericError );
  PoliciesPasswordExpiryDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  PoliciesReputationCreateResponse: ( ReputationPolicy ) | ( ValidationError ) | ( GenericError );
  PoliciesReputationUpdateResponse: ( ReputationPolicy ) | ( ValidationError ) | ( GenericError );
  PoliciesReputationPartialUpdateResponse: ( ReputationPolicy ) | ( ValidationError ) | ( GenericError );
  PoliciesReputationDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  PoliciesReputationScoresDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  PropertymappingsAllDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  PropertymappingsAllTestCreateResponse: ( PropertyMappingTestResult ) | ( GenericError );
  PropertymappingsLdapCreateResponse: ( LdapPropertyMapping ) | ( ValidationError ) | ( GenericError );
  PropertymappingsLdapUpdateResponse: ( LdapPropertyMapping ) | ( ValidationError ) | ( GenericError );
  PropertymappingsLdapPartialUpdateResponse: ( LdapPropertyMapping ) | ( ValidationError ) | ( GenericError );
  PropertymappingsLdapDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  PropertymappingsNotificationCreateResponse: ( NotificationWebhookMapping ) | ( ValidationError ) | ( GenericError );
  PropertymappingsNotificationUpdateResponse: ( NotificationWebhookMapping ) | ( ValidationError ) | ( GenericError );
  PropertymappingsNotificationPartialUpdateResponse: ( NotificationWebhookMapping ) | ( ValidationError ) | ( GenericError );
  PropertymappingsNotificationDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  PropertymappingsRacCreateResponse: ( RacPropertyMapping ) | ( ValidationError ) | ( GenericError );
  PropertymappingsRacUpdateResponse: ( RacPropertyMapping ) | ( ValidationError ) | ( GenericError );
  PropertymappingsRacPartialUpdateResponse: ( RacPropertyMapping ) | ( ValidationError ) | ( GenericError );
  PropertymappingsRacDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  PropertymappingsSamlCreateResponse: ( SamlPropertyMapping ) | ( ValidationError ) | ( GenericError );
  PropertymappingsSamlUpdateResponse: ( SamlPropertyMapping ) | ( ValidationError ) | ( GenericError );
  PropertymappingsSamlPartialUpdateResponse: ( SamlPropertyMapping ) | ( ValidationError ) | ( GenericError );
  PropertymappingsSamlDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  PropertymappingsScimCreateResponse: ( ScimMapping ) | ( ValidationError ) | ( GenericError );
  PropertymappingsScimUpdateResponse: ( ScimMapping ) | ( ValidationError ) | ( GenericError );
  PropertymappingsScimPartialUpdateResponse: ( ScimMapping ) | ( ValidationError ) | ( GenericError );
  PropertymappingsScimDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  PropertymappingsScopeCreateResponse: ( ScopeMapping ) | ( ValidationError ) | ( GenericError );
  PropertymappingsScopeUpdateResponse: ( ScopeMapping ) | ( ValidationError ) | ( GenericError );
  PropertymappingsScopePartialUpdateResponse: ( ScopeMapping ) | ( ValidationError ) | ( GenericError );
  PropertymappingsScopeDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  ProvidersAllDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  ProvidersLdapCreateResponse: ( LdapProvider ) | ( ValidationError ) | ( GenericError );
  ProvidersLdapUpdateResponse: ( LdapProvider ) | ( ValidationError ) | ( GenericError );
  ProvidersLdapPartialUpdateResponse: ( LdapProvider ) | ( ValidationError ) | ( GenericError );
  ProvidersLdapDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  ProvidersOauth2CreateResponse: ( OAuth2Provider ) | ( ValidationError ) | ( GenericError );
  ProvidersOauth2UpdateResponse: ( OAuth2Provider ) | ( ValidationError ) | ( GenericError );
  ProvidersOauth2PartialUpdateResponse: ( OAuth2Provider ) | ( ValidationError ) | ( GenericError );
  ProvidersOauth2DestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  ProvidersProxyCreateResponse: ( ProxyProvider ) | ( ValidationError ) | ( GenericError );
  ProvidersProxyUpdateResponse: ( ProxyProvider ) | ( ValidationError ) | ( GenericError );
  ProvidersProxyPartialUpdateResponse: ( ProxyProvider ) | ( ValidationError ) | ( GenericError );
  ProvidersProxyDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  ProvidersRacCreateResponse: ( RacProvider ) | ( ValidationError ) | ( GenericError );
  ProvidersRacUpdateResponse: ( RacProvider ) | ( ValidationError ) | ( GenericError );
  ProvidersRacPartialUpdateResponse: ( RacProvider ) | ( ValidationError ) | ( GenericError );
  ProvidersRacDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  ProvidersRadiusCreateResponse: ( RadiusProvider ) | ( ValidationError ) | ( GenericError );
  ProvidersRadiusUpdateResponse: ( RadiusProvider ) | ( ValidationError ) | ( GenericError );
  ProvidersRadiusPartialUpdateResponse: ( RadiusProvider ) | ( ValidationError ) | ( GenericError );
  ProvidersRadiusDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  ProvidersSamlCreateResponse: ( SamlProvider ) | ( ValidationError ) | ( GenericError );
  ProvidersSamlUpdateResponse: ( SamlProvider ) | ( ValidationError ) | ( GenericError );
  ProvidersSamlPartialUpdateResponse: ( SamlProvider ) | ( ValidationError ) | ( GenericError );
  ProvidersSamlDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  ProvidersSamlImportMetadataCreateResponse: ( VoidContainer ) | ( GenericError );
  ProvidersScimCreateResponse: ( ScimProvider ) | ( ValidationError ) | ( GenericError );
  ProvidersScimUpdateResponse: ( ScimProvider ) | ( ValidationError ) | ( GenericError );
  ProvidersScimPartialUpdateResponse: ( ScimProvider ) | ( ValidationError ) | ( GenericError );
  ProvidersScimDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  RacConnectionTokensUpdateResponse: ( ConnectionToken ) | ( ValidationError ) | ( GenericError );
  RacConnectionTokensPartialUpdateResponse: ( ConnectionToken ) | ( ValidationError ) | ( GenericError );
  RacConnectionTokensDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  RacEndpointsCreateResponse: ( Endpoint ) | ( ValidationError ) | ( GenericError );
  RacEndpointsUpdateResponse: ( Endpoint ) | ( ValidationError ) | ( GenericError );
  RacEndpointsPartialUpdateResponse: ( Endpoint ) | ( ValidationError ) | ( GenericError );
  RacEndpointsDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  RbacPermissionsAssignedByRolesAssignCreateResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  RbacPermissionsAssignedByRolesUnassignPartialUpdateResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  RbacPermissionsAssignedByUsersAssignCreateResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  RbacPermissionsAssignedByUsersUnassignPartialUpdateResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  RbacRolesCreateResponse: ( Role ) | ( ValidationError ) | ( GenericError );
  RbacRolesUpdateResponse: ( Role ) | ( ValidationError ) | ( GenericError );
  RbacRolesPartialUpdateResponse: ( Role ) | ( ValidationError ) | ( GenericError );
  RbacRolesDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  SourcesAllDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  SourcesLdapCreateResponse: ( LdapSource ) | ( ValidationError ) | ( GenericError );
  SourcesLdapUpdateResponse: ( LdapSource ) | ( ValidationError ) | ( GenericError );
  SourcesLdapPartialUpdateResponse: ( LdapSource ) | ( ValidationError ) | ( GenericError );
  SourcesLdapDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  SourcesOauthCreateResponse: ( OAuthSource ) | ( ValidationError ) | ( GenericError );
  SourcesOauthUpdateResponse: ( OAuthSource ) | ( ValidationError ) | ( GenericError );
  SourcesOauthPartialUpdateResponse: ( OAuthSource ) | ( ValidationError ) | ( GenericError );
  SourcesOauthDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  SourcesPlexCreateResponse: ( PlexSource ) | ( ValidationError ) | ( GenericError );
  SourcesPlexUpdateResponse: ( PlexSource ) | ( ValidationError ) | ( GenericError );
  SourcesPlexPartialUpdateResponse: ( PlexSource ) | ( ValidationError ) | ( GenericError );
  SourcesPlexDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  SourcesSamlCreateResponse: ( SamlSource ) | ( ValidationError ) | ( GenericError );
  SourcesSamlUpdateResponse: ( SamlSource ) | ( ValidationError ) | ( GenericError );
  SourcesSamlPartialUpdateResponse: ( SamlSource ) | ( ValidationError ) | ( GenericError );
  SourcesSamlDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  SourcesScimCreateResponse: ( ScimSource ) | ( ValidationError ) | ( GenericError );
  SourcesScimUpdateResponse: ( ScimSource ) | ( ValidationError ) | ( GenericError );
  SourcesScimPartialUpdateResponse: ( ScimSource ) | ( ValidationError ) | ( GenericError );
  SourcesScimDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  SourcesScimGroupsCreateResponse: ( ScimSourceGroup ) | ( ValidationError ) | ( GenericError );
  SourcesScimGroupsUpdateResponse: ( ScimSourceGroup ) | ( ValidationError ) | ( GenericError );
  SourcesScimGroupsPartialUpdateResponse: ( ScimSourceGroup ) | ( ValidationError ) | ( GenericError );
  SourcesScimGroupsDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  SourcesScimUsersCreateResponse: ( ScimSourceUser ) | ( ValidationError ) | ( GenericError );
  SourcesScimUsersUpdateResponse: ( ScimSourceUser ) | ( ValidationError ) | ( GenericError );
  SourcesScimUsersPartialUpdateResponse: ( ScimSourceUser ) | ( ValidationError ) | ( GenericError );
  SourcesScimUsersDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  SourcesUserConnectionsAllUpdateResponse: ( UserSourceConnection ) | ( ValidationError ) | ( GenericError );
  SourcesUserConnectionsAllPartialUpdateResponse: ( UserSourceConnection ) | ( ValidationError ) | ( GenericError );
  SourcesUserConnectionsAllDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  SourcesUserConnectionsOauthCreateResponse: ( UserOAuthSourceConnection ) | ( ValidationError ) | ( GenericError );
  SourcesUserConnectionsOauthUpdateResponse: ( UserOAuthSourceConnection ) | ( ValidationError ) | ( GenericError );
  SourcesUserConnectionsOauthPartialUpdateResponse: ( UserOAuthSourceConnection ) | ( ValidationError ) | ( GenericError );
  SourcesUserConnectionsOauthDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  SourcesUserConnectionsPlexCreateResponse: ( PlexSourceConnection ) | ( ValidationError ) | ( GenericError );
  SourcesUserConnectionsPlexUpdateResponse: ( PlexSourceConnection ) | ( ValidationError ) | ( GenericError );
  SourcesUserConnectionsPlexPartialUpdateResponse: ( PlexSourceConnection ) | ( ValidationError ) | ( GenericError );
  SourcesUserConnectionsPlexDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  SourcesUserConnectionsSamlCreateResponse: ( UserSamlSourceConnection ) | ( ValidationError ) | ( GenericError );
  SourcesUserConnectionsSamlUpdateResponse: ( UserSamlSourceConnection ) | ( ValidationError ) | ( GenericError );
  SourcesUserConnectionsSamlPartialUpdateResponse: ( UserSamlSourceConnection ) | ( ValidationError ) | ( GenericError );
  SourcesUserConnectionsSamlDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  StagesAllDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorDuoCreateResponse: ( AuthenticatorDuoStage ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorDuoUpdateResponse: ( AuthenticatorDuoStage ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorDuoPartialUpdateResponse: ( AuthenticatorDuoStage ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorDuoDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorDuoEnrollmentStatusCreateResponse: ( DuoDeviceEnrollmentStatus ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorDuoImportDeviceManualCreateResponse: ( VoidContainer ) | ( GenericError );
  StagesAuthenticatorDuoImportDevicesAutomaticCreateResponse: ( AuthenticatorDuoStageDeviceImportResponse ) | ( GenericError );
  StagesAuthenticatorSmsCreateResponse: ( AuthenticatorSmsStage ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorSmsUpdateResponse: ( AuthenticatorSmsStage ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorSmsPartialUpdateResponse: ( AuthenticatorSmsStage ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorSmsDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorStaticCreateResponse: ( AuthenticatorStaticStage ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorStaticUpdateResponse: ( AuthenticatorStaticStage ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorStaticPartialUpdateResponse: ( AuthenticatorStaticStage ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorStaticDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorTotpCreateResponse: ( AuthenticatorTotpStage ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorTotpUpdateResponse: ( AuthenticatorTotpStage ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorTotpPartialUpdateResponse: ( AuthenticatorTotpStage ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorTotpDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorValidateCreateResponse: ( AuthenticatorValidateStage ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorValidateUpdateResponse: ( AuthenticatorValidateStage ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorValidatePartialUpdateResponse: ( AuthenticatorValidateStage ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorValidateDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorWebauthnCreateResponse: ( AuthenticatorWebAuthnStage ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorWebauthnUpdateResponse: ( AuthenticatorWebAuthnStage ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorWebauthnPartialUpdateResponse: ( AuthenticatorWebAuthnStage ) | ( ValidationError ) | ( GenericError );
  StagesAuthenticatorWebauthnDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  StagesCaptchaCreateResponse: ( CaptchaStage ) | ( ValidationError ) | ( GenericError );
  StagesCaptchaUpdateResponse: ( CaptchaStage ) | ( ValidationError ) | ( GenericError );
  StagesCaptchaPartialUpdateResponse: ( CaptchaStage ) | ( ValidationError ) | ( GenericError );
  StagesCaptchaDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  StagesConsentCreateResponse: ( ConsentStage ) | ( ValidationError ) | ( GenericError );
  StagesConsentUpdateResponse: ( ConsentStage ) | ( ValidationError ) | ( GenericError );
  StagesConsentPartialUpdateResponse: ( ConsentStage ) | ( ValidationError ) | ( GenericError );
  StagesConsentDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  StagesDenyCreateResponse: ( DenyStage ) | ( ValidationError ) | ( GenericError );
  StagesDenyUpdateResponse: ( DenyStage ) | ( ValidationError ) | ( GenericError );
  StagesDenyPartialUpdateResponse: ( DenyStage ) | ( ValidationError ) | ( GenericError );
  StagesDenyDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  StagesDummyCreateResponse: ( DummyStage ) | ( ValidationError ) | ( GenericError );
  StagesDummyUpdateResponse: ( DummyStage ) | ( ValidationError ) | ( GenericError );
  StagesDummyPartialUpdateResponse: ( DummyStage ) | ( ValidationError ) | ( GenericError );
  StagesDummyDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  StagesEmailCreateResponse: ( EmailStage ) | ( ValidationError ) | ( GenericError );
  StagesEmailUpdateResponse: ( EmailStage ) | ( ValidationError ) | ( GenericError );
  StagesEmailPartialUpdateResponse: ( EmailStage ) | ( ValidationError ) | ( GenericError );
  StagesEmailDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  StagesIdentificationCreateResponse: ( IdentificationStage ) | ( ValidationError ) | ( GenericError );
  StagesIdentificationUpdateResponse: ( IdentificationStage ) | ( ValidationError ) | ( GenericError );
  StagesIdentificationPartialUpdateResponse: ( IdentificationStage ) | ( ValidationError ) | ( GenericError );
  StagesIdentificationDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  StagesInvitationInvitationsCreateResponse: ( Invitation ) | ( ValidationError ) | ( GenericError );
  StagesInvitationInvitationsUpdateResponse: ( Invitation ) | ( ValidationError ) | ( GenericError );
  StagesInvitationInvitationsPartialUpdateResponse: ( Invitation ) | ( ValidationError ) | ( GenericError );
  StagesInvitationInvitationsDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  StagesInvitationStagesCreateResponse: ( InvitationStage ) | ( ValidationError ) | ( GenericError );
  StagesInvitationStagesUpdateResponse: ( InvitationStage ) | ( ValidationError ) | ( GenericError );
  StagesInvitationStagesPartialUpdateResponse: ( InvitationStage ) | ( ValidationError ) | ( GenericError );
  StagesInvitationStagesDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  StagesPasswordCreateResponse: ( PasswordStage ) | ( ValidationError ) | ( GenericError );
  StagesPasswordUpdateResponse: ( PasswordStage ) | ( ValidationError ) | ( GenericError );
  StagesPasswordPartialUpdateResponse: ( PasswordStage ) | ( ValidationError ) | ( GenericError );
  StagesPasswordDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  StagesPromptPromptsCreateResponse: ( Prompt ) | ( ValidationError ) | ( GenericError );
  StagesPromptPromptsUpdateResponse: ( Prompt ) | ( ValidationError ) | ( GenericError );
  StagesPromptPromptsPartialUpdateResponse: ( Prompt ) | ( ValidationError ) | ( GenericError );
  StagesPromptPromptsDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  StagesPromptPromptsPreviewCreateResponse: ( PromptChallenge ) | ( ValidationError ) | ( GenericError );
  StagesPromptStagesCreateResponse: ( PromptStage ) | ( ValidationError ) | ( GenericError );
  StagesPromptStagesUpdateResponse: ( PromptStage ) | ( ValidationError ) | ( GenericError );
  StagesPromptStagesPartialUpdateResponse: ( PromptStage ) | ( ValidationError ) | ( GenericError );
  StagesPromptStagesDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  StagesSourceCreateResponse: ( SourceStage ) | ( ValidationError ) | ( GenericError );
  StagesSourceUpdateResponse: ( SourceStage ) | ( ValidationError ) | ( GenericError );
  StagesSourcePartialUpdateResponse: ( SourceStage ) | ( ValidationError ) | ( GenericError );
  StagesSourceDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  StagesUserDeleteCreateResponse: ( UserDeleteStage ) | ( ValidationError ) | ( GenericError );
  StagesUserDeleteUpdateResponse: ( UserDeleteStage ) | ( ValidationError ) | ( GenericError );
  StagesUserDeletePartialUpdateResponse: ( UserDeleteStage ) | ( ValidationError ) | ( GenericError );
  StagesUserDeleteDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  StagesUserLoginCreateResponse: ( UserLoginStage ) | ( ValidationError ) | ( GenericError );
  StagesUserLoginUpdateResponse: ( UserLoginStage ) | ( ValidationError ) | ( GenericError );
  StagesUserLoginPartialUpdateResponse: ( UserLoginStage ) | ( ValidationError ) | ( GenericError );
  StagesUserLoginDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  StagesUserLogoutCreateResponse: ( UserLogoutStage ) | ( ValidationError ) | ( GenericError );
  StagesUserLogoutUpdateResponse: ( UserLogoutStage ) | ( ValidationError ) | ( GenericError );
  StagesUserLogoutPartialUpdateResponse: ( UserLogoutStage ) | ( ValidationError ) | ( GenericError );
  StagesUserLogoutDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
  StagesUserWriteCreateResponse: ( UserWriteStage ) | ( ValidationError ) | ( GenericError );
  StagesUserWriteUpdateResponse: ( UserWriteStage ) | ( ValidationError ) | ( GenericError );
  StagesUserWritePartialUpdateResponse: ( UserWriteStage ) | ( ValidationError ) | ( GenericError );
  StagesUserWriteDestroyResponse: ( VoidContainer ) | ( ValidationError ) | ( GenericError );
}>;

/** Mapping of interface types */
export type ResolversInterfaceTypes<_RefType extends Record<string, unknown>> = ResolversObject<{
  ChurrosAnswer: ( Omit<ChurrosAnswerDate, 'createdBy' | 'form' | 'question' | 'section'> & { createdBy?: Maybe<_RefType['ChurrosUser']>, form: _RefType['ChurrosForm'], question: _RefType['ChurrosQuestionScalar'], section: _RefType['ChurrosFormSection'] } ) | ( Omit<ChurrosAnswerFileUpload, 'createdBy' | 'form' | 'question' | 'section'> & { createdBy?: Maybe<_RefType['ChurrosUser']>, form: _RefType['ChurrosForm'], question: _RefType['ChurrosQuestionFileUpload'], section: _RefType['ChurrosFormSection'] } ) | ( Omit<ChurrosAnswerLongText, 'createdBy' | 'form' | 'question' | 'section'> & { createdBy?: Maybe<_RefType['ChurrosUser']>, form: _RefType['ChurrosForm'], question: _RefType['ChurrosQuestionScalar'], section: _RefType['ChurrosFormSection'] } ) | ( Omit<ChurrosAnswerNumber, 'createdBy' | 'form' | 'question' | 'section'> & { createdBy?: Maybe<_RefType['ChurrosUser']>, form: _RefType['ChurrosForm'], question: _RefType['ChurrosQuestionScalar'], section: _RefType['ChurrosFormSection'] } ) | ( Omit<ChurrosAnswerScale, 'createdBy' | 'form' | 'question' | 'section'> & { createdBy?: Maybe<_RefType['ChurrosUser']>, form: _RefType['ChurrosForm'], question: _RefType['ChurrosQuestionScale'], section: _RefType['ChurrosFormSection'] } ) | ( Omit<ChurrosAnswerSelectMultiple, 'createdBy' | 'form' | 'question' | 'section'> & { createdBy?: Maybe<_RefType['ChurrosUser']>, form: _RefType['ChurrosForm'], question: _RefType['ChurrosQuestionSelectMultiple'], section: _RefType['ChurrosFormSection'] } ) | ( Omit<ChurrosAnswerSelectOne, 'createdBy' | 'form' | 'question' | 'section'> & { createdBy?: Maybe<_RefType['ChurrosUser']>, form: _RefType['ChurrosForm'], question: _RefType['ChurrosQuestionSelectOne'], section: _RefType['ChurrosFormSection'] } ) | ( Omit<ChurrosAnswerText, 'createdBy' | 'form' | 'question' | 'section'> & { createdBy?: Maybe<_RefType['ChurrosUser']>, form: _RefType['ChurrosForm'], question: _RefType['ChurrosQuestionScalar'], section: _RefType['ChurrosFormSection'] } ) | ( Omit<ChurrosAnswerTime, 'answer' | 'createdBy' | 'form' | 'question' | 'section'> & { answer: _RefType['ChurrosAnswer'], createdBy?: Maybe<_RefType['ChurrosUser']>, form: _RefType['ChurrosForm'], question: _RefType['ChurrosQuestionScalar'], section: _RefType['ChurrosFormSection'] } );
  ChurrosCommentable: ( Omit<ChurrosArticle, 'author' | 'event' | 'group'> & { author?: Maybe<_RefType['ChurrosUser']>, event?: Maybe<_RefType['ChurrosEvent']>, group: _RefType['ChurrosGroup'] } ) | ( Omit<ChurrosDocument, 'uploader'> & { uploader?: Maybe<_RefType['ChurrosUser']> } );
  ChurrosErrorInterface: ( ChurrosError ) | ( ChurrosNotFoundError ) | ( ChurrosZodError );
  ChurrosNode: ( Omit<ChurrosAnnouncement, 'by'> & { by?: Maybe<_RefType['ChurrosUser']> } ) | ( Omit<ChurrosArticle, 'author' | 'event' | 'group'> & { author?: Maybe<_RefType['ChurrosUser']>, event?: Maybe<_RefType['ChurrosEvent']>, group: _RefType['ChurrosGroup'] } ) | ( Omit<ChurrosBarWeek, 'groups'> & { groups: Array<_RefType['ChurrosGroup']> } ) | ( Omit<ChurrosComment, 'author'> & { author?: Maybe<_RefType['ChurrosUser']> } ) | ( Omit<ChurrosDocument, 'uploader'> & { uploader?: Maybe<_RefType['ChurrosUser']> } ) | ( Omit<ChurrosEvent, 'articles' | 'author' | 'bannedUsers' | 'beneficiary' | 'bookingsCsv' | 'coOrganizers' | 'forms' | 'group' | 'managers' | 'myBookings'> & { articles: Array<_RefType['ChurrosArticle']>, author?: Maybe<_RefType['ChurrosUser']>, bannedUsers: Array<_RefType['ChurrosUser']>, beneficiary?: Maybe<_RefType['ChurrosLydiaAccount']>, bookingsCsv: _RefType['ChurrosEventBookingsCsvResult'], coOrganizers: Array<_RefType['ChurrosGroup']>, forms: Array<_RefType['ChurrosForm']>, group: _RefType['ChurrosGroup'], managers: Array<_RefType['ChurrosEventManager']>, myBookings: _RefType['ChurrosEventMyBookingsResult'] } ) | ( Omit<ChurrosForm, 'answers' | 'answersByUser' | 'createdBy' | 'event' | 'group' | 'myAnswers' | 'questions' | 'searchAnswers' | 'section' | 'sections'> & { answers: _RefType['ChurrosFormAnswersConnection'], answersByUser: _RefType['ChurrosFormAnswersByUserConnection'], createdBy?: Maybe<_RefType['ChurrosUser']>, event?: Maybe<_RefType['ChurrosEvent']>, group?: Maybe<_RefType['ChurrosGroup']>, myAnswers: Array<_RefType['ChurrosAnswer']>, questions: _RefType['ChurrosFormQuestionsConnection'], searchAnswers: Array<_RefType['ChurrosAnswerSearchResult']>, section: _RefType['ChurrosFormSection'], sections: Array<_RefType['ChurrosFormSection']> } ) | ( Omit<ChurrosGroup, 'ancestors' | 'articles' | 'boardMembers' | 'children' | 'coOrganizedEvents' | 'events' | 'familyChildren' | 'forms' | 'lydiaAccounts' | 'members' | 'ownEvents' | 'parent' | 'president' | 'related' | 'root' | 'secretaries' | 'shopItem' | 'shopItems' | 'shopOrders' | 'treasurers' | 'vicePresidents'> & { ancestors: Array<_RefType['ChurrosGroup']>, articles: Array<_RefType['ChurrosArticle']>, boardMembers: Array<_RefType['ChurrosGroupMember']>, children: Array<_RefType['ChurrosGroup']>, coOrganizedEvents: Array<_RefType['ChurrosEvent']>, events: _RefType['ChurrosGroupEventsConnection'], familyChildren: Array<_RefType['ChurrosGroup']>, forms: Array<_RefType['ChurrosForm']>, lydiaAccounts: Array<_RefType['ChurrosLydiaAccount']>, members: Array<_RefType['ChurrosGroupMember']>, ownEvents: Array<_RefType['ChurrosEvent']>, parent?: Maybe<_RefType['ChurrosGroup']>, president?: Maybe<_RefType['ChurrosGroupMember']>, related: Array<_RefType['ChurrosGroup']>, root?: Maybe<_RefType['ChurrosGroup']>, secretaries: Array<_RefType['ChurrosGroupMember']>, shopItem?: Maybe<_RefType['ChurrosShopItem']>, shopItems: _RefType['ChurrosGroupShopItemsConnection'], shopOrders: Array<_RefType['ChurrosShopPayment']>, treasurers: Array<_RefType['ChurrosGroupMember']>, vicePresidents: Array<_RefType['ChurrosGroupMember']> } ) | ( ChurrosLink ) | ( Omit<ChurrosLogEntry, 'user'> & { user?: Maybe<_RefType['ChurrosUser']> } ) | ( Omit<ChurrosMinor, 'users'> & { users: Array<_RefType['ChurrosUser']> } ) | ( Omit<ChurrosNotification, 'group' | 'subscription'> & { group?: Maybe<_RefType['ChurrosGroup']>, subscription: _RefType['ChurrosNotificationSubscription'] } ) | ( ChurrosQuickSignup ) | ( Omit<ChurrosReaction, 'author'> & { author?: Maybe<_RefType['ChurrosUser']> } ) | ( Omit<ChurrosRegistration, 'author' | 'beneficiaryUser' | 'cancelledBy' | 'opposedBy' | 'verifiedBy'> & { author?: Maybe<_RefType['ChurrosUser']>, beneficiaryUser?: Maybe<_RefType['ChurrosUser']>, cancelledBy?: Maybe<_RefType['ChurrosUser']>, opposedBy?: Maybe<_RefType['ChurrosUser']>, verifiedBy?: Maybe<_RefType['ChurrosUser']> } ) | ( Omit<ChurrosService, 'group'> & { group?: Maybe<_RefType['ChurrosGroup']> } ) | ( Omit<ChurrosShopItem, 'group' | 'itemOptions' | 'lydiaAccount' | 'shopPayments'> & { group: _RefType['ChurrosGroup'], itemOptions: Array<_RefType['ChurrosShopItemOption']>, lydiaAccount?: Maybe<_RefType['ChurrosLydiaAccount']>, shopPayments: Array<_RefType['ChurrosShopPayment']> } ) | ( Omit<ChurrosTicket, 'autojoinGroups' | 'event' | 'openToGroups'> & { autojoinGroups: Array<_RefType['ChurrosGroup']>, event: _RefType['ChurrosEvent'], openToGroups: Array<_RefType['ChurrosGroup']> } ) | ( Omit<ChurrosTicketGroup, 'event'> & { event: _RefType['ChurrosEvent'] } ) | ( Omit<ChurrosUser, 'allowedApps' | 'answeredForms' | 'articles' | 'authorizedApps' | 'boardMemberships' | 'canCreatePostsOn' | 'credentials' | 'emailChangeRequests' | 'familyTree' | 'godchildren' | 'godparent' | 'groups' | 'incomingGodparentRequests' | 'managedEvents' | 'outgoingGodparentRequests' | 'partiallyAnsweredForms'> & { allowedApps: Array<_RefType['ChurrosThirdPartyApp']>, answeredForms: _RefType['ChurrosUserAnsweredFormsConnection'], articles: _RefType['ChurrosUserArticlesConnection'], authorizedApps: Array<_RefType['ChurrosThirdPartyApp']>, boardMemberships: Array<_RefType['ChurrosGroupMember']>, canCreatePostsOn: Array<_RefType['ChurrosGroup']>, credentials: Array<_RefType['ChurrosCredential']>, emailChangeRequests: Array<_RefType['ChurrosEmailChange']>, familyTree: _RefType['ChurrosFamilyTree'], godchildren: Array<_RefType['ChurrosUser']>, godparent?: Maybe<_RefType['ChurrosUser']>, groups: Array<_RefType['ChurrosGroupMember']>, incomingGodparentRequests: Array<_RefType['ChurrosGodparentRequest']>, managedEvents: Array<_RefType['ChurrosEventManager']>, outgoingGodparentRequests: Array<_RefType['ChurrosGodparentRequest']>, partiallyAnsweredForms: _RefType['ChurrosUserPartiallyAnsweredFormsConnection'] } ) | ( ChurrosUserCandidate );
  ChurrosPictured: ( Omit<ChurrosArticle, 'author' | 'event' | 'group'> & { author?: Maybe<_RefType['ChurrosUser']>, event?: Maybe<_RefType['ChurrosEvent']>, group: _RefType['ChurrosGroup'] } ) | ( Omit<ChurrosEvent, 'articles' | 'author' | 'bannedUsers' | 'beneficiary' | 'bookingsCsv' | 'coOrganizers' | 'forms' | 'group' | 'managers' | 'myBookings'> & { articles: Array<_RefType['ChurrosArticle']>, author?: Maybe<_RefType['ChurrosUser']>, bannedUsers: Array<_RefType['ChurrosUser']>, beneficiary?: Maybe<_RefType['ChurrosLydiaAccount']>, bookingsCsv: _RefType['ChurrosEventBookingsCsvResult'], coOrganizers: Array<_RefType['ChurrosGroup']>, forms: Array<_RefType['ChurrosForm']>, group: _RefType['ChurrosGroup'], managers: Array<_RefType['ChurrosEventManager']>, myBookings: _RefType['ChurrosEventMyBookingsResult'] } ) | ( Omit<ChurrosGroup, 'ancestors' | 'articles' | 'boardMembers' | 'children' | 'coOrganizedEvents' | 'events' | 'familyChildren' | 'forms' | 'lydiaAccounts' | 'members' | 'ownEvents' | 'parent' | 'president' | 'related' | 'root' | 'secretaries' | 'shopItem' | 'shopItems' | 'shopOrders' | 'treasurers' | 'vicePresidents'> & { ancestors: Array<_RefType['ChurrosGroup']>, articles: Array<_RefType['ChurrosArticle']>, boardMembers: Array<_RefType['ChurrosGroupMember']>, children: Array<_RefType['ChurrosGroup']>, coOrganizedEvents: Array<_RefType['ChurrosEvent']>, events: _RefType['ChurrosGroupEventsConnection'], familyChildren: Array<_RefType['ChurrosGroup']>, forms: Array<_RefType['ChurrosForm']>, lydiaAccounts: Array<_RefType['ChurrosLydiaAccount']>, members: Array<_RefType['ChurrosGroupMember']>, ownEvents: Array<_RefType['ChurrosEvent']>, parent?: Maybe<_RefType['ChurrosGroup']>, president?: Maybe<_RefType['ChurrosGroupMember']>, related: Array<_RefType['ChurrosGroup']>, root?: Maybe<_RefType['ChurrosGroup']>, secretaries: Array<_RefType['ChurrosGroupMember']>, shopItem?: Maybe<_RefType['ChurrosShopItem']>, shopItems: _RefType['ChurrosGroupShopItemsConnection'], shopOrders: Array<_RefType['ChurrosShopPayment']>, treasurers: Array<_RefType['ChurrosGroupMember']>, vicePresidents: Array<_RefType['ChurrosGroupMember']> } ) | ( ChurrosSchool ) | ( ChurrosStudentAssociation ) | ( Omit<ChurrosUser, 'allowedApps' | 'answeredForms' | 'articles' | 'authorizedApps' | 'boardMemberships' | 'canCreatePostsOn' | 'credentials' | 'emailChangeRequests' | 'familyTree' | 'godchildren' | 'godparent' | 'groups' | 'incomingGodparentRequests' | 'managedEvents' | 'outgoingGodparentRequests' | 'partiallyAnsweredForms'> & { allowedApps: Array<_RefType['ChurrosThirdPartyApp']>, answeredForms: _RefType['ChurrosUserAnsweredFormsConnection'], articles: _RefType['ChurrosUserArticlesConnection'], authorizedApps: Array<_RefType['ChurrosThirdPartyApp']>, boardMemberships: Array<_RefType['ChurrosGroupMember']>, canCreatePostsOn: Array<_RefType['ChurrosGroup']>, credentials: Array<_RefType['ChurrosCredential']>, emailChangeRequests: Array<_RefType['ChurrosEmailChange']>, familyTree: _RefType['ChurrosFamilyTree'], godchildren: Array<_RefType['ChurrosUser']>, godparent?: Maybe<_RefType['ChurrosUser']>, groups: Array<_RefType['ChurrosGroupMember']>, incomingGodparentRequests: Array<_RefType['ChurrosGodparentRequest']>, managedEvents: Array<_RefType['ChurrosEventManager']>, outgoingGodparentRequests: Array<_RefType['ChurrosGodparentRequest']>, partiallyAnsweredForms: _RefType['ChurrosUserPartiallyAnsweredFormsConnection'] } );
  ChurrosQuestion: ( Omit<ChurrosQuestionFileUpload, 'answers' | 'defaultAnswer' | 'myAnswer' | 'section'> & { answers: _RefType['ChurrosQuestionAnswersConnection'], defaultAnswer?: Maybe<_RefType['ChurrosAnswer']>, myAnswer?: Maybe<_RefType['ChurrosAnswer']>, section: _RefType['ChurrosFormSection'] } ) | ( Omit<ChurrosQuestionScalar, 'answers' | 'defaultAnswer' | 'myAnswer' | 'section'> & { answers: _RefType['ChurrosQuestionAnswersConnection'], defaultAnswer?: Maybe<_RefType['ChurrosAnswer']>, myAnswer?: Maybe<_RefType['ChurrosAnswer']>, section: _RefType['ChurrosFormSection'] } ) | ( Omit<ChurrosQuestionScale, 'answerCounts' | 'answers' | 'defaultAnswer' | 'myAnswer' | 'section'> & { answerCounts: Array<_RefType['ChurrosStringToIntMapping']>, answers: _RefType['ChurrosQuestionAnswersConnection'], defaultAnswer?: Maybe<_RefType['ChurrosAnswer']>, myAnswer?: Maybe<_RefType['ChurrosAnswer']>, section: _RefType['ChurrosFormSection'] } ) | ( Omit<ChurrosQuestionSelectMultiple, 'answerCounts' | 'answers' | 'defaultAnswer' | 'myAnswer' | 'section'> & { answerCounts: Array<_RefType['ChurrosStringToIntMapping']>, answers: _RefType['ChurrosQuestionAnswersConnection'], defaultAnswer?: Maybe<_RefType['ChurrosAnswer']>, myAnswer?: Maybe<_RefType['ChurrosAnswer']>, section: _RefType['ChurrosFormSection'] } ) | ( Omit<ChurrosQuestionSelectOne, 'answerCounts' | 'answers' | 'defaultAnswer' | 'groups' | 'jumps' | 'myAnswer' | 'section'> & { answerCounts: Array<_RefType['ChurrosStringToIntMapping']>, answers: _RefType['ChurrosQuestionAnswersConnection'], defaultAnswer?: Maybe<_RefType['ChurrosAnswer']>, groups: Array<Maybe<_RefType['ChurrosGroup']>>, jumps: Array<Maybe<_RefType['ChurrosFormSection']>>, myAnswer?: Maybe<_RefType['ChurrosAnswer']>, section: _RefType['ChurrosFormSection'] } );
  ChurrosReactable: ( Omit<ChurrosArticle, 'author' | 'event' | 'group'> & { author?: Maybe<_RefType['ChurrosUser']>, event?: Maybe<_RefType['ChurrosEvent']>, group: _RefType['ChurrosGroup'] } ) | ( Omit<ChurrosComment, 'author'> & { author?: Maybe<_RefType['ChurrosUser']> } ) | ( Omit<ChurrosDocument, 'uploader'> & { uploader?: Maybe<_RefType['ChurrosUser']> } ) | ( Omit<ChurrosEvent, 'articles' | 'author' | 'bannedUsers' | 'beneficiary' | 'bookingsCsv' | 'coOrganizers' | 'forms' | 'group' | 'managers' | 'myBookings'> & { articles: Array<_RefType['ChurrosArticle']>, author?: Maybe<_RefType['ChurrosUser']>, bannedUsers: Array<_RefType['ChurrosUser']>, beneficiary?: Maybe<_RefType['ChurrosLydiaAccount']>, bookingsCsv: _RefType['ChurrosEventBookingsCsvResult'], coOrganizers: Array<_RefType['ChurrosGroup']>, forms: Array<_RefType['ChurrosForm']>, group: _RefType['ChurrosGroup'], managers: Array<_RefType['ChurrosEventManager']>, myBookings: _RefType['ChurrosEventMyBookingsResult'] } );
}>;

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = ResolversObject<{
  Query: ResolverTypeWrapper<{}>;
  Subscription: ResolverTypeWrapper<{}>;
  ChurrosAnnouncement: ResolverTypeWrapper<Omit<ChurrosAnnouncement, 'by'> & { by?: Maybe<ResolversTypes['ChurrosUser']> }>;
  ChurrosAnswer: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['ChurrosAnswer']>;
  ChurrosAnswerDate: ResolverTypeWrapper<Omit<ChurrosAnswerDate, 'createdBy' | 'form' | 'question' | 'section'> & { createdBy?: Maybe<ResolversTypes['ChurrosUser']>, form: ResolversTypes['ChurrosForm'], question: ResolversTypes['ChurrosQuestionScalar'], section: ResolversTypes['ChurrosFormSection'] }>;
  ChurrosAnswerFileUpload: ResolverTypeWrapper<Omit<ChurrosAnswerFileUpload, 'createdBy' | 'form' | 'question' | 'section'> & { createdBy?: Maybe<ResolversTypes['ChurrosUser']>, form: ResolversTypes['ChurrosForm'], question: ResolversTypes['ChurrosQuestionFileUpload'], section: ResolversTypes['ChurrosFormSection'] }>;
  ChurrosAnswerInput: ChurrosAnswerInput;
  ChurrosAnswerLongText: ResolverTypeWrapper<Omit<ChurrosAnswerLongText, 'createdBy' | 'form' | 'question' | 'section'> & { createdBy?: Maybe<ResolversTypes['ChurrosUser']>, form: ResolversTypes['ChurrosForm'], question: ResolversTypes['ChurrosQuestionScalar'], section: ResolversTypes['ChurrosFormSection'] }>;
  ChurrosAnswerNumber: ResolverTypeWrapper<Omit<ChurrosAnswerNumber, 'createdBy' | 'form' | 'question' | 'section'> & { createdBy?: Maybe<ResolversTypes['ChurrosUser']>, form: ResolversTypes['ChurrosForm'], question: ResolversTypes['ChurrosQuestionScalar'], section: ResolversTypes['ChurrosFormSection'] }>;
  ChurrosAnswerScale: ResolverTypeWrapper<Omit<ChurrosAnswerScale, 'createdBy' | 'form' | 'question' | 'section'> & { createdBy?: Maybe<ResolversTypes['ChurrosUser']>, form: ResolversTypes['ChurrosForm'], question: ResolversTypes['ChurrosQuestionScale'], section: ResolversTypes['ChurrosFormSection'] }>;
  ChurrosAnswerSearchResult: ResolverTypeWrapper<Omit<ChurrosAnswerSearchResult, 'answer'> & { answer: ResolversTypes['ChurrosAnswer'] }>;
  ChurrosAnswerSelectMultiple: ResolverTypeWrapper<Omit<ChurrosAnswerSelectMultiple, 'createdBy' | 'form' | 'question' | 'section'> & { createdBy?: Maybe<ResolversTypes['ChurrosUser']>, form: ResolversTypes['ChurrosForm'], question: ResolversTypes['ChurrosQuestionSelectMultiple'], section: ResolversTypes['ChurrosFormSection'] }>;
  ChurrosAnswerSelectOne: ResolverTypeWrapper<Omit<ChurrosAnswerSelectOne, 'createdBy' | 'form' | 'question' | 'section'> & { createdBy?: Maybe<ResolversTypes['ChurrosUser']>, form: ResolversTypes['ChurrosForm'], question: ResolversTypes['ChurrosQuestionSelectOne'], section: ResolversTypes['ChurrosFormSection'] }>;
  ChurrosAnswerText: ResolverTypeWrapper<Omit<ChurrosAnswerText, 'createdBy' | 'form' | 'question' | 'section'> & { createdBy?: Maybe<ResolversTypes['ChurrosUser']>, form: ResolversTypes['ChurrosForm'], question: ResolversTypes['ChurrosQuestionScalar'], section: ResolversTypes['ChurrosFormSection'] }>;
  ChurrosAnswerTime: ResolverTypeWrapper<Omit<ChurrosAnswerTime, 'answer' | 'createdBy' | 'form' | 'question' | 'section'> & { answer: ResolversTypes['ChurrosAnswer'], createdBy?: Maybe<ResolversTypes['ChurrosUser']>, form: ResolversTypes['ChurrosForm'], question: ResolversTypes['ChurrosQuestionScalar'], section: ResolversTypes['ChurrosFormSection'] }>;
  ChurrosAnswersExportFormats: ChurrosAnswersExportFormats;
  ChurrosAnswersOfUser: ResolverTypeWrapper<Omit<ChurrosAnswersOfUser, 'answers' | 'user'> & { answers: Array<ResolversTypes['ChurrosAnswer']>, user: ResolversTypes['ChurrosUser'] }>;
  ChurrosApiRateLimitHits: ResolverTypeWrapper<Omit<ChurrosApiRateLimitHits, 'user'> & { user?: Maybe<ResolversTypes['ChurrosUser']> }>;
  ChurrosApiUsage: ResolverTypeWrapper<Omit<ChurrosApiUsage, 'user'> & { user?: Maybe<ResolversTypes['ChurrosUser']> }>;
  ChurrosApiUsageQueryType: ChurrosApiUsageQueryType;
  ChurrosArticle: ResolverTypeWrapper<Omit<ChurrosArticle, 'author' | 'event' | 'group'> & { author?: Maybe<ResolversTypes['ChurrosUser']>, event?: Maybe<ResolversTypes['ChurrosEvent']>, group: ResolversTypes['ChurrosGroup'] }>;
  ChurrosArticleSearchResultType: ResolverTypeWrapper<Omit<ChurrosArticleSearchResultType, 'article'> & { article: ResolversTypes['ChurrosArticle'] }>;
  ChurrosAwaitingValidationError: ResolverTypeWrapper<ChurrosAwaitingValidationError>;
  ChurrosBarWeek: ResolverTypeWrapper<Omit<ChurrosBarWeek, 'groups'> & { groups: Array<ResolversTypes['ChurrosGroup']> }>;
  Boolean: ResolverTypeWrapper<Scalars['Boolean']['output']>;
  ChurrosBooleanMap: ResolverTypeWrapper<Scalars['ChurrosBooleanMap']['output']>;
  ChurrosBuildInfo: ResolverTypeWrapper<ChurrosBuildInfo>;
  ChurrosChangelogRelease: ResolverTypeWrapper<ChurrosChangelogRelease>;
  ChurrosComment: ResolverTypeWrapper<Omit<ChurrosComment, 'author'> & { author?: Maybe<ResolversTypes['ChurrosUser']> }>;
  ChurrosCommentable: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['ChurrosCommentable']>;
  ChurrosCommentsConnection: ResolverTypeWrapper<ChurrosCommentsConnection>;
  ChurrosCommentsEdge: ResolverTypeWrapper<ChurrosCommentsEdge>;
  ChurrosCompleteSignupResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosCompleteSignupResult']>;
  ChurrosContributionOption: ResolverTypeWrapper<ChurrosContributionOption>;
  ChurrosCounts: ResolverTypeWrapper<Scalars['ChurrosCounts']['output']>;
  ChurrosCredential: ResolverTypeWrapper<Omit<ChurrosCredential, 'user'> & { user: ResolversTypes['ChurrosUser'] }>;
  ChurrosCredentialType: ChurrosCredentialType;
  ChurrosDatabaseHealthCheck: ResolverTypeWrapper<ChurrosDatabaseHealthCheck>;
  DateTime: ResolverTypeWrapper<Scalars['DateTime']['output']>;
  ChurrosDocument: ResolverTypeWrapper<Omit<ChurrosDocument, 'uploader'> & { uploader?: Maybe<ResolversTypes['ChurrosUser']> }>;
  ChurrosDocumentSearchResult: ResolverTypeWrapper<ChurrosDocumentSearchResult>;
  ChurrosDocumentType: ChurrosDocumentType;
  ChurrosEmailChange: ResolverTypeWrapper<Omit<ChurrosEmailChange, 'user'> & { user: ResolversTypes['ChurrosUser'] }>;
  ChurrosError: ResolverTypeWrapper<ChurrosError>;
  ChurrosErrorInterface: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['ChurrosErrorInterface']>;
  ChurrosEvenSearchResult: ResolverTypeWrapper<Omit<ChurrosEvenSearchResult, 'event'> & { event: ResolversTypes['ChurrosEvent'] }>;
  ChurrosEvent: ResolverTypeWrapper<Omit<ChurrosEvent, 'articles' | 'author' | 'bannedUsers' | 'beneficiary' | 'bookingsCsv' | 'coOrganizers' | 'forms' | 'group' | 'managers' | 'myBookings'> & { articles: Array<ResolversTypes['ChurrosArticle']>, author?: Maybe<ResolversTypes['ChurrosUser']>, bannedUsers: Array<ResolversTypes['ChurrosUser']>, beneficiary?: Maybe<ResolversTypes['ChurrosLydiaAccount']>, bookingsCsv: ResolversTypes['ChurrosEventBookingsCsvResult'], coOrganizers: Array<ResolversTypes['ChurrosGroup']>, forms: Array<ResolversTypes['ChurrosForm']>, group: ResolversTypes['ChurrosGroup'], managers: Array<ResolversTypes['ChurrosEventManager']>, myBookings: ResolversTypes['ChurrosEventMyBookingsResult'] }>;
  ChurrosEventBookingsConnection: ResolverTypeWrapper<ChurrosEventBookingsConnection>;
  ChurrosEventBookingsConnectionEdge: ResolverTypeWrapper<ChurrosEventBookingsConnectionEdge>;
  ChurrosEventBookingsCsvResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosEventBookingsCsvResult']>;
  ChurrosEventBookingsCsvSuccess: ResolverTypeWrapper<ChurrosEventBookingsCsvSuccess>;
  ChurrosEventFrequency: ChurrosEventFrequency;
  ChurrosEventLogsConnection: ResolverTypeWrapper<ChurrosEventLogsConnection>;
  ChurrosEventLogsConnectionEdge: ResolverTypeWrapper<ChurrosEventLogsConnectionEdge>;
  ChurrosEventManager: ResolverTypeWrapper<Omit<ChurrosEventManager, 'event' | 'user'> & { event: ResolversTypes['ChurrosEvent'], user: ResolversTypes['ChurrosUser'] }>;
  ChurrosEventManagerPowerLevel: ChurrosEventManagerPowerLevel;
  ChurrosEventMyBookingsResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosEventMyBookingsResult']>;
  ChurrosEventMyBookingsSuccess: ResolverTypeWrapper<ChurrosEventMyBookingsSuccess>;
  ChurrosEventsByDay: ResolverTypeWrapper<Omit<ChurrosEventsByDay, 'happening' | 'shotgunning'> & { happening: Array<ResolversTypes['ChurrosEvent']>, shotgunning: Array<ResolversTypes['ChurrosEvent']> }>;
  ChurrosFamilyTree: ResolverTypeWrapper<Omit<ChurrosFamilyTree, 'users'> & { users: Array<ResolversTypes['ChurrosUser']> }>;
  ChurrosFile: ResolverTypeWrapper<Scalars['ChurrosFile']['output']>;
  Float: ResolverTypeWrapper<Scalars['Float']['output']>;
  ChurrosForm: ResolverTypeWrapper<Omit<ChurrosForm, 'answers' | 'answersByUser' | 'createdBy' | 'event' | 'group' | 'myAnswers' | 'questions' | 'searchAnswers' | 'section' | 'sections'> & { answers: ResolversTypes['ChurrosFormAnswersConnection'], answersByUser: ResolversTypes['ChurrosFormAnswersByUserConnection'], createdBy?: Maybe<ResolversTypes['ChurrosUser']>, event?: Maybe<ResolversTypes['ChurrosEvent']>, group?: Maybe<ResolversTypes['ChurrosGroup']>, myAnswers: Array<ResolversTypes['ChurrosAnswer']>, questions: ResolversTypes['ChurrosFormQuestionsConnection'], searchAnswers: Array<ResolversTypes['ChurrosAnswerSearchResult']>, section: ResolversTypes['ChurrosFormSection'], sections: Array<ResolversTypes['ChurrosFormSection']> }>;
  ChurrosFormAnswersByUserConnection: ResolverTypeWrapper<Omit<ChurrosFormAnswersByUserConnection, 'edges' | 'nodes'> & { edges: Array<ResolversTypes['ChurrosFormAnswersByUserConnectionEdge']>, nodes: Array<ResolversTypes['ChurrosAnswersOfUser']> }>;
  ChurrosFormAnswersByUserConnectionEdge: ResolverTypeWrapper<Omit<ChurrosFormAnswersByUserConnectionEdge, 'node'> & { node: ResolversTypes['ChurrosAnswersOfUser'] }>;
  ChurrosFormAnswersConnection: ResolverTypeWrapper<Omit<ChurrosFormAnswersConnection, 'edges' | 'nodes'> & { edges: Array<ResolversTypes['ChurrosFormAnswersConnectionEdge']>, nodes: Array<ResolversTypes['ChurrosAnswer']> }>;
  ChurrosFormAnswersConnectionEdge: ResolverTypeWrapper<Omit<ChurrosFormAnswersConnectionEdge, 'node'> & { node: ResolversTypes['ChurrosAnswer'] }>;
  ChurrosFormQuestionsConnection: ResolverTypeWrapper<Omit<ChurrosFormQuestionsConnection, 'edges' | 'nodes'> & { edges: Array<ResolversTypes['ChurrosFormQuestionsConnectionEdge']>, nodes: Array<ResolversTypes['ChurrosQuestion']> }>;
  ChurrosFormQuestionsConnectionEdge: ResolverTypeWrapper<Omit<ChurrosFormQuestionsConnectionEdge, 'node'> & { node: ResolversTypes['ChurrosQuestion'] }>;
  ChurrosFormSearchResult: ResolverTypeWrapper<Omit<ChurrosFormSearchResult, 'form'> & { form: ResolversTypes['ChurrosForm'] }>;
  ChurrosFormSection: ResolverTypeWrapper<Omit<ChurrosFormSection, 'answers' | 'form' | 'nextSection' | 'questions' | 'restrictedToGroups'> & { answers: ResolversTypes['ChurrosFormSectionAnswersConnection'], form: ResolversTypes['ChurrosForm'], nextSection?: Maybe<ResolversTypes['ChurrosFormSection']>, questions: Array<ResolversTypes['ChurrosQuestion']>, restrictedToGroups: Array<ResolversTypes['ChurrosGroup']> }>;
  ChurrosFormSectionAnswersConnection: ResolverTypeWrapper<Omit<ChurrosFormSectionAnswersConnection, 'edges' | 'nodes'> & { edges: Array<ResolversTypes['ChurrosFormSectionAnswersConnectionEdge']>, nodes: Array<ResolversTypes['ChurrosAnswer']> }>;
  ChurrosFormSectionAnswersConnectionEdge: ResolverTypeWrapper<Omit<ChurrosFormSectionAnswersConnectionEdge, 'node'> & { node: ResolversTypes['ChurrosAnswer'] }>;
  ChurrosGodparentRequest: ResolverTypeWrapper<Omit<ChurrosGodparentRequest, 'godchild' | 'godparent'> & { godchild: ResolversTypes['ChurrosUser'], godparent: ResolversTypes['ChurrosUser'] }>;
  ChurrosGroup: ResolverTypeWrapper<Omit<ChurrosGroup, 'ancestors' | 'articles' | 'boardMembers' | 'children' | 'coOrganizedEvents' | 'events' | 'familyChildren' | 'forms' | 'lydiaAccounts' | 'members' | 'ownEvents' | 'parent' | 'president' | 'related' | 'root' | 'secretaries' | 'shopItem' | 'shopItems' | 'shopOrders' | 'treasurers' | 'vicePresidents'> & { ancestors: Array<ResolversTypes['ChurrosGroup']>, articles: Array<ResolversTypes['ChurrosArticle']>, boardMembers: Array<ResolversTypes['ChurrosGroupMember']>, children: Array<ResolversTypes['ChurrosGroup']>, coOrganizedEvents: Array<ResolversTypes['ChurrosEvent']>, events: ResolversTypes['ChurrosGroupEventsConnection'], familyChildren: Array<ResolversTypes['ChurrosGroup']>, forms: Array<ResolversTypes['ChurrosForm']>, lydiaAccounts: Array<ResolversTypes['ChurrosLydiaAccount']>, members: Array<ResolversTypes['ChurrosGroupMember']>, ownEvents: Array<ResolversTypes['ChurrosEvent']>, parent?: Maybe<ResolversTypes['ChurrosGroup']>, president?: Maybe<ResolversTypes['ChurrosGroupMember']>, related: Array<ResolversTypes['ChurrosGroup']>, root?: Maybe<ResolversTypes['ChurrosGroup']>, secretaries: Array<ResolversTypes['ChurrosGroupMember']>, shopItem?: Maybe<ResolversTypes['ChurrosShopItem']>, shopItems: ResolversTypes['ChurrosGroupShopItemsConnection'], shopOrders: Array<ResolversTypes['ChurrosShopPayment']>, treasurers: Array<ResolversTypes['ChurrosGroupMember']>, vicePresidents: Array<ResolversTypes['ChurrosGroupMember']> }>;
  ChurrosGroupEventsConnection: ResolverTypeWrapper<Omit<ChurrosGroupEventsConnection, 'edges' | 'nodes'> & { edges: Array<ResolversTypes['ChurrosGroupEventsConnectionEdge']>, nodes: Array<ResolversTypes['ChurrosEvent']> }>;
  ChurrosGroupEventsConnectionEdge: ResolverTypeWrapper<Omit<ChurrosGroupEventsConnectionEdge, 'node'> & { node: ResolversTypes['ChurrosEvent'] }>;
  ChurrosGroupMember: ResolverTypeWrapper<Omit<ChurrosGroupMember, 'group' | 'member'> & { group: ResolversTypes['ChurrosGroup'], member: ResolversTypes['ChurrosUser'] }>;
  ChurrosGroupSearchResult: ResolverTypeWrapper<Omit<ChurrosGroupSearchResult, 'group'> & { group: ResolversTypes['ChurrosGroup'] }>;
  ChurrosGroupShopItemsConnection: ResolverTypeWrapper<Omit<ChurrosGroupShopItemsConnection, 'edges' | 'nodes'> & { edges: Array<ResolversTypes['ChurrosGroupShopItemsConnectionEdge']>, nodes: Array<ResolversTypes['ChurrosShopItem']> }>;
  ChurrosGroupShopItemsConnectionEdge: ResolverTypeWrapper<Omit<ChurrosGroupShopItemsConnectionEdge, 'node'> & { node: ResolversTypes['ChurrosShopItem'] }>;
  ChurrosGroupType: ChurrosGroupType;
  ChurrosHealthCheck: ResolverTypeWrapper<ChurrosHealthCheck>;
  ID: ResolverTypeWrapper<Scalars['ID']['output']>;
  Int: ResolverTypeWrapper<Scalars['Int']['output']>;
  ChurrosIssue: ResolverTypeWrapper<ChurrosIssue>;
  ChurrosIssueComment: ResolverTypeWrapper<ChurrosIssueComment>;
  ChurrosIssueState: ChurrosIssueState;
  ChurrosLdapHealthCheck: ResolverTypeWrapper<ChurrosLdapHealthCheck>;
  ChurrosLink: ResolverTypeWrapper<ChurrosLink>;
  ChurrosLinkInput: ChurrosLinkInput;
  ChurrosLocalID: ResolverTypeWrapper<Scalars['ChurrosLocalID']['output']>;
  ChurrosLogEntry: ResolverTypeWrapper<Omit<ChurrosLogEntry, 'user'> & { user?: Maybe<ResolversTypes['ChurrosUser']> }>;
  ChurrosLogoSourceType: ChurrosLogoSourceType;
  ChurrosLydiaAccount: ResolverTypeWrapper<Omit<ChurrosLydiaAccount, 'events' | 'group'> & { events: Array<ResolversTypes['ChurrosEvent']>, group?: Maybe<ResolversTypes['ChurrosGroup']> }>;
  ChurrosMailHealthCheck: ResolverTypeWrapper<ChurrosMailHealthCheck>;
  ChurrosMajor: ResolverTypeWrapper<ChurrosMajor>;
  ChurrosManagerOfEventInput: ChurrosManagerOfEventInput;
  ChurrosMinor: ResolverTypeWrapper<Omit<ChurrosMinor, 'users'> & { users: Array<ResolversTypes['ChurrosUser']> }>;
  ChurrosMutationAcceptRegistrationResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosMutationAcceptRegistrationResult']>;
  ChurrosMutationAcceptRegistrationSuccess: ResolverTypeWrapper<Omit<ChurrosMutationAcceptRegistrationSuccess, 'data'> & { data: ResolversTypes['ChurrosUser'] }>;
  ChurrosMutationAddFileToPageResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosMutationAddFileToPageResult']>;
  ChurrosMutationAddFileToPageSuccess: ResolverTypeWrapper<ChurrosMutationAddFileToPageSuccess>;
  ChurrosMutationAddGroupMemberResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosMutationAddGroupMemberResult']>;
  ChurrosMutationAddGroupMemberSuccess: ResolverTypeWrapper<Omit<ChurrosMutationAddGroupMemberSuccess, 'data'> & { data: ResolversTypes['ChurrosGroupMember'] }>;
  ChurrosMutationAnswerFormSectionResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosMutationAnswerFormSectionResult']>;
  ChurrosMutationAnswerFormSectionSuccess: ResolverTypeWrapper<Omit<ChurrosMutationAnswerFormSectionSuccess, 'data'> & { data: Array<ResolversTypes['ChurrosAnswer']> }>;
  ChurrosMutationAuthorizeResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosMutationAuthorizeResult']>;
  ChurrosMutationAuthorizeSuccess: ResolverTypeWrapper<ChurrosMutationAuthorizeSuccess>;
  ChurrosMutationCancelRegistrationResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosMutationCancelRegistrationResult']>;
  ChurrosMutationCancelRegistrationSuccess: ResolverTypeWrapper<ChurrosMutationCancelRegistrationSuccess>;
  ChurrosMutationCompleteRegistrationResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosMutationCompleteRegistrationResult']>;
  ChurrosMutationCompleteRegistrationSuccess: ResolverTypeWrapper<Omit<ChurrosMutationCompleteRegistrationSuccess, 'data'> & { data: ResolversTypes['ChurrosCompleteSignupResult'] }>;
  ChurrosMutationContributeResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosMutationContributeResult']>;
  ChurrosMutationContributeSuccess: ResolverTypeWrapper<ChurrosMutationContributeSuccess>;
  ChurrosMutationCreatePasswordResetResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosMutationCreatePasswordResetResult']>;
  ChurrosMutationCreatePasswordResetSuccess: ResolverTypeWrapper<ChurrosMutationCreatePasswordResetSuccess>;
  ChurrosMutationDeletePageResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosMutationDeletePageResult']>;
  ChurrosMutationDeletePageSuccess: ResolverTypeWrapper<ChurrosMutationDeletePageSuccess>;
  ChurrosMutationDeleteShopItemResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosMutationDeleteShopItemResult']>;
  ChurrosMutationDeleteShopItemSuccess: ResolverTypeWrapper<ChurrosMutationDeleteShopItemSuccess>;
  ChurrosMutationFinishPaypalRegistrationPaymentResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosMutationFinishPaypalRegistrationPaymentResult']>;
  ChurrosMutationFinishPaypalRegistrationPaymentSuccess: ResolverTypeWrapper<ChurrosMutationFinishPaypalRegistrationPaymentSuccess>;
  ChurrosMutationLoginResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosMutationLoginResult']>;
  ChurrosMutationLoginSuccess: ResolverTypeWrapper<Omit<ChurrosMutationLoginSuccess, 'data'> & { data: ResolversTypes['ChurrosCredential'] }>;
  ChurrosMutationMailFormAnswersResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosMutationMailFormAnswersResult']>;
  ChurrosMutationMailFormAnswersSuccess: ResolverTypeWrapper<ChurrosMutationMailFormAnswersSuccess>;
  ChurrosMutationOpposeRegistrationResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosMutationOpposeRegistrationResult']>;
  ChurrosMutationOpposeRegistrationSuccess: ResolverTypeWrapper<ChurrosMutationOpposeRegistrationSuccess>;
  ChurrosMutationPaidRegistrationResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosMutationPaidRegistrationResult']>;
  ChurrosMutationPaidRegistrationSuccess: ResolverTypeWrapper<ChurrosMutationPaidRegistrationSuccess>;
  ChurrosMutationPaidShopPaymentResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosMutationPaidShopPaymentResult']>;
  ChurrosMutationPaidShopPaymentSuccess: ResolverTypeWrapper<Omit<ChurrosMutationPaidShopPaymentSuccess, 'data'> & { data: ResolversTypes['ChurrosShopPayment'] }>;
  ChurrosMutationRegisterGoogleCredentialResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosMutationRegisterGoogleCredentialResult']>;
  ChurrosMutationRegisterGoogleCredentialSuccess: ResolverTypeWrapper<ChurrosMutationRegisterGoogleCredentialSuccess>;
  ChurrosMutationRemoveFileFromPageResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosMutationRemoveFileFromPageResult']>;
  ChurrosMutationRemoveFileFromPageSuccess: ResolverTypeWrapper<ChurrosMutationRemoveFileFromPageSuccess>;
  ChurrosMutationRequestEmailChangeResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosMutationRequestEmailChangeResult']>;
  ChurrosMutationRequestEmailChangeSuccess: ResolverTypeWrapper<ChurrosMutationRequestEmailChangeSuccess>;
  ChurrosMutationResetPasswordResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosMutationResetPasswordResult']>;
  ChurrosMutationResetPasswordSuccess: ResolverTypeWrapper<ChurrosMutationResetPasswordSuccess>;
  ChurrosMutationStartRegistrationResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosMutationStartRegistrationResult']>;
  ChurrosMutationStartRegistrationSuccess: ResolverTypeWrapper<ChurrosMutationStartRegistrationSuccess>;
  ChurrosMutationUpdateUserCandidateResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosMutationUpdateUserCandidateResult']>;
  ChurrosMutationUpdateUserCandidateSuccess: ResolverTypeWrapper<ChurrosMutationUpdateUserCandidateSuccess>;
  ChurrosMutationUpdateUserResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosMutationUpdateUserResult']>;
  ChurrosMutationUpdateUserSuccess: ResolverTypeWrapper<Omit<ChurrosMutationUpdateUserSuccess, 'data'> & { data: ResolversTypes['ChurrosUser'] }>;
  ChurrosMutationUpsertAnnouncementResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosMutationUpsertAnnouncementResult']>;
  ChurrosMutationUpsertAnnouncementSuccess: ResolverTypeWrapper<Omit<ChurrosMutationUpsertAnnouncementSuccess, 'data'> & { data: ResolversTypes['ChurrosAnnouncement'] }>;
  ChurrosMutationUpsertArticleResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosMutationUpsertArticleResult']>;
  ChurrosMutationUpsertArticleSuccess: ResolverTypeWrapper<Omit<ChurrosMutationUpsertArticleSuccess, 'data'> & { data: ResolversTypes['ChurrosArticle'] }>;
  ChurrosMutationUpsertBarWeekResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosMutationUpsertBarWeekResult']>;
  ChurrosMutationUpsertBarWeekSuccess: ResolverTypeWrapper<Omit<ChurrosMutationUpsertBarWeekSuccess, 'data'> & { data: ResolversTypes['ChurrosBarWeek'] }>;
  ChurrosMutationUpsertDocumentResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosMutationUpsertDocumentResult']>;
  ChurrosMutationUpsertDocumentSuccess: ResolverTypeWrapper<ChurrosMutationUpsertDocumentSuccess>;
  ChurrosMutationUpsertEventResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosMutationUpsertEventResult']>;
  ChurrosMutationUpsertEventSuccess: ResolverTypeWrapper<Omit<ChurrosMutationUpsertEventSuccess, 'data'> & { data: ResolversTypes['ChurrosEvent'] }>;
  ChurrosMutationUpsertFormInput: ChurrosMutationUpsertFormInput;
  ChurrosMutationUpsertFormSectionInput: ChurrosMutationUpsertFormSectionInput;
  ChurrosMutationUpsertGodparentRequestResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosMutationUpsertGodparentRequestResult']>;
  ChurrosMutationUpsertGodparentRequestSuccess: ResolverTypeWrapper<Omit<ChurrosMutationUpsertGodparentRequestSuccess, 'data'> & { data: ResolversTypes['ChurrosGodparentRequest'] }>;
  ChurrosMutationUpsertGroupResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosMutationUpsertGroupResult']>;
  ChurrosMutationUpsertGroupSuccess: ResolverTypeWrapper<Omit<ChurrosMutationUpsertGroupSuccess, 'data'> & { data: ResolversTypes['ChurrosGroup'] }>;
  ChurrosMutationUpsertPageResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosMutationUpsertPageResult']>;
  ChurrosMutationUpsertPageSuccess: ResolverTypeWrapper<ChurrosMutationUpsertPageSuccess>;
  ChurrosMutationUpsertQuestionInput: ChurrosMutationUpsertQuestionInput;
  ChurrosMutationUpsertRegistrationResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosMutationUpsertRegistrationResult']>;
  ChurrosMutationUpsertRegistrationSuccess: ResolverTypeWrapper<ChurrosMutationUpsertRegistrationSuccess>;
  ChurrosMutationUpsertServiceResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosMutationUpsertServiceResult']>;
  ChurrosMutationUpsertServiceSuccess: ResolverTypeWrapper<ChurrosMutationUpsertServiceSuccess>;
  ChurrosMutationUpsertShopItemResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosMutationUpsertShopItemResult']>;
  ChurrosMutationUpsertShopItemSuccess: ResolverTypeWrapper<Omit<ChurrosMutationUpsertShopItemSuccess, 'data'> & { data: ResolversTypes['ChurrosShopItem'] }>;
  ChurrosMutationUpsertShopPaymentResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosMutationUpsertShopPaymentResult']>;
  ChurrosMutationUpsertShopPaymentSuccess: ResolverTypeWrapper<Omit<ChurrosMutationUpsertShopPaymentSuccess, 'data'> & { data: ResolversTypes['ChurrosShopPayment'] }>;
  ChurrosMutationUsePasswordResetResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosMutationUsePasswordResetResult']>;
  ChurrosMutationUsePasswordResetSuccess: ResolverTypeWrapper<ChurrosMutationUsePasswordResetSuccess>;
  ChurrosMutationValidateEmailResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosMutationValidateEmailResult']>;
  ChurrosMutationValidateEmailSuccess: ResolverTypeWrapper<ChurrosMutationValidateEmailSuccess>;
  ChurrosMutationVerifyBookingResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosMutationVerifyBookingResult']>;
  ChurrosMutationVerifyBookingSuccess: ResolverTypeWrapper<ChurrosMutationVerifyBookingSuccess>;
  ChurrosNode: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['ChurrosNode']>;
  ChurrosNotFoundError: ResolverTypeWrapper<ChurrosNotFoundError>;
  ChurrosNotification: ResolverTypeWrapper<Omit<ChurrosNotification, 'group' | 'subscription'> & { group?: Maybe<ResolversTypes['ChurrosGroup']>, subscription: ResolversTypes['ChurrosNotificationSubscription'] }>;
  ChurrosNotificationChannel: ChurrosNotificationChannel;
  ChurrosNotificationSubscription: ResolverTypeWrapper<Omit<ChurrosNotificationSubscription, 'owner'> & { owner: ResolversTypes['ChurrosUser'] }>;
  ChurrosNotificationSubscriptionKeysInput: ChurrosNotificationSubscriptionKeysInput;
  ChurrosOAuth2Error: ResolverTypeWrapper<ChurrosOAuth2Error>;
  ChurrosOAuth2ErrorCode: ChurrosOAuth2ErrorCode;
  ChurrosPage: ResolverTypeWrapper<Omit<ChurrosPage, 'group' | 'lastAuthor'> & { group?: Maybe<ResolversTypes['ChurrosGroup']>, lastAuthor?: Maybe<ResolversTypes['ChurrosUser']> }>;
  ChurrosPageInfo: ResolverTypeWrapper<ChurrosPageInfo>;
  ChurrosPagesConnection: ResolverTypeWrapper<ChurrosPagesConnection>;
  ChurrosPagesEdge: ResolverTypeWrapper<ChurrosPagesEdge>;
  ChurrosPaymentMethod: ChurrosPaymentMethod;
  ChurrosPicture: ResolverTypeWrapper<ChurrosPicture>;
  ChurrosPictured: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['ChurrosPictured']>;
  ChurrosProfitsBreakdown: ResolverTypeWrapper<ChurrosProfitsBreakdown>;
  ChurrosProfitsBreakdownByPaymentMethod: ResolverTypeWrapper<ChurrosProfitsBreakdownByPaymentMethod>;
  ChurrosProfitsBreakdownByTicket: ResolverTypeWrapper<ChurrosProfitsBreakdownByTicket>;
  ChurrosPromotionType: ChurrosPromotionType;
  ChurrosQRCode: ResolverTypeWrapper<ChurrosQRCode>;
  ChurrosQueryAllFormsConnection: ResolverTypeWrapper<Omit<ChurrosQueryAllFormsConnection, 'edges' | 'nodes'> & { edges: Array<ResolversTypes['ChurrosQueryAllFormsConnectionEdge']>, nodes: Array<ResolversTypes['ChurrosForm']> }>;
  ChurrosQueryAllFormsConnectionEdge: ResolverTypeWrapper<Omit<ChurrosQueryAllFormsConnectionEdge, 'node'> & { node: ResolversTypes['ChurrosForm'] }>;
  ChurrosQueryAllUsersConnection: ResolverTypeWrapper<Omit<ChurrosQueryAllUsersConnection, 'edges' | 'nodes'> & { edges: Array<ResolversTypes['ChurrosQueryAllUsersConnectionEdge']>, nodes: Array<ResolversTypes['ChurrosUser']> }>;
  ChurrosQueryAllUsersConnectionEdge: ResolverTypeWrapper<Omit<ChurrosQueryAllUsersConnectionEdge, 'node'> & { node: ResolversTypes['ChurrosUser'] }>;
  ChurrosQueryAnnouncementsConnection: ResolverTypeWrapper<Omit<ChurrosQueryAnnouncementsConnection, 'edges' | 'nodes'> & { edges: Array<ResolversTypes['ChurrosQueryAnnouncementsConnectionEdge']>, nodes: Array<ResolversTypes['ChurrosAnnouncement']> }>;
  ChurrosQueryAnnouncementsConnectionEdge: ResolverTypeWrapper<Omit<ChurrosQueryAnnouncementsConnectionEdge, 'node'> & { node: ResolversTypes['ChurrosAnnouncement'] }>;
  ChurrosQueryCodeContributorsResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosQueryCodeContributorsResult']>;
  ChurrosQueryCodeContributorsSuccess: ResolverTypeWrapper<Omit<ChurrosQueryCodeContributorsSuccess, 'data'> & { data: Array<ResolversTypes['ChurrosUser']> }>;
  ChurrosQueryCombinedChangelogResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosQueryCombinedChangelogResult']>;
  ChurrosQueryCombinedChangelogSuccess: ResolverTypeWrapper<ChurrosQueryCombinedChangelogSuccess>;
  ChurrosQueryDocumentsConnection: ResolverTypeWrapper<ChurrosQueryDocumentsConnection>;
  ChurrosQueryDocumentsConnectionEdge: ResolverTypeWrapper<ChurrosQueryDocumentsConnectionEdge>;
  ChurrosQueryEventsByDayConnection: ResolverTypeWrapper<Omit<ChurrosQueryEventsByDayConnection, 'edges' | 'nodes'> & { edges: Array<ResolversTypes['ChurrosQueryEventsByDayConnectionEdge']>, nodes: Array<ResolversTypes['ChurrosEventsByDay']> }>;
  ChurrosQueryEventsByDayConnectionEdge: ResolverTypeWrapper<Omit<ChurrosQueryEventsByDayConnectionEdge, 'node'> & { node: ResolversTypes['ChurrosEventsByDay'] }>;
  ChurrosQueryEventsConnection: ResolverTypeWrapper<Omit<ChurrosQueryEventsConnection, 'edges' | 'nodes'> & { edges: Array<ResolversTypes['ChurrosQueryEventsConnectionEdge']>, nodes: Array<ResolversTypes['ChurrosEvent']> }>;
  ChurrosQueryEventsConnectionEdge: ResolverTypeWrapper<Omit<ChurrosQueryEventsConnectionEdge, 'node'> & { node: ResolversTypes['ChurrosEvent'] }>;
  ChurrosQueryFormsConnection: ResolverTypeWrapper<Omit<ChurrosQueryFormsConnection, 'edges' | 'nodes'> & { edges: Array<ResolversTypes['ChurrosQueryFormsConnectionEdge']>, nodes: Array<ResolversTypes['ChurrosForm']> }>;
  ChurrosQueryFormsConnectionEdge: ResolverTypeWrapper<Omit<ChurrosQueryFormsConnectionEdge, 'node'> & { node: ResolversTypes['ChurrosForm'] }>;
  ChurrosQueryGroupMembersCsvResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosQueryGroupMembersCsvResult']>;
  ChurrosQueryGroupMembersCsvSuccess: ResolverTypeWrapper<ChurrosQueryGroupMembersCsvSuccess>;
  ChurrosQueryHomepageConnection: ResolverTypeWrapper<Omit<ChurrosQueryHomepageConnection, 'edges' | 'nodes'> & { edges: Array<ResolversTypes['ChurrosQueryHomepageConnectionEdge']>, nodes: Array<ResolversTypes['ChurrosArticle']> }>;
  ChurrosQueryHomepageConnectionEdge: ResolverTypeWrapper<Omit<ChurrosQueryHomepageConnectionEdge, 'node'> & { node: ResolversTypes['ChurrosArticle'] }>;
  ChurrosQueryLogsConnection: ResolverTypeWrapper<ChurrosQueryLogsConnection>;
  ChurrosQueryLogsConnectionEdge: ResolverTypeWrapper<ChurrosQueryLogsConnectionEdge>;
  ChurrosQueryMinorsConnection: ResolverTypeWrapper<ChurrosQueryMinorsConnection>;
  ChurrosQueryMinorsConnectionEdge: ResolverTypeWrapper<ChurrosQueryMinorsConnectionEdge>;
  ChurrosQueryNotificationsConnection: ResolverTypeWrapper<Omit<ChurrosQueryNotificationsConnection, 'edges' | 'nodes'> & { edges: Array<ResolversTypes['ChurrosQueryNotificationsConnectionEdge']>, nodes: Array<ResolversTypes['ChurrosNotification']> }>;
  ChurrosQueryNotificationsConnectionEdge: ResolverTypeWrapper<Omit<ChurrosQueryNotificationsConnectionEdge, 'node'> & { node: ResolversTypes['ChurrosNotification'] }>;
  ChurrosQueryPagesConnection: ResolverTypeWrapper<ChurrosQueryPagesConnection>;
  ChurrosQueryPagesConnectionEdge: ResolverTypeWrapper<ChurrosQueryPagesConnectionEdge>;
  ChurrosQueryQuickSignupsConnection: ResolverTypeWrapper<ChurrosQueryQuickSignupsConnection>;
  ChurrosQueryQuickSignupsConnectionEdge: ResolverTypeWrapper<ChurrosQueryQuickSignupsConnectionEdge>;
  ChurrosQueryReactionsConnection: ResolverTypeWrapper<Omit<ChurrosQueryReactionsConnection, 'edges' | 'nodes'> & { edges: Array<ResolversTypes['ChurrosQueryReactionsConnectionEdge']>, nodes: Array<ResolversTypes['ChurrosReaction']> }>;
  ChurrosQueryReactionsConnectionEdge: ResolverTypeWrapper<Omit<ChurrosQueryReactionsConnectionEdge, 'node'> & { node: ResolversTypes['ChurrosReaction'] }>;
  ChurrosQueryRegistrationResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosQueryRegistrationResult']>;
  ChurrosQueryRegistrationSuccess: ResolverTypeWrapper<ChurrosQueryRegistrationSuccess>;
  ChurrosQueryRegistrationsOfUserConnection: ResolverTypeWrapper<ChurrosQueryRegistrationsOfUserConnection>;
  ChurrosQueryRegistrationsOfUserConnectionEdge: ResolverTypeWrapper<ChurrosQueryRegistrationsOfUserConnectionEdge>;
  ChurrosQueryUpcomingChangelogResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosQueryUpcomingChangelogResult']>;
  ChurrosQueryUpcomingChangelogSuccess: ResolverTypeWrapper<ChurrosQueryUpcomingChangelogSuccess>;
  ChurrosQueryUserCandidatesConnection: ResolverTypeWrapper<ChurrosQueryUserCandidatesConnection>;
  ChurrosQueryUserCandidatesConnectionEdge: ResolverTypeWrapper<ChurrosQueryUserCandidatesConnectionEdge>;
  ChurrosQuestion: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['ChurrosQuestion']>;
  ChurrosQuestionAnswersConnection: ResolverTypeWrapper<Omit<ChurrosQuestionAnswersConnection, 'edges' | 'nodes'> & { edges: Array<ResolversTypes['ChurrosQuestionAnswersConnectionEdge']>, nodes: Array<ResolversTypes['ChurrosAnswer']> }>;
  ChurrosQuestionAnswersConnectionEdge: ResolverTypeWrapper<Omit<ChurrosQuestionAnswersConnectionEdge, 'node'> & { node: ResolversTypes['ChurrosAnswer'] }>;
  ChurrosQuestionFileUpload: ResolverTypeWrapper<Omit<ChurrosQuestionFileUpload, 'answers' | 'defaultAnswer' | 'myAnswer' | 'section'> & { answers: ResolversTypes['ChurrosQuestionAnswersConnection'], defaultAnswer?: Maybe<ResolversTypes['ChurrosAnswer']>, myAnswer?: Maybe<ResolversTypes['ChurrosAnswer']>, section: ResolversTypes['ChurrosFormSection'] }>;
  ChurrosQuestionKind: ChurrosQuestionKind;
  ChurrosQuestionOptionInput: ChurrosQuestionOptionInput;
  ChurrosQuestionScalar: ResolverTypeWrapper<Omit<ChurrosQuestionScalar, 'answers' | 'defaultAnswer' | 'myAnswer' | 'section'> & { answers: ResolversTypes['ChurrosQuestionAnswersConnection'], defaultAnswer?: Maybe<ResolversTypes['ChurrosAnswer']>, myAnswer?: Maybe<ResolversTypes['ChurrosAnswer']>, section: ResolversTypes['ChurrosFormSection'] }>;
  ChurrosQuestionScale: ResolverTypeWrapper<Omit<ChurrosQuestionScale, 'answerCounts' | 'answers' | 'defaultAnswer' | 'myAnswer' | 'section'> & { answerCounts: Array<ResolversTypes['ChurrosStringToIntMapping']>, answers: ResolversTypes['ChurrosQuestionAnswersConnection'], defaultAnswer?: Maybe<ResolversTypes['ChurrosAnswer']>, myAnswer?: Maybe<ResolversTypes['ChurrosAnswer']>, section: ResolversTypes['ChurrosFormSection'] }>;
  ChurrosQuestionScaleInput: ChurrosQuestionScaleInput;
  ChurrosQuestionSelectMultiple: ResolverTypeWrapper<Omit<ChurrosQuestionSelectMultiple, 'answerCounts' | 'answers' | 'defaultAnswer' | 'myAnswer' | 'section'> & { answerCounts: Array<ResolversTypes['ChurrosStringToIntMapping']>, answers: ResolversTypes['ChurrosQuestionAnswersConnection'], defaultAnswer?: Maybe<ResolversTypes['ChurrosAnswer']>, myAnswer?: Maybe<ResolversTypes['ChurrosAnswer']>, section: ResolversTypes['ChurrosFormSection'] }>;
  ChurrosQuestionSelectOne: ResolverTypeWrapper<Omit<ChurrosQuestionSelectOne, 'answerCounts' | 'answers' | 'defaultAnswer' | 'groups' | 'jumps' | 'myAnswer' | 'section'> & { answerCounts: Array<ResolversTypes['ChurrosStringToIntMapping']>, answers: ResolversTypes['ChurrosQuestionAnswersConnection'], defaultAnswer?: Maybe<ResolversTypes['ChurrosAnswer']>, groups: Array<Maybe<ResolversTypes['ChurrosGroup']>>, jumps: Array<Maybe<ResolversTypes['ChurrosFormSection']>>, myAnswer?: Maybe<ResolversTypes['ChurrosAnswer']>, section: ResolversTypes['ChurrosFormSection'] }>;
  ChurrosQuickSignup: ResolverTypeWrapper<ChurrosQuickSignup>;
  ChurrosReactable: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['ChurrosReactable']>;
  ChurrosReaction: ResolverTypeWrapper<Omit<ChurrosReaction, 'author'> & { author?: Maybe<ResolversTypes['ChurrosUser']> }>;
  ChurrosRedisHealthCheck: ResolverTypeWrapper<ChurrosRedisHealthCheck>;
  ChurrosRegistration: ResolverTypeWrapper<Omit<ChurrosRegistration, 'author' | 'beneficiaryUser' | 'cancelledBy' | 'opposedBy' | 'verifiedBy'> & { author?: Maybe<ResolversTypes['ChurrosUser']>, beneficiaryUser?: Maybe<ResolversTypes['ChurrosUser']>, cancelledBy?: Maybe<ResolversTypes['ChurrosUser']>, opposedBy?: Maybe<ResolversTypes['ChurrosUser']>, verifiedBy?: Maybe<ResolversTypes['ChurrosUser']> }>;
  ChurrosRegistrationSearchResult: ResolverTypeWrapper<ChurrosRegistrationSearchResult>;
  ChurrosRegistrationVerificationResult: ResolverTypeWrapper<ChurrosRegistrationVerificationResult>;
  ChurrosRegistrationVerificationState: ChurrosRegistrationVerificationState;
  ChurrosRegistrationsCounts: ResolverTypeWrapper<ChurrosRegistrationsCounts>;
  ChurrosReleaseChange: ResolverTypeWrapper<ChurrosReleaseChange>;
  ChurrosReleaseChangesMaps: ResolverTypeWrapper<ChurrosReleaseChangesMaps>;
  ChurrosSchool: ResolverTypeWrapper<ChurrosSchool>;
  ChurrosSchoolGroup: ResolverTypeWrapper<ChurrosSchoolGroup>;
  ChurrosSchoolInput: ChurrosSchoolInput;
  ChurrosService: ResolverTypeWrapper<Omit<ChurrosService, 'group'> & { group?: Maybe<ResolversTypes['ChurrosGroup']> }>;
  ChurrosShopItem: ResolverTypeWrapper<Omit<ChurrosShopItem, 'group' | 'itemOptions' | 'lydiaAccount' | 'shopPayments'> & { group: ResolversTypes['ChurrosGroup'], itemOptions: Array<ResolversTypes['ChurrosShopItemOption']>, lydiaAccount?: Maybe<ResolversTypes['ChurrosLydiaAccount']>, shopPayments: Array<ResolversTypes['ChurrosShopPayment']> }>;
  ChurrosShopItemAnswer: ResolverTypeWrapper<Omit<ChurrosShopItemAnswer, 'shopPayment'> & { shopPayment: ResolversTypes['ChurrosShopPayment'] }>;
  ChurrosShopItemOption: ResolverTypeWrapper<Omit<ChurrosShopItemOption, 'shopItem'> & { shopItem: ResolversTypes['ChurrosShopItem'] }>;
  ChurrosShopItemOptionInput: ChurrosShopItemOptionInput;
  ChurrosShopPayment: ResolverTypeWrapper<Omit<ChurrosShopPayment, 'shopItem' | 'shopItemAnswer' | 'user'> & { shopItem: ResolversTypes['ChurrosShopItem'], shopItemAnswer?: Maybe<ResolversTypes['ChurrosShopItemAnswer']>, user: ResolversTypes['ChurrosUser'] }>;
  ChurrosSortDirection: ChurrosSortDirection;
  String: ResolverTypeWrapper<Scalars['String']['output']>;
  ChurrosStringToIntMapping: ResolverTypeWrapper<ChurrosStringToIntMapping>;
  ChurrosStudentAssociation: ResolverTypeWrapper<ChurrosStudentAssociation>;
  ChurrosStudentAssociationGroupsConnection: ResolverTypeWrapper<Omit<ChurrosStudentAssociationGroupsConnection, 'nodes'> & { nodes: Array<ResolversTypes['ChurrosGroup']> }>;
  ChurrosStudentAssociationGroupsConnectionEdge: ResolverTypeWrapper<Omit<ChurrosStudentAssociationGroupsConnectionEdge, 'node'> & { node: ResolversTypes['ChurrosGroup'] }>;
  ChurrosSubject: ResolverTypeWrapper<ChurrosSubject>;
  ChurrosSubjectDocumentsConnection: ResolverTypeWrapper<ChurrosSubjectDocumentsConnection>;
  ChurrosSubjectDocumentsConnectionEdge: ResolverTypeWrapper<ChurrosSubjectDocumentsConnectionEdge>;
  ChurrosSubscriptionRegistrationResult: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ChurrosSubscriptionRegistrationResult']>;
  ChurrosSubscriptionRegistrationSuccess: ResolverTypeWrapper<ChurrosSubscriptionRegistrationSuccess>;
  ChurrosTeachingUnit: ResolverTypeWrapper<ChurrosTeachingUnit>;
  ChurrosThirdPartyApp: ResolverTypeWrapper<Omit<ChurrosThirdPartyApp, 'owner'> & { owner: ResolversTypes['ChurrosGroup'] }>;
  ChurrosThirdPartyAppApiUsageConnection: ResolverTypeWrapper<ChurrosThirdPartyAppApiUsageConnection>;
  ChurrosThirdPartyAppApiUsageConnectionEdge: ResolverTypeWrapper<ChurrosThirdPartyAppApiUsageConnectionEdge>;
  ChurrosThirdPartyAppLogsConnection: ResolverTypeWrapper<ChurrosThirdPartyAppLogsConnection>;
  ChurrosThirdPartyAppLogsConnectionEdge: ResolverTypeWrapper<ChurrosThirdPartyAppLogsConnectionEdge>;
  ChurrosThirdPartyAppRateLimitHitsConnection: ResolverTypeWrapper<ChurrosThirdPartyAppRateLimitHitsConnection>;
  ChurrosThirdPartyAppRateLimitHitsConnectionEdge: ResolverTypeWrapper<ChurrosThirdPartyAppRateLimitHitsConnectionEdge>;
  ChurrosThirdPartyAppRegistrationResponse: ResolverTypeWrapper<ChurrosThirdPartyAppRegistrationResponse>;
  ChurrosThirdPartyAppUsersConnection: ResolverTypeWrapper<Omit<ChurrosThirdPartyAppUsersConnection, 'nodes'> & { nodes: Array<ResolversTypes['ChurrosUser']> }>;
  ChurrosThirdPartyAppUsersConnectionEdge: ResolverTypeWrapper<Omit<ChurrosThirdPartyAppUsersConnectionEdge, 'node'> & { node: ResolversTypes['ChurrosUser'] }>;
  ChurrosTicket: ResolverTypeWrapper<Omit<ChurrosTicket, 'autojoinGroups' | 'event' | 'openToGroups'> & { autojoinGroups: Array<ResolversTypes['ChurrosGroup']>, event: ResolversTypes['ChurrosEvent'], openToGroups: Array<ResolversTypes['ChurrosGroup']> }>;
  ChurrosTicketGroup: ResolverTypeWrapper<Omit<ChurrosTicketGroup, 'event'> & { event: ResolversTypes['ChurrosEvent'] }>;
  ChurrosTicketGroupInput: ChurrosTicketGroupInput;
  ChurrosTicketInput: ChurrosTicketInput;
  ChurrosUID: ResolverTypeWrapper<Scalars['ChurrosUID']['output']>;
  ChurrosUpsertGroupInput: ChurrosUpsertGroupInput;
  ChurrosUser: ResolverTypeWrapper<Omit<ChurrosUser, 'allowedApps' | 'answeredForms' | 'articles' | 'authorizedApps' | 'boardMemberships' | 'canCreatePostsOn' | 'credentials' | 'emailChangeRequests' | 'familyTree' | 'godchildren' | 'godparent' | 'groups' | 'incomingGodparentRequests' | 'managedEvents' | 'outgoingGodparentRequests' | 'partiallyAnsweredForms'> & { allowedApps: Array<ResolversTypes['ChurrosThirdPartyApp']>, answeredForms: ResolversTypes['ChurrosUserAnsweredFormsConnection'], articles: ResolversTypes['ChurrosUserArticlesConnection'], authorizedApps: Array<ResolversTypes['ChurrosThirdPartyApp']>, boardMemberships: Array<ResolversTypes['ChurrosGroupMember']>, canCreatePostsOn: Array<ResolversTypes['ChurrosGroup']>, credentials: Array<ResolversTypes['ChurrosCredential']>, emailChangeRequests: Array<ResolversTypes['ChurrosEmailChange']>, familyTree: ResolversTypes['ChurrosFamilyTree'], godchildren: Array<ResolversTypes['ChurrosUser']>, godparent?: Maybe<ResolversTypes['ChurrosUser']>, groups: Array<ResolversTypes['ChurrosGroupMember']>, incomingGodparentRequests: Array<ResolversTypes['ChurrosGodparentRequest']>, managedEvents: Array<ResolversTypes['ChurrosEventManager']>, outgoingGodparentRequests: Array<ResolversTypes['ChurrosGodparentRequest']>, partiallyAnsweredForms: ResolversTypes['ChurrosUserPartiallyAnsweredFormsConnection'] }>;
  ChurrosUserAnsweredFormsConnection: ResolverTypeWrapper<Omit<ChurrosUserAnsweredFormsConnection, 'edges' | 'nodes'> & { edges: Array<ResolversTypes['ChurrosUserAnsweredFormsConnectionEdge']>, nodes: Array<ResolversTypes['ChurrosForm']> }>;
  ChurrosUserAnsweredFormsConnectionEdge: ResolverTypeWrapper<Omit<ChurrosUserAnsweredFormsConnectionEdge, 'node'> & { node: ResolversTypes['ChurrosForm'] }>;
  ChurrosUserArticlesConnection: ResolverTypeWrapper<Omit<ChurrosUserArticlesConnection, 'edges' | 'nodes'> & { edges: Array<ResolversTypes['ChurrosUserArticlesConnectionEdge']>, nodes: Array<ResolversTypes['ChurrosArticle']> }>;
  ChurrosUserArticlesConnectionEdge: ResolverTypeWrapper<Omit<ChurrosUserArticlesConnectionEdge, 'node'> & { node: ResolversTypes['ChurrosArticle'] }>;
  ChurrosUserBookingsConnection: ResolverTypeWrapper<ChurrosUserBookingsConnection>;
  ChurrosUserBookingsConnectionEdge: ResolverTypeWrapper<ChurrosUserBookingsConnectionEdge>;
  ChurrosUserCandidate: ResolverTypeWrapper<ChurrosUserCandidate>;
  ChurrosUserPartiallyAnsweredFormsConnection: ResolverTypeWrapper<Omit<ChurrosUserPartiallyAnsweredFormsConnection, 'edges' | 'nodes'> & { edges: Array<ResolversTypes['ChurrosUserPartiallyAnsweredFormsConnectionEdge']>, nodes: Array<ResolversTypes['ChurrosForm']> }>;
  ChurrosUserPartiallyAnsweredFormsConnectionEdge: ResolverTypeWrapper<Omit<ChurrosUserPartiallyAnsweredFormsConnectionEdge, 'node'> & { node: ResolversTypes['ChurrosForm'] }>;
  ChurrosUserSearchResult: ResolverTypeWrapper<Omit<ChurrosUserSearchResult, 'user'> & { user: ResolversTypes['ChurrosUser'] }>;
  ChurrosVisibility: ChurrosVisibility;
  ChurrosZodError: ResolverTypeWrapper<ChurrosZodError>;
  ChurrosZodFieldError: ResolverTypeWrapper<ChurrosZodFieldError>;
  Mutation: ResolverTypeWrapper<{}>;
  AdminAppsListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AdminAppsListResponse']>;
  App: ResolverTypeWrapper<App>;
  ValidationError: ResolverTypeWrapper<ValidationError>;
  JSON: ResolverTypeWrapper<Scalars['JSON']['output']>;
  GenericError: ResolverTypeWrapper<GenericError>;
  AdminMetricsRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AdminMetricsRetrieveResponse']>;
  LoginMetrics: ResolverTypeWrapper<LoginMetrics>;
  Coordinate: ResolverTypeWrapper<Coordinate>;
  AdminModelsListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AdminModelsListResponse']>;
  AdminSettingsRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AdminSettingsRetrieveResponse']>;
  Settings: ResolverTypeWrapper<Settings>;
  PositiveInt: ResolverTypeWrapper<Scalars['PositiveInt']['output']>;
  AdminSystemRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AdminSystemRetrieveResponse']>;
  SystemInfo: ResolverTypeWrapper<SystemInfo>;
  QueryAdminSystemRetrieveOneOf_0Runtime: ResolverTypeWrapper<QueryAdminSystemRetrieveOneOf_0Runtime>;
  AdminVersionRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AdminVersionRetrieveResponse']>;
  Version: ResolverTypeWrapper<Version>;
  AdminWorkersRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AdminWorkersRetrieveResponse']>;
  Workers: ResolverTypeWrapper<Workers>;
  AuthenticatorsAdminAllListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsAdminAllListResponse']>;
  Device: ResolverTypeWrapper<Device>;
  AuthenticatorsAdminDuoListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsAdminDuoListResponse']>;
  PaginatedDuoDeviceList: ResolverTypeWrapper<PaginatedDuoDeviceList>;
  Pagination: ResolverTypeWrapper<Pagination>;
  DuoDevice: ResolverTypeWrapper<DuoDevice>;
  QueryAuthenticatorsAdminDuoListOneOf_0ResultsItemsName: ResolverTypeWrapper<Scalars['QueryAuthenticatorsAdminDuoListOneOf_0ResultsItemsName']['output']>;
  AuthenticatorsAdminDuoRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsAdminDuoRetrieveResponse']>;
  AuthenticatorsAdminSmsListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsAdminSmsListResponse']>;
  PaginatedSmsDeviceList: ResolverTypeWrapper<PaginatedSmsDeviceList>;
  SmsDevice: ResolverTypeWrapper<SmsDevice>;
  QueryAuthenticatorsAdminSmsListOneOf_0ResultsItemsName: ResolverTypeWrapper<Scalars['QueryAuthenticatorsAdminSmsListOneOf_0ResultsItemsName']['output']>;
  AuthenticatorsAdminSmsRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsAdminSmsRetrieveResponse']>;
  AuthenticatorsAdminStaticListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsAdminStaticListResponse']>;
  PaginatedStaticDeviceList: ResolverTypeWrapper<PaginatedStaticDeviceList>;
  StaticDevice: ResolverTypeWrapper<StaticDevice>;
  QueryAuthenticatorsAdminStaticListOneOf_0ResultsItemsName: ResolverTypeWrapper<Scalars['QueryAuthenticatorsAdminStaticListOneOf_0ResultsItemsName']['output']>;
  StaticDeviceToken: ResolverTypeWrapper<StaticDeviceToken>;
  QueryAuthenticatorsAdminStaticListOneOf_0ResultsItemsTokenSetItemsToken: ResolverTypeWrapper<Scalars['QueryAuthenticatorsAdminStaticListOneOf_0ResultsItemsTokenSetItemsToken']['output']>;
  AuthenticatorsAdminStaticRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsAdminStaticRetrieveResponse']>;
  AuthenticatorsAdminTotpListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsAdminTotpListResponse']>;
  PaginatedTotpDeviceList: ResolverTypeWrapper<PaginatedTotpDeviceList>;
  TotpDevice: ResolverTypeWrapper<TotpDevice>;
  QueryAuthenticatorsAdminTotpListOneOf_0ResultsItemsName: ResolverTypeWrapper<Scalars['QueryAuthenticatorsAdminTotpListOneOf_0ResultsItemsName']['output']>;
  AuthenticatorsAdminTotpRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsAdminTotpRetrieveResponse']>;
  AuthenticatorsAdminWebauthnListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsAdminWebauthnListResponse']>;
  PaginatedWebAuthnDeviceList: ResolverTypeWrapper<PaginatedWebAuthnDeviceList>;
  WebAuthnDevice: ResolverTypeWrapper<WebAuthnDevice>;
  QueryAuthenticatorsAdminWebauthnListOneOf_0ResultsItemsName: ResolverTypeWrapper<Scalars['QueryAuthenticatorsAdminWebauthnListOneOf_0ResultsItemsName']['output']>;
  WebAuthnDeviceType: ResolverTypeWrapper<WebAuthnDeviceType>;
  UUID: ResolverTypeWrapper<Scalars['UUID']['output']>;
  AuthenticatorsAdminWebauthnRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsAdminWebauthnRetrieveResponse']>;
  AuthenticatorsAllListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsAllListResponse']>;
  AuthenticatorsDuoListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsDuoListResponse']>;
  AuthenticatorsDuoRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsDuoRetrieveResponse']>;
  AuthenticatorsDuoUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsDuoUsedByListResponse']>;
  UsedBy: ResolverTypeWrapper<UsedBy>;
  UsedByActionEnum: UsedByActionEnum;
  AuthenticatorsSmsListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsSmsListResponse']>;
  AuthenticatorsSmsRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsSmsRetrieveResponse']>;
  AuthenticatorsSmsUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsSmsUsedByListResponse']>;
  AuthenticatorsStaticListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsStaticListResponse']>;
  AuthenticatorsStaticRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsStaticRetrieveResponse']>;
  AuthenticatorsStaticUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsStaticUsedByListResponse']>;
  AuthenticatorsTotpListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsTotpListResponse']>;
  AuthenticatorsTotpRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsTotpRetrieveResponse']>;
  AuthenticatorsTotpUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsTotpUsedByListResponse']>;
  AuthenticatorsWebauthnListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsWebauthnListResponse']>;
  AuthenticatorsWebauthnRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsWebauthnRetrieveResponse']>;
  AuthenticatorsWebauthnUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsWebauthnUsedByListResponse']>;
  CoreApplicationsListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreApplicationsListResponse']>;
  PaginatedApplicationList: ResolverTypeWrapper<Omit<PaginatedApplicationList, 'results'> & { results: Array<Maybe<ResolversTypes['Application']>> }>;
  Application: ResolverTypeWrapper<Omit<Application, 'providerObj' | 'backchannelProvidersObj' | 'churrosGroup' | 'metrics'> & { providerObj: ResolversTypes['Provider'], backchannelProvidersObj: Array<Maybe<ResolversTypes['Provider']>>, churrosGroup: ResolversTypes['ChurrosGroup'], metrics?: Maybe<Array<Maybe<ResolversTypes['CoreApplicationsMetricsListResponse']>>> }>;
  QueryCoreApplicationsListOneOf_0ResultsItemsSlug: ResolverTypeWrapper<Scalars['QueryCoreApplicationsListOneOf_0ResultsItemsSlug']['output']>;
  Provider: ResolverTypeWrapper<Omit<Provider, 'application'> & { application?: Maybe<ResolversTypes['CoreApplicationsRetrieveResponse']> }>;
  URL: ResolverTypeWrapper<Scalars['URL']['output']>;
  PolicyEngineMode: PolicyEngineMode;
  CoreApplicationsRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreApplicationsRetrieveResponse']>;
  CoreApplicationsCheckAccessRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreApplicationsCheckAccessRetrieveResponse']>;
  PolicyTestResult: ResolverTypeWrapper<PolicyTestResult>;
  LogEvent: ResolverTypeWrapper<LogEvent>;
  LogLevelEnum: LogLevelEnum;
  CoreApplicationsMetricsListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreApplicationsMetricsListResponse']>;
  CoreApplicationsUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreApplicationsUsedByListResponse']>;
  CoreAuthenticatedSessionsListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreAuthenticatedSessionsListResponse']>;
  PaginatedAuthenticatedSessionList: ResolverTypeWrapper<PaginatedAuthenticatedSessionList>;
  AuthenticatedSession: ResolverTypeWrapper<AuthenticatedSession>;
  QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgent: ResolverTypeWrapper<QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgent>;
  QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentDevice: ResolverTypeWrapper<QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentDevice>;
  QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentOs: ResolverTypeWrapper<QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentOs>;
  QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentUserAgent: ResolverTypeWrapper<QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentUserAgent>;
  QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsGeoIp: ResolverTypeWrapper<QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsGeoIp>;
  QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsAsn: ResolverTypeWrapper<QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsAsn>;
  CoreAuthenticatedSessionsRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreAuthenticatedSessionsRetrieveResponse']>;
  CoreAuthenticatedSessionsUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreAuthenticatedSessionsUsedByListResponse']>;
  CoreBrandsListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreBrandsListResponse']>;
  PaginatedBrandList: ResolverTypeWrapper<PaginatedBrandList>;
  Brand: ResolverTypeWrapper<Brand>;
  CoreBrandsRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreBrandsRetrieveResponse']>;
  CoreBrandsUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreBrandsUsedByListResponse']>;
  CoreBrandsCurrentRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreBrandsCurrentRetrieveResponse']>;
  CurrentBrand: ResolverTypeWrapper<CurrentBrand>;
  FooterLink: ResolverTypeWrapper<FooterLink>;
  UiThemeEnum: UiThemeEnum;
  CoreGroupsListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreGroupsListResponse']>;
  PaginatedGroupList: ResolverTypeWrapper<PaginatedGroupList>;
  Group: ResolverTypeWrapper<Group>;
  QueryCoreGroupsListOneOf_0ResultsItemsName: ResolverTypeWrapper<Scalars['QueryCoreGroupsListOneOf_0ResultsItemsName']['output']>;
  GroupMember: ResolverTypeWrapper<GroupMember>;
  QueryCoreGroupsListOneOf_0ResultsItemsUsersObjItemsUsername: ResolverTypeWrapper<Scalars['QueryCoreGroupsListOneOf_0ResultsItemsUsersObjItemsUsername']['output']>;
  EmailAddress: ResolverTypeWrapper<Scalars['EmailAddress']['output']>;
  Role: ResolverTypeWrapper<Role>;
  QueryCoreGroupsListOneOf_0ResultsItemsRolesObjItemsName: ResolverTypeWrapper<Scalars['QueryCoreGroupsListOneOf_0ResultsItemsRolesObjItemsName']['output']>;
  CoreGroupsRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreGroupsRetrieveResponse']>;
  CoreGroupsUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreGroupsUsedByListResponse']>;
  CoreTokensListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreTokensListResponse']>;
  PaginatedTokenList: ResolverTypeWrapper<PaginatedTokenList>;
  Token: ResolverTypeWrapper<Token>;
  QueryCoreTokensListOneOf_0ResultsItemsIdentifier: ResolverTypeWrapper<Scalars['QueryCoreTokensListOneOf_0ResultsItemsIdentifier']['output']>;
  IntentEnum: IntentEnum;
  User: ResolverTypeWrapper<User>;
  QueryCoreTokensListOneOf_0ResultsItemsUserObjUsername: ResolverTypeWrapper<Scalars['QueryCoreTokensListOneOf_0ResultsItemsUserObjUsername']['output']>;
  UserGroup: ResolverTypeWrapper<UserGroup>;
  QueryCoreTokensListOneOf_0ResultsItemsUserObjGroupsObjItemsName: ResolverTypeWrapper<Scalars['QueryCoreTokensListOneOf_0ResultsItemsUserObjGroupsObjItemsName']['output']>;
  UserTypeEnum: UserTypeEnum;
  QueryInputCoreTokensListIntent: QueryInputCoreTokensListIntent;
  CoreTokensRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreTokensRetrieveResponse']>;
  CoreTokensUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreTokensUsedByListResponse']>;
  CoreTokensViewKeyRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreTokensViewKeyRetrieveResponse']>;
  TokenView: ResolverTypeWrapper<TokenView>;
  CoreUserConsentListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreUserConsentListResponse']>;
  PaginatedUserConsentList: ResolverTypeWrapper<Omit<PaginatedUserConsentList, 'results'> & { results: Array<Maybe<ResolversTypes['UserConsent']>> }>;
  UserConsent: ResolverTypeWrapper<Omit<UserConsent, 'application'> & { application: ResolversTypes['Application'] }>;
  CoreUserConsentRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreUserConsentRetrieveResponse']>;
  CoreUserConsentUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreUserConsentUsedByListResponse']>;
  CoreUsersListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreUsersListResponse']>;
  PaginatedUserList: ResolverTypeWrapper<PaginatedUserList>;
  QueryInputCoreUsersListTypeItems: QueryInputCoreUsersListTypeItems;
  CoreUsersRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreUsersRetrieveResponse']>;
  CoreUsersMetricsRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreUsersMetricsRetrieveResponse']>;
  UserMetrics: ResolverTypeWrapper<UserMetrics>;
  CoreUsersUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreUsersUsedByListResponse']>;
  CoreUsersImpersonateEndRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreUsersImpersonateEndRetrieveResponse']>;
  VoidContainer: ResolverTypeWrapper<VoidContainer>;
  Void: ResolverTypeWrapper<Scalars['Void']['output']>;
  CoreUsersMeRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreUsersMeRetrieveResponse']>;
  SessionUser: ResolverTypeWrapper<SessionUser>;
  UserSelf: ResolverTypeWrapper<UserSelf>;
  QueryCoreUsersMeRetrieveOneOf_0UserUsername: ResolverTypeWrapper<Scalars['QueryCoreUsersMeRetrieveOneOf_0UserUsername']['output']>;
  UserSelfGroups: ResolverTypeWrapper<UserSelfGroups>;
  CoreUsersPathsRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreUsersPathsRetrieveResponse']>;
  UserPath: ResolverTypeWrapper<UserPath>;
  CryptoCertificatekeypairsListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CryptoCertificatekeypairsListResponse']>;
  PaginatedCertificateKeyPairList: ResolverTypeWrapper<PaginatedCertificateKeyPairList>;
  CertificateKeyPair: ResolverTypeWrapper<CertificateKeyPair>;
  CryptoCertificatekeypairsRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CryptoCertificatekeypairsRetrieveResponse']>;
  CryptoCertificatekeypairsUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CryptoCertificatekeypairsUsedByListResponse']>;
  CryptoCertificatekeypairsViewCertificateRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CryptoCertificatekeypairsViewCertificateRetrieveResponse']>;
  CertificateData: ResolverTypeWrapper<CertificateData>;
  CryptoCertificatekeypairsViewPrivateKeyRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CryptoCertificatekeypairsViewPrivateKeyRetrieveResponse']>;
  EnterpriseLicenseListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EnterpriseLicenseListResponse']>;
  PaginatedLicenseList: ResolverTypeWrapper<PaginatedLicenseList>;
  License: ResolverTypeWrapper<License>;
  EnterpriseLicenseRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EnterpriseLicenseRetrieveResponse']>;
  EnterpriseLicenseUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EnterpriseLicenseUsedByListResponse']>;
  EnterpriseLicenseForecastRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EnterpriseLicenseForecastRetrieveResponse']>;
  LicenseForecast: ResolverTypeWrapper<LicenseForecast>;
  EnterpriseLicenseGetInstallIdRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EnterpriseLicenseGetInstallIdRetrieveResponse']>;
  InstallId: ResolverTypeWrapper<InstallId>;
  EnterpriseLicenseSummaryRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EnterpriseLicenseSummaryRetrieveResponse']>;
  LicenseSummary: ResolverTypeWrapper<LicenseSummary>;
  EventsEventsListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EventsEventsListResponse']>;
  PaginatedEventList: ResolverTypeWrapper<PaginatedEventList>;
  Event: ResolverTypeWrapper<Event>;
  EventActions: EventActions;
  EventsEventsRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EventsEventsRetrieveResponse']>;
  EventsEventsActionsListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EventsEventsActionsListResponse']>;
  TypeCreate: ResolverTypeWrapper<TypeCreate>;
  EventsEventsPerMonthListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EventsEventsPerMonthListResponse']>;
  EventsEventsTopPerUserListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EventsEventsTopPerUserListResponse']>;
  EventTopPerUser: ResolverTypeWrapper<EventTopPerUser>;
  EventsEventsVolumeListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EventsEventsVolumeListResponse']>;
  EventsNotificationsListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EventsNotificationsListResponse']>;
  PaginatedNotificationList: ResolverTypeWrapper<PaginatedNotificationList>;
  Notification: ResolverTypeWrapper<Notification>;
  SeverityEnum: SeverityEnum;
  QueryInputEventsNotificationsListSeverity: QueryInputEventsNotificationsListSeverity;
  EventsNotificationsRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EventsNotificationsRetrieveResponse']>;
  EventsNotificationsUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EventsNotificationsUsedByListResponse']>;
  EventsRulesListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EventsRulesListResponse']>;
  PaginatedNotificationRuleList: ResolverTypeWrapper<PaginatedNotificationRuleList>;
  NotificationRule: ResolverTypeWrapper<NotificationRule>;
  QueryInputEventsRulesListSeverity: QueryInputEventsRulesListSeverity;
  EventsRulesRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EventsRulesRetrieveResponse']>;
  EventsRulesUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EventsRulesUsedByListResponse']>;
  EventsSystemTasksListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EventsSystemTasksListResponse']>;
  PaginatedSystemTaskList: ResolverTypeWrapper<PaginatedSystemTaskList>;
  SystemTask: ResolverTypeWrapper<SystemTask>;
  SystemTaskStatusEnum: SystemTaskStatusEnum;
  QueryInputEventsSystemTasksListStatus: QueryInputEventsSystemTasksListStatus;
  EventsSystemTasksRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EventsSystemTasksRetrieveResponse']>;
  EventsTransportsListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EventsTransportsListResponse']>;
  PaginatedNotificationTransportList: ResolverTypeWrapper<PaginatedNotificationTransportList>;
  NotificationTransport: ResolverTypeWrapper<NotificationTransport>;
  NotificationTransportModeEnum: NotificationTransportModeEnum;
  QueryInputEventsTransportsListMode: QueryInputEventsTransportsListMode;
  EventsTransportsRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EventsTransportsRetrieveResponse']>;
  EventsTransportsUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EventsTransportsUsedByListResponse']>;
  FlowsBindingsListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['FlowsBindingsListResponse']>;
  PaginatedFlowStageBindingList: ResolverTypeWrapper<PaginatedFlowStageBindingList>;
  FlowStageBinding: ResolverTypeWrapper<FlowStageBinding>;
  Stage: ResolverTypeWrapper<Stage>;
  FlowSet: ResolverTypeWrapper<FlowSet>;
  QueryFlowsBindingsListOneOf_0ResultsItemsStageObjFlowSetItemsSlug: ResolverTypeWrapper<Scalars['QueryFlowsBindingsListOneOf_0ResultsItemsStageObjFlowSetItemsSlug']['output']>;
  FlowDesignationEnum: FlowDesignationEnum;
  FlowLayoutEnum: FlowLayoutEnum;
  DeniedActionEnum: DeniedActionEnum;
  InvalidResponseActionEnum: InvalidResponseActionEnum;
  QueryInputFlowsBindingsListInvalidResponseAction: QueryInputFlowsBindingsListInvalidResponseAction;
  QueryInputFlowsBindingsListPolicyEngineMode: QueryInputFlowsBindingsListPolicyEngineMode;
  FlowsBindingsRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['FlowsBindingsRetrieveResponse']>;
  FlowsBindingsUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['FlowsBindingsUsedByListResponse']>;
  FlowsExecutorGetResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['FlowsExecutorGetResponse']>;
  AccessDeniedChallenge: ResolverTypeWrapper<AccessDeniedChallenge>;
  ChallengeChoices: ChallengeChoices;
  ContextualFlowInfo: ResolverTypeWrapper<ContextualFlowInfo>;
  ContextualFlowInfoLayoutEnum: ContextualFlowInfoLayoutEnum;
  AppleLoginChallenge: ResolverTypeWrapper<AppleLoginChallenge>;
  AuthenticatorDuoChallenge: ResolverTypeWrapper<AuthenticatorDuoChallenge>;
  AuthenticatorSmsChallenge: ResolverTypeWrapper<AuthenticatorSmsChallenge>;
  AuthenticatorStaticChallenge: ResolverTypeWrapper<AuthenticatorStaticChallenge>;
  AuthenticatorTotpChallenge: ResolverTypeWrapper<AuthenticatorTotpChallenge>;
  AuthenticatorValidationChallenge: ResolverTypeWrapper<AuthenticatorValidationChallenge>;
  DeviceChallenge: ResolverTypeWrapper<DeviceChallenge>;
  SelectableStage: ResolverTypeWrapper<SelectableStage>;
  AuthenticatorWebAuthnChallenge: ResolverTypeWrapper<AuthenticatorWebAuthnChallenge>;
  AutosubmitChallenge: ResolverTypeWrapper<AutosubmitChallenge>;
  CaptchaChallenge: ResolverTypeWrapper<CaptchaChallenge>;
  ConsentChallenge: ResolverTypeWrapper<ConsentChallenge>;
  ConsentPermission: ResolverTypeWrapper<ConsentPermission>;
  EmailChallenge: ResolverTypeWrapper<EmailChallenge>;
  FlowErrorChallenge: ResolverTypeWrapper<FlowErrorChallenge>;
  IdentificationChallenge: ResolverTypeWrapper<Omit<IdentificationChallenge, 'sources'> & { sources?: Maybe<Array<Maybe<ResolversTypes['LoginSource']>>> }>;
  LoginSource: ResolverTypeWrapper<Omit<LoginSource, 'challenge'> & { challenge: ResolversTypes['LoginChallengeTypes'] }>;
  LoginChallengeTypes: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['LoginChallengeTypes']>;
  RedirectChallenge: ResolverTypeWrapper<RedirectChallenge>;
  PlexAuthenticationChallenge: ResolverTypeWrapper<PlexAuthenticationChallenge>;
  OAuthDeviceCodeChallenge: ResolverTypeWrapper<OAuthDeviceCodeChallenge>;
  OAuthDeviceCodeFinishChallenge: ResolverTypeWrapper<OAuthDeviceCodeFinishChallenge>;
  PasswordChallenge: ResolverTypeWrapper<PasswordChallenge>;
  PromptChallenge: ResolverTypeWrapper<PromptChallenge>;
  StagePrompt: ResolverTypeWrapper<StagePrompt>;
  PromptTypeEnum: PromptTypeEnum;
  ShellChallenge: ResolverTypeWrapper<ShellChallenge>;
  UserLoginChallenge: ResolverTypeWrapper<UserLoginChallenge>;
  FlowsInspectorGetResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['FlowsInspectorGetResponse']>;
  FlowInspection: ResolverTypeWrapper<FlowInspection>;
  FlowInspectorPlan: ResolverTypeWrapper<FlowInspectorPlan>;
  FlowsInstancesListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['FlowsInstancesListResponse']>;
  PaginatedFlowList: ResolverTypeWrapper<PaginatedFlowList>;
  Flow: ResolverTypeWrapper<Flow>;
  QueryFlowsInstancesListOneOf_0ResultsItemsSlug: ResolverTypeWrapper<Scalars['QueryFlowsInstancesListOneOf_0ResultsItemsSlug']['output']>;
  AuthenticationEnum: AuthenticationEnum;
  QueryInputFlowsInstancesListDeniedAction: QueryInputFlowsInstancesListDeniedAction;
  QueryInputFlowsInstancesListDesignation: QueryInputFlowsInstancesListDesignation;
  FlowsInstancesRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['FlowsInstancesRetrieveResponse']>;
  FlowsInstancesDiagramRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['FlowsInstancesDiagramRetrieveResponse']>;
  FlowDiagram: ResolverTypeWrapper<FlowDiagram>;
  FlowsInstancesExecuteRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['FlowsInstancesExecuteRetrieveResponse']>;
  Link: ResolverTypeWrapper<Link>;
  FlowsInstancesExportRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['FlowsInstancesExportRetrieveResponse']>;
  FileContainer: ResolverTypeWrapper<FileContainer>;
  File: ResolverTypeWrapper<Scalars['File']['output']>;
  FlowsInstancesUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['FlowsInstancesUsedByListResponse']>;
  FlowsInstancesCacheInfoRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['FlowsInstancesCacheInfoRetrieveResponse']>;
  Cache: ResolverTypeWrapper<Cache>;
  ManagedBlueprintsListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ManagedBlueprintsListResponse']>;
  PaginatedBlueprintInstanceList: ResolverTypeWrapper<PaginatedBlueprintInstanceList>;
  BlueprintInstance: ResolverTypeWrapper<BlueprintInstance>;
  BlueprintInstanceStatusEnum: BlueprintInstanceStatusEnum;
  ManagedBlueprintsRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ManagedBlueprintsRetrieveResponse']>;
  ManagedBlueprintsUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ManagedBlueprintsUsedByListResponse']>;
  ManagedBlueprintsAvailableListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ManagedBlueprintsAvailableListResponse']>;
  BlueprintFile: ResolverTypeWrapper<BlueprintFile>;
  Metadata: ResolverTypeWrapper<Metadata>;
  Oauth2AccessTokensListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['Oauth2AccessTokensListResponse']>;
  PaginatedTokenModelList: ResolverTypeWrapper<PaginatedTokenModelList>;
  TokenModel: ResolverTypeWrapper<TokenModel>;
  OAuth2Provider: ResolverTypeWrapper<OAuth2Provider>;
  ClientTypeEnum: ClientTypeEnum;
  QueryOauth2AccessTokensListOneOf_0ResultsItemsProviderClientId: ResolverTypeWrapper<Scalars['QueryOauth2AccessTokensListOneOf_0ResultsItemsProviderClientId']['output']>;
  QueryOauth2AccessTokensListOneOf_0ResultsItemsProviderClientSecret: ResolverTypeWrapper<Scalars['QueryOauth2AccessTokensListOneOf_0ResultsItemsProviderClientSecret']['output']>;
  SubModeEnum: SubModeEnum;
  IssuerModeEnum: IssuerModeEnum;
  Oauth2AccessTokensRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['Oauth2AccessTokensRetrieveResponse']>;
  Oauth2AccessTokensUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['Oauth2AccessTokensUsedByListResponse']>;
  Oauth2AuthorizationCodesListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['Oauth2AuthorizationCodesListResponse']>;
  PaginatedExpiringBaseGrantModelList: ResolverTypeWrapper<PaginatedExpiringBaseGrantModelList>;
  ExpiringBaseGrantModel: ResolverTypeWrapper<ExpiringBaseGrantModel>;
  Oauth2AuthorizationCodesRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['Oauth2AuthorizationCodesRetrieveResponse']>;
  Oauth2AuthorizationCodesUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['Oauth2AuthorizationCodesUsedByListResponse']>;
  Oauth2RefreshTokensListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['Oauth2RefreshTokensListResponse']>;
  Oauth2RefreshTokensRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['Oauth2RefreshTokensRetrieveResponse']>;
  Oauth2RefreshTokensUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['Oauth2RefreshTokensUsedByListResponse']>;
  OutpostsInstancesListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['OutpostsInstancesListResponse']>;
  PaginatedOutpostList: ResolverTypeWrapper<Omit<PaginatedOutpostList, 'results'> & { results: Array<Maybe<ResolversTypes['Outpost']>> }>;
  Outpost: ResolverTypeWrapper<Omit<Outpost, 'providersObj'> & { providersObj: Array<Maybe<ResolversTypes['Provider']>> }>;
  OutpostTypeEnum: OutpostTypeEnum;
  ServiceConnection: ResolverTypeWrapper<ServiceConnection>;
  OutpostsInstancesRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['OutpostsInstancesRetrieveResponse']>;
  OutpostsInstancesHealthListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['OutpostsInstancesHealthListResponse']>;
  OutpostHealth: ResolverTypeWrapper<OutpostHealth>;
  OutpostsInstancesUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['OutpostsInstancesUsedByListResponse']>;
  OutpostsInstancesDefaultSettingsRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['OutpostsInstancesDefaultSettingsRetrieveResponse']>;
  OutpostDefaultConfig: ResolverTypeWrapper<OutpostDefaultConfig>;
  OutpostsLdapListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['OutpostsLdapListResponse']>;
  PaginatedLdapOutpostConfigList: ResolverTypeWrapper<PaginatedLdapOutpostConfigList>;
  LdapOutpostConfig: ResolverTypeWrapper<LdapOutpostConfig>;
  LdapapiAccessMode: LdapapiAccessMode;
  OutpostsLdapRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['OutpostsLdapRetrieveResponse']>;
  OutpostsProxyListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['OutpostsProxyListResponse']>;
  PaginatedProxyOutpostConfigList: ResolverTypeWrapper<PaginatedProxyOutpostConfigList>;
  ProxyOutpostConfig: ResolverTypeWrapper<ProxyOutpostConfig>;
  QueryOutpostsProxyListOneOf_0ResultsItemsClientId: ResolverTypeWrapper<Scalars['QueryOutpostsProxyListOneOf_0ResultsItemsClientId']['output']>;
  QueryOutpostsProxyListOneOf_0ResultsItemsClientSecret: ResolverTypeWrapper<Scalars['QueryOutpostsProxyListOneOf_0ResultsItemsClientSecret']['output']>;
  OpenIdConnectConfiguration: ResolverTypeWrapper<OpenIdConnectConfiguration>;
  ProxyMode: ProxyMode;
  OutpostsProxyRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['OutpostsProxyRetrieveResponse']>;
  OutpostsRadiusListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['OutpostsRadiusListResponse']>;
  PaginatedRadiusOutpostConfigList: ResolverTypeWrapper<PaginatedRadiusOutpostConfigList>;
  RadiusOutpostConfig: ResolverTypeWrapper<RadiusOutpostConfig>;
  OutpostsRadiusRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['OutpostsRadiusRetrieveResponse']>;
  OutpostsServiceConnectionsAllListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['OutpostsServiceConnectionsAllListResponse']>;
  PaginatedServiceConnectionList: ResolverTypeWrapper<PaginatedServiceConnectionList>;
  OutpostsServiceConnectionsAllRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['OutpostsServiceConnectionsAllRetrieveResponse']>;
  OutpostsServiceConnectionsAllStateRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['OutpostsServiceConnectionsAllStateRetrieveResponse']>;
  ServiceConnectionState: ResolverTypeWrapper<ServiceConnectionState>;
  OutpostsServiceConnectionsAllUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['OutpostsServiceConnectionsAllUsedByListResponse']>;
  OutpostsServiceConnectionsAllTypesListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['OutpostsServiceConnectionsAllTypesListResponse']>;
  OutpostsServiceConnectionsDockerListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['OutpostsServiceConnectionsDockerListResponse']>;
  PaginatedDockerServiceConnectionList: ResolverTypeWrapper<PaginatedDockerServiceConnectionList>;
  DockerServiceConnection: ResolverTypeWrapper<DockerServiceConnection>;
  OutpostsServiceConnectionsDockerRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['OutpostsServiceConnectionsDockerRetrieveResponse']>;
  OutpostsServiceConnectionsDockerUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['OutpostsServiceConnectionsDockerUsedByListResponse']>;
  OutpostsServiceConnectionsKubernetesListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['OutpostsServiceConnectionsKubernetesListResponse']>;
  PaginatedKubernetesServiceConnectionList: ResolverTypeWrapper<PaginatedKubernetesServiceConnectionList>;
  KubernetesServiceConnection: ResolverTypeWrapper<KubernetesServiceConnection>;
  OutpostsServiceConnectionsKubernetesRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['OutpostsServiceConnectionsKubernetesRetrieveResponse']>;
  OutpostsServiceConnectionsKubernetesUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['OutpostsServiceConnectionsKubernetesUsedByListResponse']>;
  PoliciesAllListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesAllListResponse']>;
  PaginatedPolicyList: ResolverTypeWrapper<PaginatedPolicyList>;
  Policy: ResolverTypeWrapper<Policy>;
  PoliciesAllRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesAllRetrieveResponse']>;
  PoliciesAllUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesAllUsedByListResponse']>;
  PoliciesAllCacheInfoRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesAllCacheInfoRetrieveResponse']>;
  PoliciesAllTypesListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesAllTypesListResponse']>;
  PoliciesBindingsListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesBindingsListResponse']>;
  PaginatedPolicyBindingList: ResolverTypeWrapper<PaginatedPolicyBindingList>;
  PolicyBinding: ResolverTypeWrapper<PolicyBinding>;
  NonNegativeInt: ResolverTypeWrapper<Scalars['NonNegativeInt']['output']>;
  PoliciesBindingsRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesBindingsRetrieveResponse']>;
  PoliciesBindingsUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesBindingsUsedByListResponse']>;
  PoliciesDummyListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesDummyListResponse']>;
  PaginatedDummyPolicyList: ResolverTypeWrapper<PaginatedDummyPolicyList>;
  DummyPolicy: ResolverTypeWrapper<DummyPolicy>;
  PoliciesDummyRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesDummyRetrieveResponse']>;
  PoliciesDummyUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesDummyUsedByListResponse']>;
  PoliciesEventMatcherListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesEventMatcherListResponse']>;
  PaginatedEventMatcherPolicyList: ResolverTypeWrapper<PaginatedEventMatcherPolicyList>;
  EventMatcherPolicy: ResolverTypeWrapper<EventMatcherPolicy>;
  AppEnum: AppEnum;
  ModelEnum: ModelEnum;
  QueryInputPoliciesEventMatcherListAction: QueryInputPoliciesEventMatcherListAction;
  PoliciesEventMatcherRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesEventMatcherRetrieveResponse']>;
  PoliciesEventMatcherUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesEventMatcherUsedByListResponse']>;
  PoliciesExpressionListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesExpressionListResponse']>;
  PaginatedExpressionPolicyList: ResolverTypeWrapper<PaginatedExpressionPolicyList>;
  ExpressionPolicy: ResolverTypeWrapper<ExpressionPolicy>;
  PoliciesExpressionRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesExpressionRetrieveResponse']>;
  PoliciesExpressionUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesExpressionUsedByListResponse']>;
  PoliciesPasswordListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesPasswordListResponse']>;
  PaginatedPasswordPolicyList: ResolverTypeWrapper<PaginatedPasswordPolicyList>;
  PasswordPolicy: ResolverTypeWrapper<PasswordPolicy>;
  PoliciesPasswordRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesPasswordRetrieveResponse']>;
  PoliciesPasswordUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesPasswordUsedByListResponse']>;
  PoliciesPasswordExpiryListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesPasswordExpiryListResponse']>;
  PaginatedPasswordExpiryPolicyList: ResolverTypeWrapper<PaginatedPasswordExpiryPolicyList>;
  PasswordExpiryPolicy: ResolverTypeWrapper<PasswordExpiryPolicy>;
  PoliciesPasswordExpiryRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesPasswordExpiryRetrieveResponse']>;
  PoliciesPasswordExpiryUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesPasswordExpiryUsedByListResponse']>;
  PoliciesReputationListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesReputationListResponse']>;
  PaginatedReputationPolicyList: ResolverTypeWrapper<PaginatedReputationPolicyList>;
  ReputationPolicy: ResolverTypeWrapper<ReputationPolicy>;
  PoliciesReputationRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesReputationRetrieveResponse']>;
  PoliciesReputationUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesReputationUsedByListResponse']>;
  PoliciesReputationScoresListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesReputationScoresListResponse']>;
  PaginatedReputationList: ResolverTypeWrapper<PaginatedReputationList>;
  Reputation: ResolverTypeWrapper<Reputation>;
  BigInt: ResolverTypeWrapper<Scalars['BigInt']['output']>;
  PoliciesReputationScoresRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesReputationScoresRetrieveResponse']>;
  PoliciesReputationScoresUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesReputationScoresUsedByListResponse']>;
  PropertymappingsAllListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsAllListResponse']>;
  PaginatedPropertyMappingList: ResolverTypeWrapper<PaginatedPropertyMappingList>;
  PropertyMapping: ResolverTypeWrapper<PropertyMapping>;
  PropertymappingsAllRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsAllRetrieveResponse']>;
  PropertymappingsAllUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsAllUsedByListResponse']>;
  PropertymappingsAllTypesListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsAllTypesListResponse']>;
  PropertymappingsLdapListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsLdapListResponse']>;
  PaginatedLdapPropertyMappingList: ResolverTypeWrapper<PaginatedLdapPropertyMappingList>;
  LdapPropertyMapping: ResolverTypeWrapper<LdapPropertyMapping>;
  PropertymappingsLdapRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsLdapRetrieveResponse']>;
  PropertymappingsLdapUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsLdapUsedByListResponse']>;
  PropertymappingsNotificationListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsNotificationListResponse']>;
  PaginatedNotificationWebhookMappingList: ResolverTypeWrapper<PaginatedNotificationWebhookMappingList>;
  NotificationWebhookMapping: ResolverTypeWrapper<NotificationWebhookMapping>;
  PropertymappingsNotificationRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsNotificationRetrieveResponse']>;
  PropertymappingsNotificationUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsNotificationUsedByListResponse']>;
  PropertymappingsRacListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsRacListResponse']>;
  PaginatedRacPropertyMappingList: ResolverTypeWrapper<PaginatedRacPropertyMappingList>;
  RacPropertyMapping: ResolverTypeWrapper<RacPropertyMapping>;
  PropertymappingsRacRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsRacRetrieveResponse']>;
  PropertymappingsRacUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsRacUsedByListResponse']>;
  PropertymappingsSamlListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsSamlListResponse']>;
  PaginatedSamlPropertyMappingList: ResolverTypeWrapper<PaginatedSamlPropertyMappingList>;
  SamlPropertyMapping: ResolverTypeWrapper<SamlPropertyMapping>;
  PropertymappingsSamlRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsSamlRetrieveResponse']>;
  PropertymappingsSamlUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsSamlUsedByListResponse']>;
  PropertymappingsScimListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsScimListResponse']>;
  PaginatedScimMappingList: ResolverTypeWrapper<PaginatedScimMappingList>;
  ScimMapping: ResolverTypeWrapper<ScimMapping>;
  PropertymappingsScimRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsScimRetrieveResponse']>;
  PropertymappingsScimUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsScimUsedByListResponse']>;
  PropertymappingsScopeListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsScopeListResponse']>;
  PaginatedScopeMappingList: ResolverTypeWrapper<PaginatedScopeMappingList>;
  ScopeMapping: ResolverTypeWrapper<ScopeMapping>;
  PropertymappingsScopeRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsScopeRetrieveResponse']>;
  PropertymappingsScopeUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsScopeUsedByListResponse']>;
  ProvidersAllListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersAllListResponse']>;
  PaginatedProviderList: ResolverTypeWrapper<Omit<PaginatedProviderList, 'results'> & { results: Array<Maybe<ResolversTypes['Provider']>> }>;
  ProvidersAllRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersAllRetrieveResponse']>;
  ProvidersAllUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersAllUsedByListResponse']>;
  ProvidersAllTypesListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersAllTypesListResponse']>;
  ProvidersLdapListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersLdapListResponse']>;
  PaginatedLdapProviderList: ResolverTypeWrapper<PaginatedLdapProviderList>;
  LdapProvider: ResolverTypeWrapper<LdapProvider>;
  ProvidersLdapRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersLdapRetrieveResponse']>;
  ProvidersLdapUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersLdapUsedByListResponse']>;
  ProvidersOauth2ListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersOauth2ListResponse']>;
  PaginatedOAuth2ProviderList: ResolverTypeWrapper<PaginatedOAuth2ProviderList>;
  QueryInputProvidersOauth2ListClientType: QueryInputProvidersOauth2ListClientType;
  QueryInputProvidersOauth2ListIssuerMode: QueryInputProvidersOauth2ListIssuerMode;
  QueryInputProvidersOauth2ListSubMode: QueryInputProvidersOauth2ListSubMode;
  ProvidersOauth2RetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersOauth2RetrieveResponse']>;
  ProvidersOauth2PreviewUserRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersOauth2PreviewUserRetrieveResponse']>;
  PropertyMappingPreview: ResolverTypeWrapper<PropertyMappingPreview>;
  ProvidersOauth2SetupUrlsRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersOauth2SetupUrlsRetrieveResponse']>;
  OAuth2ProviderSetupUrLs: ResolverTypeWrapper<OAuth2ProviderSetupUrLs>;
  ProvidersOauth2UsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersOauth2UsedByListResponse']>;
  ProvidersProxyListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersProxyListResponse']>;
  PaginatedProxyProviderList: ResolverTypeWrapper<PaginatedProxyProviderList>;
  ProxyProvider: ResolverTypeWrapper<ProxyProvider>;
  ProvidersProxyRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersProxyRetrieveResponse']>;
  ProvidersProxyUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersProxyUsedByListResponse']>;
  ProvidersRacListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersRacListResponse']>;
  PaginatedRacProviderList: ResolverTypeWrapper<PaginatedRacProviderList>;
  RacProvider: ResolverTypeWrapper<RacProvider>;
  ProvidersRacRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersRacRetrieveResponse']>;
  ProvidersRacUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersRacUsedByListResponse']>;
  ProvidersRadiusListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersRadiusListResponse']>;
  PaginatedRadiusProviderList: ResolverTypeWrapper<PaginatedRadiusProviderList>;
  RadiusProvider: ResolverTypeWrapper<RadiusProvider>;
  ProvidersRadiusRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersRadiusRetrieveResponse']>;
  ProvidersRadiusUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersRadiusUsedByListResponse']>;
  ProvidersSamlListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersSamlListResponse']>;
  PaginatedSamlProviderList: ResolverTypeWrapper<PaginatedSamlProviderList>;
  SamlProvider: ResolverTypeWrapper<SamlProvider>;
  DigestAlgorithmEnum: DigestAlgorithmEnum;
  SignatureAlgorithmEnum: SignatureAlgorithmEnum;
  ServiceProviderBinding: ResolverTypeWrapper<ServiceProviderBinding>;
  SpBindingEnum: SpBindingEnum;
  QueryInputProvidersSamlListDigestAlgorithm: QueryInputProvidersSamlListDigestAlgorithm;
  QueryInputProvidersSamlListSignatureAlgorithm: QueryInputProvidersSamlListSignatureAlgorithm;
  QueryInputProvidersSamlListSpBinding: QueryInputProvidersSamlListSpBinding;
  ProvidersSamlRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersSamlRetrieveResponse']>;
  ProvidersSamlMetadataRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersSamlMetadataRetrieveResponse']>;
  SamlMetadata: ResolverTypeWrapper<SamlMetadata>;
  QueryInputProvidersSamlMetadataRetrieveForceBinding: QueryInputProvidersSamlMetadataRetrieveForceBinding;
  ProvidersSamlPreviewUserRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersSamlPreviewUserRetrieveResponse']>;
  ProvidersSamlUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersSamlUsedByListResponse']>;
  ProvidersScimListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersScimListResponse']>;
  PaginatedScimProviderList: ResolverTypeWrapper<PaginatedScimProviderList>;
  ScimProvider: ResolverTypeWrapper<ScimProvider>;
  ProvidersScimRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersScimRetrieveResponse']>;
  ProvidersScimSyncStatusRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersScimSyncStatusRetrieveResponse']>;
  ScimSyncStatus: ResolverTypeWrapper<ScimSyncStatus>;
  ProvidersScimUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersScimUsedByListResponse']>;
  RacConnectionTokensListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['RacConnectionTokensListResponse']>;
  PaginatedConnectionTokenList: ResolverTypeWrapper<PaginatedConnectionTokenList>;
  ConnectionToken: ResolverTypeWrapper<ConnectionToken>;
  Endpoint: ResolverTypeWrapper<Endpoint>;
  ProtocolEnum: ProtocolEnum;
  AuthModeEnum: AuthModeEnum;
  RacConnectionTokensRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['RacConnectionTokensRetrieveResponse']>;
  RacConnectionTokensUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['RacConnectionTokensUsedByListResponse']>;
  RacEndpointsListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['RacEndpointsListResponse']>;
  PaginatedEndpointList: ResolverTypeWrapper<PaginatedEndpointList>;
  RacEndpointsRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['RacEndpointsRetrieveResponse']>;
  RacEndpointsUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['RacEndpointsUsedByListResponse']>;
  RbacPermissionsListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['RbacPermissionsListResponse']>;
  PaginatedPermissionList: ResolverTypeWrapper<PaginatedPermissionList>;
  Permission: ResolverTypeWrapper<Permission>;
  QueryRbacPermissionsListOneOf_0ResultsItemsName: ResolverTypeWrapper<Scalars['QueryRbacPermissionsListOneOf_0ResultsItemsName']['output']>;
  QueryRbacPermissionsListOneOf_0ResultsItemsCodename: ResolverTypeWrapper<Scalars['QueryRbacPermissionsListOneOf_0ResultsItemsCodename']['output']>;
  RbacPermissionsRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['RbacPermissionsRetrieveResponse']>;
  RbacPermissionsAssignedByRolesListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['RbacPermissionsAssignedByRolesListResponse']>;
  PaginatedRoleAssignedObjectPermissionList: ResolverTypeWrapper<PaginatedRoleAssignedObjectPermissionList>;
  RoleAssignedObjectPermission: ResolverTypeWrapper<RoleAssignedObjectPermission>;
  RoleObjectPermission: ResolverTypeWrapper<RoleObjectPermission>;
  QueryInputRbacPermissionsAssignedByRolesListModel: QueryInputRbacPermissionsAssignedByRolesListModel;
  RbacPermissionsAssignedByUsersListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['RbacPermissionsAssignedByUsersListResponse']>;
  PaginatedUserAssignedObjectPermissionList: ResolverTypeWrapper<PaginatedUserAssignedObjectPermissionList>;
  UserAssignedObjectPermission: ResolverTypeWrapper<UserAssignedObjectPermission>;
  QueryRbacPermissionsAssignedByUsersListOneOf_0ResultsItemsUsername: ResolverTypeWrapper<Scalars['QueryRbacPermissionsAssignedByUsersListOneOf_0ResultsItemsUsername']['output']>;
  UserObjectPermission: ResolverTypeWrapper<UserObjectPermission>;
  QueryInputRbacPermissionsAssignedByUsersListModel: QueryInputRbacPermissionsAssignedByUsersListModel;
  RbacPermissionsRolesListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['RbacPermissionsRolesListResponse']>;
  PaginatedExtraRoleObjectPermissionList: ResolverTypeWrapper<PaginatedExtraRoleObjectPermissionList>;
  ExtraRoleObjectPermission: ResolverTypeWrapper<ExtraRoleObjectPermission>;
  RbacPermissionsUsersListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['RbacPermissionsUsersListResponse']>;
  PaginatedExtraUserObjectPermissionList: ResolverTypeWrapper<PaginatedExtraUserObjectPermissionList>;
  ExtraUserObjectPermission: ResolverTypeWrapper<ExtraUserObjectPermission>;
  RbacRolesListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['RbacRolesListResponse']>;
  PaginatedRoleList: ResolverTypeWrapper<PaginatedRoleList>;
  RbacRolesRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['RbacRolesRetrieveResponse']>;
  RbacRolesUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['RbacRolesUsedByListResponse']>;
  RootConfigRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['RootConfigRetrieveResponse']>;
  Config: ResolverTypeWrapper<Config>;
  ErrorReportingConfig: ResolverTypeWrapper<ErrorReportingConfig>;
  CapabilitiesEnum: CapabilitiesEnum;
  SchemaRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SchemaRetrieveResponse']>;
  JsonContainer: ResolverTypeWrapper<JsonContainer>;
  QueryInputSchemaRetrieveFormat: QueryInputSchemaRetrieveFormat;
  QueryInputSchemaRetrieveLang: QueryInputSchemaRetrieveLang;
  SourcesAllListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesAllListResponse']>;
  PaginatedSourceList: ResolverTypeWrapper<PaginatedSourceList>;
  Source: ResolverTypeWrapper<Source>;
  QuerySourcesAllListOneOf_0ResultsItemsSlug: ResolverTypeWrapper<Scalars['QuerySourcesAllListOneOf_0ResultsItemsSlug']['output']>;
  UserMatchingModeEnum: UserMatchingModeEnum;
  SourcesAllRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesAllRetrieveResponse']>;
  SourcesAllUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesAllUsedByListResponse']>;
  SourcesAllTypesListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesAllTypesListResponse']>;
  SourcesAllUserSettingsListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesAllUserSettingsListResponse']>;
  UserSetting: ResolverTypeWrapper<UserSetting>;
  SourcesLdapListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesLdapListResponse']>;
  PaginatedLdapSourceList: ResolverTypeWrapper<PaginatedLdapSourceList>;
  LdapSource: ResolverTypeWrapper<LdapSource>;
  QuerySourcesLdapListOneOf_0ResultsItemsSlug: ResolverTypeWrapper<Scalars['QuerySourcesLdapListOneOf_0ResultsItemsSlug']['output']>;
  SourcesLdapRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesLdapRetrieveResponse']>;
  SourcesLdapDebugRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesLdapDebugRetrieveResponse']>;
  LdapDebug: ResolverTypeWrapper<LdapDebug>;
  SourcesLdapSyncStatusRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesLdapSyncStatusRetrieveResponse']>;
  LdapSyncStatus: ResolverTypeWrapper<LdapSyncStatus>;
  SourcesLdapUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesLdapUsedByListResponse']>;
  SourcesOauthListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesOauthListResponse']>;
  PaginatedOAuthSourceList: ResolverTypeWrapper<PaginatedOAuthSourceList>;
  OAuthSource: ResolverTypeWrapper<OAuthSource>;
  QuerySourcesOauthListOneOf_0ResultsItemsSlug: ResolverTypeWrapper<Scalars['QuerySourcesOauthListOneOf_0ResultsItemsSlug']['output']>;
  ProviderTypeEnum: ProviderTypeEnum;
  QuerySourcesOauthListOneOf_0ResultsItemsRequestTokenUrl: ResolverTypeWrapper<Scalars['QuerySourcesOauthListOneOf_0ResultsItemsRequestTokenUrl']['output']>;
  QuerySourcesOauthListOneOf_0ResultsItemsAuthorizationUrl: ResolverTypeWrapper<Scalars['QuerySourcesOauthListOneOf_0ResultsItemsAuthorizationUrl']['output']>;
  QuerySourcesOauthListOneOf_0ResultsItemsAccessTokenUrl: ResolverTypeWrapper<Scalars['QuerySourcesOauthListOneOf_0ResultsItemsAccessTokenUrl']['output']>;
  QuerySourcesOauthListOneOf_0ResultsItemsProfileUrl: ResolverTypeWrapper<Scalars['QuerySourcesOauthListOneOf_0ResultsItemsProfileUrl']['output']>;
  SourceType: ResolverTypeWrapper<SourceType>;
  QueryInputSourcesOauthListPolicyEngineMode: QueryInputSourcesOauthListPolicyEngineMode;
  QueryInputSourcesOauthListUserMatchingMode: QueryInputSourcesOauthListUserMatchingMode;
  SourcesOauthRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesOauthRetrieveResponse']>;
  SourcesOauthUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesOauthUsedByListResponse']>;
  SourcesOauthSourceTypesListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesOauthSourceTypesListResponse']>;
  SourcesPlexListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesPlexListResponse']>;
  PaginatedPlexSourceList: ResolverTypeWrapper<PaginatedPlexSourceList>;
  PlexSource: ResolverTypeWrapper<PlexSource>;
  QuerySourcesPlexListOneOf_0ResultsItemsSlug: ResolverTypeWrapper<Scalars['QuerySourcesPlexListOneOf_0ResultsItemsSlug']['output']>;
  QueryInputSourcesPlexListPolicyEngineMode: QueryInputSourcesPlexListPolicyEngineMode;
  QueryInputSourcesPlexListUserMatchingMode: QueryInputSourcesPlexListUserMatchingMode;
  SourcesPlexRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesPlexRetrieveResponse']>;
  SourcesPlexUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesPlexUsedByListResponse']>;
  SourcesSamlListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesSamlListResponse']>;
  PaginatedSamlSourceList: ResolverTypeWrapper<PaginatedSamlSourceList>;
  SamlSource: ResolverTypeWrapper<SamlSource>;
  QuerySourcesSamlListOneOf_0ResultsItemsSlug: ResolverTypeWrapper<Scalars['QuerySourcesSamlListOneOf_0ResultsItemsSlug']['output']>;
  NameIdPolicyEnum: NameIdPolicyEnum;
  BindingTypeEnum: BindingTypeEnum;
  QueryInputSourcesSamlListBindingType: QueryInputSourcesSamlListBindingType;
  QueryInputSourcesSamlListDigestAlgorithm: QueryInputSourcesSamlListDigestAlgorithm;
  QueryInputSourcesSamlListNameIdPolicy: QueryInputSourcesSamlListNameIdPolicy;
  QueryInputSourcesSamlListPolicyEngineMode: QueryInputSourcesSamlListPolicyEngineMode;
  QueryInputSourcesSamlListSignatureAlgorithm: QueryInputSourcesSamlListSignatureAlgorithm;
  QueryInputSourcesSamlListUserMatchingMode: QueryInputSourcesSamlListUserMatchingMode;
  SourcesSamlRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesSamlRetrieveResponse']>;
  SourcesSamlMetadataRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesSamlMetadataRetrieveResponse']>;
  SourcesSamlUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesSamlUsedByListResponse']>;
  SourcesScimListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesScimListResponse']>;
  PaginatedScimSourceList: ResolverTypeWrapper<PaginatedScimSourceList>;
  ScimSource: ResolverTypeWrapper<ScimSource>;
  QuerySourcesScimListOneOf_0ResultsItemsSlug: ResolverTypeWrapper<Scalars['QuerySourcesScimListOneOf_0ResultsItemsSlug']['output']>;
  SourcesScimRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesScimRetrieveResponse']>;
  SourcesScimUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesScimUsedByListResponse']>;
  SourcesScimGroupsListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesScimGroupsListResponse']>;
  PaginatedScimSourceGroupList: ResolverTypeWrapper<PaginatedScimSourceGroupList>;
  ScimSourceGroup: ResolverTypeWrapper<ScimSourceGroup>;
  SourcesScimGroupsRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesScimGroupsRetrieveResponse']>;
  SourcesScimGroupsUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesScimGroupsUsedByListResponse']>;
  SourcesScimUsersListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesScimUsersListResponse']>;
  PaginatedScimSourceUserList: ResolverTypeWrapper<PaginatedScimSourceUserList>;
  ScimSourceUser: ResolverTypeWrapper<ScimSourceUser>;
  SourcesScimUsersRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesScimUsersRetrieveResponse']>;
  SourcesScimUsersUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesScimUsersUsedByListResponse']>;
  SourcesUserConnectionsAllListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesUserConnectionsAllListResponse']>;
  PaginatedUserSourceConnectionList: ResolverTypeWrapper<PaginatedUserSourceConnectionList>;
  UserSourceConnection: ResolverTypeWrapper<UserSourceConnection>;
  SourcesUserConnectionsAllRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesUserConnectionsAllRetrieveResponse']>;
  SourcesUserConnectionsAllUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesUserConnectionsAllUsedByListResponse']>;
  SourcesUserConnectionsOauthListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesUserConnectionsOauthListResponse']>;
  PaginatedUserOAuthSourceConnectionList: ResolverTypeWrapper<PaginatedUserOAuthSourceConnectionList>;
  UserOAuthSourceConnection: ResolverTypeWrapper<UserOAuthSourceConnection>;
  QuerySourcesUserConnectionsOauthListOneOf_0ResultsItemsIdentifier: ResolverTypeWrapper<Scalars['QuerySourcesUserConnectionsOauthListOneOf_0ResultsItemsIdentifier']['output']>;
  SourcesUserConnectionsOauthRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesUserConnectionsOauthRetrieveResponse']>;
  SourcesUserConnectionsOauthUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesUserConnectionsOauthUsedByListResponse']>;
  SourcesUserConnectionsPlexListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesUserConnectionsPlexListResponse']>;
  PaginatedPlexSourceConnectionList: ResolverTypeWrapper<PaginatedPlexSourceConnectionList>;
  PlexSourceConnection: ResolverTypeWrapper<PlexSourceConnection>;
  SourcesUserConnectionsPlexRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesUserConnectionsPlexRetrieveResponse']>;
  SourcesUserConnectionsPlexUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesUserConnectionsPlexUsedByListResponse']>;
  SourcesUserConnectionsSamlListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesUserConnectionsSamlListResponse']>;
  PaginatedUserSamlSourceConnectionList: ResolverTypeWrapper<PaginatedUserSamlSourceConnectionList>;
  UserSamlSourceConnection: ResolverTypeWrapper<UserSamlSourceConnection>;
  SourcesUserConnectionsSamlRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesUserConnectionsSamlRetrieveResponse']>;
  SourcesUserConnectionsSamlUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesUserConnectionsSamlUsedByListResponse']>;
  StagesAllListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAllListResponse']>;
  PaginatedStageList: ResolverTypeWrapper<PaginatedStageList>;
  StagesAllRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAllRetrieveResponse']>;
  StagesAllUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAllUsedByListResponse']>;
  StagesAllTypesListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAllTypesListResponse']>;
  StagesAllUserSettingsListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAllUserSettingsListResponse']>;
  StagesAuthenticatorDuoListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorDuoListResponse']>;
  PaginatedAuthenticatorDuoStageList: ResolverTypeWrapper<PaginatedAuthenticatorDuoStageList>;
  AuthenticatorDuoStage: ResolverTypeWrapper<AuthenticatorDuoStage>;
  StagesAuthenticatorDuoRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorDuoRetrieveResponse']>;
  StagesAuthenticatorDuoUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorDuoUsedByListResponse']>;
  StagesAuthenticatorSmsListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorSmsListResponse']>;
  PaginatedAuthenticatorSmsStageList: ResolverTypeWrapper<PaginatedAuthenticatorSmsStageList>;
  AuthenticatorSmsStage: ResolverTypeWrapper<AuthenticatorSmsStage>;
  ProviderEnum: ProviderEnum;
  AuthTypeEnum: AuthTypeEnum;
  QueryInputStagesAuthenticatorSmsListAuthType: QueryInputStagesAuthenticatorSmsListAuthType;
  QueryInputStagesAuthenticatorSmsListProvider: QueryInputStagesAuthenticatorSmsListProvider;
  StagesAuthenticatorSmsRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorSmsRetrieveResponse']>;
  StagesAuthenticatorSmsUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorSmsUsedByListResponse']>;
  StagesAuthenticatorStaticListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorStaticListResponse']>;
  PaginatedAuthenticatorStaticStageList: ResolverTypeWrapper<PaginatedAuthenticatorStaticStageList>;
  AuthenticatorStaticStage: ResolverTypeWrapper<AuthenticatorStaticStage>;
  StagesAuthenticatorStaticRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorStaticRetrieveResponse']>;
  StagesAuthenticatorStaticUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorStaticUsedByListResponse']>;
  StagesAuthenticatorTotpListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorTotpListResponse']>;
  PaginatedAuthenticatorTotpStageList: ResolverTypeWrapper<PaginatedAuthenticatorTotpStageList>;
  AuthenticatorTotpStage: ResolverTypeWrapper<AuthenticatorTotpStage>;
  DigitsEnum: DigitsEnum;
  QueryInputStagesAuthenticatorTotpListDigits: QueryInputStagesAuthenticatorTotpListDigits;
  StagesAuthenticatorTotpRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorTotpRetrieveResponse']>;
  StagesAuthenticatorTotpUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorTotpUsedByListResponse']>;
  StagesAuthenticatorValidateListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorValidateListResponse']>;
  PaginatedAuthenticatorValidateStageList: ResolverTypeWrapper<PaginatedAuthenticatorValidateStageList>;
  AuthenticatorValidateStage: ResolverTypeWrapper<AuthenticatorValidateStage>;
  NotConfiguredActionEnum: NotConfiguredActionEnum;
  DeviceClassesEnum: DeviceClassesEnum;
  UserVerificationEnum: UserVerificationEnum;
  QueryInputStagesAuthenticatorValidateListNotConfiguredAction: QueryInputStagesAuthenticatorValidateListNotConfiguredAction;
  StagesAuthenticatorValidateRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorValidateRetrieveResponse']>;
  StagesAuthenticatorValidateUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorValidateUsedByListResponse']>;
  StagesAuthenticatorWebauthnListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorWebauthnListResponse']>;
  PaginatedAuthenticatorWebAuthnStageList: ResolverTypeWrapper<PaginatedAuthenticatorWebAuthnStageList>;
  AuthenticatorWebAuthnStage: ResolverTypeWrapper<AuthenticatorWebAuthnStage>;
  AuthenticatorAttachmentEnum: AuthenticatorAttachmentEnum;
  ResidentKeyRequirementEnum: ResidentKeyRequirementEnum;
  QueryInputStagesAuthenticatorWebauthnListAuthenticatorAttachment: QueryInputStagesAuthenticatorWebauthnListAuthenticatorAttachment;
  QueryInputStagesAuthenticatorWebauthnListResidentKeyRequirement: QueryInputStagesAuthenticatorWebauthnListResidentKeyRequirement;
  QueryInputStagesAuthenticatorWebauthnListUserVerification: QueryInputStagesAuthenticatorWebauthnListUserVerification;
  StagesAuthenticatorWebauthnRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorWebauthnRetrieveResponse']>;
  StagesAuthenticatorWebauthnUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorWebauthnUsedByListResponse']>;
  StagesAuthenticatorWebauthnDeviceTypesListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorWebauthnDeviceTypesListResponse']>;
  PaginatedWebAuthnDeviceTypeList: ResolverTypeWrapper<PaginatedWebAuthnDeviceTypeList>;
  StagesAuthenticatorWebauthnDeviceTypesRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorWebauthnDeviceTypesRetrieveResponse']>;
  StagesCaptchaListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesCaptchaListResponse']>;
  PaginatedCaptchaStageList: ResolverTypeWrapper<PaginatedCaptchaStageList>;
  CaptchaStage: ResolverTypeWrapper<CaptchaStage>;
  StagesCaptchaRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesCaptchaRetrieveResponse']>;
  StagesCaptchaUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesCaptchaUsedByListResponse']>;
  StagesConsentListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesConsentListResponse']>;
  PaginatedConsentStageList: ResolverTypeWrapper<PaginatedConsentStageList>;
  ConsentStage: ResolverTypeWrapper<ConsentStage>;
  ConsentStageModeEnum: ConsentStageModeEnum;
  QueryInputStagesConsentListMode: QueryInputStagesConsentListMode;
  StagesConsentRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesConsentRetrieveResponse']>;
  StagesConsentUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesConsentUsedByListResponse']>;
  StagesDenyListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesDenyListResponse']>;
  PaginatedDenyStageList: ResolverTypeWrapper<PaginatedDenyStageList>;
  DenyStage: ResolverTypeWrapper<DenyStage>;
  StagesDenyRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesDenyRetrieveResponse']>;
  StagesDenyUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesDenyUsedByListResponse']>;
  StagesDummyListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesDummyListResponse']>;
  PaginatedDummyStageList: ResolverTypeWrapper<PaginatedDummyStageList>;
  DummyStage: ResolverTypeWrapper<DummyStage>;
  StagesDummyRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesDummyRetrieveResponse']>;
  StagesDummyUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesDummyUsedByListResponse']>;
  StagesEmailListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesEmailListResponse']>;
  PaginatedEmailStageList: ResolverTypeWrapper<PaginatedEmailStageList>;
  EmailStage: ResolverTypeWrapper<EmailStage>;
  StagesEmailRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesEmailRetrieveResponse']>;
  StagesEmailUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesEmailUsedByListResponse']>;
  StagesEmailTemplatesListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesEmailTemplatesListResponse']>;
  StagesIdentificationListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesIdentificationListResponse']>;
  PaginatedIdentificationStageList: ResolverTypeWrapper<PaginatedIdentificationStageList>;
  IdentificationStage: ResolverTypeWrapper<IdentificationStage>;
  UserFieldsEnum: UserFieldsEnum;
  StagesIdentificationRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesIdentificationRetrieveResponse']>;
  StagesIdentificationUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesIdentificationUsedByListResponse']>;
  StagesInvitationInvitationsListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesInvitationInvitationsListResponse']>;
  PaginatedInvitationList: ResolverTypeWrapper<PaginatedInvitationList>;
  Invitation: ResolverTypeWrapper<Invitation>;
  QueryStagesInvitationInvitationsListOneOf_0ResultsItemsName: ResolverTypeWrapper<Scalars['QueryStagesInvitationInvitationsListOneOf_0ResultsItemsName']['output']>;
  StagesInvitationInvitationsRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesInvitationInvitationsRetrieveResponse']>;
  StagesInvitationInvitationsUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesInvitationInvitationsUsedByListResponse']>;
  StagesInvitationStagesListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesInvitationStagesListResponse']>;
  PaginatedInvitationStageList: ResolverTypeWrapper<PaginatedInvitationStageList>;
  InvitationStage: ResolverTypeWrapper<InvitationStage>;
  StagesInvitationStagesRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesInvitationStagesRetrieveResponse']>;
  StagesInvitationStagesUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesInvitationStagesUsedByListResponse']>;
  StagesPasswordListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesPasswordListResponse']>;
  PaginatedPasswordStageList: ResolverTypeWrapper<PaginatedPasswordStageList>;
  PasswordStage: ResolverTypeWrapper<PasswordStage>;
  BackendsEnum: BackendsEnum;
  StagesPasswordRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesPasswordRetrieveResponse']>;
  StagesPasswordUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesPasswordUsedByListResponse']>;
  StagesPromptPromptsListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesPromptPromptsListResponse']>;
  PaginatedPromptList: ResolverTypeWrapper<PaginatedPromptList>;
  Prompt: ResolverTypeWrapper<Prompt>;
  QueryInputStagesPromptPromptsListType: QueryInputStagesPromptPromptsListType;
  StagesPromptPromptsRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesPromptPromptsRetrieveResponse']>;
  StagesPromptPromptsUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesPromptPromptsUsedByListResponse']>;
  StagesPromptStagesListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesPromptStagesListResponse']>;
  PaginatedPromptStageList: ResolverTypeWrapper<PaginatedPromptStageList>;
  PromptStage: ResolverTypeWrapper<PromptStage>;
  StagesPromptStagesRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesPromptStagesRetrieveResponse']>;
  StagesPromptStagesUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesPromptStagesUsedByListResponse']>;
  StagesSourceListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesSourceListResponse']>;
  PaginatedSourceStageList: ResolverTypeWrapper<PaginatedSourceStageList>;
  SourceStage: ResolverTypeWrapper<SourceStage>;
  StagesSourceRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesSourceRetrieveResponse']>;
  StagesSourceUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesSourceUsedByListResponse']>;
  StagesUserDeleteListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesUserDeleteListResponse']>;
  PaginatedUserDeleteStageList: ResolverTypeWrapper<PaginatedUserDeleteStageList>;
  UserDeleteStage: ResolverTypeWrapper<UserDeleteStage>;
  StagesUserDeleteRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesUserDeleteRetrieveResponse']>;
  StagesUserDeleteUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesUserDeleteUsedByListResponse']>;
  StagesUserLoginListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesUserLoginListResponse']>;
  PaginatedUserLoginStageList: ResolverTypeWrapper<PaginatedUserLoginStageList>;
  UserLoginStage: ResolverTypeWrapper<UserLoginStage>;
  NetworkBindingEnum: NetworkBindingEnum;
  GeoipBindingEnum: GeoipBindingEnum;
  QueryInputStagesUserLoginListGeoipBinding: QueryInputStagesUserLoginListGeoipBinding;
  QueryInputStagesUserLoginListNetworkBinding: QueryInputStagesUserLoginListNetworkBinding;
  StagesUserLoginRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesUserLoginRetrieveResponse']>;
  StagesUserLoginUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesUserLoginUsedByListResponse']>;
  StagesUserLogoutListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesUserLogoutListResponse']>;
  PaginatedUserLogoutStageList: ResolverTypeWrapper<PaginatedUserLogoutStageList>;
  UserLogoutStage: ResolverTypeWrapper<UserLogoutStage>;
  StagesUserLogoutRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesUserLogoutRetrieveResponse']>;
  StagesUserLogoutUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesUserLogoutUsedByListResponse']>;
  StagesUserWriteListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesUserWriteListResponse']>;
  PaginatedUserWriteStageList: ResolverTypeWrapper<PaginatedUserWriteStageList>;
  UserWriteStage: ResolverTypeWrapper<UserWriteStage>;
  UserCreationModeEnum: UserCreationModeEnum;
  QueryInputStagesUserWriteListUserCreationMode: QueryInputStagesUserWriteListUserCreationMode;
  QueryInputStagesUserWriteListUserType: QueryInputStagesUserWriteListUserType;
  StagesUserWriteRetrieveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesUserWriteRetrieveResponse']>;
  StagesUserWriteUsedByListResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesUserWriteUsedByListResponse']>;
  AdminSettingsUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AdminSettingsUpdateResponse']>;
  SettingsRequestInput: SettingsRequestInput;
  NonEmptyString: ResolverTypeWrapper<Scalars['NonEmptyString']['output']>;
  AdminSettingsPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AdminSettingsPartialUpdateResponse']>;
  PatchedSettingsRequestInput: PatchedSettingsRequestInput;
  AdminSystemCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AdminSystemCreateResponse']>;
  AuthenticatorsAdminDuoCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsAdminDuoCreateResponse']>;
  DuoDeviceRequestInput: DuoDeviceRequestInput;
  MutationInputAuthenticatorsAdminDuoCreateInputName: ResolverTypeWrapper<Scalars['MutationInputAuthenticatorsAdminDuoCreateInputName']['output']>;
  AuthenticatorsAdminDuoUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsAdminDuoUpdateResponse']>;
  AuthenticatorsAdminDuoPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsAdminDuoPartialUpdateResponse']>;
  PatchedDuoDeviceRequestInput: PatchedDuoDeviceRequestInput;
  MutationInputAuthenticatorsAdminDuoPartialUpdateInputName: ResolverTypeWrapper<Scalars['MutationInputAuthenticatorsAdminDuoPartialUpdateInputName']['output']>;
  AuthenticatorsAdminDuoDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsAdminDuoDestroyResponse']>;
  AuthenticatorsAdminSmsCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsAdminSmsCreateResponse']>;
  SmsDeviceRequestInput: SmsDeviceRequestInput;
  MutationInputAuthenticatorsAdminSmsCreateInputName: ResolverTypeWrapper<Scalars['MutationInputAuthenticatorsAdminSmsCreateInputName']['output']>;
  AuthenticatorsAdminSmsUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsAdminSmsUpdateResponse']>;
  AuthenticatorsAdminSmsPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsAdminSmsPartialUpdateResponse']>;
  PatchedSmsDeviceRequestInput: PatchedSmsDeviceRequestInput;
  MutationInputAuthenticatorsAdminSmsPartialUpdateInputName: ResolverTypeWrapper<Scalars['MutationInputAuthenticatorsAdminSmsPartialUpdateInputName']['output']>;
  AuthenticatorsAdminSmsDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsAdminSmsDestroyResponse']>;
  AuthenticatorsAdminStaticCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsAdminStaticCreateResponse']>;
  StaticDeviceRequestInput: StaticDeviceRequestInput;
  MutationInputAuthenticatorsAdminStaticCreateInputName: ResolverTypeWrapper<Scalars['MutationInputAuthenticatorsAdminStaticCreateInputName']['output']>;
  AuthenticatorsAdminStaticUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsAdminStaticUpdateResponse']>;
  AuthenticatorsAdminStaticPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsAdminStaticPartialUpdateResponse']>;
  PatchedStaticDeviceRequestInput: PatchedStaticDeviceRequestInput;
  MutationInputAuthenticatorsAdminStaticPartialUpdateInputName: ResolverTypeWrapper<Scalars['MutationInputAuthenticatorsAdminStaticPartialUpdateInputName']['output']>;
  AuthenticatorsAdminStaticDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsAdminStaticDestroyResponse']>;
  AuthenticatorsAdminTotpCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsAdminTotpCreateResponse']>;
  TotpDeviceRequestInput: TotpDeviceRequestInput;
  MutationInputAuthenticatorsAdminTotpCreateInputName: ResolverTypeWrapper<Scalars['MutationInputAuthenticatorsAdminTotpCreateInputName']['output']>;
  AuthenticatorsAdminTotpUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsAdminTotpUpdateResponse']>;
  AuthenticatorsAdminTotpPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsAdminTotpPartialUpdateResponse']>;
  PatchedTotpDeviceRequestInput: PatchedTotpDeviceRequestInput;
  MutationInputAuthenticatorsAdminTotpPartialUpdateInputName: ResolverTypeWrapper<Scalars['MutationInputAuthenticatorsAdminTotpPartialUpdateInputName']['output']>;
  AuthenticatorsAdminTotpDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsAdminTotpDestroyResponse']>;
  AuthenticatorsAdminWebauthnCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsAdminWebauthnCreateResponse']>;
  WebAuthnDeviceRequestInput: WebAuthnDeviceRequestInput;
  MutationInputAuthenticatorsAdminWebauthnCreateInputName: ResolverTypeWrapper<Scalars['MutationInputAuthenticatorsAdminWebauthnCreateInputName']['output']>;
  AuthenticatorsAdminWebauthnUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsAdminWebauthnUpdateResponse']>;
  AuthenticatorsAdminWebauthnPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsAdminWebauthnPartialUpdateResponse']>;
  PatchedWebAuthnDeviceRequestInput: PatchedWebAuthnDeviceRequestInput;
  MutationInputAuthenticatorsAdminWebauthnPartialUpdateInputName: ResolverTypeWrapper<Scalars['MutationInputAuthenticatorsAdminWebauthnPartialUpdateInputName']['output']>;
  AuthenticatorsAdminWebauthnDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsAdminWebauthnDestroyResponse']>;
  AuthenticatorsDuoUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsDuoUpdateResponse']>;
  AuthenticatorsDuoPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsDuoPartialUpdateResponse']>;
  AuthenticatorsDuoDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsDuoDestroyResponse']>;
  AuthenticatorsSmsUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsSmsUpdateResponse']>;
  AuthenticatorsSmsPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsSmsPartialUpdateResponse']>;
  AuthenticatorsSmsDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsSmsDestroyResponse']>;
  AuthenticatorsStaticUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsStaticUpdateResponse']>;
  AuthenticatorsStaticPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsStaticPartialUpdateResponse']>;
  AuthenticatorsStaticDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsStaticDestroyResponse']>;
  AuthenticatorsTotpUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsTotpUpdateResponse']>;
  AuthenticatorsTotpPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsTotpPartialUpdateResponse']>;
  AuthenticatorsTotpDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsTotpDestroyResponse']>;
  AuthenticatorsWebauthnUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsWebauthnUpdateResponse']>;
  AuthenticatorsWebauthnPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsWebauthnPartialUpdateResponse']>;
  AuthenticatorsWebauthnDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuthenticatorsWebauthnDestroyResponse']>;
  CoreApplicationsCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreApplicationsCreateResponse']>;
  ApplicationRequestInput: ApplicationRequestInput;
  MutationInputCoreApplicationsCreateInputSlug: ResolverTypeWrapper<Scalars['MutationInputCoreApplicationsCreateInputSlug']['output']>;
  CoreApplicationsUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreApplicationsUpdateResponse']>;
  CoreApplicationsPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreApplicationsPartialUpdateResponse']>;
  PatchedApplicationRequestInput: PatchedApplicationRequestInput;
  MutationInputCoreApplicationsPartialUpdateInputSlug: ResolverTypeWrapper<Scalars['MutationInputCoreApplicationsPartialUpdateInputSlug']['output']>;
  CoreApplicationsDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreApplicationsDestroyResponse']>;
  FileUploadRequestInput: FileUploadRequestInput;
  FilePathRequestInput: FilePathRequestInput;
  CoreAuthenticatedSessionsDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreAuthenticatedSessionsDestroyResponse']>;
  CoreBrandsCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreBrandsCreateResponse']>;
  BrandRequestInput: BrandRequestInput;
  CoreBrandsUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreBrandsUpdateResponse']>;
  CoreBrandsPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreBrandsPartialUpdateResponse']>;
  PatchedBrandRequestInput: PatchedBrandRequestInput;
  CoreBrandsDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreBrandsDestroyResponse']>;
  CoreGroupsCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreGroupsCreateResponse']>;
  GroupRequestInput: GroupRequestInput;
  MutationInputCoreGroupsCreateInputName: ResolverTypeWrapper<Scalars['MutationInputCoreGroupsCreateInputName']['output']>;
  CoreGroupsUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreGroupsUpdateResponse']>;
  CoreGroupsPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreGroupsPartialUpdateResponse']>;
  PatchedGroupRequestInput: PatchedGroupRequestInput;
  MutationInputCoreGroupsPartialUpdateInputName: ResolverTypeWrapper<Scalars['MutationInputCoreGroupsPartialUpdateInputName']['output']>;
  CoreGroupsDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreGroupsDestroyResponse']>;
  CoreGroupsAddUserCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreGroupsAddUserCreateResponse']>;
  UserAccountRequestInput: UserAccountRequestInput;
  CoreGroupsRemoveUserCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreGroupsRemoveUserCreateResponse']>;
  CoreTokensCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreTokensCreateResponse']>;
  TokenRequestInput: TokenRequestInput;
  MutationInputCoreTokensCreateInputIdentifier: ResolverTypeWrapper<Scalars['MutationInputCoreTokensCreateInputIdentifier']['output']>;
  CoreTokensUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreTokensUpdateResponse']>;
  CoreTokensPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreTokensPartialUpdateResponse']>;
  PatchedTokenRequestInput: PatchedTokenRequestInput;
  MutationInputCoreTokensPartialUpdateInputIdentifier: ResolverTypeWrapper<Scalars['MutationInputCoreTokensPartialUpdateInputIdentifier']['output']>;
  CoreTokensDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreTokensDestroyResponse']>;
  CoreTokensSetKeyCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreTokensSetKeyCreateResponse']>;
  TokenSetKeyRequestInput: TokenSetKeyRequestInput;
  CoreTransactionalApplicationsUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreTransactionalApplicationsUpdateResponse']>;
  TransactionApplicationResponse: ResolverTypeWrapper<TransactionApplicationResponse>;
  TransactionApplicationRequestInput: TransactionApplicationRequestInput;
  ProviderModelEnum: ProviderModelEnum;
  ModelRequestInput: ModelRequestInput;
  LdapProviderRequestInput: LdapProviderRequestInput;
  OAuth2ProviderRequestInput: OAuth2ProviderRequestInput;
  MutationInputCoreTransactionalApplicationsUpdateInputProviderOneOf_1ClientId: ResolverTypeWrapper<Scalars['MutationInputCoreTransactionalApplicationsUpdateInputProviderOneOf_1ClientId']['output']>;
  MutationInputCoreTransactionalApplicationsUpdateInputProviderOneOf_1ClientSecret: ResolverTypeWrapper<Scalars['MutationInputCoreTransactionalApplicationsUpdateInputProviderOneOf_1ClientSecret']['output']>;
  ProxyProviderRequestInput: ProxyProviderRequestInput;
  RacProviderRequestInput: RacProviderRequestInput;
  RadiusProviderRequestInput: RadiusProviderRequestInput;
  SamlProviderRequestInput: SamlProviderRequestInput;
  ScimProviderRequestInput: ScimProviderRequestInput;
  CoreUserConsentDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreUserConsentDestroyResponse']>;
  CoreUsersCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreUsersCreateResponse']>;
  UserRequestInput: UserRequestInput;
  MutationInputCoreUsersCreateInputUsername: ResolverTypeWrapper<Scalars['MutationInputCoreUsersCreateInputUsername']['output']>;
  CoreUsersUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreUsersUpdateResponse']>;
  CoreUsersPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreUsersPartialUpdateResponse']>;
  PatchedUserRequestInput: PatchedUserRequestInput;
  MutationInputCoreUsersPartialUpdateInputUsername: ResolverTypeWrapper<Scalars['MutationInputCoreUsersPartialUpdateInputUsername']['output']>;
  CoreUsersDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreUsersDestroyResponse']>;
  CoreUsersImpersonateCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreUsersImpersonateCreateResponse']>;
  CoreUsersRecoveryCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreUsersRecoveryCreateResponse']>;
  CoreUsersRecoveryEmailCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreUsersRecoveryEmailCreateResponse']>;
  CoreUsersSetPasswordCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreUsersSetPasswordCreateResponse']>;
  UserPasswordSetRequestInput: UserPasswordSetRequestInput;
  CoreUsersServiceAccountCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CoreUsersServiceAccountCreateResponse']>;
  UserServiceAccountResponse: ResolverTypeWrapper<UserServiceAccountResponse>;
  UserServiceAccountRequestInput: UserServiceAccountRequestInput;
  CryptoCertificatekeypairsCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CryptoCertificatekeypairsCreateResponse']>;
  CertificateKeyPairRequestInput: CertificateKeyPairRequestInput;
  CryptoCertificatekeypairsUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CryptoCertificatekeypairsUpdateResponse']>;
  CryptoCertificatekeypairsPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CryptoCertificatekeypairsPartialUpdateResponse']>;
  PatchedCertificateKeyPairRequestInput: PatchedCertificateKeyPairRequestInput;
  CryptoCertificatekeypairsDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CryptoCertificatekeypairsDestroyResponse']>;
  CryptoCertificatekeypairsGenerateCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CryptoCertificatekeypairsGenerateCreateResponse']>;
  CertificateGenerationRequestInput: CertificateGenerationRequestInput;
  AlgEnum: AlgEnum;
  EnterpriseLicenseCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EnterpriseLicenseCreateResponse']>;
  LicenseRequestInput: LicenseRequestInput;
  EnterpriseLicenseUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EnterpriseLicenseUpdateResponse']>;
  EnterpriseLicensePartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EnterpriseLicensePartialUpdateResponse']>;
  PatchedLicenseRequestInput: PatchedLicenseRequestInput;
  EnterpriseLicenseDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EnterpriseLicenseDestroyResponse']>;
  EventsEventsCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EventsEventsCreateResponse']>;
  EventRequestInput: EventRequestInput;
  EventsEventsUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EventsEventsUpdateResponse']>;
  EventsEventsPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EventsEventsPartialUpdateResponse']>;
  PatchedEventRequestInput: PatchedEventRequestInput;
  EventsEventsDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EventsEventsDestroyResponse']>;
  EventsNotificationsUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EventsNotificationsUpdateResponse']>;
  NotificationRequestInput: NotificationRequestInput;
  EventsNotificationsPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EventsNotificationsPartialUpdateResponse']>;
  PatchedNotificationRequestInput: PatchedNotificationRequestInput;
  EventsNotificationsDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EventsNotificationsDestroyResponse']>;
  EventsNotificationsMarkAllSeenCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EventsNotificationsMarkAllSeenCreateResponse']>;
  EventsRulesCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EventsRulesCreateResponse']>;
  NotificationRuleRequestInput: NotificationRuleRequestInput;
  EventsRulesUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EventsRulesUpdateResponse']>;
  EventsRulesPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EventsRulesPartialUpdateResponse']>;
  PatchedNotificationRuleRequestInput: PatchedNotificationRuleRequestInput;
  EventsRulesDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EventsRulesDestroyResponse']>;
  EventsSystemTasksRunCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EventsSystemTasksRunCreateResponse']>;
  EventsTransportsCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EventsTransportsCreateResponse']>;
  NotificationTransportRequestInput: NotificationTransportRequestInput;
  EventsTransportsUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EventsTransportsUpdateResponse']>;
  EventsTransportsPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EventsTransportsPartialUpdateResponse']>;
  PatchedNotificationTransportRequestInput: PatchedNotificationTransportRequestInput;
  EventsTransportsDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EventsTransportsDestroyResponse']>;
  EventsTransportsTestCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EventsTransportsTestCreateResponse']>;
  NotificationTransportTest: ResolverTypeWrapper<NotificationTransportTest>;
  FlowsBindingsCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['FlowsBindingsCreateResponse']>;
  FlowStageBindingRequestInput: FlowStageBindingRequestInput;
  FlowsBindingsUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['FlowsBindingsUpdateResponse']>;
  FlowsBindingsPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['FlowsBindingsPartialUpdateResponse']>;
  PatchedFlowStageBindingRequestInput: PatchedFlowStageBindingRequestInput;
  FlowsBindingsDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['FlowsBindingsDestroyResponse']>;
  FlowsExecutorSolveResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['FlowsExecutorSolveResponse']>;
  FlowChallengeResponseRequestInput: FlowChallengeResponseRequestInput;
  AppleChallengeResponseRequestInput: AppleChallengeResponseRequestInput;
  AuthenticatorDuoChallengeResponseRequestInput: AuthenticatorDuoChallengeResponseRequestInput;
  AuthenticatorSmsChallengeResponseRequestInput: AuthenticatorSmsChallengeResponseRequestInput;
  AuthenticatorStaticChallengeResponseRequestInput: AuthenticatorStaticChallengeResponseRequestInput;
  AuthenticatorTotpChallengeResponseRequestInput: AuthenticatorTotpChallengeResponseRequestInput;
  AuthenticatorValidationChallengeResponseRequestInput: AuthenticatorValidationChallengeResponseRequestInput;
  DeviceChallengeRequestInput: DeviceChallengeRequestInput;
  AuthenticatorWebAuthnChallengeResponseRequestInput: AuthenticatorWebAuthnChallengeResponseRequestInput;
  AutoSubmitChallengeResponseRequestInput: AutoSubmitChallengeResponseRequestInput;
  CaptchaChallengeResponseRequestInput: CaptchaChallengeResponseRequestInput;
  ConsentChallengeResponseRequestInput: ConsentChallengeResponseRequestInput;
  EmailChallengeResponseRequestInput: EmailChallengeResponseRequestInput;
  IdentificationChallengeResponseRequestInput: IdentificationChallengeResponseRequestInput;
  OAuthDeviceCodeChallengeResponseRequestInput: OAuthDeviceCodeChallengeResponseRequestInput;
  OAuthDeviceCodeFinishChallengeResponseRequestInput: OAuthDeviceCodeFinishChallengeResponseRequestInput;
  PasswordChallengeResponseRequestInput: PasswordChallengeResponseRequestInput;
  PlexAuthenticationChallengeResponseRequestInput: PlexAuthenticationChallengeResponseRequestInput;
  PromptChallengeResponseRequestInput: PromptChallengeResponseRequestInput;
  UserLoginChallengeResponseRequestInput: UserLoginChallengeResponseRequestInput;
  FlowsInstancesCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['FlowsInstancesCreateResponse']>;
  FlowRequestInput: FlowRequestInput;
  MutationInputFlowsInstancesCreateInputSlug: ResolverTypeWrapper<Scalars['MutationInputFlowsInstancesCreateInputSlug']['output']>;
  FlowsInstancesUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['FlowsInstancesUpdateResponse']>;
  FlowsInstancesPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['FlowsInstancesPartialUpdateResponse']>;
  PatchedFlowRequestInput: PatchedFlowRequestInput;
  MutationInputFlowsInstancesPartialUpdateInputSlug: ResolverTypeWrapper<Scalars['MutationInputFlowsInstancesPartialUpdateInputSlug']['output']>;
  FlowsInstancesDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['FlowsInstancesDestroyResponse']>;
  FlowsInstancesCacheClearCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['FlowsInstancesCacheClearCreateResponse']>;
  FlowsInstancesImportCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['FlowsInstancesImportCreateResponse']>;
  FlowImportResult: ResolverTypeWrapper<FlowImportResult>;
  ManagedBlueprintsCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ManagedBlueprintsCreateResponse']>;
  BlueprintInstanceRequestInput: BlueprintInstanceRequestInput;
  ManagedBlueprintsUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ManagedBlueprintsUpdateResponse']>;
  ManagedBlueprintsPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ManagedBlueprintsPartialUpdateResponse']>;
  PatchedBlueprintInstanceRequestInput: PatchedBlueprintInstanceRequestInput;
  ManagedBlueprintsDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ManagedBlueprintsDestroyResponse']>;
  ManagedBlueprintsApplyCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ManagedBlueprintsApplyCreateResponse']>;
  Oauth2AccessTokensDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['Oauth2AccessTokensDestroyResponse']>;
  Oauth2AuthorizationCodesDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['Oauth2AuthorizationCodesDestroyResponse']>;
  Oauth2RefreshTokensDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['Oauth2RefreshTokensDestroyResponse']>;
  OutpostsInstancesCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['OutpostsInstancesCreateResponse']>;
  OutpostRequestInput: OutpostRequestInput;
  OutpostsInstancesUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['OutpostsInstancesUpdateResponse']>;
  OutpostsInstancesPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['OutpostsInstancesPartialUpdateResponse']>;
  PatchedOutpostRequestInput: PatchedOutpostRequestInput;
  OutpostsInstancesDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['OutpostsInstancesDestroyResponse']>;
  OutpostsServiceConnectionsAllDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['OutpostsServiceConnectionsAllDestroyResponse']>;
  OutpostsServiceConnectionsDockerCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['OutpostsServiceConnectionsDockerCreateResponse']>;
  DockerServiceConnectionRequestInput: DockerServiceConnectionRequestInput;
  OutpostsServiceConnectionsDockerUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['OutpostsServiceConnectionsDockerUpdateResponse']>;
  OutpostsServiceConnectionsDockerPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['OutpostsServiceConnectionsDockerPartialUpdateResponse']>;
  PatchedDockerServiceConnectionRequestInput: PatchedDockerServiceConnectionRequestInput;
  OutpostsServiceConnectionsDockerDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['OutpostsServiceConnectionsDockerDestroyResponse']>;
  OutpostsServiceConnectionsKubernetesCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['OutpostsServiceConnectionsKubernetesCreateResponse']>;
  KubernetesServiceConnectionRequestInput: KubernetesServiceConnectionRequestInput;
  OutpostsServiceConnectionsKubernetesUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['OutpostsServiceConnectionsKubernetesUpdateResponse']>;
  OutpostsServiceConnectionsKubernetesPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['OutpostsServiceConnectionsKubernetesPartialUpdateResponse']>;
  PatchedKubernetesServiceConnectionRequestInput: PatchedKubernetesServiceConnectionRequestInput;
  OutpostsServiceConnectionsKubernetesDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['OutpostsServiceConnectionsKubernetesDestroyResponse']>;
  PoliciesAllDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesAllDestroyResponse']>;
  PoliciesAllTestCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesAllTestCreateResponse']>;
  PolicyTestRequestInput: PolicyTestRequestInput;
  PoliciesAllCacheClearCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesAllCacheClearCreateResponse']>;
  PoliciesBindingsCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesBindingsCreateResponse']>;
  PolicyBindingRequestInput: PolicyBindingRequestInput;
  PoliciesBindingsUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesBindingsUpdateResponse']>;
  PoliciesBindingsPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesBindingsPartialUpdateResponse']>;
  PatchedPolicyBindingRequestInput: PatchedPolicyBindingRequestInput;
  PoliciesBindingsDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesBindingsDestroyResponse']>;
  PoliciesDummyCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesDummyCreateResponse']>;
  DummyPolicyRequestInput: DummyPolicyRequestInput;
  PoliciesDummyUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesDummyUpdateResponse']>;
  PoliciesDummyPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesDummyPartialUpdateResponse']>;
  PatchedDummyPolicyRequestInput: PatchedDummyPolicyRequestInput;
  PoliciesDummyDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesDummyDestroyResponse']>;
  PoliciesEventMatcherCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesEventMatcherCreateResponse']>;
  EventMatcherPolicyRequestInput: EventMatcherPolicyRequestInput;
  PoliciesEventMatcherUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesEventMatcherUpdateResponse']>;
  PoliciesEventMatcherPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesEventMatcherPartialUpdateResponse']>;
  PatchedEventMatcherPolicyRequestInput: PatchedEventMatcherPolicyRequestInput;
  PoliciesEventMatcherDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesEventMatcherDestroyResponse']>;
  PoliciesExpressionCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesExpressionCreateResponse']>;
  ExpressionPolicyRequestInput: ExpressionPolicyRequestInput;
  PoliciesExpressionUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesExpressionUpdateResponse']>;
  PoliciesExpressionPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesExpressionPartialUpdateResponse']>;
  PatchedExpressionPolicyRequestInput: PatchedExpressionPolicyRequestInput;
  PoliciesExpressionDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesExpressionDestroyResponse']>;
  PoliciesPasswordCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesPasswordCreateResponse']>;
  PasswordPolicyRequestInput: PasswordPolicyRequestInput;
  PoliciesPasswordUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesPasswordUpdateResponse']>;
  PoliciesPasswordPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesPasswordPartialUpdateResponse']>;
  PatchedPasswordPolicyRequestInput: PatchedPasswordPolicyRequestInput;
  PoliciesPasswordDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesPasswordDestroyResponse']>;
  PoliciesPasswordExpiryCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesPasswordExpiryCreateResponse']>;
  PasswordExpiryPolicyRequestInput: PasswordExpiryPolicyRequestInput;
  PoliciesPasswordExpiryUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesPasswordExpiryUpdateResponse']>;
  PoliciesPasswordExpiryPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesPasswordExpiryPartialUpdateResponse']>;
  PatchedPasswordExpiryPolicyRequestInput: PatchedPasswordExpiryPolicyRequestInput;
  PoliciesPasswordExpiryDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesPasswordExpiryDestroyResponse']>;
  PoliciesReputationCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesReputationCreateResponse']>;
  ReputationPolicyRequestInput: ReputationPolicyRequestInput;
  PoliciesReputationUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesReputationUpdateResponse']>;
  PoliciesReputationPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesReputationPartialUpdateResponse']>;
  PatchedReputationPolicyRequestInput: PatchedReputationPolicyRequestInput;
  PoliciesReputationDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesReputationDestroyResponse']>;
  PoliciesReputationScoresDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PoliciesReputationScoresDestroyResponse']>;
  PropertymappingsAllDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsAllDestroyResponse']>;
  PropertymappingsAllTestCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsAllTestCreateResponse']>;
  PropertyMappingTestResult: ResolverTypeWrapper<PropertyMappingTestResult>;
  PropertymappingsLdapCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsLdapCreateResponse']>;
  LdapPropertyMappingRequestInput: LdapPropertyMappingRequestInput;
  PropertymappingsLdapUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsLdapUpdateResponse']>;
  PropertymappingsLdapPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsLdapPartialUpdateResponse']>;
  PatchedLdapPropertyMappingRequestInput: PatchedLdapPropertyMappingRequestInput;
  PropertymappingsLdapDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsLdapDestroyResponse']>;
  PropertymappingsNotificationCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsNotificationCreateResponse']>;
  NotificationWebhookMappingRequestInput: NotificationWebhookMappingRequestInput;
  PropertymappingsNotificationUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsNotificationUpdateResponse']>;
  PropertymappingsNotificationPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsNotificationPartialUpdateResponse']>;
  PatchedNotificationWebhookMappingRequestInput: PatchedNotificationWebhookMappingRequestInput;
  PropertymappingsNotificationDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsNotificationDestroyResponse']>;
  PropertymappingsRacCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsRacCreateResponse']>;
  RacPropertyMappingRequestInput: RacPropertyMappingRequestInput;
  PropertymappingsRacUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsRacUpdateResponse']>;
  PropertymappingsRacPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsRacPartialUpdateResponse']>;
  PatchedRacPropertyMappingRequestInput: PatchedRacPropertyMappingRequestInput;
  PropertymappingsRacDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsRacDestroyResponse']>;
  PropertymappingsSamlCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsSamlCreateResponse']>;
  SamlPropertyMappingRequestInput: SamlPropertyMappingRequestInput;
  PropertymappingsSamlUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsSamlUpdateResponse']>;
  PropertymappingsSamlPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsSamlPartialUpdateResponse']>;
  PatchedSamlPropertyMappingRequestInput: PatchedSamlPropertyMappingRequestInput;
  PropertymappingsSamlDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsSamlDestroyResponse']>;
  PropertymappingsScimCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsScimCreateResponse']>;
  ScimMappingRequestInput: ScimMappingRequestInput;
  PropertymappingsScimUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsScimUpdateResponse']>;
  PropertymappingsScimPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsScimPartialUpdateResponse']>;
  PatchedScimMappingRequestInput: PatchedScimMappingRequestInput;
  PropertymappingsScimDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsScimDestroyResponse']>;
  PropertymappingsScopeCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsScopeCreateResponse']>;
  ScopeMappingRequestInput: ScopeMappingRequestInput;
  PropertymappingsScopeUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsScopeUpdateResponse']>;
  PropertymappingsScopePartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsScopePartialUpdateResponse']>;
  PatchedScopeMappingRequestInput: PatchedScopeMappingRequestInput;
  PropertymappingsScopeDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PropertymappingsScopeDestroyResponse']>;
  ProvidersAllDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersAllDestroyResponse']>;
  ProvidersLdapCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersLdapCreateResponse']>;
  ProvidersLdapUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersLdapUpdateResponse']>;
  ProvidersLdapPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersLdapPartialUpdateResponse']>;
  PatchedLdapProviderRequestInput: PatchedLdapProviderRequestInput;
  ProvidersLdapDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersLdapDestroyResponse']>;
  ProvidersOauth2CreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersOauth2CreateResponse']>;
  ProvidersOauth2UpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersOauth2UpdateResponse']>;
  ProvidersOauth2PartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersOauth2PartialUpdateResponse']>;
  PatchedOAuth2ProviderRequestInput: PatchedOAuth2ProviderRequestInput;
  MutationInputProvidersOauth2PartialUpdateInputClientId: ResolverTypeWrapper<Scalars['MutationInputProvidersOauth2PartialUpdateInputClientId']['output']>;
  MutationInputProvidersOauth2PartialUpdateInputClientSecret: ResolverTypeWrapper<Scalars['MutationInputProvidersOauth2PartialUpdateInputClientSecret']['output']>;
  ProvidersOauth2DestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersOauth2DestroyResponse']>;
  ProvidersProxyCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersProxyCreateResponse']>;
  ProvidersProxyUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersProxyUpdateResponse']>;
  ProvidersProxyPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersProxyPartialUpdateResponse']>;
  PatchedProxyProviderRequestInput: PatchedProxyProviderRequestInput;
  ProvidersProxyDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersProxyDestroyResponse']>;
  ProvidersRacCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersRacCreateResponse']>;
  ProvidersRacUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersRacUpdateResponse']>;
  ProvidersRacPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersRacPartialUpdateResponse']>;
  PatchedRacProviderRequestInput: PatchedRacProviderRequestInput;
  ProvidersRacDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersRacDestroyResponse']>;
  ProvidersRadiusCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersRadiusCreateResponse']>;
  ProvidersRadiusUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersRadiusUpdateResponse']>;
  ProvidersRadiusPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersRadiusPartialUpdateResponse']>;
  PatchedRadiusProviderRequestInput: PatchedRadiusProviderRequestInput;
  ProvidersRadiusDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersRadiusDestroyResponse']>;
  ProvidersSamlCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersSamlCreateResponse']>;
  ProvidersSamlUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersSamlUpdateResponse']>;
  ProvidersSamlPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersSamlPartialUpdateResponse']>;
  PatchedSamlProviderRequestInput: PatchedSamlProviderRequestInput;
  ProvidersSamlDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersSamlDestroyResponse']>;
  ProvidersSamlImportMetadataCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersSamlImportMetadataCreateResponse']>;
  SamlProviderImportRequestInput: SamlProviderImportRequestInput;
  ProvidersScimCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersScimCreateResponse']>;
  ProvidersScimUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersScimUpdateResponse']>;
  ProvidersScimPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersScimPartialUpdateResponse']>;
  PatchedScimProviderRequestInput: PatchedScimProviderRequestInput;
  ProvidersScimDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProvidersScimDestroyResponse']>;
  RacConnectionTokensUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['RacConnectionTokensUpdateResponse']>;
  ConnectionTokenRequestInput: ConnectionTokenRequestInput;
  RacConnectionTokensPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['RacConnectionTokensPartialUpdateResponse']>;
  PatchedConnectionTokenRequestInput: PatchedConnectionTokenRequestInput;
  RacConnectionTokensDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['RacConnectionTokensDestroyResponse']>;
  RacEndpointsCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['RacEndpointsCreateResponse']>;
  EndpointRequestInput: EndpointRequestInput;
  RacEndpointsUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['RacEndpointsUpdateResponse']>;
  RacEndpointsPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['RacEndpointsPartialUpdateResponse']>;
  PatchedEndpointRequestInput: PatchedEndpointRequestInput;
  RacEndpointsDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['RacEndpointsDestroyResponse']>;
  RbacPermissionsAssignedByRolesAssignCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['RbacPermissionsAssignedByRolesAssignCreateResponse']>;
  PermissionAssignRequestInput: PermissionAssignRequestInput;
  RbacPermissionsAssignedByRolesUnassignPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['RbacPermissionsAssignedByRolesUnassignPartialUpdateResponse']>;
  PatchedPermissionAssignRequestInput: PatchedPermissionAssignRequestInput;
  RbacPermissionsAssignedByUsersAssignCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['RbacPermissionsAssignedByUsersAssignCreateResponse']>;
  RbacPermissionsAssignedByUsersUnassignPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['RbacPermissionsAssignedByUsersUnassignPartialUpdateResponse']>;
  RbacRolesCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['RbacRolesCreateResponse']>;
  RoleRequestInput: RoleRequestInput;
  MutationInputRbacRolesCreateInputName: ResolverTypeWrapper<Scalars['MutationInputRbacRolesCreateInputName']['output']>;
  RbacRolesUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['RbacRolesUpdateResponse']>;
  RbacRolesPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['RbacRolesPartialUpdateResponse']>;
  PatchedRoleRequestInput: PatchedRoleRequestInput;
  MutationInputRbacRolesPartialUpdateInputName: ResolverTypeWrapper<Scalars['MutationInputRbacRolesPartialUpdateInputName']['output']>;
  RbacRolesDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['RbacRolesDestroyResponse']>;
  SourcesAllDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesAllDestroyResponse']>;
  SourcesLdapCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesLdapCreateResponse']>;
  LdapSourceRequestInput: LdapSourceRequestInput;
  MutationInputSourcesLdapCreateInputSlug: ResolverTypeWrapper<Scalars['MutationInputSourcesLdapCreateInputSlug']['output']>;
  SourcesLdapUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesLdapUpdateResponse']>;
  SourcesLdapPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesLdapPartialUpdateResponse']>;
  PatchedLdapSourceRequestInput: PatchedLdapSourceRequestInput;
  MutationInputSourcesLdapPartialUpdateInputSlug: ResolverTypeWrapper<Scalars['MutationInputSourcesLdapPartialUpdateInputSlug']['output']>;
  SourcesLdapDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesLdapDestroyResponse']>;
  SourcesOauthCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesOauthCreateResponse']>;
  OAuthSourceRequestInput: OAuthSourceRequestInput;
  MutationInputSourcesOauthCreateInputSlug: ResolverTypeWrapper<Scalars['MutationInputSourcesOauthCreateInputSlug']['output']>;
  MutationInputSourcesOauthCreateInputRequestTokenUrl: ResolverTypeWrapper<Scalars['MutationInputSourcesOauthCreateInputRequestTokenUrl']['output']>;
  MutationInputSourcesOauthCreateInputAuthorizationUrl: ResolverTypeWrapper<Scalars['MutationInputSourcesOauthCreateInputAuthorizationUrl']['output']>;
  MutationInputSourcesOauthCreateInputAccessTokenUrl: ResolverTypeWrapper<Scalars['MutationInputSourcesOauthCreateInputAccessTokenUrl']['output']>;
  MutationInputSourcesOauthCreateInputProfileUrl: ResolverTypeWrapper<Scalars['MutationInputSourcesOauthCreateInputProfileUrl']['output']>;
  SourcesOauthUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesOauthUpdateResponse']>;
  SourcesOauthPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesOauthPartialUpdateResponse']>;
  PatchedOAuthSourceRequestInput: PatchedOAuthSourceRequestInput;
  MutationInputSourcesOauthPartialUpdateInputSlug: ResolverTypeWrapper<Scalars['MutationInputSourcesOauthPartialUpdateInputSlug']['output']>;
  MutationInputSourcesOauthPartialUpdateInputRequestTokenUrl: ResolverTypeWrapper<Scalars['MutationInputSourcesOauthPartialUpdateInputRequestTokenUrl']['output']>;
  MutationInputSourcesOauthPartialUpdateInputAuthorizationUrl: ResolverTypeWrapper<Scalars['MutationInputSourcesOauthPartialUpdateInputAuthorizationUrl']['output']>;
  MutationInputSourcesOauthPartialUpdateInputAccessTokenUrl: ResolverTypeWrapper<Scalars['MutationInputSourcesOauthPartialUpdateInputAccessTokenUrl']['output']>;
  MutationInputSourcesOauthPartialUpdateInputProfileUrl: ResolverTypeWrapper<Scalars['MutationInputSourcesOauthPartialUpdateInputProfileUrl']['output']>;
  SourcesOauthDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesOauthDestroyResponse']>;
  SourcesPlexCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesPlexCreateResponse']>;
  PlexSourceRequestInput: PlexSourceRequestInput;
  MutationInputSourcesPlexCreateInputSlug: ResolverTypeWrapper<Scalars['MutationInputSourcesPlexCreateInputSlug']['output']>;
  SourcesPlexUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesPlexUpdateResponse']>;
  SourcesPlexPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesPlexPartialUpdateResponse']>;
  PatchedPlexSourceRequestInput: PatchedPlexSourceRequestInput;
  MutationInputSourcesPlexPartialUpdateInputSlug: ResolverTypeWrapper<Scalars['MutationInputSourcesPlexPartialUpdateInputSlug']['output']>;
  SourcesPlexDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesPlexDestroyResponse']>;
  PlexTokenRedeemRequestInput: PlexTokenRedeemRequestInput;
  SourcesSamlCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesSamlCreateResponse']>;
  SamlSourceRequestInput: SamlSourceRequestInput;
  MutationInputSourcesSamlCreateInputSlug: ResolverTypeWrapper<Scalars['MutationInputSourcesSamlCreateInputSlug']['output']>;
  SourcesSamlUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesSamlUpdateResponse']>;
  SourcesSamlPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesSamlPartialUpdateResponse']>;
  PatchedSamlSourceRequestInput: PatchedSamlSourceRequestInput;
  MutationInputSourcesSamlPartialUpdateInputSlug: ResolverTypeWrapper<Scalars['MutationInputSourcesSamlPartialUpdateInputSlug']['output']>;
  SourcesSamlDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesSamlDestroyResponse']>;
  SourcesScimCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesScimCreateResponse']>;
  ScimSourceRequestInput: ScimSourceRequestInput;
  MutationInputSourcesScimCreateInputSlug: ResolverTypeWrapper<Scalars['MutationInputSourcesScimCreateInputSlug']['output']>;
  SourcesScimUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesScimUpdateResponse']>;
  SourcesScimPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesScimPartialUpdateResponse']>;
  PatchedScimSourceRequestInput: PatchedScimSourceRequestInput;
  MutationInputSourcesScimPartialUpdateInputSlug: ResolverTypeWrapper<Scalars['MutationInputSourcesScimPartialUpdateInputSlug']['output']>;
  SourcesScimDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesScimDestroyResponse']>;
  SourcesScimGroupsCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesScimGroupsCreateResponse']>;
  ScimSourceGroupRequestInput: ScimSourceGroupRequestInput;
  SourcesScimGroupsUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesScimGroupsUpdateResponse']>;
  SourcesScimGroupsPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesScimGroupsPartialUpdateResponse']>;
  PatchedScimSourceGroupRequestInput: PatchedScimSourceGroupRequestInput;
  SourcesScimGroupsDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesScimGroupsDestroyResponse']>;
  SourcesScimUsersCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesScimUsersCreateResponse']>;
  ScimSourceUserRequestInput: ScimSourceUserRequestInput;
  SourcesScimUsersUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesScimUsersUpdateResponse']>;
  SourcesScimUsersPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesScimUsersPartialUpdateResponse']>;
  PatchedScimSourceUserRequestInput: PatchedScimSourceUserRequestInput;
  SourcesScimUsersDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesScimUsersDestroyResponse']>;
  SourcesUserConnectionsAllUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesUserConnectionsAllUpdateResponse']>;
  SourcesUserConnectionsAllPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesUserConnectionsAllPartialUpdateResponse']>;
  SourcesUserConnectionsAllDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesUserConnectionsAllDestroyResponse']>;
  SourcesUserConnectionsOauthCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesUserConnectionsOauthCreateResponse']>;
  UserOAuthSourceConnectionRequestInput: UserOAuthSourceConnectionRequestInput;
  MutationInputSourcesUserConnectionsOauthCreateInputIdentifier: ResolverTypeWrapper<Scalars['MutationInputSourcesUserConnectionsOauthCreateInputIdentifier']['output']>;
  SourcesUserConnectionsOauthUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesUserConnectionsOauthUpdateResponse']>;
  SourcesUserConnectionsOauthPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesUserConnectionsOauthPartialUpdateResponse']>;
  PatchedUserOAuthSourceConnectionRequestInput: PatchedUserOAuthSourceConnectionRequestInput;
  MutationInputSourcesUserConnectionsOauthPartialUpdateInputIdentifier: ResolverTypeWrapper<Scalars['MutationInputSourcesUserConnectionsOauthPartialUpdateInputIdentifier']['output']>;
  SourcesUserConnectionsOauthDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesUserConnectionsOauthDestroyResponse']>;
  SourcesUserConnectionsPlexCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesUserConnectionsPlexCreateResponse']>;
  PlexSourceConnectionRequestInput: PlexSourceConnectionRequestInput;
  SourcesUserConnectionsPlexUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesUserConnectionsPlexUpdateResponse']>;
  SourcesUserConnectionsPlexPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesUserConnectionsPlexPartialUpdateResponse']>;
  PatchedPlexSourceConnectionRequestInput: PatchedPlexSourceConnectionRequestInput;
  SourcesUserConnectionsPlexDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesUserConnectionsPlexDestroyResponse']>;
  SourcesUserConnectionsSamlCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesUserConnectionsSamlCreateResponse']>;
  UserSamlSourceConnectionRequestInput: UserSamlSourceConnectionRequestInput;
  SourcesUserConnectionsSamlUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesUserConnectionsSamlUpdateResponse']>;
  SourcesUserConnectionsSamlPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesUserConnectionsSamlPartialUpdateResponse']>;
  PatchedUserSamlSourceConnectionRequestInput: PatchedUserSamlSourceConnectionRequestInput;
  SourcesUserConnectionsSamlDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SourcesUserConnectionsSamlDestroyResponse']>;
  StagesAllDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAllDestroyResponse']>;
  StagesAuthenticatorDuoCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorDuoCreateResponse']>;
  AuthenticatorDuoStageRequestInput: AuthenticatorDuoStageRequestInput;
  FlowSetRequestInput: FlowSetRequestInput;
  MutationInputStagesAuthenticatorDuoCreateInputFlowSetItemsSlug: ResolverTypeWrapper<Scalars['MutationInputStagesAuthenticatorDuoCreateInputFlowSetItemsSlug']['output']>;
  StagesAuthenticatorDuoUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorDuoUpdateResponse']>;
  StagesAuthenticatorDuoPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorDuoPartialUpdateResponse']>;
  PatchedAuthenticatorDuoStageRequestInput: PatchedAuthenticatorDuoStageRequestInput;
  StagesAuthenticatorDuoDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorDuoDestroyResponse']>;
  StagesAuthenticatorDuoEnrollmentStatusCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorDuoEnrollmentStatusCreateResponse']>;
  DuoDeviceEnrollmentStatus: ResolverTypeWrapper<DuoDeviceEnrollmentStatus>;
  DuoResponseEnum: DuoResponseEnum;
  StagesAuthenticatorDuoImportDeviceManualCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorDuoImportDeviceManualCreateResponse']>;
  AuthenticatorDuoStageManualDeviceImportRequestInput: AuthenticatorDuoStageManualDeviceImportRequestInput;
  StagesAuthenticatorDuoImportDevicesAutomaticCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorDuoImportDevicesAutomaticCreateResponse']>;
  AuthenticatorDuoStageDeviceImportResponse: ResolverTypeWrapper<AuthenticatorDuoStageDeviceImportResponse>;
  StagesAuthenticatorSmsCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorSmsCreateResponse']>;
  AuthenticatorSmsStageRequestInput: AuthenticatorSmsStageRequestInput;
  StagesAuthenticatorSmsUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorSmsUpdateResponse']>;
  StagesAuthenticatorSmsPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorSmsPartialUpdateResponse']>;
  PatchedAuthenticatorSmsStageRequestInput: PatchedAuthenticatorSmsStageRequestInput;
  StagesAuthenticatorSmsDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorSmsDestroyResponse']>;
  StagesAuthenticatorStaticCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorStaticCreateResponse']>;
  AuthenticatorStaticStageRequestInput: AuthenticatorStaticStageRequestInput;
  StagesAuthenticatorStaticUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorStaticUpdateResponse']>;
  StagesAuthenticatorStaticPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorStaticPartialUpdateResponse']>;
  PatchedAuthenticatorStaticStageRequestInput: PatchedAuthenticatorStaticStageRequestInput;
  StagesAuthenticatorStaticDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorStaticDestroyResponse']>;
  StagesAuthenticatorTotpCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorTotpCreateResponse']>;
  AuthenticatorTotpStageRequestInput: AuthenticatorTotpStageRequestInput;
  StagesAuthenticatorTotpUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorTotpUpdateResponse']>;
  StagesAuthenticatorTotpPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorTotpPartialUpdateResponse']>;
  PatchedAuthenticatorTotpStageRequestInput: PatchedAuthenticatorTotpStageRequestInput;
  StagesAuthenticatorTotpDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorTotpDestroyResponse']>;
  StagesAuthenticatorValidateCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorValidateCreateResponse']>;
  AuthenticatorValidateStageRequestInput: AuthenticatorValidateStageRequestInput;
  StagesAuthenticatorValidateUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorValidateUpdateResponse']>;
  StagesAuthenticatorValidatePartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorValidatePartialUpdateResponse']>;
  PatchedAuthenticatorValidateStageRequestInput: PatchedAuthenticatorValidateStageRequestInput;
  StagesAuthenticatorValidateDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorValidateDestroyResponse']>;
  StagesAuthenticatorWebauthnCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorWebauthnCreateResponse']>;
  AuthenticatorWebAuthnStageRequestInput: AuthenticatorWebAuthnStageRequestInput;
  StagesAuthenticatorWebauthnUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorWebauthnUpdateResponse']>;
  StagesAuthenticatorWebauthnPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorWebauthnPartialUpdateResponse']>;
  PatchedAuthenticatorWebAuthnStageRequestInput: PatchedAuthenticatorWebAuthnStageRequestInput;
  StagesAuthenticatorWebauthnDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesAuthenticatorWebauthnDestroyResponse']>;
  StagesCaptchaCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesCaptchaCreateResponse']>;
  CaptchaStageRequestInput: CaptchaStageRequestInput;
  StagesCaptchaUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesCaptchaUpdateResponse']>;
  StagesCaptchaPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesCaptchaPartialUpdateResponse']>;
  PatchedCaptchaStageRequestInput: PatchedCaptchaStageRequestInput;
  StagesCaptchaDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesCaptchaDestroyResponse']>;
  StagesConsentCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesConsentCreateResponse']>;
  ConsentStageRequestInput: ConsentStageRequestInput;
  StagesConsentUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesConsentUpdateResponse']>;
  StagesConsentPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesConsentPartialUpdateResponse']>;
  PatchedConsentStageRequestInput: PatchedConsentStageRequestInput;
  StagesConsentDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesConsentDestroyResponse']>;
  StagesDenyCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesDenyCreateResponse']>;
  DenyStageRequestInput: DenyStageRequestInput;
  StagesDenyUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesDenyUpdateResponse']>;
  StagesDenyPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesDenyPartialUpdateResponse']>;
  PatchedDenyStageRequestInput: PatchedDenyStageRequestInput;
  StagesDenyDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesDenyDestroyResponse']>;
  StagesDummyCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesDummyCreateResponse']>;
  DummyStageRequestInput: DummyStageRequestInput;
  StagesDummyUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesDummyUpdateResponse']>;
  StagesDummyPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesDummyPartialUpdateResponse']>;
  PatchedDummyStageRequestInput: PatchedDummyStageRequestInput;
  StagesDummyDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesDummyDestroyResponse']>;
  StagesEmailCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesEmailCreateResponse']>;
  EmailStageRequestInput: EmailStageRequestInput;
  StagesEmailUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesEmailUpdateResponse']>;
  StagesEmailPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesEmailPartialUpdateResponse']>;
  PatchedEmailStageRequestInput: PatchedEmailStageRequestInput;
  StagesEmailDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesEmailDestroyResponse']>;
  StagesIdentificationCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesIdentificationCreateResponse']>;
  IdentificationStageRequestInput: IdentificationStageRequestInput;
  StagesIdentificationUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesIdentificationUpdateResponse']>;
  StagesIdentificationPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesIdentificationPartialUpdateResponse']>;
  PatchedIdentificationStageRequestInput: PatchedIdentificationStageRequestInput;
  StagesIdentificationDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesIdentificationDestroyResponse']>;
  StagesInvitationInvitationsCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesInvitationInvitationsCreateResponse']>;
  InvitationRequestInput: InvitationRequestInput;
  MutationInputStagesInvitationInvitationsCreateInputName: ResolverTypeWrapper<Scalars['MutationInputStagesInvitationInvitationsCreateInputName']['output']>;
  StagesInvitationInvitationsUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesInvitationInvitationsUpdateResponse']>;
  StagesInvitationInvitationsPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesInvitationInvitationsPartialUpdateResponse']>;
  PatchedInvitationRequestInput: PatchedInvitationRequestInput;
  MutationInputStagesInvitationInvitationsPartialUpdateInputName: ResolverTypeWrapper<Scalars['MutationInputStagesInvitationInvitationsPartialUpdateInputName']['output']>;
  StagesInvitationInvitationsDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesInvitationInvitationsDestroyResponse']>;
  StagesInvitationStagesCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesInvitationStagesCreateResponse']>;
  InvitationStageRequestInput: InvitationStageRequestInput;
  StagesInvitationStagesUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesInvitationStagesUpdateResponse']>;
  StagesInvitationStagesPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesInvitationStagesPartialUpdateResponse']>;
  PatchedInvitationStageRequestInput: PatchedInvitationStageRequestInput;
  StagesInvitationStagesDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesInvitationStagesDestroyResponse']>;
  StagesPasswordCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesPasswordCreateResponse']>;
  PasswordStageRequestInput: PasswordStageRequestInput;
  StagesPasswordUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesPasswordUpdateResponse']>;
  StagesPasswordPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesPasswordPartialUpdateResponse']>;
  PatchedPasswordStageRequestInput: PatchedPasswordStageRequestInput;
  StagesPasswordDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesPasswordDestroyResponse']>;
  StagesPromptPromptsCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesPromptPromptsCreateResponse']>;
  PromptRequestInput: PromptRequestInput;
  StageRequestInput: StageRequestInput;
  StagesPromptPromptsUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesPromptPromptsUpdateResponse']>;
  StagesPromptPromptsPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesPromptPromptsPartialUpdateResponse']>;
  PatchedPromptRequestInput: PatchedPromptRequestInput;
  StagesPromptPromptsDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesPromptPromptsDestroyResponse']>;
  StagesPromptPromptsPreviewCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesPromptPromptsPreviewCreateResponse']>;
  StagesPromptStagesCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesPromptStagesCreateResponse']>;
  PromptStageRequestInput: PromptStageRequestInput;
  StagesPromptStagesUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesPromptStagesUpdateResponse']>;
  StagesPromptStagesPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesPromptStagesPartialUpdateResponse']>;
  PatchedPromptStageRequestInput: PatchedPromptStageRequestInput;
  StagesPromptStagesDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesPromptStagesDestroyResponse']>;
  StagesSourceCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesSourceCreateResponse']>;
  SourceStageRequestInput: SourceStageRequestInput;
  StagesSourceUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesSourceUpdateResponse']>;
  StagesSourcePartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesSourcePartialUpdateResponse']>;
  PatchedSourceStageRequestInput: PatchedSourceStageRequestInput;
  StagesSourceDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesSourceDestroyResponse']>;
  StagesUserDeleteCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesUserDeleteCreateResponse']>;
  UserDeleteStageRequestInput: UserDeleteStageRequestInput;
  StagesUserDeleteUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesUserDeleteUpdateResponse']>;
  StagesUserDeletePartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesUserDeletePartialUpdateResponse']>;
  PatchedUserDeleteStageRequestInput: PatchedUserDeleteStageRequestInput;
  StagesUserDeleteDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesUserDeleteDestroyResponse']>;
  StagesUserLoginCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesUserLoginCreateResponse']>;
  UserLoginStageRequestInput: UserLoginStageRequestInput;
  StagesUserLoginUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesUserLoginUpdateResponse']>;
  StagesUserLoginPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesUserLoginPartialUpdateResponse']>;
  PatchedUserLoginStageRequestInput: PatchedUserLoginStageRequestInput;
  StagesUserLoginDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesUserLoginDestroyResponse']>;
  StagesUserLogoutCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesUserLogoutCreateResponse']>;
  UserLogoutStageRequestInput: UserLogoutStageRequestInput;
  StagesUserLogoutUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesUserLogoutUpdateResponse']>;
  StagesUserLogoutPartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesUserLogoutPartialUpdateResponse']>;
  PatchedUserLogoutStageRequestInput: PatchedUserLogoutStageRequestInput;
  StagesUserLogoutDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesUserLogoutDestroyResponse']>;
  StagesUserWriteCreateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesUserWriteCreateResponse']>;
  UserWriteStageRequestInput: UserWriteStageRequestInput;
  StagesUserWriteUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesUserWriteUpdateResponse']>;
  StagesUserWritePartialUpdateResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesUserWritePartialUpdateResponse']>;
  PatchedUserWriteStageRequestInput: PatchedUserWriteStageRequestInput;
  StagesUserWriteDestroyResponse: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StagesUserWriteDestroyResponse']>;
  ObjMap: ResolverTypeWrapper<Scalars['ObjMap']['output']>;
  HttpMethod: HttpMethod;
  ResolveToSourceArgs: ResolverTypeWrapper<Scalars['ResolveToSourceArgs']['output']>;
}>;

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = ResolversObject<{
  Query: {};
  Subscription: {};
  ChurrosAnnouncement: Omit<ChurrosAnnouncement, 'by'> & { by?: Maybe<ResolversParentTypes['ChurrosUser']> };
  ChurrosAnswer: ResolversInterfaceTypes<ResolversParentTypes>['ChurrosAnswer'];
  ChurrosAnswerDate: Omit<ChurrosAnswerDate, 'createdBy' | 'form' | 'question' | 'section'> & { createdBy?: Maybe<ResolversParentTypes['ChurrosUser']>, form: ResolversParentTypes['ChurrosForm'], question: ResolversParentTypes['ChurrosQuestionScalar'], section: ResolversParentTypes['ChurrosFormSection'] };
  ChurrosAnswerFileUpload: Omit<ChurrosAnswerFileUpload, 'createdBy' | 'form' | 'question' | 'section'> & { createdBy?: Maybe<ResolversParentTypes['ChurrosUser']>, form: ResolversParentTypes['ChurrosForm'], question: ResolversParentTypes['ChurrosQuestionFileUpload'], section: ResolversParentTypes['ChurrosFormSection'] };
  ChurrosAnswerInput: ChurrosAnswerInput;
  ChurrosAnswerLongText: Omit<ChurrosAnswerLongText, 'createdBy' | 'form' | 'question' | 'section'> & { createdBy?: Maybe<ResolversParentTypes['ChurrosUser']>, form: ResolversParentTypes['ChurrosForm'], question: ResolversParentTypes['ChurrosQuestionScalar'], section: ResolversParentTypes['ChurrosFormSection'] };
  ChurrosAnswerNumber: Omit<ChurrosAnswerNumber, 'createdBy' | 'form' | 'question' | 'section'> & { createdBy?: Maybe<ResolversParentTypes['ChurrosUser']>, form: ResolversParentTypes['ChurrosForm'], question: ResolversParentTypes['ChurrosQuestionScalar'], section: ResolversParentTypes['ChurrosFormSection'] };
  ChurrosAnswerScale: Omit<ChurrosAnswerScale, 'createdBy' | 'form' | 'question' | 'section'> & { createdBy?: Maybe<ResolversParentTypes['ChurrosUser']>, form: ResolversParentTypes['ChurrosForm'], question: ResolversParentTypes['ChurrosQuestionScale'], section: ResolversParentTypes['ChurrosFormSection'] };
  ChurrosAnswerSearchResult: Omit<ChurrosAnswerSearchResult, 'answer'> & { answer: ResolversParentTypes['ChurrosAnswer'] };
  ChurrosAnswerSelectMultiple: Omit<ChurrosAnswerSelectMultiple, 'createdBy' | 'form' | 'question' | 'section'> & { createdBy?: Maybe<ResolversParentTypes['ChurrosUser']>, form: ResolversParentTypes['ChurrosForm'], question: ResolversParentTypes['ChurrosQuestionSelectMultiple'], section: ResolversParentTypes['ChurrosFormSection'] };
  ChurrosAnswerSelectOne: Omit<ChurrosAnswerSelectOne, 'createdBy' | 'form' | 'question' | 'section'> & { createdBy?: Maybe<ResolversParentTypes['ChurrosUser']>, form: ResolversParentTypes['ChurrosForm'], question: ResolversParentTypes['ChurrosQuestionSelectOne'], section: ResolversParentTypes['ChurrosFormSection'] };
  ChurrosAnswerText: Omit<ChurrosAnswerText, 'createdBy' | 'form' | 'question' | 'section'> & { createdBy?: Maybe<ResolversParentTypes['ChurrosUser']>, form: ResolversParentTypes['ChurrosForm'], question: ResolversParentTypes['ChurrosQuestionScalar'], section: ResolversParentTypes['ChurrosFormSection'] };
  ChurrosAnswerTime: Omit<ChurrosAnswerTime, 'answer' | 'createdBy' | 'form' | 'question' | 'section'> & { answer: ResolversParentTypes['ChurrosAnswer'], createdBy?: Maybe<ResolversParentTypes['ChurrosUser']>, form: ResolversParentTypes['ChurrosForm'], question: ResolversParentTypes['ChurrosQuestionScalar'], section: ResolversParentTypes['ChurrosFormSection'] };
  ChurrosAnswersOfUser: Omit<ChurrosAnswersOfUser, 'answers' | 'user'> & { answers: Array<ResolversParentTypes['ChurrosAnswer']>, user: ResolversParentTypes['ChurrosUser'] };
  ChurrosApiRateLimitHits: Omit<ChurrosApiRateLimitHits, 'user'> & { user?: Maybe<ResolversParentTypes['ChurrosUser']> };
  ChurrosApiUsage: Omit<ChurrosApiUsage, 'user'> & { user?: Maybe<ResolversParentTypes['ChurrosUser']> };
  ChurrosArticle: Omit<ChurrosArticle, 'author' | 'event' | 'group'> & { author?: Maybe<ResolversParentTypes['ChurrosUser']>, event?: Maybe<ResolversParentTypes['ChurrosEvent']>, group: ResolversParentTypes['ChurrosGroup'] };
  ChurrosArticleSearchResultType: Omit<ChurrosArticleSearchResultType, 'article'> & { article: ResolversParentTypes['ChurrosArticle'] };
  ChurrosAwaitingValidationError: ChurrosAwaitingValidationError;
  ChurrosBarWeek: Omit<ChurrosBarWeek, 'groups'> & { groups: Array<ResolversParentTypes['ChurrosGroup']> };
  Boolean: Scalars['Boolean']['output'];
  ChurrosBooleanMap: Scalars['ChurrosBooleanMap']['output'];
  ChurrosBuildInfo: ChurrosBuildInfo;
  ChurrosChangelogRelease: ChurrosChangelogRelease;
  ChurrosComment: Omit<ChurrosComment, 'author'> & { author?: Maybe<ResolversParentTypes['ChurrosUser']> };
  ChurrosCommentable: ResolversInterfaceTypes<ResolversParentTypes>['ChurrosCommentable'];
  ChurrosCommentsConnection: ChurrosCommentsConnection;
  ChurrosCommentsEdge: ChurrosCommentsEdge;
  ChurrosCompleteSignupResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosCompleteSignupResult'];
  ChurrosContributionOption: ChurrosContributionOption;
  ChurrosCounts: Scalars['ChurrosCounts']['output'];
  ChurrosCredential: Omit<ChurrosCredential, 'user'> & { user: ResolversParentTypes['ChurrosUser'] };
  ChurrosDatabaseHealthCheck: ChurrosDatabaseHealthCheck;
  DateTime: Scalars['DateTime']['output'];
  ChurrosDocument: Omit<ChurrosDocument, 'uploader'> & { uploader?: Maybe<ResolversParentTypes['ChurrosUser']> };
  ChurrosDocumentSearchResult: ChurrosDocumentSearchResult;
  ChurrosEmailChange: Omit<ChurrosEmailChange, 'user'> & { user: ResolversParentTypes['ChurrosUser'] };
  ChurrosError: ChurrosError;
  ChurrosErrorInterface: ResolversInterfaceTypes<ResolversParentTypes>['ChurrosErrorInterface'];
  ChurrosEvenSearchResult: Omit<ChurrosEvenSearchResult, 'event'> & { event: ResolversParentTypes['ChurrosEvent'] };
  ChurrosEvent: Omit<ChurrosEvent, 'articles' | 'author' | 'bannedUsers' | 'beneficiary' | 'bookingsCsv' | 'coOrganizers' | 'forms' | 'group' | 'managers' | 'myBookings'> & { articles: Array<ResolversParentTypes['ChurrosArticle']>, author?: Maybe<ResolversParentTypes['ChurrosUser']>, bannedUsers: Array<ResolversParentTypes['ChurrosUser']>, beneficiary?: Maybe<ResolversParentTypes['ChurrosLydiaAccount']>, bookingsCsv: ResolversParentTypes['ChurrosEventBookingsCsvResult'], coOrganizers: Array<ResolversParentTypes['ChurrosGroup']>, forms: Array<ResolversParentTypes['ChurrosForm']>, group: ResolversParentTypes['ChurrosGroup'], managers: Array<ResolversParentTypes['ChurrosEventManager']>, myBookings: ResolversParentTypes['ChurrosEventMyBookingsResult'] };
  ChurrosEventBookingsConnection: ChurrosEventBookingsConnection;
  ChurrosEventBookingsConnectionEdge: ChurrosEventBookingsConnectionEdge;
  ChurrosEventBookingsCsvResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosEventBookingsCsvResult'];
  ChurrosEventBookingsCsvSuccess: ChurrosEventBookingsCsvSuccess;
  ChurrosEventLogsConnection: ChurrosEventLogsConnection;
  ChurrosEventLogsConnectionEdge: ChurrosEventLogsConnectionEdge;
  ChurrosEventManager: Omit<ChurrosEventManager, 'event' | 'user'> & { event: ResolversParentTypes['ChurrosEvent'], user: ResolversParentTypes['ChurrosUser'] };
  ChurrosEventMyBookingsResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosEventMyBookingsResult'];
  ChurrosEventMyBookingsSuccess: ChurrosEventMyBookingsSuccess;
  ChurrosEventsByDay: Omit<ChurrosEventsByDay, 'happening' | 'shotgunning'> & { happening: Array<ResolversParentTypes['ChurrosEvent']>, shotgunning: Array<ResolversParentTypes['ChurrosEvent']> };
  ChurrosFamilyTree: Omit<ChurrosFamilyTree, 'users'> & { users: Array<ResolversParentTypes['ChurrosUser']> };
  ChurrosFile: Scalars['ChurrosFile']['output'];
  Float: Scalars['Float']['output'];
  ChurrosForm: Omit<ChurrosForm, 'answers' | 'answersByUser' | 'createdBy' | 'event' | 'group' | 'myAnswers' | 'questions' | 'searchAnswers' | 'section' | 'sections'> & { answers: ResolversParentTypes['ChurrosFormAnswersConnection'], answersByUser: ResolversParentTypes['ChurrosFormAnswersByUserConnection'], createdBy?: Maybe<ResolversParentTypes['ChurrosUser']>, event?: Maybe<ResolversParentTypes['ChurrosEvent']>, group?: Maybe<ResolversParentTypes['ChurrosGroup']>, myAnswers: Array<ResolversParentTypes['ChurrosAnswer']>, questions: ResolversParentTypes['ChurrosFormQuestionsConnection'], searchAnswers: Array<ResolversParentTypes['ChurrosAnswerSearchResult']>, section: ResolversParentTypes['ChurrosFormSection'], sections: Array<ResolversParentTypes['ChurrosFormSection']> };
  ChurrosFormAnswersByUserConnection: Omit<ChurrosFormAnswersByUserConnection, 'edges' | 'nodes'> & { edges: Array<ResolversParentTypes['ChurrosFormAnswersByUserConnectionEdge']>, nodes: Array<ResolversParentTypes['ChurrosAnswersOfUser']> };
  ChurrosFormAnswersByUserConnectionEdge: Omit<ChurrosFormAnswersByUserConnectionEdge, 'node'> & { node: ResolversParentTypes['ChurrosAnswersOfUser'] };
  ChurrosFormAnswersConnection: Omit<ChurrosFormAnswersConnection, 'edges' | 'nodes'> & { edges: Array<ResolversParentTypes['ChurrosFormAnswersConnectionEdge']>, nodes: Array<ResolversParentTypes['ChurrosAnswer']> };
  ChurrosFormAnswersConnectionEdge: Omit<ChurrosFormAnswersConnectionEdge, 'node'> & { node: ResolversParentTypes['ChurrosAnswer'] };
  ChurrosFormQuestionsConnection: Omit<ChurrosFormQuestionsConnection, 'edges' | 'nodes'> & { edges: Array<ResolversParentTypes['ChurrosFormQuestionsConnectionEdge']>, nodes: Array<ResolversParentTypes['ChurrosQuestion']> };
  ChurrosFormQuestionsConnectionEdge: Omit<ChurrosFormQuestionsConnectionEdge, 'node'> & { node: ResolversParentTypes['ChurrosQuestion'] };
  ChurrosFormSearchResult: Omit<ChurrosFormSearchResult, 'form'> & { form: ResolversParentTypes['ChurrosForm'] };
  ChurrosFormSection: Omit<ChurrosFormSection, 'answers' | 'form' | 'nextSection' | 'questions' | 'restrictedToGroups'> & { answers: ResolversParentTypes['ChurrosFormSectionAnswersConnection'], form: ResolversParentTypes['ChurrosForm'], nextSection?: Maybe<ResolversParentTypes['ChurrosFormSection']>, questions: Array<ResolversParentTypes['ChurrosQuestion']>, restrictedToGroups: Array<ResolversParentTypes['ChurrosGroup']> };
  ChurrosFormSectionAnswersConnection: Omit<ChurrosFormSectionAnswersConnection, 'edges' | 'nodes'> & { edges: Array<ResolversParentTypes['ChurrosFormSectionAnswersConnectionEdge']>, nodes: Array<ResolversParentTypes['ChurrosAnswer']> };
  ChurrosFormSectionAnswersConnectionEdge: Omit<ChurrosFormSectionAnswersConnectionEdge, 'node'> & { node: ResolversParentTypes['ChurrosAnswer'] };
  ChurrosGodparentRequest: Omit<ChurrosGodparentRequest, 'godchild' | 'godparent'> & { godchild: ResolversParentTypes['ChurrosUser'], godparent: ResolversParentTypes['ChurrosUser'] };
  ChurrosGroup: Omit<ChurrosGroup, 'ancestors' | 'articles' | 'boardMembers' | 'children' | 'coOrganizedEvents' | 'events' | 'familyChildren' | 'forms' | 'lydiaAccounts' | 'members' | 'ownEvents' | 'parent' | 'president' | 'related' | 'root' | 'secretaries' | 'shopItem' | 'shopItems' | 'shopOrders' | 'treasurers' | 'vicePresidents'> & { ancestors: Array<ResolversParentTypes['ChurrosGroup']>, articles: Array<ResolversParentTypes['ChurrosArticle']>, boardMembers: Array<ResolversParentTypes['ChurrosGroupMember']>, children: Array<ResolversParentTypes['ChurrosGroup']>, coOrganizedEvents: Array<ResolversParentTypes['ChurrosEvent']>, events: ResolversParentTypes['ChurrosGroupEventsConnection'], familyChildren: Array<ResolversParentTypes['ChurrosGroup']>, forms: Array<ResolversParentTypes['ChurrosForm']>, lydiaAccounts: Array<ResolversParentTypes['ChurrosLydiaAccount']>, members: Array<ResolversParentTypes['ChurrosGroupMember']>, ownEvents: Array<ResolversParentTypes['ChurrosEvent']>, parent?: Maybe<ResolversParentTypes['ChurrosGroup']>, president?: Maybe<ResolversParentTypes['ChurrosGroupMember']>, related: Array<ResolversParentTypes['ChurrosGroup']>, root?: Maybe<ResolversParentTypes['ChurrosGroup']>, secretaries: Array<ResolversParentTypes['ChurrosGroupMember']>, shopItem?: Maybe<ResolversParentTypes['ChurrosShopItem']>, shopItems: ResolversParentTypes['ChurrosGroupShopItemsConnection'], shopOrders: Array<ResolversParentTypes['ChurrosShopPayment']>, treasurers: Array<ResolversParentTypes['ChurrosGroupMember']>, vicePresidents: Array<ResolversParentTypes['ChurrosGroupMember']> };
  ChurrosGroupEventsConnection: Omit<ChurrosGroupEventsConnection, 'edges' | 'nodes'> & { edges: Array<ResolversParentTypes['ChurrosGroupEventsConnectionEdge']>, nodes: Array<ResolversParentTypes['ChurrosEvent']> };
  ChurrosGroupEventsConnectionEdge: Omit<ChurrosGroupEventsConnectionEdge, 'node'> & { node: ResolversParentTypes['ChurrosEvent'] };
  ChurrosGroupMember: Omit<ChurrosGroupMember, 'group' | 'member'> & { group: ResolversParentTypes['ChurrosGroup'], member: ResolversParentTypes['ChurrosUser'] };
  ChurrosGroupSearchResult: Omit<ChurrosGroupSearchResult, 'group'> & { group: ResolversParentTypes['ChurrosGroup'] };
  ChurrosGroupShopItemsConnection: Omit<ChurrosGroupShopItemsConnection, 'edges' | 'nodes'> & { edges: Array<ResolversParentTypes['ChurrosGroupShopItemsConnectionEdge']>, nodes: Array<ResolversParentTypes['ChurrosShopItem']> };
  ChurrosGroupShopItemsConnectionEdge: Omit<ChurrosGroupShopItemsConnectionEdge, 'node'> & { node: ResolversParentTypes['ChurrosShopItem'] };
  ChurrosHealthCheck: ChurrosHealthCheck;
  ID: Scalars['ID']['output'];
  Int: Scalars['Int']['output'];
  ChurrosIssue: ChurrosIssue;
  ChurrosIssueComment: ChurrosIssueComment;
  ChurrosLdapHealthCheck: ChurrosLdapHealthCheck;
  ChurrosLink: ChurrosLink;
  ChurrosLinkInput: ChurrosLinkInput;
  ChurrosLocalID: Scalars['ChurrosLocalID']['output'];
  ChurrosLogEntry: Omit<ChurrosLogEntry, 'user'> & { user?: Maybe<ResolversParentTypes['ChurrosUser']> };
  ChurrosLydiaAccount: Omit<ChurrosLydiaAccount, 'events' | 'group'> & { events: Array<ResolversParentTypes['ChurrosEvent']>, group?: Maybe<ResolversParentTypes['ChurrosGroup']> };
  ChurrosMailHealthCheck: ChurrosMailHealthCheck;
  ChurrosMajor: ChurrosMajor;
  ChurrosManagerOfEventInput: ChurrosManagerOfEventInput;
  ChurrosMinor: Omit<ChurrosMinor, 'users'> & { users: Array<ResolversParentTypes['ChurrosUser']> };
  ChurrosMutationAcceptRegistrationResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosMutationAcceptRegistrationResult'];
  ChurrosMutationAcceptRegistrationSuccess: Omit<ChurrosMutationAcceptRegistrationSuccess, 'data'> & { data: ResolversParentTypes['ChurrosUser'] };
  ChurrosMutationAddFileToPageResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosMutationAddFileToPageResult'];
  ChurrosMutationAddFileToPageSuccess: ChurrosMutationAddFileToPageSuccess;
  ChurrosMutationAddGroupMemberResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosMutationAddGroupMemberResult'];
  ChurrosMutationAddGroupMemberSuccess: Omit<ChurrosMutationAddGroupMemberSuccess, 'data'> & { data: ResolversParentTypes['ChurrosGroupMember'] };
  ChurrosMutationAnswerFormSectionResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosMutationAnswerFormSectionResult'];
  ChurrosMutationAnswerFormSectionSuccess: Omit<ChurrosMutationAnswerFormSectionSuccess, 'data'> & { data: Array<ResolversParentTypes['ChurrosAnswer']> };
  ChurrosMutationAuthorizeResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosMutationAuthorizeResult'];
  ChurrosMutationAuthorizeSuccess: ChurrosMutationAuthorizeSuccess;
  ChurrosMutationCancelRegistrationResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosMutationCancelRegistrationResult'];
  ChurrosMutationCancelRegistrationSuccess: ChurrosMutationCancelRegistrationSuccess;
  ChurrosMutationCompleteRegistrationResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosMutationCompleteRegistrationResult'];
  ChurrosMutationCompleteRegistrationSuccess: Omit<ChurrosMutationCompleteRegistrationSuccess, 'data'> & { data: ResolversParentTypes['ChurrosCompleteSignupResult'] };
  ChurrosMutationContributeResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosMutationContributeResult'];
  ChurrosMutationContributeSuccess: ChurrosMutationContributeSuccess;
  ChurrosMutationCreatePasswordResetResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosMutationCreatePasswordResetResult'];
  ChurrosMutationCreatePasswordResetSuccess: ChurrosMutationCreatePasswordResetSuccess;
  ChurrosMutationDeletePageResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosMutationDeletePageResult'];
  ChurrosMutationDeletePageSuccess: ChurrosMutationDeletePageSuccess;
  ChurrosMutationDeleteShopItemResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosMutationDeleteShopItemResult'];
  ChurrosMutationDeleteShopItemSuccess: ChurrosMutationDeleteShopItemSuccess;
  ChurrosMutationFinishPaypalRegistrationPaymentResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosMutationFinishPaypalRegistrationPaymentResult'];
  ChurrosMutationFinishPaypalRegistrationPaymentSuccess: ChurrosMutationFinishPaypalRegistrationPaymentSuccess;
  ChurrosMutationLoginResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosMutationLoginResult'];
  ChurrosMutationLoginSuccess: Omit<ChurrosMutationLoginSuccess, 'data'> & { data: ResolversParentTypes['ChurrosCredential'] };
  ChurrosMutationMailFormAnswersResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosMutationMailFormAnswersResult'];
  ChurrosMutationMailFormAnswersSuccess: ChurrosMutationMailFormAnswersSuccess;
  ChurrosMutationOpposeRegistrationResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosMutationOpposeRegistrationResult'];
  ChurrosMutationOpposeRegistrationSuccess: ChurrosMutationOpposeRegistrationSuccess;
  ChurrosMutationPaidRegistrationResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosMutationPaidRegistrationResult'];
  ChurrosMutationPaidRegistrationSuccess: ChurrosMutationPaidRegistrationSuccess;
  ChurrosMutationPaidShopPaymentResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosMutationPaidShopPaymentResult'];
  ChurrosMutationPaidShopPaymentSuccess: Omit<ChurrosMutationPaidShopPaymentSuccess, 'data'> & { data: ResolversParentTypes['ChurrosShopPayment'] };
  ChurrosMutationRegisterGoogleCredentialResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosMutationRegisterGoogleCredentialResult'];
  ChurrosMutationRegisterGoogleCredentialSuccess: ChurrosMutationRegisterGoogleCredentialSuccess;
  ChurrosMutationRemoveFileFromPageResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosMutationRemoveFileFromPageResult'];
  ChurrosMutationRemoveFileFromPageSuccess: ChurrosMutationRemoveFileFromPageSuccess;
  ChurrosMutationRequestEmailChangeResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosMutationRequestEmailChangeResult'];
  ChurrosMutationRequestEmailChangeSuccess: ChurrosMutationRequestEmailChangeSuccess;
  ChurrosMutationResetPasswordResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosMutationResetPasswordResult'];
  ChurrosMutationResetPasswordSuccess: ChurrosMutationResetPasswordSuccess;
  ChurrosMutationStartRegistrationResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosMutationStartRegistrationResult'];
  ChurrosMutationStartRegistrationSuccess: ChurrosMutationStartRegistrationSuccess;
  ChurrosMutationUpdateUserCandidateResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosMutationUpdateUserCandidateResult'];
  ChurrosMutationUpdateUserCandidateSuccess: ChurrosMutationUpdateUserCandidateSuccess;
  ChurrosMutationUpdateUserResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosMutationUpdateUserResult'];
  ChurrosMutationUpdateUserSuccess: Omit<ChurrosMutationUpdateUserSuccess, 'data'> & { data: ResolversParentTypes['ChurrosUser'] };
  ChurrosMutationUpsertAnnouncementResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosMutationUpsertAnnouncementResult'];
  ChurrosMutationUpsertAnnouncementSuccess: Omit<ChurrosMutationUpsertAnnouncementSuccess, 'data'> & { data: ResolversParentTypes['ChurrosAnnouncement'] };
  ChurrosMutationUpsertArticleResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosMutationUpsertArticleResult'];
  ChurrosMutationUpsertArticleSuccess: Omit<ChurrosMutationUpsertArticleSuccess, 'data'> & { data: ResolversParentTypes['ChurrosArticle'] };
  ChurrosMutationUpsertBarWeekResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosMutationUpsertBarWeekResult'];
  ChurrosMutationUpsertBarWeekSuccess: Omit<ChurrosMutationUpsertBarWeekSuccess, 'data'> & { data: ResolversParentTypes['ChurrosBarWeek'] };
  ChurrosMutationUpsertDocumentResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosMutationUpsertDocumentResult'];
  ChurrosMutationUpsertDocumentSuccess: ChurrosMutationUpsertDocumentSuccess;
  ChurrosMutationUpsertEventResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosMutationUpsertEventResult'];
  ChurrosMutationUpsertEventSuccess: Omit<ChurrosMutationUpsertEventSuccess, 'data'> & { data: ResolversParentTypes['ChurrosEvent'] };
  ChurrosMutationUpsertFormInput: ChurrosMutationUpsertFormInput;
  ChurrosMutationUpsertFormSectionInput: ChurrosMutationUpsertFormSectionInput;
  ChurrosMutationUpsertGodparentRequestResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosMutationUpsertGodparentRequestResult'];
  ChurrosMutationUpsertGodparentRequestSuccess: Omit<ChurrosMutationUpsertGodparentRequestSuccess, 'data'> & { data: ResolversParentTypes['ChurrosGodparentRequest'] };
  ChurrosMutationUpsertGroupResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosMutationUpsertGroupResult'];
  ChurrosMutationUpsertGroupSuccess: Omit<ChurrosMutationUpsertGroupSuccess, 'data'> & { data: ResolversParentTypes['ChurrosGroup'] };
  ChurrosMutationUpsertPageResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosMutationUpsertPageResult'];
  ChurrosMutationUpsertPageSuccess: ChurrosMutationUpsertPageSuccess;
  ChurrosMutationUpsertQuestionInput: ChurrosMutationUpsertQuestionInput;
  ChurrosMutationUpsertRegistrationResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosMutationUpsertRegistrationResult'];
  ChurrosMutationUpsertRegistrationSuccess: ChurrosMutationUpsertRegistrationSuccess;
  ChurrosMutationUpsertServiceResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosMutationUpsertServiceResult'];
  ChurrosMutationUpsertServiceSuccess: ChurrosMutationUpsertServiceSuccess;
  ChurrosMutationUpsertShopItemResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosMutationUpsertShopItemResult'];
  ChurrosMutationUpsertShopItemSuccess: Omit<ChurrosMutationUpsertShopItemSuccess, 'data'> & { data: ResolversParentTypes['ChurrosShopItem'] };
  ChurrosMutationUpsertShopPaymentResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosMutationUpsertShopPaymentResult'];
  ChurrosMutationUpsertShopPaymentSuccess: Omit<ChurrosMutationUpsertShopPaymentSuccess, 'data'> & { data: ResolversParentTypes['ChurrosShopPayment'] };
  ChurrosMutationUsePasswordResetResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosMutationUsePasswordResetResult'];
  ChurrosMutationUsePasswordResetSuccess: ChurrosMutationUsePasswordResetSuccess;
  ChurrosMutationValidateEmailResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosMutationValidateEmailResult'];
  ChurrosMutationValidateEmailSuccess: ChurrosMutationValidateEmailSuccess;
  ChurrosMutationVerifyBookingResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosMutationVerifyBookingResult'];
  ChurrosMutationVerifyBookingSuccess: ChurrosMutationVerifyBookingSuccess;
  ChurrosNode: ResolversInterfaceTypes<ResolversParentTypes>['ChurrosNode'];
  ChurrosNotFoundError: ChurrosNotFoundError;
  ChurrosNotification: Omit<ChurrosNotification, 'group' | 'subscription'> & { group?: Maybe<ResolversParentTypes['ChurrosGroup']>, subscription: ResolversParentTypes['ChurrosNotificationSubscription'] };
  ChurrosNotificationSubscription: Omit<ChurrosNotificationSubscription, 'owner'> & { owner: ResolversParentTypes['ChurrosUser'] };
  ChurrosNotificationSubscriptionKeysInput: ChurrosNotificationSubscriptionKeysInput;
  ChurrosOAuth2Error: ChurrosOAuth2Error;
  ChurrosPage: Omit<ChurrosPage, 'group' | 'lastAuthor'> & { group?: Maybe<ResolversParentTypes['ChurrosGroup']>, lastAuthor?: Maybe<ResolversParentTypes['ChurrosUser']> };
  ChurrosPageInfo: ChurrosPageInfo;
  ChurrosPagesConnection: ChurrosPagesConnection;
  ChurrosPagesEdge: ChurrosPagesEdge;
  ChurrosPicture: ChurrosPicture;
  ChurrosPictured: ResolversInterfaceTypes<ResolversParentTypes>['ChurrosPictured'];
  ChurrosProfitsBreakdown: ChurrosProfitsBreakdown;
  ChurrosProfitsBreakdownByPaymentMethod: ChurrosProfitsBreakdownByPaymentMethod;
  ChurrosProfitsBreakdownByTicket: ChurrosProfitsBreakdownByTicket;
  ChurrosQRCode: ChurrosQRCode;
  ChurrosQueryAllFormsConnection: Omit<ChurrosQueryAllFormsConnection, 'edges' | 'nodes'> & { edges: Array<ResolversParentTypes['ChurrosQueryAllFormsConnectionEdge']>, nodes: Array<ResolversParentTypes['ChurrosForm']> };
  ChurrosQueryAllFormsConnectionEdge: Omit<ChurrosQueryAllFormsConnectionEdge, 'node'> & { node: ResolversParentTypes['ChurrosForm'] };
  ChurrosQueryAllUsersConnection: Omit<ChurrosQueryAllUsersConnection, 'edges' | 'nodes'> & { edges: Array<ResolversParentTypes['ChurrosQueryAllUsersConnectionEdge']>, nodes: Array<ResolversParentTypes['ChurrosUser']> };
  ChurrosQueryAllUsersConnectionEdge: Omit<ChurrosQueryAllUsersConnectionEdge, 'node'> & { node: ResolversParentTypes['ChurrosUser'] };
  ChurrosQueryAnnouncementsConnection: Omit<ChurrosQueryAnnouncementsConnection, 'edges' | 'nodes'> & { edges: Array<ResolversParentTypes['ChurrosQueryAnnouncementsConnectionEdge']>, nodes: Array<ResolversParentTypes['ChurrosAnnouncement']> };
  ChurrosQueryAnnouncementsConnectionEdge: Omit<ChurrosQueryAnnouncementsConnectionEdge, 'node'> & { node: ResolversParentTypes['ChurrosAnnouncement'] };
  ChurrosQueryCodeContributorsResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosQueryCodeContributorsResult'];
  ChurrosQueryCodeContributorsSuccess: Omit<ChurrosQueryCodeContributorsSuccess, 'data'> & { data: Array<ResolversParentTypes['ChurrosUser']> };
  ChurrosQueryCombinedChangelogResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosQueryCombinedChangelogResult'];
  ChurrosQueryCombinedChangelogSuccess: ChurrosQueryCombinedChangelogSuccess;
  ChurrosQueryDocumentsConnection: ChurrosQueryDocumentsConnection;
  ChurrosQueryDocumentsConnectionEdge: ChurrosQueryDocumentsConnectionEdge;
  ChurrosQueryEventsByDayConnection: Omit<ChurrosQueryEventsByDayConnection, 'edges' | 'nodes'> & { edges: Array<ResolversParentTypes['ChurrosQueryEventsByDayConnectionEdge']>, nodes: Array<ResolversParentTypes['ChurrosEventsByDay']> };
  ChurrosQueryEventsByDayConnectionEdge: Omit<ChurrosQueryEventsByDayConnectionEdge, 'node'> & { node: ResolversParentTypes['ChurrosEventsByDay'] };
  ChurrosQueryEventsConnection: Omit<ChurrosQueryEventsConnection, 'edges' | 'nodes'> & { edges: Array<ResolversParentTypes['ChurrosQueryEventsConnectionEdge']>, nodes: Array<ResolversParentTypes['ChurrosEvent']> };
  ChurrosQueryEventsConnectionEdge: Omit<ChurrosQueryEventsConnectionEdge, 'node'> & { node: ResolversParentTypes['ChurrosEvent'] };
  ChurrosQueryFormsConnection: Omit<ChurrosQueryFormsConnection, 'edges' | 'nodes'> & { edges: Array<ResolversParentTypes['ChurrosQueryFormsConnectionEdge']>, nodes: Array<ResolversParentTypes['ChurrosForm']> };
  ChurrosQueryFormsConnectionEdge: Omit<ChurrosQueryFormsConnectionEdge, 'node'> & { node: ResolversParentTypes['ChurrosForm'] };
  ChurrosQueryGroupMembersCsvResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosQueryGroupMembersCsvResult'];
  ChurrosQueryGroupMembersCsvSuccess: ChurrosQueryGroupMembersCsvSuccess;
  ChurrosQueryHomepageConnection: Omit<ChurrosQueryHomepageConnection, 'edges' | 'nodes'> & { edges: Array<ResolversParentTypes['ChurrosQueryHomepageConnectionEdge']>, nodes: Array<ResolversParentTypes['ChurrosArticle']> };
  ChurrosQueryHomepageConnectionEdge: Omit<ChurrosQueryHomepageConnectionEdge, 'node'> & { node: ResolversParentTypes['ChurrosArticle'] };
  ChurrosQueryLogsConnection: ChurrosQueryLogsConnection;
  ChurrosQueryLogsConnectionEdge: ChurrosQueryLogsConnectionEdge;
  ChurrosQueryMinorsConnection: ChurrosQueryMinorsConnection;
  ChurrosQueryMinorsConnectionEdge: ChurrosQueryMinorsConnectionEdge;
  ChurrosQueryNotificationsConnection: Omit<ChurrosQueryNotificationsConnection, 'edges' | 'nodes'> & { edges: Array<ResolversParentTypes['ChurrosQueryNotificationsConnectionEdge']>, nodes: Array<ResolversParentTypes['ChurrosNotification']> };
  ChurrosQueryNotificationsConnectionEdge: Omit<ChurrosQueryNotificationsConnectionEdge, 'node'> & { node: ResolversParentTypes['ChurrosNotification'] };
  ChurrosQueryPagesConnection: ChurrosQueryPagesConnection;
  ChurrosQueryPagesConnectionEdge: ChurrosQueryPagesConnectionEdge;
  ChurrosQueryQuickSignupsConnection: ChurrosQueryQuickSignupsConnection;
  ChurrosQueryQuickSignupsConnectionEdge: ChurrosQueryQuickSignupsConnectionEdge;
  ChurrosQueryReactionsConnection: Omit<ChurrosQueryReactionsConnection, 'edges' | 'nodes'> & { edges: Array<ResolversParentTypes['ChurrosQueryReactionsConnectionEdge']>, nodes: Array<ResolversParentTypes['ChurrosReaction']> };
  ChurrosQueryReactionsConnectionEdge: Omit<ChurrosQueryReactionsConnectionEdge, 'node'> & { node: ResolversParentTypes['ChurrosReaction'] };
  ChurrosQueryRegistrationResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosQueryRegistrationResult'];
  ChurrosQueryRegistrationSuccess: ChurrosQueryRegistrationSuccess;
  ChurrosQueryRegistrationsOfUserConnection: ChurrosQueryRegistrationsOfUserConnection;
  ChurrosQueryRegistrationsOfUserConnectionEdge: ChurrosQueryRegistrationsOfUserConnectionEdge;
  ChurrosQueryUpcomingChangelogResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosQueryUpcomingChangelogResult'];
  ChurrosQueryUpcomingChangelogSuccess: ChurrosQueryUpcomingChangelogSuccess;
  ChurrosQueryUserCandidatesConnection: ChurrosQueryUserCandidatesConnection;
  ChurrosQueryUserCandidatesConnectionEdge: ChurrosQueryUserCandidatesConnectionEdge;
  ChurrosQuestion: ResolversInterfaceTypes<ResolversParentTypes>['ChurrosQuestion'];
  ChurrosQuestionAnswersConnection: Omit<ChurrosQuestionAnswersConnection, 'edges' | 'nodes'> & { edges: Array<ResolversParentTypes['ChurrosQuestionAnswersConnectionEdge']>, nodes: Array<ResolversParentTypes['ChurrosAnswer']> };
  ChurrosQuestionAnswersConnectionEdge: Omit<ChurrosQuestionAnswersConnectionEdge, 'node'> & { node: ResolversParentTypes['ChurrosAnswer'] };
  ChurrosQuestionFileUpload: Omit<ChurrosQuestionFileUpload, 'answers' | 'defaultAnswer' | 'myAnswer' | 'section'> & { answers: ResolversParentTypes['ChurrosQuestionAnswersConnection'], defaultAnswer?: Maybe<ResolversParentTypes['ChurrosAnswer']>, myAnswer?: Maybe<ResolversParentTypes['ChurrosAnswer']>, section: ResolversParentTypes['ChurrosFormSection'] };
  ChurrosQuestionOptionInput: ChurrosQuestionOptionInput;
  ChurrosQuestionScalar: Omit<ChurrosQuestionScalar, 'answers' | 'defaultAnswer' | 'myAnswer' | 'section'> & { answers: ResolversParentTypes['ChurrosQuestionAnswersConnection'], defaultAnswer?: Maybe<ResolversParentTypes['ChurrosAnswer']>, myAnswer?: Maybe<ResolversParentTypes['ChurrosAnswer']>, section: ResolversParentTypes['ChurrosFormSection'] };
  ChurrosQuestionScale: Omit<ChurrosQuestionScale, 'answerCounts' | 'answers' | 'defaultAnswer' | 'myAnswer' | 'section'> & { answerCounts: Array<ResolversParentTypes['ChurrosStringToIntMapping']>, answers: ResolversParentTypes['ChurrosQuestionAnswersConnection'], defaultAnswer?: Maybe<ResolversParentTypes['ChurrosAnswer']>, myAnswer?: Maybe<ResolversParentTypes['ChurrosAnswer']>, section: ResolversParentTypes['ChurrosFormSection'] };
  ChurrosQuestionScaleInput: ChurrosQuestionScaleInput;
  ChurrosQuestionSelectMultiple: Omit<ChurrosQuestionSelectMultiple, 'answerCounts' | 'answers' | 'defaultAnswer' | 'myAnswer' | 'section'> & { answerCounts: Array<ResolversParentTypes['ChurrosStringToIntMapping']>, answers: ResolversParentTypes['ChurrosQuestionAnswersConnection'], defaultAnswer?: Maybe<ResolversParentTypes['ChurrosAnswer']>, myAnswer?: Maybe<ResolversParentTypes['ChurrosAnswer']>, section: ResolversParentTypes['ChurrosFormSection'] };
  ChurrosQuestionSelectOne: Omit<ChurrosQuestionSelectOne, 'answerCounts' | 'answers' | 'defaultAnswer' | 'groups' | 'jumps' | 'myAnswer' | 'section'> & { answerCounts: Array<ResolversParentTypes['ChurrosStringToIntMapping']>, answers: ResolversParentTypes['ChurrosQuestionAnswersConnection'], defaultAnswer?: Maybe<ResolversParentTypes['ChurrosAnswer']>, groups: Array<Maybe<ResolversParentTypes['ChurrosGroup']>>, jumps: Array<Maybe<ResolversParentTypes['ChurrosFormSection']>>, myAnswer?: Maybe<ResolversParentTypes['ChurrosAnswer']>, section: ResolversParentTypes['ChurrosFormSection'] };
  ChurrosQuickSignup: ChurrosQuickSignup;
  ChurrosReactable: ResolversInterfaceTypes<ResolversParentTypes>['ChurrosReactable'];
  ChurrosReaction: Omit<ChurrosReaction, 'author'> & { author?: Maybe<ResolversParentTypes['ChurrosUser']> };
  ChurrosRedisHealthCheck: ChurrosRedisHealthCheck;
  ChurrosRegistration: Omit<ChurrosRegistration, 'author' | 'beneficiaryUser' | 'cancelledBy' | 'opposedBy' | 'verifiedBy'> & { author?: Maybe<ResolversParentTypes['ChurrosUser']>, beneficiaryUser?: Maybe<ResolversParentTypes['ChurrosUser']>, cancelledBy?: Maybe<ResolversParentTypes['ChurrosUser']>, opposedBy?: Maybe<ResolversParentTypes['ChurrosUser']>, verifiedBy?: Maybe<ResolversParentTypes['ChurrosUser']> };
  ChurrosRegistrationSearchResult: ChurrosRegistrationSearchResult;
  ChurrosRegistrationVerificationResult: ChurrosRegistrationVerificationResult;
  ChurrosRegistrationsCounts: ChurrosRegistrationsCounts;
  ChurrosReleaseChange: ChurrosReleaseChange;
  ChurrosReleaseChangesMaps: ChurrosReleaseChangesMaps;
  ChurrosSchool: ChurrosSchool;
  ChurrosSchoolGroup: ChurrosSchoolGroup;
  ChurrosSchoolInput: ChurrosSchoolInput;
  ChurrosService: Omit<ChurrosService, 'group'> & { group?: Maybe<ResolversParentTypes['ChurrosGroup']> };
  ChurrosShopItem: Omit<ChurrosShopItem, 'group' | 'itemOptions' | 'lydiaAccount' | 'shopPayments'> & { group: ResolversParentTypes['ChurrosGroup'], itemOptions: Array<ResolversParentTypes['ChurrosShopItemOption']>, lydiaAccount?: Maybe<ResolversParentTypes['ChurrosLydiaAccount']>, shopPayments: Array<ResolversParentTypes['ChurrosShopPayment']> };
  ChurrosShopItemAnswer: Omit<ChurrosShopItemAnswer, 'shopPayment'> & { shopPayment: ResolversParentTypes['ChurrosShopPayment'] };
  ChurrosShopItemOption: Omit<ChurrosShopItemOption, 'shopItem'> & { shopItem: ResolversParentTypes['ChurrosShopItem'] };
  ChurrosShopItemOptionInput: ChurrosShopItemOptionInput;
  ChurrosShopPayment: Omit<ChurrosShopPayment, 'shopItem' | 'shopItemAnswer' | 'user'> & { shopItem: ResolversParentTypes['ChurrosShopItem'], shopItemAnswer?: Maybe<ResolversParentTypes['ChurrosShopItemAnswer']>, user: ResolversParentTypes['ChurrosUser'] };
  String: Scalars['String']['output'];
  ChurrosStringToIntMapping: ChurrosStringToIntMapping;
  ChurrosStudentAssociation: ChurrosStudentAssociation;
  ChurrosStudentAssociationGroupsConnection: Omit<ChurrosStudentAssociationGroupsConnection, 'nodes'> & { nodes: Array<ResolversParentTypes['ChurrosGroup']> };
  ChurrosStudentAssociationGroupsConnectionEdge: Omit<ChurrosStudentAssociationGroupsConnectionEdge, 'node'> & { node: ResolversParentTypes['ChurrosGroup'] };
  ChurrosSubject: ChurrosSubject;
  ChurrosSubjectDocumentsConnection: ChurrosSubjectDocumentsConnection;
  ChurrosSubjectDocumentsConnectionEdge: ChurrosSubjectDocumentsConnectionEdge;
  ChurrosSubscriptionRegistrationResult: ResolversUnionTypes<ResolversParentTypes>['ChurrosSubscriptionRegistrationResult'];
  ChurrosSubscriptionRegistrationSuccess: ChurrosSubscriptionRegistrationSuccess;
  ChurrosTeachingUnit: ChurrosTeachingUnit;
  ChurrosThirdPartyApp: Omit<ChurrosThirdPartyApp, 'owner'> & { owner: ResolversParentTypes['ChurrosGroup'] };
  ChurrosThirdPartyAppApiUsageConnection: ChurrosThirdPartyAppApiUsageConnection;
  ChurrosThirdPartyAppApiUsageConnectionEdge: ChurrosThirdPartyAppApiUsageConnectionEdge;
  ChurrosThirdPartyAppLogsConnection: ChurrosThirdPartyAppLogsConnection;
  ChurrosThirdPartyAppLogsConnectionEdge: ChurrosThirdPartyAppLogsConnectionEdge;
  ChurrosThirdPartyAppRateLimitHitsConnection: ChurrosThirdPartyAppRateLimitHitsConnection;
  ChurrosThirdPartyAppRateLimitHitsConnectionEdge: ChurrosThirdPartyAppRateLimitHitsConnectionEdge;
  ChurrosThirdPartyAppRegistrationResponse: ChurrosThirdPartyAppRegistrationResponse;
  ChurrosThirdPartyAppUsersConnection: Omit<ChurrosThirdPartyAppUsersConnection, 'nodes'> & { nodes: Array<ResolversParentTypes['ChurrosUser']> };
  ChurrosThirdPartyAppUsersConnectionEdge: Omit<ChurrosThirdPartyAppUsersConnectionEdge, 'node'> & { node: ResolversParentTypes['ChurrosUser'] };
  ChurrosTicket: Omit<ChurrosTicket, 'autojoinGroups' | 'event' | 'openToGroups'> & { autojoinGroups: Array<ResolversParentTypes['ChurrosGroup']>, event: ResolversParentTypes['ChurrosEvent'], openToGroups: Array<ResolversParentTypes['ChurrosGroup']> };
  ChurrosTicketGroup: Omit<ChurrosTicketGroup, 'event'> & { event: ResolversParentTypes['ChurrosEvent'] };
  ChurrosTicketGroupInput: ChurrosTicketGroupInput;
  ChurrosTicketInput: ChurrosTicketInput;
  ChurrosUID: Scalars['ChurrosUID']['output'];
  ChurrosUpsertGroupInput: ChurrosUpsertGroupInput;
  ChurrosUser: Omit<ChurrosUser, 'allowedApps' | 'answeredForms' | 'articles' | 'authorizedApps' | 'boardMemberships' | 'canCreatePostsOn' | 'credentials' | 'emailChangeRequests' | 'familyTree' | 'godchildren' | 'godparent' | 'groups' | 'incomingGodparentRequests' | 'managedEvents' | 'outgoingGodparentRequests' | 'partiallyAnsweredForms'> & { allowedApps: Array<ResolversParentTypes['ChurrosThirdPartyApp']>, answeredForms: ResolversParentTypes['ChurrosUserAnsweredFormsConnection'], articles: ResolversParentTypes['ChurrosUserArticlesConnection'], authorizedApps: Array<ResolversParentTypes['ChurrosThirdPartyApp']>, boardMemberships: Array<ResolversParentTypes['ChurrosGroupMember']>, canCreatePostsOn: Array<ResolversParentTypes['ChurrosGroup']>, credentials: Array<ResolversParentTypes['ChurrosCredential']>, emailChangeRequests: Array<ResolversParentTypes['ChurrosEmailChange']>, familyTree: ResolversParentTypes['ChurrosFamilyTree'], godchildren: Array<ResolversParentTypes['ChurrosUser']>, godparent?: Maybe<ResolversParentTypes['ChurrosUser']>, groups: Array<ResolversParentTypes['ChurrosGroupMember']>, incomingGodparentRequests: Array<ResolversParentTypes['ChurrosGodparentRequest']>, managedEvents: Array<ResolversParentTypes['ChurrosEventManager']>, outgoingGodparentRequests: Array<ResolversParentTypes['ChurrosGodparentRequest']>, partiallyAnsweredForms: ResolversParentTypes['ChurrosUserPartiallyAnsweredFormsConnection'] };
  ChurrosUserAnsweredFormsConnection: Omit<ChurrosUserAnsweredFormsConnection, 'edges' | 'nodes'> & { edges: Array<ResolversParentTypes['ChurrosUserAnsweredFormsConnectionEdge']>, nodes: Array<ResolversParentTypes['ChurrosForm']> };
  ChurrosUserAnsweredFormsConnectionEdge: Omit<ChurrosUserAnsweredFormsConnectionEdge, 'node'> & { node: ResolversParentTypes['ChurrosForm'] };
  ChurrosUserArticlesConnection: Omit<ChurrosUserArticlesConnection, 'edges' | 'nodes'> & { edges: Array<ResolversParentTypes['ChurrosUserArticlesConnectionEdge']>, nodes: Array<ResolversParentTypes['ChurrosArticle']> };
  ChurrosUserArticlesConnectionEdge: Omit<ChurrosUserArticlesConnectionEdge, 'node'> & { node: ResolversParentTypes['ChurrosArticle'] };
  ChurrosUserBookingsConnection: ChurrosUserBookingsConnection;
  ChurrosUserBookingsConnectionEdge: ChurrosUserBookingsConnectionEdge;
  ChurrosUserCandidate: ChurrosUserCandidate;
  ChurrosUserPartiallyAnsweredFormsConnection: Omit<ChurrosUserPartiallyAnsweredFormsConnection, 'edges' | 'nodes'> & { edges: Array<ResolversParentTypes['ChurrosUserPartiallyAnsweredFormsConnectionEdge']>, nodes: Array<ResolversParentTypes['ChurrosForm']> };
  ChurrosUserPartiallyAnsweredFormsConnectionEdge: Omit<ChurrosUserPartiallyAnsweredFormsConnectionEdge, 'node'> & { node: ResolversParentTypes['ChurrosForm'] };
  ChurrosUserSearchResult: Omit<ChurrosUserSearchResult, 'user'> & { user: ResolversParentTypes['ChurrosUser'] };
  ChurrosZodError: ChurrosZodError;
  ChurrosZodFieldError: ChurrosZodFieldError;
  Mutation: {};
  AdminAppsListResponse: ResolversUnionTypes<ResolversParentTypes>['AdminAppsListResponse'];
  App: App;
  ValidationError: ValidationError;
  JSON: Scalars['JSON']['output'];
  GenericError: GenericError;
  AdminMetricsRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['AdminMetricsRetrieveResponse'];
  LoginMetrics: LoginMetrics;
  Coordinate: Coordinate;
  AdminModelsListResponse: ResolversUnionTypes<ResolversParentTypes>['AdminModelsListResponse'];
  AdminSettingsRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['AdminSettingsRetrieveResponse'];
  Settings: Settings;
  PositiveInt: Scalars['PositiveInt']['output'];
  AdminSystemRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['AdminSystemRetrieveResponse'];
  SystemInfo: SystemInfo;
  QueryAdminSystemRetrieveOneOf_0Runtime: QueryAdminSystemRetrieveOneOf_0Runtime;
  AdminVersionRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['AdminVersionRetrieveResponse'];
  Version: Version;
  AdminWorkersRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['AdminWorkersRetrieveResponse'];
  Workers: Workers;
  AuthenticatorsAdminAllListResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsAdminAllListResponse'];
  Device: Device;
  AuthenticatorsAdminDuoListResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsAdminDuoListResponse'];
  PaginatedDuoDeviceList: PaginatedDuoDeviceList;
  Pagination: Pagination;
  DuoDevice: DuoDevice;
  QueryAuthenticatorsAdminDuoListOneOf_0ResultsItemsName: Scalars['QueryAuthenticatorsAdminDuoListOneOf_0ResultsItemsName']['output'];
  AuthenticatorsAdminDuoRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsAdminDuoRetrieveResponse'];
  AuthenticatorsAdminSmsListResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsAdminSmsListResponse'];
  PaginatedSmsDeviceList: PaginatedSmsDeviceList;
  SmsDevice: SmsDevice;
  QueryAuthenticatorsAdminSmsListOneOf_0ResultsItemsName: Scalars['QueryAuthenticatorsAdminSmsListOneOf_0ResultsItemsName']['output'];
  AuthenticatorsAdminSmsRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsAdminSmsRetrieveResponse'];
  AuthenticatorsAdminStaticListResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsAdminStaticListResponse'];
  PaginatedStaticDeviceList: PaginatedStaticDeviceList;
  StaticDevice: StaticDevice;
  QueryAuthenticatorsAdminStaticListOneOf_0ResultsItemsName: Scalars['QueryAuthenticatorsAdminStaticListOneOf_0ResultsItemsName']['output'];
  StaticDeviceToken: StaticDeviceToken;
  QueryAuthenticatorsAdminStaticListOneOf_0ResultsItemsTokenSetItemsToken: Scalars['QueryAuthenticatorsAdminStaticListOneOf_0ResultsItemsTokenSetItemsToken']['output'];
  AuthenticatorsAdminStaticRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsAdminStaticRetrieveResponse'];
  AuthenticatorsAdminTotpListResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsAdminTotpListResponse'];
  PaginatedTotpDeviceList: PaginatedTotpDeviceList;
  TotpDevice: TotpDevice;
  QueryAuthenticatorsAdminTotpListOneOf_0ResultsItemsName: Scalars['QueryAuthenticatorsAdminTotpListOneOf_0ResultsItemsName']['output'];
  AuthenticatorsAdminTotpRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsAdminTotpRetrieveResponse'];
  AuthenticatorsAdminWebauthnListResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsAdminWebauthnListResponse'];
  PaginatedWebAuthnDeviceList: PaginatedWebAuthnDeviceList;
  WebAuthnDevice: WebAuthnDevice;
  QueryAuthenticatorsAdminWebauthnListOneOf_0ResultsItemsName: Scalars['QueryAuthenticatorsAdminWebauthnListOneOf_0ResultsItemsName']['output'];
  WebAuthnDeviceType: WebAuthnDeviceType;
  UUID: Scalars['UUID']['output'];
  AuthenticatorsAdminWebauthnRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsAdminWebauthnRetrieveResponse'];
  AuthenticatorsAllListResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsAllListResponse'];
  AuthenticatorsDuoListResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsDuoListResponse'];
  AuthenticatorsDuoRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsDuoRetrieveResponse'];
  AuthenticatorsDuoUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsDuoUsedByListResponse'];
  UsedBy: UsedBy;
  AuthenticatorsSmsListResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsSmsListResponse'];
  AuthenticatorsSmsRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsSmsRetrieveResponse'];
  AuthenticatorsSmsUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsSmsUsedByListResponse'];
  AuthenticatorsStaticListResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsStaticListResponse'];
  AuthenticatorsStaticRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsStaticRetrieveResponse'];
  AuthenticatorsStaticUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsStaticUsedByListResponse'];
  AuthenticatorsTotpListResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsTotpListResponse'];
  AuthenticatorsTotpRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsTotpRetrieveResponse'];
  AuthenticatorsTotpUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsTotpUsedByListResponse'];
  AuthenticatorsWebauthnListResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsWebauthnListResponse'];
  AuthenticatorsWebauthnRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsWebauthnRetrieveResponse'];
  AuthenticatorsWebauthnUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsWebauthnUsedByListResponse'];
  CoreApplicationsListResponse: ResolversUnionTypes<ResolversParentTypes>['CoreApplicationsListResponse'];
  PaginatedApplicationList: Omit<PaginatedApplicationList, 'results'> & { results: Array<Maybe<ResolversParentTypes['Application']>> };
  Application: Omit<Application, 'providerObj' | 'backchannelProvidersObj' | 'churrosGroup' | 'metrics'> & { providerObj: ResolversParentTypes['Provider'], backchannelProvidersObj: Array<Maybe<ResolversParentTypes['Provider']>>, churrosGroup: ResolversParentTypes['ChurrosGroup'], metrics?: Maybe<Array<Maybe<ResolversParentTypes['CoreApplicationsMetricsListResponse']>>> };
  QueryCoreApplicationsListOneOf_0ResultsItemsSlug: Scalars['QueryCoreApplicationsListOneOf_0ResultsItemsSlug']['output'];
  Provider: Omit<Provider, 'application'> & { application?: Maybe<ResolversParentTypes['CoreApplicationsRetrieveResponse']> };
  URL: Scalars['URL']['output'];
  CoreApplicationsRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['CoreApplicationsRetrieveResponse'];
  CoreApplicationsCheckAccessRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['CoreApplicationsCheckAccessRetrieveResponse'];
  PolicyTestResult: PolicyTestResult;
  LogEvent: LogEvent;
  CoreApplicationsMetricsListResponse: ResolversUnionTypes<ResolversParentTypes>['CoreApplicationsMetricsListResponse'];
  CoreApplicationsUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['CoreApplicationsUsedByListResponse'];
  CoreAuthenticatedSessionsListResponse: ResolversUnionTypes<ResolversParentTypes>['CoreAuthenticatedSessionsListResponse'];
  PaginatedAuthenticatedSessionList: PaginatedAuthenticatedSessionList;
  AuthenticatedSession: AuthenticatedSession;
  QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgent: QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgent;
  QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentDevice: QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentDevice;
  QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentOs: QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentOs;
  QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentUserAgent: QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentUserAgent;
  QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsGeoIp: QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsGeoIp;
  QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsAsn: QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsAsn;
  CoreAuthenticatedSessionsRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['CoreAuthenticatedSessionsRetrieveResponse'];
  CoreAuthenticatedSessionsUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['CoreAuthenticatedSessionsUsedByListResponse'];
  CoreBrandsListResponse: ResolversUnionTypes<ResolversParentTypes>['CoreBrandsListResponse'];
  PaginatedBrandList: PaginatedBrandList;
  Brand: Brand;
  CoreBrandsRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['CoreBrandsRetrieveResponse'];
  CoreBrandsUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['CoreBrandsUsedByListResponse'];
  CoreBrandsCurrentRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['CoreBrandsCurrentRetrieveResponse'];
  CurrentBrand: CurrentBrand;
  FooterLink: FooterLink;
  CoreGroupsListResponse: ResolversUnionTypes<ResolversParentTypes>['CoreGroupsListResponse'];
  PaginatedGroupList: PaginatedGroupList;
  Group: Group;
  QueryCoreGroupsListOneOf_0ResultsItemsName: Scalars['QueryCoreGroupsListOneOf_0ResultsItemsName']['output'];
  GroupMember: GroupMember;
  QueryCoreGroupsListOneOf_0ResultsItemsUsersObjItemsUsername: Scalars['QueryCoreGroupsListOneOf_0ResultsItemsUsersObjItemsUsername']['output'];
  EmailAddress: Scalars['EmailAddress']['output'];
  Role: Role;
  QueryCoreGroupsListOneOf_0ResultsItemsRolesObjItemsName: Scalars['QueryCoreGroupsListOneOf_0ResultsItemsRolesObjItemsName']['output'];
  CoreGroupsRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['CoreGroupsRetrieveResponse'];
  CoreGroupsUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['CoreGroupsUsedByListResponse'];
  CoreTokensListResponse: ResolversUnionTypes<ResolversParentTypes>['CoreTokensListResponse'];
  PaginatedTokenList: PaginatedTokenList;
  Token: Token;
  QueryCoreTokensListOneOf_0ResultsItemsIdentifier: Scalars['QueryCoreTokensListOneOf_0ResultsItemsIdentifier']['output'];
  User: User;
  QueryCoreTokensListOneOf_0ResultsItemsUserObjUsername: Scalars['QueryCoreTokensListOneOf_0ResultsItemsUserObjUsername']['output'];
  UserGroup: UserGroup;
  QueryCoreTokensListOneOf_0ResultsItemsUserObjGroupsObjItemsName: Scalars['QueryCoreTokensListOneOf_0ResultsItemsUserObjGroupsObjItemsName']['output'];
  CoreTokensRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['CoreTokensRetrieveResponse'];
  CoreTokensUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['CoreTokensUsedByListResponse'];
  CoreTokensViewKeyRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['CoreTokensViewKeyRetrieveResponse'];
  TokenView: TokenView;
  CoreUserConsentListResponse: ResolversUnionTypes<ResolversParentTypes>['CoreUserConsentListResponse'];
  PaginatedUserConsentList: Omit<PaginatedUserConsentList, 'results'> & { results: Array<Maybe<ResolversParentTypes['UserConsent']>> };
  UserConsent: Omit<UserConsent, 'application'> & { application: ResolversParentTypes['Application'] };
  CoreUserConsentRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['CoreUserConsentRetrieveResponse'];
  CoreUserConsentUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['CoreUserConsentUsedByListResponse'];
  CoreUsersListResponse: ResolversUnionTypes<ResolversParentTypes>['CoreUsersListResponse'];
  PaginatedUserList: PaginatedUserList;
  CoreUsersRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['CoreUsersRetrieveResponse'];
  CoreUsersMetricsRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['CoreUsersMetricsRetrieveResponse'];
  UserMetrics: UserMetrics;
  CoreUsersUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['CoreUsersUsedByListResponse'];
  CoreUsersImpersonateEndRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['CoreUsersImpersonateEndRetrieveResponse'];
  VoidContainer: VoidContainer;
  Void: Scalars['Void']['output'];
  CoreUsersMeRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['CoreUsersMeRetrieveResponse'];
  SessionUser: SessionUser;
  UserSelf: UserSelf;
  QueryCoreUsersMeRetrieveOneOf_0UserUsername: Scalars['QueryCoreUsersMeRetrieveOneOf_0UserUsername']['output'];
  UserSelfGroups: UserSelfGroups;
  CoreUsersPathsRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['CoreUsersPathsRetrieveResponse'];
  UserPath: UserPath;
  CryptoCertificatekeypairsListResponse: ResolversUnionTypes<ResolversParentTypes>['CryptoCertificatekeypairsListResponse'];
  PaginatedCertificateKeyPairList: PaginatedCertificateKeyPairList;
  CertificateKeyPair: CertificateKeyPair;
  CryptoCertificatekeypairsRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['CryptoCertificatekeypairsRetrieveResponse'];
  CryptoCertificatekeypairsUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['CryptoCertificatekeypairsUsedByListResponse'];
  CryptoCertificatekeypairsViewCertificateRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['CryptoCertificatekeypairsViewCertificateRetrieveResponse'];
  CertificateData: CertificateData;
  CryptoCertificatekeypairsViewPrivateKeyRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['CryptoCertificatekeypairsViewPrivateKeyRetrieveResponse'];
  EnterpriseLicenseListResponse: ResolversUnionTypes<ResolversParentTypes>['EnterpriseLicenseListResponse'];
  PaginatedLicenseList: PaginatedLicenseList;
  License: License;
  EnterpriseLicenseRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['EnterpriseLicenseRetrieveResponse'];
  EnterpriseLicenseUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['EnterpriseLicenseUsedByListResponse'];
  EnterpriseLicenseForecastRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['EnterpriseLicenseForecastRetrieveResponse'];
  LicenseForecast: LicenseForecast;
  EnterpriseLicenseGetInstallIdRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['EnterpriseLicenseGetInstallIdRetrieveResponse'];
  InstallId: InstallId;
  EnterpriseLicenseSummaryRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['EnterpriseLicenseSummaryRetrieveResponse'];
  LicenseSummary: LicenseSummary;
  EventsEventsListResponse: ResolversUnionTypes<ResolversParentTypes>['EventsEventsListResponse'];
  PaginatedEventList: PaginatedEventList;
  Event: Event;
  EventsEventsRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['EventsEventsRetrieveResponse'];
  EventsEventsActionsListResponse: ResolversUnionTypes<ResolversParentTypes>['EventsEventsActionsListResponse'];
  TypeCreate: TypeCreate;
  EventsEventsPerMonthListResponse: ResolversUnionTypes<ResolversParentTypes>['EventsEventsPerMonthListResponse'];
  EventsEventsTopPerUserListResponse: ResolversUnionTypes<ResolversParentTypes>['EventsEventsTopPerUserListResponse'];
  EventTopPerUser: EventTopPerUser;
  EventsEventsVolumeListResponse: ResolversUnionTypes<ResolversParentTypes>['EventsEventsVolumeListResponse'];
  EventsNotificationsListResponse: ResolversUnionTypes<ResolversParentTypes>['EventsNotificationsListResponse'];
  PaginatedNotificationList: PaginatedNotificationList;
  Notification: Notification;
  EventsNotificationsRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['EventsNotificationsRetrieveResponse'];
  EventsNotificationsUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['EventsNotificationsUsedByListResponse'];
  EventsRulesListResponse: ResolversUnionTypes<ResolversParentTypes>['EventsRulesListResponse'];
  PaginatedNotificationRuleList: PaginatedNotificationRuleList;
  NotificationRule: NotificationRule;
  EventsRulesRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['EventsRulesRetrieveResponse'];
  EventsRulesUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['EventsRulesUsedByListResponse'];
  EventsSystemTasksListResponse: ResolversUnionTypes<ResolversParentTypes>['EventsSystemTasksListResponse'];
  PaginatedSystemTaskList: PaginatedSystemTaskList;
  SystemTask: SystemTask;
  EventsSystemTasksRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['EventsSystemTasksRetrieveResponse'];
  EventsTransportsListResponse: ResolversUnionTypes<ResolversParentTypes>['EventsTransportsListResponse'];
  PaginatedNotificationTransportList: PaginatedNotificationTransportList;
  NotificationTransport: NotificationTransport;
  EventsTransportsRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['EventsTransportsRetrieveResponse'];
  EventsTransportsUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['EventsTransportsUsedByListResponse'];
  FlowsBindingsListResponse: ResolversUnionTypes<ResolversParentTypes>['FlowsBindingsListResponse'];
  PaginatedFlowStageBindingList: PaginatedFlowStageBindingList;
  FlowStageBinding: FlowStageBinding;
  Stage: Stage;
  FlowSet: FlowSet;
  QueryFlowsBindingsListOneOf_0ResultsItemsStageObjFlowSetItemsSlug: Scalars['QueryFlowsBindingsListOneOf_0ResultsItemsStageObjFlowSetItemsSlug']['output'];
  FlowsBindingsRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['FlowsBindingsRetrieveResponse'];
  FlowsBindingsUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['FlowsBindingsUsedByListResponse'];
  FlowsExecutorGetResponse: ResolversUnionTypes<ResolversParentTypes>['FlowsExecutorGetResponse'];
  AccessDeniedChallenge: AccessDeniedChallenge;
  ContextualFlowInfo: ContextualFlowInfo;
  AppleLoginChallenge: AppleLoginChallenge;
  AuthenticatorDuoChallenge: AuthenticatorDuoChallenge;
  AuthenticatorSmsChallenge: AuthenticatorSmsChallenge;
  AuthenticatorStaticChallenge: AuthenticatorStaticChallenge;
  AuthenticatorTotpChallenge: AuthenticatorTotpChallenge;
  AuthenticatorValidationChallenge: AuthenticatorValidationChallenge;
  DeviceChallenge: DeviceChallenge;
  SelectableStage: SelectableStage;
  AuthenticatorWebAuthnChallenge: AuthenticatorWebAuthnChallenge;
  AutosubmitChallenge: AutosubmitChallenge;
  CaptchaChallenge: CaptchaChallenge;
  ConsentChallenge: ConsentChallenge;
  ConsentPermission: ConsentPermission;
  EmailChallenge: EmailChallenge;
  FlowErrorChallenge: FlowErrorChallenge;
  IdentificationChallenge: Omit<IdentificationChallenge, 'sources'> & { sources?: Maybe<Array<Maybe<ResolversParentTypes['LoginSource']>>> };
  LoginSource: Omit<LoginSource, 'challenge'> & { challenge: ResolversParentTypes['LoginChallengeTypes'] };
  LoginChallengeTypes: ResolversUnionTypes<ResolversParentTypes>['LoginChallengeTypes'];
  RedirectChallenge: RedirectChallenge;
  PlexAuthenticationChallenge: PlexAuthenticationChallenge;
  OAuthDeviceCodeChallenge: OAuthDeviceCodeChallenge;
  OAuthDeviceCodeFinishChallenge: OAuthDeviceCodeFinishChallenge;
  PasswordChallenge: PasswordChallenge;
  PromptChallenge: PromptChallenge;
  StagePrompt: StagePrompt;
  ShellChallenge: ShellChallenge;
  UserLoginChallenge: UserLoginChallenge;
  FlowsInspectorGetResponse: ResolversUnionTypes<ResolversParentTypes>['FlowsInspectorGetResponse'];
  FlowInspection: FlowInspection;
  FlowInspectorPlan: FlowInspectorPlan;
  FlowsInstancesListResponse: ResolversUnionTypes<ResolversParentTypes>['FlowsInstancesListResponse'];
  PaginatedFlowList: PaginatedFlowList;
  Flow: Flow;
  QueryFlowsInstancesListOneOf_0ResultsItemsSlug: Scalars['QueryFlowsInstancesListOneOf_0ResultsItemsSlug']['output'];
  FlowsInstancesRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['FlowsInstancesRetrieveResponse'];
  FlowsInstancesDiagramRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['FlowsInstancesDiagramRetrieveResponse'];
  FlowDiagram: FlowDiagram;
  FlowsInstancesExecuteRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['FlowsInstancesExecuteRetrieveResponse'];
  Link: Link;
  FlowsInstancesExportRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['FlowsInstancesExportRetrieveResponse'];
  FileContainer: FileContainer;
  File: Scalars['File']['output'];
  FlowsInstancesUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['FlowsInstancesUsedByListResponse'];
  FlowsInstancesCacheInfoRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['FlowsInstancesCacheInfoRetrieveResponse'];
  Cache: Cache;
  ManagedBlueprintsListResponse: ResolversUnionTypes<ResolversParentTypes>['ManagedBlueprintsListResponse'];
  PaginatedBlueprintInstanceList: PaginatedBlueprintInstanceList;
  BlueprintInstance: BlueprintInstance;
  ManagedBlueprintsRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['ManagedBlueprintsRetrieveResponse'];
  ManagedBlueprintsUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['ManagedBlueprintsUsedByListResponse'];
  ManagedBlueprintsAvailableListResponse: ResolversUnionTypes<ResolversParentTypes>['ManagedBlueprintsAvailableListResponse'];
  BlueprintFile: BlueprintFile;
  Metadata: Metadata;
  Oauth2AccessTokensListResponse: ResolversUnionTypes<ResolversParentTypes>['Oauth2AccessTokensListResponse'];
  PaginatedTokenModelList: PaginatedTokenModelList;
  TokenModel: TokenModel;
  OAuth2Provider: OAuth2Provider;
  QueryOauth2AccessTokensListOneOf_0ResultsItemsProviderClientId: Scalars['QueryOauth2AccessTokensListOneOf_0ResultsItemsProviderClientId']['output'];
  QueryOauth2AccessTokensListOneOf_0ResultsItemsProviderClientSecret: Scalars['QueryOauth2AccessTokensListOneOf_0ResultsItemsProviderClientSecret']['output'];
  Oauth2AccessTokensRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['Oauth2AccessTokensRetrieveResponse'];
  Oauth2AccessTokensUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['Oauth2AccessTokensUsedByListResponse'];
  Oauth2AuthorizationCodesListResponse: ResolversUnionTypes<ResolversParentTypes>['Oauth2AuthorizationCodesListResponse'];
  PaginatedExpiringBaseGrantModelList: PaginatedExpiringBaseGrantModelList;
  ExpiringBaseGrantModel: ExpiringBaseGrantModel;
  Oauth2AuthorizationCodesRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['Oauth2AuthorizationCodesRetrieveResponse'];
  Oauth2AuthorizationCodesUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['Oauth2AuthorizationCodesUsedByListResponse'];
  Oauth2RefreshTokensListResponse: ResolversUnionTypes<ResolversParentTypes>['Oauth2RefreshTokensListResponse'];
  Oauth2RefreshTokensRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['Oauth2RefreshTokensRetrieveResponse'];
  Oauth2RefreshTokensUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['Oauth2RefreshTokensUsedByListResponse'];
  OutpostsInstancesListResponse: ResolversUnionTypes<ResolversParentTypes>['OutpostsInstancesListResponse'];
  PaginatedOutpostList: Omit<PaginatedOutpostList, 'results'> & { results: Array<Maybe<ResolversParentTypes['Outpost']>> };
  Outpost: Omit<Outpost, 'providersObj'> & { providersObj: Array<Maybe<ResolversParentTypes['Provider']>> };
  ServiceConnection: ServiceConnection;
  OutpostsInstancesRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['OutpostsInstancesRetrieveResponse'];
  OutpostsInstancesHealthListResponse: ResolversUnionTypes<ResolversParentTypes>['OutpostsInstancesHealthListResponse'];
  OutpostHealth: OutpostHealth;
  OutpostsInstancesUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['OutpostsInstancesUsedByListResponse'];
  OutpostsInstancesDefaultSettingsRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['OutpostsInstancesDefaultSettingsRetrieveResponse'];
  OutpostDefaultConfig: OutpostDefaultConfig;
  OutpostsLdapListResponse: ResolversUnionTypes<ResolversParentTypes>['OutpostsLdapListResponse'];
  PaginatedLdapOutpostConfigList: PaginatedLdapOutpostConfigList;
  LdapOutpostConfig: LdapOutpostConfig;
  OutpostsLdapRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['OutpostsLdapRetrieveResponse'];
  OutpostsProxyListResponse: ResolversUnionTypes<ResolversParentTypes>['OutpostsProxyListResponse'];
  PaginatedProxyOutpostConfigList: PaginatedProxyOutpostConfigList;
  ProxyOutpostConfig: ProxyOutpostConfig;
  QueryOutpostsProxyListOneOf_0ResultsItemsClientId: Scalars['QueryOutpostsProxyListOneOf_0ResultsItemsClientId']['output'];
  QueryOutpostsProxyListOneOf_0ResultsItemsClientSecret: Scalars['QueryOutpostsProxyListOneOf_0ResultsItemsClientSecret']['output'];
  OpenIdConnectConfiguration: OpenIdConnectConfiguration;
  OutpostsProxyRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['OutpostsProxyRetrieveResponse'];
  OutpostsRadiusListResponse: ResolversUnionTypes<ResolversParentTypes>['OutpostsRadiusListResponse'];
  PaginatedRadiusOutpostConfigList: PaginatedRadiusOutpostConfigList;
  RadiusOutpostConfig: RadiusOutpostConfig;
  OutpostsRadiusRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['OutpostsRadiusRetrieveResponse'];
  OutpostsServiceConnectionsAllListResponse: ResolversUnionTypes<ResolversParentTypes>['OutpostsServiceConnectionsAllListResponse'];
  PaginatedServiceConnectionList: PaginatedServiceConnectionList;
  OutpostsServiceConnectionsAllRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['OutpostsServiceConnectionsAllRetrieveResponse'];
  OutpostsServiceConnectionsAllStateRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['OutpostsServiceConnectionsAllStateRetrieveResponse'];
  ServiceConnectionState: ServiceConnectionState;
  OutpostsServiceConnectionsAllUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['OutpostsServiceConnectionsAllUsedByListResponse'];
  OutpostsServiceConnectionsAllTypesListResponse: ResolversUnionTypes<ResolversParentTypes>['OutpostsServiceConnectionsAllTypesListResponse'];
  OutpostsServiceConnectionsDockerListResponse: ResolversUnionTypes<ResolversParentTypes>['OutpostsServiceConnectionsDockerListResponse'];
  PaginatedDockerServiceConnectionList: PaginatedDockerServiceConnectionList;
  DockerServiceConnection: DockerServiceConnection;
  OutpostsServiceConnectionsDockerRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['OutpostsServiceConnectionsDockerRetrieveResponse'];
  OutpostsServiceConnectionsDockerUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['OutpostsServiceConnectionsDockerUsedByListResponse'];
  OutpostsServiceConnectionsKubernetesListResponse: ResolversUnionTypes<ResolversParentTypes>['OutpostsServiceConnectionsKubernetesListResponse'];
  PaginatedKubernetesServiceConnectionList: PaginatedKubernetesServiceConnectionList;
  KubernetesServiceConnection: KubernetesServiceConnection;
  OutpostsServiceConnectionsKubernetesRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['OutpostsServiceConnectionsKubernetesRetrieveResponse'];
  OutpostsServiceConnectionsKubernetesUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['OutpostsServiceConnectionsKubernetesUsedByListResponse'];
  PoliciesAllListResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesAllListResponse'];
  PaginatedPolicyList: PaginatedPolicyList;
  Policy: Policy;
  PoliciesAllRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesAllRetrieveResponse'];
  PoliciesAllUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesAllUsedByListResponse'];
  PoliciesAllCacheInfoRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesAllCacheInfoRetrieveResponse'];
  PoliciesAllTypesListResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesAllTypesListResponse'];
  PoliciesBindingsListResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesBindingsListResponse'];
  PaginatedPolicyBindingList: PaginatedPolicyBindingList;
  PolicyBinding: PolicyBinding;
  NonNegativeInt: Scalars['NonNegativeInt']['output'];
  PoliciesBindingsRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesBindingsRetrieveResponse'];
  PoliciesBindingsUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesBindingsUsedByListResponse'];
  PoliciesDummyListResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesDummyListResponse'];
  PaginatedDummyPolicyList: PaginatedDummyPolicyList;
  DummyPolicy: DummyPolicy;
  PoliciesDummyRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesDummyRetrieveResponse'];
  PoliciesDummyUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesDummyUsedByListResponse'];
  PoliciesEventMatcherListResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesEventMatcherListResponse'];
  PaginatedEventMatcherPolicyList: PaginatedEventMatcherPolicyList;
  EventMatcherPolicy: EventMatcherPolicy;
  PoliciesEventMatcherRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesEventMatcherRetrieveResponse'];
  PoliciesEventMatcherUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesEventMatcherUsedByListResponse'];
  PoliciesExpressionListResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesExpressionListResponse'];
  PaginatedExpressionPolicyList: PaginatedExpressionPolicyList;
  ExpressionPolicy: ExpressionPolicy;
  PoliciesExpressionRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesExpressionRetrieveResponse'];
  PoliciesExpressionUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesExpressionUsedByListResponse'];
  PoliciesPasswordListResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesPasswordListResponse'];
  PaginatedPasswordPolicyList: PaginatedPasswordPolicyList;
  PasswordPolicy: PasswordPolicy;
  PoliciesPasswordRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesPasswordRetrieveResponse'];
  PoliciesPasswordUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesPasswordUsedByListResponse'];
  PoliciesPasswordExpiryListResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesPasswordExpiryListResponse'];
  PaginatedPasswordExpiryPolicyList: PaginatedPasswordExpiryPolicyList;
  PasswordExpiryPolicy: PasswordExpiryPolicy;
  PoliciesPasswordExpiryRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesPasswordExpiryRetrieveResponse'];
  PoliciesPasswordExpiryUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesPasswordExpiryUsedByListResponse'];
  PoliciesReputationListResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesReputationListResponse'];
  PaginatedReputationPolicyList: PaginatedReputationPolicyList;
  ReputationPolicy: ReputationPolicy;
  PoliciesReputationRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesReputationRetrieveResponse'];
  PoliciesReputationUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesReputationUsedByListResponse'];
  PoliciesReputationScoresListResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesReputationScoresListResponse'];
  PaginatedReputationList: PaginatedReputationList;
  Reputation: Reputation;
  BigInt: Scalars['BigInt']['output'];
  PoliciesReputationScoresRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesReputationScoresRetrieveResponse'];
  PoliciesReputationScoresUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesReputationScoresUsedByListResponse'];
  PropertymappingsAllListResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsAllListResponse'];
  PaginatedPropertyMappingList: PaginatedPropertyMappingList;
  PropertyMapping: PropertyMapping;
  PropertymappingsAllRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsAllRetrieveResponse'];
  PropertymappingsAllUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsAllUsedByListResponse'];
  PropertymappingsAllTypesListResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsAllTypesListResponse'];
  PropertymappingsLdapListResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsLdapListResponse'];
  PaginatedLdapPropertyMappingList: PaginatedLdapPropertyMappingList;
  LdapPropertyMapping: LdapPropertyMapping;
  PropertymappingsLdapRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsLdapRetrieveResponse'];
  PropertymappingsLdapUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsLdapUsedByListResponse'];
  PropertymappingsNotificationListResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsNotificationListResponse'];
  PaginatedNotificationWebhookMappingList: PaginatedNotificationWebhookMappingList;
  NotificationWebhookMapping: NotificationWebhookMapping;
  PropertymappingsNotificationRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsNotificationRetrieveResponse'];
  PropertymappingsNotificationUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsNotificationUsedByListResponse'];
  PropertymappingsRacListResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsRacListResponse'];
  PaginatedRacPropertyMappingList: PaginatedRacPropertyMappingList;
  RacPropertyMapping: RacPropertyMapping;
  PropertymappingsRacRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsRacRetrieveResponse'];
  PropertymappingsRacUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsRacUsedByListResponse'];
  PropertymappingsSamlListResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsSamlListResponse'];
  PaginatedSamlPropertyMappingList: PaginatedSamlPropertyMappingList;
  SamlPropertyMapping: SamlPropertyMapping;
  PropertymappingsSamlRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsSamlRetrieveResponse'];
  PropertymappingsSamlUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsSamlUsedByListResponse'];
  PropertymappingsScimListResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsScimListResponse'];
  PaginatedScimMappingList: PaginatedScimMappingList;
  ScimMapping: ScimMapping;
  PropertymappingsScimRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsScimRetrieveResponse'];
  PropertymappingsScimUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsScimUsedByListResponse'];
  PropertymappingsScopeListResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsScopeListResponse'];
  PaginatedScopeMappingList: PaginatedScopeMappingList;
  ScopeMapping: ScopeMapping;
  PropertymappingsScopeRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsScopeRetrieveResponse'];
  PropertymappingsScopeUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsScopeUsedByListResponse'];
  ProvidersAllListResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersAllListResponse'];
  PaginatedProviderList: Omit<PaginatedProviderList, 'results'> & { results: Array<Maybe<ResolversParentTypes['Provider']>> };
  ProvidersAllRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersAllRetrieveResponse'];
  ProvidersAllUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersAllUsedByListResponse'];
  ProvidersAllTypesListResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersAllTypesListResponse'];
  ProvidersLdapListResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersLdapListResponse'];
  PaginatedLdapProviderList: PaginatedLdapProviderList;
  LdapProvider: LdapProvider;
  ProvidersLdapRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersLdapRetrieveResponse'];
  ProvidersLdapUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersLdapUsedByListResponse'];
  ProvidersOauth2ListResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersOauth2ListResponse'];
  PaginatedOAuth2ProviderList: PaginatedOAuth2ProviderList;
  ProvidersOauth2RetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersOauth2RetrieveResponse'];
  ProvidersOauth2PreviewUserRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersOauth2PreviewUserRetrieveResponse'];
  PropertyMappingPreview: PropertyMappingPreview;
  ProvidersOauth2SetupUrlsRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersOauth2SetupUrlsRetrieveResponse'];
  OAuth2ProviderSetupUrLs: OAuth2ProviderSetupUrLs;
  ProvidersOauth2UsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersOauth2UsedByListResponse'];
  ProvidersProxyListResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersProxyListResponse'];
  PaginatedProxyProviderList: PaginatedProxyProviderList;
  ProxyProvider: ProxyProvider;
  ProvidersProxyRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersProxyRetrieveResponse'];
  ProvidersProxyUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersProxyUsedByListResponse'];
  ProvidersRacListResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersRacListResponse'];
  PaginatedRacProviderList: PaginatedRacProviderList;
  RacProvider: RacProvider;
  ProvidersRacRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersRacRetrieveResponse'];
  ProvidersRacUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersRacUsedByListResponse'];
  ProvidersRadiusListResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersRadiusListResponse'];
  PaginatedRadiusProviderList: PaginatedRadiusProviderList;
  RadiusProvider: RadiusProvider;
  ProvidersRadiusRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersRadiusRetrieveResponse'];
  ProvidersRadiusUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersRadiusUsedByListResponse'];
  ProvidersSamlListResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersSamlListResponse'];
  PaginatedSamlProviderList: PaginatedSamlProviderList;
  SamlProvider: SamlProvider;
  ServiceProviderBinding: ServiceProviderBinding;
  ProvidersSamlRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersSamlRetrieveResponse'];
  ProvidersSamlMetadataRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersSamlMetadataRetrieveResponse'];
  SamlMetadata: SamlMetadata;
  ProvidersSamlPreviewUserRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersSamlPreviewUserRetrieveResponse'];
  ProvidersSamlUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersSamlUsedByListResponse'];
  ProvidersScimListResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersScimListResponse'];
  PaginatedScimProviderList: PaginatedScimProviderList;
  ScimProvider: ScimProvider;
  ProvidersScimRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersScimRetrieveResponse'];
  ProvidersScimSyncStatusRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersScimSyncStatusRetrieveResponse'];
  ScimSyncStatus: ScimSyncStatus;
  ProvidersScimUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersScimUsedByListResponse'];
  RacConnectionTokensListResponse: ResolversUnionTypes<ResolversParentTypes>['RacConnectionTokensListResponse'];
  PaginatedConnectionTokenList: PaginatedConnectionTokenList;
  ConnectionToken: ConnectionToken;
  Endpoint: Endpoint;
  RacConnectionTokensRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['RacConnectionTokensRetrieveResponse'];
  RacConnectionTokensUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['RacConnectionTokensUsedByListResponse'];
  RacEndpointsListResponse: ResolversUnionTypes<ResolversParentTypes>['RacEndpointsListResponse'];
  PaginatedEndpointList: PaginatedEndpointList;
  RacEndpointsRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['RacEndpointsRetrieveResponse'];
  RacEndpointsUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['RacEndpointsUsedByListResponse'];
  RbacPermissionsListResponse: ResolversUnionTypes<ResolversParentTypes>['RbacPermissionsListResponse'];
  PaginatedPermissionList: PaginatedPermissionList;
  Permission: Permission;
  QueryRbacPermissionsListOneOf_0ResultsItemsName: Scalars['QueryRbacPermissionsListOneOf_0ResultsItemsName']['output'];
  QueryRbacPermissionsListOneOf_0ResultsItemsCodename: Scalars['QueryRbacPermissionsListOneOf_0ResultsItemsCodename']['output'];
  RbacPermissionsRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['RbacPermissionsRetrieveResponse'];
  RbacPermissionsAssignedByRolesListResponse: ResolversUnionTypes<ResolversParentTypes>['RbacPermissionsAssignedByRolesListResponse'];
  PaginatedRoleAssignedObjectPermissionList: PaginatedRoleAssignedObjectPermissionList;
  RoleAssignedObjectPermission: RoleAssignedObjectPermission;
  RoleObjectPermission: RoleObjectPermission;
  RbacPermissionsAssignedByUsersListResponse: ResolversUnionTypes<ResolversParentTypes>['RbacPermissionsAssignedByUsersListResponse'];
  PaginatedUserAssignedObjectPermissionList: PaginatedUserAssignedObjectPermissionList;
  UserAssignedObjectPermission: UserAssignedObjectPermission;
  QueryRbacPermissionsAssignedByUsersListOneOf_0ResultsItemsUsername: Scalars['QueryRbacPermissionsAssignedByUsersListOneOf_0ResultsItemsUsername']['output'];
  UserObjectPermission: UserObjectPermission;
  RbacPermissionsRolesListResponse: ResolversUnionTypes<ResolversParentTypes>['RbacPermissionsRolesListResponse'];
  PaginatedExtraRoleObjectPermissionList: PaginatedExtraRoleObjectPermissionList;
  ExtraRoleObjectPermission: ExtraRoleObjectPermission;
  RbacPermissionsUsersListResponse: ResolversUnionTypes<ResolversParentTypes>['RbacPermissionsUsersListResponse'];
  PaginatedExtraUserObjectPermissionList: PaginatedExtraUserObjectPermissionList;
  ExtraUserObjectPermission: ExtraUserObjectPermission;
  RbacRolesListResponse: ResolversUnionTypes<ResolversParentTypes>['RbacRolesListResponse'];
  PaginatedRoleList: PaginatedRoleList;
  RbacRolesRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['RbacRolesRetrieveResponse'];
  RbacRolesUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['RbacRolesUsedByListResponse'];
  RootConfigRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['RootConfigRetrieveResponse'];
  Config: Config;
  ErrorReportingConfig: ErrorReportingConfig;
  SchemaRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['SchemaRetrieveResponse'];
  JsonContainer: JsonContainer;
  SourcesAllListResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesAllListResponse'];
  PaginatedSourceList: PaginatedSourceList;
  Source: Source;
  QuerySourcesAllListOneOf_0ResultsItemsSlug: Scalars['QuerySourcesAllListOneOf_0ResultsItemsSlug']['output'];
  SourcesAllRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesAllRetrieveResponse'];
  SourcesAllUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesAllUsedByListResponse'];
  SourcesAllTypesListResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesAllTypesListResponse'];
  SourcesAllUserSettingsListResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesAllUserSettingsListResponse'];
  UserSetting: UserSetting;
  SourcesLdapListResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesLdapListResponse'];
  PaginatedLdapSourceList: PaginatedLdapSourceList;
  LdapSource: LdapSource;
  QuerySourcesLdapListOneOf_0ResultsItemsSlug: Scalars['QuerySourcesLdapListOneOf_0ResultsItemsSlug']['output'];
  SourcesLdapRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesLdapRetrieveResponse'];
  SourcesLdapDebugRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesLdapDebugRetrieveResponse'];
  LdapDebug: LdapDebug;
  SourcesLdapSyncStatusRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesLdapSyncStatusRetrieveResponse'];
  LdapSyncStatus: LdapSyncStatus;
  SourcesLdapUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesLdapUsedByListResponse'];
  SourcesOauthListResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesOauthListResponse'];
  PaginatedOAuthSourceList: PaginatedOAuthSourceList;
  OAuthSource: OAuthSource;
  QuerySourcesOauthListOneOf_0ResultsItemsSlug: Scalars['QuerySourcesOauthListOneOf_0ResultsItemsSlug']['output'];
  QuerySourcesOauthListOneOf_0ResultsItemsRequestTokenUrl: Scalars['QuerySourcesOauthListOneOf_0ResultsItemsRequestTokenUrl']['output'];
  QuerySourcesOauthListOneOf_0ResultsItemsAuthorizationUrl: Scalars['QuerySourcesOauthListOneOf_0ResultsItemsAuthorizationUrl']['output'];
  QuerySourcesOauthListOneOf_0ResultsItemsAccessTokenUrl: Scalars['QuerySourcesOauthListOneOf_0ResultsItemsAccessTokenUrl']['output'];
  QuerySourcesOauthListOneOf_0ResultsItemsProfileUrl: Scalars['QuerySourcesOauthListOneOf_0ResultsItemsProfileUrl']['output'];
  SourceType: SourceType;
  SourcesOauthRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesOauthRetrieveResponse'];
  SourcesOauthUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesOauthUsedByListResponse'];
  SourcesOauthSourceTypesListResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesOauthSourceTypesListResponse'];
  SourcesPlexListResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesPlexListResponse'];
  PaginatedPlexSourceList: PaginatedPlexSourceList;
  PlexSource: PlexSource;
  QuerySourcesPlexListOneOf_0ResultsItemsSlug: Scalars['QuerySourcesPlexListOneOf_0ResultsItemsSlug']['output'];
  SourcesPlexRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesPlexRetrieveResponse'];
  SourcesPlexUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesPlexUsedByListResponse'];
  SourcesSamlListResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesSamlListResponse'];
  PaginatedSamlSourceList: PaginatedSamlSourceList;
  SamlSource: SamlSource;
  QuerySourcesSamlListOneOf_0ResultsItemsSlug: Scalars['QuerySourcesSamlListOneOf_0ResultsItemsSlug']['output'];
  SourcesSamlRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesSamlRetrieveResponse'];
  SourcesSamlMetadataRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesSamlMetadataRetrieveResponse'];
  SourcesSamlUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesSamlUsedByListResponse'];
  SourcesScimListResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesScimListResponse'];
  PaginatedScimSourceList: PaginatedScimSourceList;
  ScimSource: ScimSource;
  QuerySourcesScimListOneOf_0ResultsItemsSlug: Scalars['QuerySourcesScimListOneOf_0ResultsItemsSlug']['output'];
  SourcesScimRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesScimRetrieveResponse'];
  SourcesScimUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesScimUsedByListResponse'];
  SourcesScimGroupsListResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesScimGroupsListResponse'];
  PaginatedScimSourceGroupList: PaginatedScimSourceGroupList;
  ScimSourceGroup: ScimSourceGroup;
  SourcesScimGroupsRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesScimGroupsRetrieveResponse'];
  SourcesScimGroupsUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesScimGroupsUsedByListResponse'];
  SourcesScimUsersListResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesScimUsersListResponse'];
  PaginatedScimSourceUserList: PaginatedScimSourceUserList;
  ScimSourceUser: ScimSourceUser;
  SourcesScimUsersRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesScimUsersRetrieveResponse'];
  SourcesScimUsersUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesScimUsersUsedByListResponse'];
  SourcesUserConnectionsAllListResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesUserConnectionsAllListResponse'];
  PaginatedUserSourceConnectionList: PaginatedUserSourceConnectionList;
  UserSourceConnection: UserSourceConnection;
  SourcesUserConnectionsAllRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesUserConnectionsAllRetrieveResponse'];
  SourcesUserConnectionsAllUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesUserConnectionsAllUsedByListResponse'];
  SourcesUserConnectionsOauthListResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesUserConnectionsOauthListResponse'];
  PaginatedUserOAuthSourceConnectionList: PaginatedUserOAuthSourceConnectionList;
  UserOAuthSourceConnection: UserOAuthSourceConnection;
  QuerySourcesUserConnectionsOauthListOneOf_0ResultsItemsIdentifier: Scalars['QuerySourcesUserConnectionsOauthListOneOf_0ResultsItemsIdentifier']['output'];
  SourcesUserConnectionsOauthRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesUserConnectionsOauthRetrieveResponse'];
  SourcesUserConnectionsOauthUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesUserConnectionsOauthUsedByListResponse'];
  SourcesUserConnectionsPlexListResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesUserConnectionsPlexListResponse'];
  PaginatedPlexSourceConnectionList: PaginatedPlexSourceConnectionList;
  PlexSourceConnection: PlexSourceConnection;
  SourcesUserConnectionsPlexRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesUserConnectionsPlexRetrieveResponse'];
  SourcesUserConnectionsPlexUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesUserConnectionsPlexUsedByListResponse'];
  SourcesUserConnectionsSamlListResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesUserConnectionsSamlListResponse'];
  PaginatedUserSamlSourceConnectionList: PaginatedUserSamlSourceConnectionList;
  UserSamlSourceConnection: UserSamlSourceConnection;
  SourcesUserConnectionsSamlRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesUserConnectionsSamlRetrieveResponse'];
  SourcesUserConnectionsSamlUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesUserConnectionsSamlUsedByListResponse'];
  StagesAllListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAllListResponse'];
  PaginatedStageList: PaginatedStageList;
  StagesAllRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAllRetrieveResponse'];
  StagesAllUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAllUsedByListResponse'];
  StagesAllTypesListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAllTypesListResponse'];
  StagesAllUserSettingsListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAllUserSettingsListResponse'];
  StagesAuthenticatorDuoListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorDuoListResponse'];
  PaginatedAuthenticatorDuoStageList: PaginatedAuthenticatorDuoStageList;
  AuthenticatorDuoStage: AuthenticatorDuoStage;
  StagesAuthenticatorDuoRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorDuoRetrieveResponse'];
  StagesAuthenticatorDuoUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorDuoUsedByListResponse'];
  StagesAuthenticatorSmsListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorSmsListResponse'];
  PaginatedAuthenticatorSmsStageList: PaginatedAuthenticatorSmsStageList;
  AuthenticatorSmsStage: AuthenticatorSmsStage;
  StagesAuthenticatorSmsRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorSmsRetrieveResponse'];
  StagesAuthenticatorSmsUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorSmsUsedByListResponse'];
  StagesAuthenticatorStaticListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorStaticListResponse'];
  PaginatedAuthenticatorStaticStageList: PaginatedAuthenticatorStaticStageList;
  AuthenticatorStaticStage: AuthenticatorStaticStage;
  StagesAuthenticatorStaticRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorStaticRetrieveResponse'];
  StagesAuthenticatorStaticUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorStaticUsedByListResponse'];
  StagesAuthenticatorTotpListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorTotpListResponse'];
  PaginatedAuthenticatorTotpStageList: PaginatedAuthenticatorTotpStageList;
  AuthenticatorTotpStage: AuthenticatorTotpStage;
  StagesAuthenticatorTotpRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorTotpRetrieveResponse'];
  StagesAuthenticatorTotpUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorTotpUsedByListResponse'];
  StagesAuthenticatorValidateListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorValidateListResponse'];
  PaginatedAuthenticatorValidateStageList: PaginatedAuthenticatorValidateStageList;
  AuthenticatorValidateStage: AuthenticatorValidateStage;
  StagesAuthenticatorValidateRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorValidateRetrieveResponse'];
  StagesAuthenticatorValidateUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorValidateUsedByListResponse'];
  StagesAuthenticatorWebauthnListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorWebauthnListResponse'];
  PaginatedAuthenticatorWebAuthnStageList: PaginatedAuthenticatorWebAuthnStageList;
  AuthenticatorWebAuthnStage: AuthenticatorWebAuthnStage;
  StagesAuthenticatorWebauthnRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorWebauthnRetrieveResponse'];
  StagesAuthenticatorWebauthnUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorWebauthnUsedByListResponse'];
  StagesAuthenticatorWebauthnDeviceTypesListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorWebauthnDeviceTypesListResponse'];
  PaginatedWebAuthnDeviceTypeList: PaginatedWebAuthnDeviceTypeList;
  StagesAuthenticatorWebauthnDeviceTypesRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorWebauthnDeviceTypesRetrieveResponse'];
  StagesCaptchaListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesCaptchaListResponse'];
  PaginatedCaptchaStageList: PaginatedCaptchaStageList;
  CaptchaStage: CaptchaStage;
  StagesCaptchaRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['StagesCaptchaRetrieveResponse'];
  StagesCaptchaUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesCaptchaUsedByListResponse'];
  StagesConsentListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesConsentListResponse'];
  PaginatedConsentStageList: PaginatedConsentStageList;
  ConsentStage: ConsentStage;
  StagesConsentRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['StagesConsentRetrieveResponse'];
  StagesConsentUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesConsentUsedByListResponse'];
  StagesDenyListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesDenyListResponse'];
  PaginatedDenyStageList: PaginatedDenyStageList;
  DenyStage: DenyStage;
  StagesDenyRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['StagesDenyRetrieveResponse'];
  StagesDenyUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesDenyUsedByListResponse'];
  StagesDummyListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesDummyListResponse'];
  PaginatedDummyStageList: PaginatedDummyStageList;
  DummyStage: DummyStage;
  StagesDummyRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['StagesDummyRetrieveResponse'];
  StagesDummyUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesDummyUsedByListResponse'];
  StagesEmailListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesEmailListResponse'];
  PaginatedEmailStageList: PaginatedEmailStageList;
  EmailStage: EmailStage;
  StagesEmailRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['StagesEmailRetrieveResponse'];
  StagesEmailUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesEmailUsedByListResponse'];
  StagesEmailTemplatesListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesEmailTemplatesListResponse'];
  StagesIdentificationListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesIdentificationListResponse'];
  PaginatedIdentificationStageList: PaginatedIdentificationStageList;
  IdentificationStage: IdentificationStage;
  StagesIdentificationRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['StagesIdentificationRetrieveResponse'];
  StagesIdentificationUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesIdentificationUsedByListResponse'];
  StagesInvitationInvitationsListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesInvitationInvitationsListResponse'];
  PaginatedInvitationList: PaginatedInvitationList;
  Invitation: Invitation;
  QueryStagesInvitationInvitationsListOneOf_0ResultsItemsName: Scalars['QueryStagesInvitationInvitationsListOneOf_0ResultsItemsName']['output'];
  StagesInvitationInvitationsRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['StagesInvitationInvitationsRetrieveResponse'];
  StagesInvitationInvitationsUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesInvitationInvitationsUsedByListResponse'];
  StagesInvitationStagesListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesInvitationStagesListResponse'];
  PaginatedInvitationStageList: PaginatedInvitationStageList;
  InvitationStage: InvitationStage;
  StagesInvitationStagesRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['StagesInvitationStagesRetrieveResponse'];
  StagesInvitationStagesUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesInvitationStagesUsedByListResponse'];
  StagesPasswordListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesPasswordListResponse'];
  PaginatedPasswordStageList: PaginatedPasswordStageList;
  PasswordStage: PasswordStage;
  StagesPasswordRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['StagesPasswordRetrieveResponse'];
  StagesPasswordUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesPasswordUsedByListResponse'];
  StagesPromptPromptsListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesPromptPromptsListResponse'];
  PaginatedPromptList: PaginatedPromptList;
  Prompt: Prompt;
  StagesPromptPromptsRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['StagesPromptPromptsRetrieveResponse'];
  StagesPromptPromptsUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesPromptPromptsUsedByListResponse'];
  StagesPromptStagesListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesPromptStagesListResponse'];
  PaginatedPromptStageList: PaginatedPromptStageList;
  PromptStage: PromptStage;
  StagesPromptStagesRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['StagesPromptStagesRetrieveResponse'];
  StagesPromptStagesUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesPromptStagesUsedByListResponse'];
  StagesSourceListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesSourceListResponse'];
  PaginatedSourceStageList: PaginatedSourceStageList;
  SourceStage: SourceStage;
  StagesSourceRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['StagesSourceRetrieveResponse'];
  StagesSourceUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesSourceUsedByListResponse'];
  StagesUserDeleteListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesUserDeleteListResponse'];
  PaginatedUserDeleteStageList: PaginatedUserDeleteStageList;
  UserDeleteStage: UserDeleteStage;
  StagesUserDeleteRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['StagesUserDeleteRetrieveResponse'];
  StagesUserDeleteUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesUserDeleteUsedByListResponse'];
  StagesUserLoginListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesUserLoginListResponse'];
  PaginatedUserLoginStageList: PaginatedUserLoginStageList;
  UserLoginStage: UserLoginStage;
  StagesUserLoginRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['StagesUserLoginRetrieveResponse'];
  StagesUserLoginUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesUserLoginUsedByListResponse'];
  StagesUserLogoutListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesUserLogoutListResponse'];
  PaginatedUserLogoutStageList: PaginatedUserLogoutStageList;
  UserLogoutStage: UserLogoutStage;
  StagesUserLogoutRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['StagesUserLogoutRetrieveResponse'];
  StagesUserLogoutUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesUserLogoutUsedByListResponse'];
  StagesUserWriteListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesUserWriteListResponse'];
  PaginatedUserWriteStageList: PaginatedUserWriteStageList;
  UserWriteStage: UserWriteStage;
  StagesUserWriteRetrieveResponse: ResolversUnionTypes<ResolversParentTypes>['StagesUserWriteRetrieveResponse'];
  StagesUserWriteUsedByListResponse: ResolversUnionTypes<ResolversParentTypes>['StagesUserWriteUsedByListResponse'];
  AdminSettingsUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['AdminSettingsUpdateResponse'];
  SettingsRequestInput: SettingsRequestInput;
  NonEmptyString: Scalars['NonEmptyString']['output'];
  AdminSettingsPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['AdminSettingsPartialUpdateResponse'];
  PatchedSettingsRequestInput: PatchedSettingsRequestInput;
  AdminSystemCreateResponse: ResolversUnionTypes<ResolversParentTypes>['AdminSystemCreateResponse'];
  AuthenticatorsAdminDuoCreateResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsAdminDuoCreateResponse'];
  DuoDeviceRequestInput: DuoDeviceRequestInput;
  MutationInputAuthenticatorsAdminDuoCreateInputName: Scalars['MutationInputAuthenticatorsAdminDuoCreateInputName']['output'];
  AuthenticatorsAdminDuoUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsAdminDuoUpdateResponse'];
  AuthenticatorsAdminDuoPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsAdminDuoPartialUpdateResponse'];
  PatchedDuoDeviceRequestInput: PatchedDuoDeviceRequestInput;
  MutationInputAuthenticatorsAdminDuoPartialUpdateInputName: Scalars['MutationInputAuthenticatorsAdminDuoPartialUpdateInputName']['output'];
  AuthenticatorsAdminDuoDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsAdminDuoDestroyResponse'];
  AuthenticatorsAdminSmsCreateResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsAdminSmsCreateResponse'];
  SmsDeviceRequestInput: SmsDeviceRequestInput;
  MutationInputAuthenticatorsAdminSmsCreateInputName: Scalars['MutationInputAuthenticatorsAdminSmsCreateInputName']['output'];
  AuthenticatorsAdminSmsUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsAdminSmsUpdateResponse'];
  AuthenticatorsAdminSmsPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsAdminSmsPartialUpdateResponse'];
  PatchedSmsDeviceRequestInput: PatchedSmsDeviceRequestInput;
  MutationInputAuthenticatorsAdminSmsPartialUpdateInputName: Scalars['MutationInputAuthenticatorsAdminSmsPartialUpdateInputName']['output'];
  AuthenticatorsAdminSmsDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsAdminSmsDestroyResponse'];
  AuthenticatorsAdminStaticCreateResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsAdminStaticCreateResponse'];
  StaticDeviceRequestInput: StaticDeviceRequestInput;
  MutationInputAuthenticatorsAdminStaticCreateInputName: Scalars['MutationInputAuthenticatorsAdminStaticCreateInputName']['output'];
  AuthenticatorsAdminStaticUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsAdminStaticUpdateResponse'];
  AuthenticatorsAdminStaticPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsAdminStaticPartialUpdateResponse'];
  PatchedStaticDeviceRequestInput: PatchedStaticDeviceRequestInput;
  MutationInputAuthenticatorsAdminStaticPartialUpdateInputName: Scalars['MutationInputAuthenticatorsAdminStaticPartialUpdateInputName']['output'];
  AuthenticatorsAdminStaticDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsAdminStaticDestroyResponse'];
  AuthenticatorsAdminTotpCreateResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsAdminTotpCreateResponse'];
  TotpDeviceRequestInput: TotpDeviceRequestInput;
  MutationInputAuthenticatorsAdminTotpCreateInputName: Scalars['MutationInputAuthenticatorsAdminTotpCreateInputName']['output'];
  AuthenticatorsAdminTotpUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsAdminTotpUpdateResponse'];
  AuthenticatorsAdminTotpPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsAdminTotpPartialUpdateResponse'];
  PatchedTotpDeviceRequestInput: PatchedTotpDeviceRequestInput;
  MutationInputAuthenticatorsAdminTotpPartialUpdateInputName: Scalars['MutationInputAuthenticatorsAdminTotpPartialUpdateInputName']['output'];
  AuthenticatorsAdminTotpDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsAdminTotpDestroyResponse'];
  AuthenticatorsAdminWebauthnCreateResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsAdminWebauthnCreateResponse'];
  WebAuthnDeviceRequestInput: WebAuthnDeviceRequestInput;
  MutationInputAuthenticatorsAdminWebauthnCreateInputName: Scalars['MutationInputAuthenticatorsAdminWebauthnCreateInputName']['output'];
  AuthenticatorsAdminWebauthnUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsAdminWebauthnUpdateResponse'];
  AuthenticatorsAdminWebauthnPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsAdminWebauthnPartialUpdateResponse'];
  PatchedWebAuthnDeviceRequestInput: PatchedWebAuthnDeviceRequestInput;
  MutationInputAuthenticatorsAdminWebauthnPartialUpdateInputName: Scalars['MutationInputAuthenticatorsAdminWebauthnPartialUpdateInputName']['output'];
  AuthenticatorsAdminWebauthnDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsAdminWebauthnDestroyResponse'];
  AuthenticatorsDuoUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsDuoUpdateResponse'];
  AuthenticatorsDuoPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsDuoPartialUpdateResponse'];
  AuthenticatorsDuoDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsDuoDestroyResponse'];
  AuthenticatorsSmsUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsSmsUpdateResponse'];
  AuthenticatorsSmsPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsSmsPartialUpdateResponse'];
  AuthenticatorsSmsDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsSmsDestroyResponse'];
  AuthenticatorsStaticUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsStaticUpdateResponse'];
  AuthenticatorsStaticPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsStaticPartialUpdateResponse'];
  AuthenticatorsStaticDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsStaticDestroyResponse'];
  AuthenticatorsTotpUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsTotpUpdateResponse'];
  AuthenticatorsTotpPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsTotpPartialUpdateResponse'];
  AuthenticatorsTotpDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsTotpDestroyResponse'];
  AuthenticatorsWebauthnUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsWebauthnUpdateResponse'];
  AuthenticatorsWebauthnPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsWebauthnPartialUpdateResponse'];
  AuthenticatorsWebauthnDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['AuthenticatorsWebauthnDestroyResponse'];
  CoreApplicationsCreateResponse: ResolversUnionTypes<ResolversParentTypes>['CoreApplicationsCreateResponse'];
  ApplicationRequestInput: ApplicationRequestInput;
  MutationInputCoreApplicationsCreateInputSlug: Scalars['MutationInputCoreApplicationsCreateInputSlug']['output'];
  CoreApplicationsUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['CoreApplicationsUpdateResponse'];
  CoreApplicationsPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['CoreApplicationsPartialUpdateResponse'];
  PatchedApplicationRequestInput: PatchedApplicationRequestInput;
  MutationInputCoreApplicationsPartialUpdateInputSlug: Scalars['MutationInputCoreApplicationsPartialUpdateInputSlug']['output'];
  CoreApplicationsDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['CoreApplicationsDestroyResponse'];
  FileUploadRequestInput: FileUploadRequestInput;
  FilePathRequestInput: FilePathRequestInput;
  CoreAuthenticatedSessionsDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['CoreAuthenticatedSessionsDestroyResponse'];
  CoreBrandsCreateResponse: ResolversUnionTypes<ResolversParentTypes>['CoreBrandsCreateResponse'];
  BrandRequestInput: BrandRequestInput;
  CoreBrandsUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['CoreBrandsUpdateResponse'];
  CoreBrandsPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['CoreBrandsPartialUpdateResponse'];
  PatchedBrandRequestInput: PatchedBrandRequestInput;
  CoreBrandsDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['CoreBrandsDestroyResponse'];
  CoreGroupsCreateResponse: ResolversUnionTypes<ResolversParentTypes>['CoreGroupsCreateResponse'];
  GroupRequestInput: GroupRequestInput;
  MutationInputCoreGroupsCreateInputName: Scalars['MutationInputCoreGroupsCreateInputName']['output'];
  CoreGroupsUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['CoreGroupsUpdateResponse'];
  CoreGroupsPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['CoreGroupsPartialUpdateResponse'];
  PatchedGroupRequestInput: PatchedGroupRequestInput;
  MutationInputCoreGroupsPartialUpdateInputName: Scalars['MutationInputCoreGroupsPartialUpdateInputName']['output'];
  CoreGroupsDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['CoreGroupsDestroyResponse'];
  CoreGroupsAddUserCreateResponse: ResolversUnionTypes<ResolversParentTypes>['CoreGroupsAddUserCreateResponse'];
  UserAccountRequestInput: UserAccountRequestInput;
  CoreGroupsRemoveUserCreateResponse: ResolversUnionTypes<ResolversParentTypes>['CoreGroupsRemoveUserCreateResponse'];
  CoreTokensCreateResponse: ResolversUnionTypes<ResolversParentTypes>['CoreTokensCreateResponse'];
  TokenRequestInput: TokenRequestInput;
  MutationInputCoreTokensCreateInputIdentifier: Scalars['MutationInputCoreTokensCreateInputIdentifier']['output'];
  CoreTokensUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['CoreTokensUpdateResponse'];
  CoreTokensPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['CoreTokensPartialUpdateResponse'];
  PatchedTokenRequestInput: PatchedTokenRequestInput;
  MutationInputCoreTokensPartialUpdateInputIdentifier: Scalars['MutationInputCoreTokensPartialUpdateInputIdentifier']['output'];
  CoreTokensDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['CoreTokensDestroyResponse'];
  CoreTokensSetKeyCreateResponse: ResolversUnionTypes<ResolversParentTypes>['CoreTokensSetKeyCreateResponse'];
  TokenSetKeyRequestInput: TokenSetKeyRequestInput;
  CoreTransactionalApplicationsUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['CoreTransactionalApplicationsUpdateResponse'];
  TransactionApplicationResponse: TransactionApplicationResponse;
  TransactionApplicationRequestInput: TransactionApplicationRequestInput;
  ModelRequestInput: ModelRequestInput;
  LdapProviderRequestInput: LdapProviderRequestInput;
  OAuth2ProviderRequestInput: OAuth2ProviderRequestInput;
  MutationInputCoreTransactionalApplicationsUpdateInputProviderOneOf_1ClientId: Scalars['MutationInputCoreTransactionalApplicationsUpdateInputProviderOneOf_1ClientId']['output'];
  MutationInputCoreTransactionalApplicationsUpdateInputProviderOneOf_1ClientSecret: Scalars['MutationInputCoreTransactionalApplicationsUpdateInputProviderOneOf_1ClientSecret']['output'];
  ProxyProviderRequestInput: ProxyProviderRequestInput;
  RacProviderRequestInput: RacProviderRequestInput;
  RadiusProviderRequestInput: RadiusProviderRequestInput;
  SamlProviderRequestInput: SamlProviderRequestInput;
  ScimProviderRequestInput: ScimProviderRequestInput;
  CoreUserConsentDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['CoreUserConsentDestroyResponse'];
  CoreUsersCreateResponse: ResolversUnionTypes<ResolversParentTypes>['CoreUsersCreateResponse'];
  UserRequestInput: UserRequestInput;
  MutationInputCoreUsersCreateInputUsername: Scalars['MutationInputCoreUsersCreateInputUsername']['output'];
  CoreUsersUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['CoreUsersUpdateResponse'];
  CoreUsersPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['CoreUsersPartialUpdateResponse'];
  PatchedUserRequestInput: PatchedUserRequestInput;
  MutationInputCoreUsersPartialUpdateInputUsername: Scalars['MutationInputCoreUsersPartialUpdateInputUsername']['output'];
  CoreUsersDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['CoreUsersDestroyResponse'];
  CoreUsersImpersonateCreateResponse: ResolversUnionTypes<ResolversParentTypes>['CoreUsersImpersonateCreateResponse'];
  CoreUsersRecoveryCreateResponse: ResolversUnionTypes<ResolversParentTypes>['CoreUsersRecoveryCreateResponse'];
  CoreUsersRecoveryEmailCreateResponse: ResolversUnionTypes<ResolversParentTypes>['CoreUsersRecoveryEmailCreateResponse'];
  CoreUsersSetPasswordCreateResponse: ResolversUnionTypes<ResolversParentTypes>['CoreUsersSetPasswordCreateResponse'];
  UserPasswordSetRequestInput: UserPasswordSetRequestInput;
  CoreUsersServiceAccountCreateResponse: ResolversUnionTypes<ResolversParentTypes>['CoreUsersServiceAccountCreateResponse'];
  UserServiceAccountResponse: UserServiceAccountResponse;
  UserServiceAccountRequestInput: UserServiceAccountRequestInput;
  CryptoCertificatekeypairsCreateResponse: ResolversUnionTypes<ResolversParentTypes>['CryptoCertificatekeypairsCreateResponse'];
  CertificateKeyPairRequestInput: CertificateKeyPairRequestInput;
  CryptoCertificatekeypairsUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['CryptoCertificatekeypairsUpdateResponse'];
  CryptoCertificatekeypairsPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['CryptoCertificatekeypairsPartialUpdateResponse'];
  PatchedCertificateKeyPairRequestInput: PatchedCertificateKeyPairRequestInput;
  CryptoCertificatekeypairsDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['CryptoCertificatekeypairsDestroyResponse'];
  CryptoCertificatekeypairsGenerateCreateResponse: ResolversUnionTypes<ResolversParentTypes>['CryptoCertificatekeypairsGenerateCreateResponse'];
  CertificateGenerationRequestInput: CertificateGenerationRequestInput;
  EnterpriseLicenseCreateResponse: ResolversUnionTypes<ResolversParentTypes>['EnterpriseLicenseCreateResponse'];
  LicenseRequestInput: LicenseRequestInput;
  EnterpriseLicenseUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['EnterpriseLicenseUpdateResponse'];
  EnterpriseLicensePartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['EnterpriseLicensePartialUpdateResponse'];
  PatchedLicenseRequestInput: PatchedLicenseRequestInput;
  EnterpriseLicenseDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['EnterpriseLicenseDestroyResponse'];
  EventsEventsCreateResponse: ResolversUnionTypes<ResolversParentTypes>['EventsEventsCreateResponse'];
  EventRequestInput: EventRequestInput;
  EventsEventsUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['EventsEventsUpdateResponse'];
  EventsEventsPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['EventsEventsPartialUpdateResponse'];
  PatchedEventRequestInput: PatchedEventRequestInput;
  EventsEventsDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['EventsEventsDestroyResponse'];
  EventsNotificationsUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['EventsNotificationsUpdateResponse'];
  NotificationRequestInput: NotificationRequestInput;
  EventsNotificationsPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['EventsNotificationsPartialUpdateResponse'];
  PatchedNotificationRequestInput: PatchedNotificationRequestInput;
  EventsNotificationsDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['EventsNotificationsDestroyResponse'];
  EventsNotificationsMarkAllSeenCreateResponse: ResolversUnionTypes<ResolversParentTypes>['EventsNotificationsMarkAllSeenCreateResponse'];
  EventsRulesCreateResponse: ResolversUnionTypes<ResolversParentTypes>['EventsRulesCreateResponse'];
  NotificationRuleRequestInput: NotificationRuleRequestInput;
  EventsRulesUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['EventsRulesUpdateResponse'];
  EventsRulesPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['EventsRulesPartialUpdateResponse'];
  PatchedNotificationRuleRequestInput: PatchedNotificationRuleRequestInput;
  EventsRulesDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['EventsRulesDestroyResponse'];
  EventsSystemTasksRunCreateResponse: ResolversUnionTypes<ResolversParentTypes>['EventsSystemTasksRunCreateResponse'];
  EventsTransportsCreateResponse: ResolversUnionTypes<ResolversParentTypes>['EventsTransportsCreateResponse'];
  NotificationTransportRequestInput: NotificationTransportRequestInput;
  EventsTransportsUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['EventsTransportsUpdateResponse'];
  EventsTransportsPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['EventsTransportsPartialUpdateResponse'];
  PatchedNotificationTransportRequestInput: PatchedNotificationTransportRequestInput;
  EventsTransportsDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['EventsTransportsDestroyResponse'];
  EventsTransportsTestCreateResponse: ResolversUnionTypes<ResolversParentTypes>['EventsTransportsTestCreateResponse'];
  NotificationTransportTest: NotificationTransportTest;
  FlowsBindingsCreateResponse: ResolversUnionTypes<ResolversParentTypes>['FlowsBindingsCreateResponse'];
  FlowStageBindingRequestInput: FlowStageBindingRequestInput;
  FlowsBindingsUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['FlowsBindingsUpdateResponse'];
  FlowsBindingsPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['FlowsBindingsPartialUpdateResponse'];
  PatchedFlowStageBindingRequestInput: PatchedFlowStageBindingRequestInput;
  FlowsBindingsDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['FlowsBindingsDestroyResponse'];
  FlowsExecutorSolveResponse: ResolversUnionTypes<ResolversParentTypes>['FlowsExecutorSolveResponse'];
  FlowChallengeResponseRequestInput: FlowChallengeResponseRequestInput;
  AppleChallengeResponseRequestInput: AppleChallengeResponseRequestInput;
  AuthenticatorDuoChallengeResponseRequestInput: AuthenticatorDuoChallengeResponseRequestInput;
  AuthenticatorSmsChallengeResponseRequestInput: AuthenticatorSmsChallengeResponseRequestInput;
  AuthenticatorStaticChallengeResponseRequestInput: AuthenticatorStaticChallengeResponseRequestInput;
  AuthenticatorTotpChallengeResponseRequestInput: AuthenticatorTotpChallengeResponseRequestInput;
  AuthenticatorValidationChallengeResponseRequestInput: AuthenticatorValidationChallengeResponseRequestInput;
  DeviceChallengeRequestInput: DeviceChallengeRequestInput;
  AuthenticatorWebAuthnChallengeResponseRequestInput: AuthenticatorWebAuthnChallengeResponseRequestInput;
  AutoSubmitChallengeResponseRequestInput: AutoSubmitChallengeResponseRequestInput;
  CaptchaChallengeResponseRequestInput: CaptchaChallengeResponseRequestInput;
  ConsentChallengeResponseRequestInput: ConsentChallengeResponseRequestInput;
  EmailChallengeResponseRequestInput: EmailChallengeResponseRequestInput;
  IdentificationChallengeResponseRequestInput: IdentificationChallengeResponseRequestInput;
  OAuthDeviceCodeChallengeResponseRequestInput: OAuthDeviceCodeChallengeResponseRequestInput;
  OAuthDeviceCodeFinishChallengeResponseRequestInput: OAuthDeviceCodeFinishChallengeResponseRequestInput;
  PasswordChallengeResponseRequestInput: PasswordChallengeResponseRequestInput;
  PlexAuthenticationChallengeResponseRequestInput: PlexAuthenticationChallengeResponseRequestInput;
  PromptChallengeResponseRequestInput: PromptChallengeResponseRequestInput;
  UserLoginChallengeResponseRequestInput: UserLoginChallengeResponseRequestInput;
  FlowsInstancesCreateResponse: ResolversUnionTypes<ResolversParentTypes>['FlowsInstancesCreateResponse'];
  FlowRequestInput: FlowRequestInput;
  MutationInputFlowsInstancesCreateInputSlug: Scalars['MutationInputFlowsInstancesCreateInputSlug']['output'];
  FlowsInstancesUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['FlowsInstancesUpdateResponse'];
  FlowsInstancesPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['FlowsInstancesPartialUpdateResponse'];
  PatchedFlowRequestInput: PatchedFlowRequestInput;
  MutationInputFlowsInstancesPartialUpdateInputSlug: Scalars['MutationInputFlowsInstancesPartialUpdateInputSlug']['output'];
  FlowsInstancesDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['FlowsInstancesDestroyResponse'];
  FlowsInstancesCacheClearCreateResponse: ResolversUnionTypes<ResolversParentTypes>['FlowsInstancesCacheClearCreateResponse'];
  FlowsInstancesImportCreateResponse: ResolversUnionTypes<ResolversParentTypes>['FlowsInstancesImportCreateResponse'];
  FlowImportResult: FlowImportResult;
  ManagedBlueprintsCreateResponse: ResolversUnionTypes<ResolversParentTypes>['ManagedBlueprintsCreateResponse'];
  BlueprintInstanceRequestInput: BlueprintInstanceRequestInput;
  ManagedBlueprintsUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['ManagedBlueprintsUpdateResponse'];
  ManagedBlueprintsPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['ManagedBlueprintsPartialUpdateResponse'];
  PatchedBlueprintInstanceRequestInput: PatchedBlueprintInstanceRequestInput;
  ManagedBlueprintsDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['ManagedBlueprintsDestroyResponse'];
  ManagedBlueprintsApplyCreateResponse: ResolversUnionTypes<ResolversParentTypes>['ManagedBlueprintsApplyCreateResponse'];
  Oauth2AccessTokensDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['Oauth2AccessTokensDestroyResponse'];
  Oauth2AuthorizationCodesDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['Oauth2AuthorizationCodesDestroyResponse'];
  Oauth2RefreshTokensDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['Oauth2RefreshTokensDestroyResponse'];
  OutpostsInstancesCreateResponse: ResolversUnionTypes<ResolversParentTypes>['OutpostsInstancesCreateResponse'];
  OutpostRequestInput: OutpostRequestInput;
  OutpostsInstancesUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['OutpostsInstancesUpdateResponse'];
  OutpostsInstancesPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['OutpostsInstancesPartialUpdateResponse'];
  PatchedOutpostRequestInput: PatchedOutpostRequestInput;
  OutpostsInstancesDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['OutpostsInstancesDestroyResponse'];
  OutpostsServiceConnectionsAllDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['OutpostsServiceConnectionsAllDestroyResponse'];
  OutpostsServiceConnectionsDockerCreateResponse: ResolversUnionTypes<ResolversParentTypes>['OutpostsServiceConnectionsDockerCreateResponse'];
  DockerServiceConnectionRequestInput: DockerServiceConnectionRequestInput;
  OutpostsServiceConnectionsDockerUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['OutpostsServiceConnectionsDockerUpdateResponse'];
  OutpostsServiceConnectionsDockerPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['OutpostsServiceConnectionsDockerPartialUpdateResponse'];
  PatchedDockerServiceConnectionRequestInput: PatchedDockerServiceConnectionRequestInput;
  OutpostsServiceConnectionsDockerDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['OutpostsServiceConnectionsDockerDestroyResponse'];
  OutpostsServiceConnectionsKubernetesCreateResponse: ResolversUnionTypes<ResolversParentTypes>['OutpostsServiceConnectionsKubernetesCreateResponse'];
  KubernetesServiceConnectionRequestInput: KubernetesServiceConnectionRequestInput;
  OutpostsServiceConnectionsKubernetesUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['OutpostsServiceConnectionsKubernetesUpdateResponse'];
  OutpostsServiceConnectionsKubernetesPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['OutpostsServiceConnectionsKubernetesPartialUpdateResponse'];
  PatchedKubernetesServiceConnectionRequestInput: PatchedKubernetesServiceConnectionRequestInput;
  OutpostsServiceConnectionsKubernetesDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['OutpostsServiceConnectionsKubernetesDestroyResponse'];
  PoliciesAllDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesAllDestroyResponse'];
  PoliciesAllTestCreateResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesAllTestCreateResponse'];
  PolicyTestRequestInput: PolicyTestRequestInput;
  PoliciesAllCacheClearCreateResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesAllCacheClearCreateResponse'];
  PoliciesBindingsCreateResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesBindingsCreateResponse'];
  PolicyBindingRequestInput: PolicyBindingRequestInput;
  PoliciesBindingsUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesBindingsUpdateResponse'];
  PoliciesBindingsPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesBindingsPartialUpdateResponse'];
  PatchedPolicyBindingRequestInput: PatchedPolicyBindingRequestInput;
  PoliciesBindingsDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesBindingsDestroyResponse'];
  PoliciesDummyCreateResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesDummyCreateResponse'];
  DummyPolicyRequestInput: DummyPolicyRequestInput;
  PoliciesDummyUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesDummyUpdateResponse'];
  PoliciesDummyPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesDummyPartialUpdateResponse'];
  PatchedDummyPolicyRequestInput: PatchedDummyPolicyRequestInput;
  PoliciesDummyDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesDummyDestroyResponse'];
  PoliciesEventMatcherCreateResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesEventMatcherCreateResponse'];
  EventMatcherPolicyRequestInput: EventMatcherPolicyRequestInput;
  PoliciesEventMatcherUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesEventMatcherUpdateResponse'];
  PoliciesEventMatcherPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesEventMatcherPartialUpdateResponse'];
  PatchedEventMatcherPolicyRequestInput: PatchedEventMatcherPolicyRequestInput;
  PoliciesEventMatcherDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesEventMatcherDestroyResponse'];
  PoliciesExpressionCreateResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesExpressionCreateResponse'];
  ExpressionPolicyRequestInput: ExpressionPolicyRequestInput;
  PoliciesExpressionUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesExpressionUpdateResponse'];
  PoliciesExpressionPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesExpressionPartialUpdateResponse'];
  PatchedExpressionPolicyRequestInput: PatchedExpressionPolicyRequestInput;
  PoliciesExpressionDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesExpressionDestroyResponse'];
  PoliciesPasswordCreateResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesPasswordCreateResponse'];
  PasswordPolicyRequestInput: PasswordPolicyRequestInput;
  PoliciesPasswordUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesPasswordUpdateResponse'];
  PoliciesPasswordPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesPasswordPartialUpdateResponse'];
  PatchedPasswordPolicyRequestInput: PatchedPasswordPolicyRequestInput;
  PoliciesPasswordDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesPasswordDestroyResponse'];
  PoliciesPasswordExpiryCreateResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesPasswordExpiryCreateResponse'];
  PasswordExpiryPolicyRequestInput: PasswordExpiryPolicyRequestInput;
  PoliciesPasswordExpiryUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesPasswordExpiryUpdateResponse'];
  PoliciesPasswordExpiryPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesPasswordExpiryPartialUpdateResponse'];
  PatchedPasswordExpiryPolicyRequestInput: PatchedPasswordExpiryPolicyRequestInput;
  PoliciesPasswordExpiryDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesPasswordExpiryDestroyResponse'];
  PoliciesReputationCreateResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesReputationCreateResponse'];
  ReputationPolicyRequestInput: ReputationPolicyRequestInput;
  PoliciesReputationUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesReputationUpdateResponse'];
  PoliciesReputationPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesReputationPartialUpdateResponse'];
  PatchedReputationPolicyRequestInput: PatchedReputationPolicyRequestInput;
  PoliciesReputationDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesReputationDestroyResponse'];
  PoliciesReputationScoresDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['PoliciesReputationScoresDestroyResponse'];
  PropertymappingsAllDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsAllDestroyResponse'];
  PropertymappingsAllTestCreateResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsAllTestCreateResponse'];
  PropertyMappingTestResult: PropertyMappingTestResult;
  PropertymappingsLdapCreateResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsLdapCreateResponse'];
  LdapPropertyMappingRequestInput: LdapPropertyMappingRequestInput;
  PropertymappingsLdapUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsLdapUpdateResponse'];
  PropertymappingsLdapPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsLdapPartialUpdateResponse'];
  PatchedLdapPropertyMappingRequestInput: PatchedLdapPropertyMappingRequestInput;
  PropertymappingsLdapDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsLdapDestroyResponse'];
  PropertymappingsNotificationCreateResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsNotificationCreateResponse'];
  NotificationWebhookMappingRequestInput: NotificationWebhookMappingRequestInput;
  PropertymappingsNotificationUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsNotificationUpdateResponse'];
  PropertymappingsNotificationPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsNotificationPartialUpdateResponse'];
  PatchedNotificationWebhookMappingRequestInput: PatchedNotificationWebhookMappingRequestInput;
  PropertymappingsNotificationDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsNotificationDestroyResponse'];
  PropertymappingsRacCreateResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsRacCreateResponse'];
  RacPropertyMappingRequestInput: RacPropertyMappingRequestInput;
  PropertymappingsRacUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsRacUpdateResponse'];
  PropertymappingsRacPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsRacPartialUpdateResponse'];
  PatchedRacPropertyMappingRequestInput: PatchedRacPropertyMappingRequestInput;
  PropertymappingsRacDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsRacDestroyResponse'];
  PropertymappingsSamlCreateResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsSamlCreateResponse'];
  SamlPropertyMappingRequestInput: SamlPropertyMappingRequestInput;
  PropertymappingsSamlUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsSamlUpdateResponse'];
  PropertymappingsSamlPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsSamlPartialUpdateResponse'];
  PatchedSamlPropertyMappingRequestInput: PatchedSamlPropertyMappingRequestInput;
  PropertymappingsSamlDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsSamlDestroyResponse'];
  PropertymappingsScimCreateResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsScimCreateResponse'];
  ScimMappingRequestInput: ScimMappingRequestInput;
  PropertymappingsScimUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsScimUpdateResponse'];
  PropertymappingsScimPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsScimPartialUpdateResponse'];
  PatchedScimMappingRequestInput: PatchedScimMappingRequestInput;
  PropertymappingsScimDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsScimDestroyResponse'];
  PropertymappingsScopeCreateResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsScopeCreateResponse'];
  ScopeMappingRequestInput: ScopeMappingRequestInput;
  PropertymappingsScopeUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsScopeUpdateResponse'];
  PropertymappingsScopePartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsScopePartialUpdateResponse'];
  PatchedScopeMappingRequestInput: PatchedScopeMappingRequestInput;
  PropertymappingsScopeDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['PropertymappingsScopeDestroyResponse'];
  ProvidersAllDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersAllDestroyResponse'];
  ProvidersLdapCreateResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersLdapCreateResponse'];
  ProvidersLdapUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersLdapUpdateResponse'];
  ProvidersLdapPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersLdapPartialUpdateResponse'];
  PatchedLdapProviderRequestInput: PatchedLdapProviderRequestInput;
  ProvidersLdapDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersLdapDestroyResponse'];
  ProvidersOauth2CreateResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersOauth2CreateResponse'];
  ProvidersOauth2UpdateResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersOauth2UpdateResponse'];
  ProvidersOauth2PartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersOauth2PartialUpdateResponse'];
  PatchedOAuth2ProviderRequestInput: PatchedOAuth2ProviderRequestInput;
  MutationInputProvidersOauth2PartialUpdateInputClientId: Scalars['MutationInputProvidersOauth2PartialUpdateInputClientId']['output'];
  MutationInputProvidersOauth2PartialUpdateInputClientSecret: Scalars['MutationInputProvidersOauth2PartialUpdateInputClientSecret']['output'];
  ProvidersOauth2DestroyResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersOauth2DestroyResponse'];
  ProvidersProxyCreateResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersProxyCreateResponse'];
  ProvidersProxyUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersProxyUpdateResponse'];
  ProvidersProxyPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersProxyPartialUpdateResponse'];
  PatchedProxyProviderRequestInput: PatchedProxyProviderRequestInput;
  ProvidersProxyDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersProxyDestroyResponse'];
  ProvidersRacCreateResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersRacCreateResponse'];
  ProvidersRacUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersRacUpdateResponse'];
  ProvidersRacPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersRacPartialUpdateResponse'];
  PatchedRacProviderRequestInput: PatchedRacProviderRequestInput;
  ProvidersRacDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersRacDestroyResponse'];
  ProvidersRadiusCreateResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersRadiusCreateResponse'];
  ProvidersRadiusUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersRadiusUpdateResponse'];
  ProvidersRadiusPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersRadiusPartialUpdateResponse'];
  PatchedRadiusProviderRequestInput: PatchedRadiusProviderRequestInput;
  ProvidersRadiusDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersRadiusDestroyResponse'];
  ProvidersSamlCreateResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersSamlCreateResponse'];
  ProvidersSamlUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersSamlUpdateResponse'];
  ProvidersSamlPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersSamlPartialUpdateResponse'];
  PatchedSamlProviderRequestInput: PatchedSamlProviderRequestInput;
  ProvidersSamlDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersSamlDestroyResponse'];
  ProvidersSamlImportMetadataCreateResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersSamlImportMetadataCreateResponse'];
  SamlProviderImportRequestInput: SamlProviderImportRequestInput;
  ProvidersScimCreateResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersScimCreateResponse'];
  ProvidersScimUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersScimUpdateResponse'];
  ProvidersScimPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersScimPartialUpdateResponse'];
  PatchedScimProviderRequestInput: PatchedScimProviderRequestInput;
  ProvidersScimDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['ProvidersScimDestroyResponse'];
  RacConnectionTokensUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['RacConnectionTokensUpdateResponse'];
  ConnectionTokenRequestInput: ConnectionTokenRequestInput;
  RacConnectionTokensPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['RacConnectionTokensPartialUpdateResponse'];
  PatchedConnectionTokenRequestInput: PatchedConnectionTokenRequestInput;
  RacConnectionTokensDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['RacConnectionTokensDestroyResponse'];
  RacEndpointsCreateResponse: ResolversUnionTypes<ResolversParentTypes>['RacEndpointsCreateResponse'];
  EndpointRequestInput: EndpointRequestInput;
  RacEndpointsUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['RacEndpointsUpdateResponse'];
  RacEndpointsPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['RacEndpointsPartialUpdateResponse'];
  PatchedEndpointRequestInput: PatchedEndpointRequestInput;
  RacEndpointsDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['RacEndpointsDestroyResponse'];
  RbacPermissionsAssignedByRolesAssignCreateResponse: ResolversUnionTypes<ResolversParentTypes>['RbacPermissionsAssignedByRolesAssignCreateResponse'];
  PermissionAssignRequestInput: PermissionAssignRequestInput;
  RbacPermissionsAssignedByRolesUnassignPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['RbacPermissionsAssignedByRolesUnassignPartialUpdateResponse'];
  PatchedPermissionAssignRequestInput: PatchedPermissionAssignRequestInput;
  RbacPermissionsAssignedByUsersAssignCreateResponse: ResolversUnionTypes<ResolversParentTypes>['RbacPermissionsAssignedByUsersAssignCreateResponse'];
  RbacPermissionsAssignedByUsersUnassignPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['RbacPermissionsAssignedByUsersUnassignPartialUpdateResponse'];
  RbacRolesCreateResponse: ResolversUnionTypes<ResolversParentTypes>['RbacRolesCreateResponse'];
  RoleRequestInput: RoleRequestInput;
  MutationInputRbacRolesCreateInputName: Scalars['MutationInputRbacRolesCreateInputName']['output'];
  RbacRolesUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['RbacRolesUpdateResponse'];
  RbacRolesPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['RbacRolesPartialUpdateResponse'];
  PatchedRoleRequestInput: PatchedRoleRequestInput;
  MutationInputRbacRolesPartialUpdateInputName: Scalars['MutationInputRbacRolesPartialUpdateInputName']['output'];
  RbacRolesDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['RbacRolesDestroyResponse'];
  SourcesAllDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesAllDestroyResponse'];
  SourcesLdapCreateResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesLdapCreateResponse'];
  LdapSourceRequestInput: LdapSourceRequestInput;
  MutationInputSourcesLdapCreateInputSlug: Scalars['MutationInputSourcesLdapCreateInputSlug']['output'];
  SourcesLdapUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesLdapUpdateResponse'];
  SourcesLdapPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesLdapPartialUpdateResponse'];
  PatchedLdapSourceRequestInput: PatchedLdapSourceRequestInput;
  MutationInputSourcesLdapPartialUpdateInputSlug: Scalars['MutationInputSourcesLdapPartialUpdateInputSlug']['output'];
  SourcesLdapDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesLdapDestroyResponse'];
  SourcesOauthCreateResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesOauthCreateResponse'];
  OAuthSourceRequestInput: OAuthSourceRequestInput;
  MutationInputSourcesOauthCreateInputSlug: Scalars['MutationInputSourcesOauthCreateInputSlug']['output'];
  MutationInputSourcesOauthCreateInputRequestTokenUrl: Scalars['MutationInputSourcesOauthCreateInputRequestTokenUrl']['output'];
  MutationInputSourcesOauthCreateInputAuthorizationUrl: Scalars['MutationInputSourcesOauthCreateInputAuthorizationUrl']['output'];
  MutationInputSourcesOauthCreateInputAccessTokenUrl: Scalars['MutationInputSourcesOauthCreateInputAccessTokenUrl']['output'];
  MutationInputSourcesOauthCreateInputProfileUrl: Scalars['MutationInputSourcesOauthCreateInputProfileUrl']['output'];
  SourcesOauthUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesOauthUpdateResponse'];
  SourcesOauthPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesOauthPartialUpdateResponse'];
  PatchedOAuthSourceRequestInput: PatchedOAuthSourceRequestInput;
  MutationInputSourcesOauthPartialUpdateInputSlug: Scalars['MutationInputSourcesOauthPartialUpdateInputSlug']['output'];
  MutationInputSourcesOauthPartialUpdateInputRequestTokenUrl: Scalars['MutationInputSourcesOauthPartialUpdateInputRequestTokenUrl']['output'];
  MutationInputSourcesOauthPartialUpdateInputAuthorizationUrl: Scalars['MutationInputSourcesOauthPartialUpdateInputAuthorizationUrl']['output'];
  MutationInputSourcesOauthPartialUpdateInputAccessTokenUrl: Scalars['MutationInputSourcesOauthPartialUpdateInputAccessTokenUrl']['output'];
  MutationInputSourcesOauthPartialUpdateInputProfileUrl: Scalars['MutationInputSourcesOauthPartialUpdateInputProfileUrl']['output'];
  SourcesOauthDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesOauthDestroyResponse'];
  SourcesPlexCreateResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesPlexCreateResponse'];
  PlexSourceRequestInput: PlexSourceRequestInput;
  MutationInputSourcesPlexCreateInputSlug: Scalars['MutationInputSourcesPlexCreateInputSlug']['output'];
  SourcesPlexUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesPlexUpdateResponse'];
  SourcesPlexPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesPlexPartialUpdateResponse'];
  PatchedPlexSourceRequestInput: PatchedPlexSourceRequestInput;
  MutationInputSourcesPlexPartialUpdateInputSlug: Scalars['MutationInputSourcesPlexPartialUpdateInputSlug']['output'];
  SourcesPlexDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesPlexDestroyResponse'];
  PlexTokenRedeemRequestInput: PlexTokenRedeemRequestInput;
  SourcesSamlCreateResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesSamlCreateResponse'];
  SamlSourceRequestInput: SamlSourceRequestInput;
  MutationInputSourcesSamlCreateInputSlug: Scalars['MutationInputSourcesSamlCreateInputSlug']['output'];
  SourcesSamlUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesSamlUpdateResponse'];
  SourcesSamlPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesSamlPartialUpdateResponse'];
  PatchedSamlSourceRequestInput: PatchedSamlSourceRequestInput;
  MutationInputSourcesSamlPartialUpdateInputSlug: Scalars['MutationInputSourcesSamlPartialUpdateInputSlug']['output'];
  SourcesSamlDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesSamlDestroyResponse'];
  SourcesScimCreateResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesScimCreateResponse'];
  ScimSourceRequestInput: ScimSourceRequestInput;
  MutationInputSourcesScimCreateInputSlug: Scalars['MutationInputSourcesScimCreateInputSlug']['output'];
  SourcesScimUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesScimUpdateResponse'];
  SourcesScimPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesScimPartialUpdateResponse'];
  PatchedScimSourceRequestInput: PatchedScimSourceRequestInput;
  MutationInputSourcesScimPartialUpdateInputSlug: Scalars['MutationInputSourcesScimPartialUpdateInputSlug']['output'];
  SourcesScimDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesScimDestroyResponse'];
  SourcesScimGroupsCreateResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesScimGroupsCreateResponse'];
  ScimSourceGroupRequestInput: ScimSourceGroupRequestInput;
  SourcesScimGroupsUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesScimGroupsUpdateResponse'];
  SourcesScimGroupsPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesScimGroupsPartialUpdateResponse'];
  PatchedScimSourceGroupRequestInput: PatchedScimSourceGroupRequestInput;
  SourcesScimGroupsDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesScimGroupsDestroyResponse'];
  SourcesScimUsersCreateResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesScimUsersCreateResponse'];
  ScimSourceUserRequestInput: ScimSourceUserRequestInput;
  SourcesScimUsersUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesScimUsersUpdateResponse'];
  SourcesScimUsersPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesScimUsersPartialUpdateResponse'];
  PatchedScimSourceUserRequestInput: PatchedScimSourceUserRequestInput;
  SourcesScimUsersDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesScimUsersDestroyResponse'];
  SourcesUserConnectionsAllUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesUserConnectionsAllUpdateResponse'];
  SourcesUserConnectionsAllPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesUserConnectionsAllPartialUpdateResponse'];
  SourcesUserConnectionsAllDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesUserConnectionsAllDestroyResponse'];
  SourcesUserConnectionsOauthCreateResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesUserConnectionsOauthCreateResponse'];
  UserOAuthSourceConnectionRequestInput: UserOAuthSourceConnectionRequestInput;
  MutationInputSourcesUserConnectionsOauthCreateInputIdentifier: Scalars['MutationInputSourcesUserConnectionsOauthCreateInputIdentifier']['output'];
  SourcesUserConnectionsOauthUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesUserConnectionsOauthUpdateResponse'];
  SourcesUserConnectionsOauthPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesUserConnectionsOauthPartialUpdateResponse'];
  PatchedUserOAuthSourceConnectionRequestInput: PatchedUserOAuthSourceConnectionRequestInput;
  MutationInputSourcesUserConnectionsOauthPartialUpdateInputIdentifier: Scalars['MutationInputSourcesUserConnectionsOauthPartialUpdateInputIdentifier']['output'];
  SourcesUserConnectionsOauthDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesUserConnectionsOauthDestroyResponse'];
  SourcesUserConnectionsPlexCreateResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesUserConnectionsPlexCreateResponse'];
  PlexSourceConnectionRequestInput: PlexSourceConnectionRequestInput;
  SourcesUserConnectionsPlexUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesUserConnectionsPlexUpdateResponse'];
  SourcesUserConnectionsPlexPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesUserConnectionsPlexPartialUpdateResponse'];
  PatchedPlexSourceConnectionRequestInput: PatchedPlexSourceConnectionRequestInput;
  SourcesUserConnectionsPlexDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesUserConnectionsPlexDestroyResponse'];
  SourcesUserConnectionsSamlCreateResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesUserConnectionsSamlCreateResponse'];
  UserSamlSourceConnectionRequestInput: UserSamlSourceConnectionRequestInput;
  SourcesUserConnectionsSamlUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesUserConnectionsSamlUpdateResponse'];
  SourcesUserConnectionsSamlPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesUserConnectionsSamlPartialUpdateResponse'];
  PatchedUserSamlSourceConnectionRequestInput: PatchedUserSamlSourceConnectionRequestInput;
  SourcesUserConnectionsSamlDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['SourcesUserConnectionsSamlDestroyResponse'];
  StagesAllDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAllDestroyResponse'];
  StagesAuthenticatorDuoCreateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorDuoCreateResponse'];
  AuthenticatorDuoStageRequestInput: AuthenticatorDuoStageRequestInput;
  FlowSetRequestInput: FlowSetRequestInput;
  MutationInputStagesAuthenticatorDuoCreateInputFlowSetItemsSlug: Scalars['MutationInputStagesAuthenticatorDuoCreateInputFlowSetItemsSlug']['output'];
  StagesAuthenticatorDuoUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorDuoUpdateResponse'];
  StagesAuthenticatorDuoPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorDuoPartialUpdateResponse'];
  PatchedAuthenticatorDuoStageRequestInput: PatchedAuthenticatorDuoStageRequestInput;
  StagesAuthenticatorDuoDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorDuoDestroyResponse'];
  StagesAuthenticatorDuoEnrollmentStatusCreateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorDuoEnrollmentStatusCreateResponse'];
  DuoDeviceEnrollmentStatus: DuoDeviceEnrollmentStatus;
  StagesAuthenticatorDuoImportDeviceManualCreateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorDuoImportDeviceManualCreateResponse'];
  AuthenticatorDuoStageManualDeviceImportRequestInput: AuthenticatorDuoStageManualDeviceImportRequestInput;
  StagesAuthenticatorDuoImportDevicesAutomaticCreateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorDuoImportDevicesAutomaticCreateResponse'];
  AuthenticatorDuoStageDeviceImportResponse: AuthenticatorDuoStageDeviceImportResponse;
  StagesAuthenticatorSmsCreateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorSmsCreateResponse'];
  AuthenticatorSmsStageRequestInput: AuthenticatorSmsStageRequestInput;
  StagesAuthenticatorSmsUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorSmsUpdateResponse'];
  StagesAuthenticatorSmsPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorSmsPartialUpdateResponse'];
  PatchedAuthenticatorSmsStageRequestInput: PatchedAuthenticatorSmsStageRequestInput;
  StagesAuthenticatorSmsDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorSmsDestroyResponse'];
  StagesAuthenticatorStaticCreateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorStaticCreateResponse'];
  AuthenticatorStaticStageRequestInput: AuthenticatorStaticStageRequestInput;
  StagesAuthenticatorStaticUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorStaticUpdateResponse'];
  StagesAuthenticatorStaticPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorStaticPartialUpdateResponse'];
  PatchedAuthenticatorStaticStageRequestInput: PatchedAuthenticatorStaticStageRequestInput;
  StagesAuthenticatorStaticDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorStaticDestroyResponse'];
  StagesAuthenticatorTotpCreateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorTotpCreateResponse'];
  AuthenticatorTotpStageRequestInput: AuthenticatorTotpStageRequestInput;
  StagesAuthenticatorTotpUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorTotpUpdateResponse'];
  StagesAuthenticatorTotpPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorTotpPartialUpdateResponse'];
  PatchedAuthenticatorTotpStageRequestInput: PatchedAuthenticatorTotpStageRequestInput;
  StagesAuthenticatorTotpDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorTotpDestroyResponse'];
  StagesAuthenticatorValidateCreateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorValidateCreateResponse'];
  AuthenticatorValidateStageRequestInput: AuthenticatorValidateStageRequestInput;
  StagesAuthenticatorValidateUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorValidateUpdateResponse'];
  StagesAuthenticatorValidatePartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorValidatePartialUpdateResponse'];
  PatchedAuthenticatorValidateStageRequestInput: PatchedAuthenticatorValidateStageRequestInput;
  StagesAuthenticatorValidateDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorValidateDestroyResponse'];
  StagesAuthenticatorWebauthnCreateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorWebauthnCreateResponse'];
  AuthenticatorWebAuthnStageRequestInput: AuthenticatorWebAuthnStageRequestInput;
  StagesAuthenticatorWebauthnUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorWebauthnUpdateResponse'];
  StagesAuthenticatorWebauthnPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorWebauthnPartialUpdateResponse'];
  PatchedAuthenticatorWebAuthnStageRequestInput: PatchedAuthenticatorWebAuthnStageRequestInput;
  StagesAuthenticatorWebauthnDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['StagesAuthenticatorWebauthnDestroyResponse'];
  StagesCaptchaCreateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesCaptchaCreateResponse'];
  CaptchaStageRequestInput: CaptchaStageRequestInput;
  StagesCaptchaUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesCaptchaUpdateResponse'];
  StagesCaptchaPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesCaptchaPartialUpdateResponse'];
  PatchedCaptchaStageRequestInput: PatchedCaptchaStageRequestInput;
  StagesCaptchaDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['StagesCaptchaDestroyResponse'];
  StagesConsentCreateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesConsentCreateResponse'];
  ConsentStageRequestInput: ConsentStageRequestInput;
  StagesConsentUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesConsentUpdateResponse'];
  StagesConsentPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesConsentPartialUpdateResponse'];
  PatchedConsentStageRequestInput: PatchedConsentStageRequestInput;
  StagesConsentDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['StagesConsentDestroyResponse'];
  StagesDenyCreateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesDenyCreateResponse'];
  DenyStageRequestInput: DenyStageRequestInput;
  StagesDenyUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesDenyUpdateResponse'];
  StagesDenyPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesDenyPartialUpdateResponse'];
  PatchedDenyStageRequestInput: PatchedDenyStageRequestInput;
  StagesDenyDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['StagesDenyDestroyResponse'];
  StagesDummyCreateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesDummyCreateResponse'];
  DummyStageRequestInput: DummyStageRequestInput;
  StagesDummyUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesDummyUpdateResponse'];
  StagesDummyPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesDummyPartialUpdateResponse'];
  PatchedDummyStageRequestInput: PatchedDummyStageRequestInput;
  StagesDummyDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['StagesDummyDestroyResponse'];
  StagesEmailCreateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesEmailCreateResponse'];
  EmailStageRequestInput: EmailStageRequestInput;
  StagesEmailUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesEmailUpdateResponse'];
  StagesEmailPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesEmailPartialUpdateResponse'];
  PatchedEmailStageRequestInput: PatchedEmailStageRequestInput;
  StagesEmailDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['StagesEmailDestroyResponse'];
  StagesIdentificationCreateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesIdentificationCreateResponse'];
  IdentificationStageRequestInput: IdentificationStageRequestInput;
  StagesIdentificationUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesIdentificationUpdateResponse'];
  StagesIdentificationPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesIdentificationPartialUpdateResponse'];
  PatchedIdentificationStageRequestInput: PatchedIdentificationStageRequestInput;
  StagesIdentificationDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['StagesIdentificationDestroyResponse'];
  StagesInvitationInvitationsCreateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesInvitationInvitationsCreateResponse'];
  InvitationRequestInput: InvitationRequestInput;
  MutationInputStagesInvitationInvitationsCreateInputName: Scalars['MutationInputStagesInvitationInvitationsCreateInputName']['output'];
  StagesInvitationInvitationsUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesInvitationInvitationsUpdateResponse'];
  StagesInvitationInvitationsPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesInvitationInvitationsPartialUpdateResponse'];
  PatchedInvitationRequestInput: PatchedInvitationRequestInput;
  MutationInputStagesInvitationInvitationsPartialUpdateInputName: Scalars['MutationInputStagesInvitationInvitationsPartialUpdateInputName']['output'];
  StagesInvitationInvitationsDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['StagesInvitationInvitationsDestroyResponse'];
  StagesInvitationStagesCreateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesInvitationStagesCreateResponse'];
  InvitationStageRequestInput: InvitationStageRequestInput;
  StagesInvitationStagesUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesInvitationStagesUpdateResponse'];
  StagesInvitationStagesPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesInvitationStagesPartialUpdateResponse'];
  PatchedInvitationStageRequestInput: PatchedInvitationStageRequestInput;
  StagesInvitationStagesDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['StagesInvitationStagesDestroyResponse'];
  StagesPasswordCreateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesPasswordCreateResponse'];
  PasswordStageRequestInput: PasswordStageRequestInput;
  StagesPasswordUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesPasswordUpdateResponse'];
  StagesPasswordPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesPasswordPartialUpdateResponse'];
  PatchedPasswordStageRequestInput: PatchedPasswordStageRequestInput;
  StagesPasswordDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['StagesPasswordDestroyResponse'];
  StagesPromptPromptsCreateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesPromptPromptsCreateResponse'];
  PromptRequestInput: PromptRequestInput;
  StageRequestInput: StageRequestInput;
  StagesPromptPromptsUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesPromptPromptsUpdateResponse'];
  StagesPromptPromptsPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesPromptPromptsPartialUpdateResponse'];
  PatchedPromptRequestInput: PatchedPromptRequestInput;
  StagesPromptPromptsDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['StagesPromptPromptsDestroyResponse'];
  StagesPromptPromptsPreviewCreateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesPromptPromptsPreviewCreateResponse'];
  StagesPromptStagesCreateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesPromptStagesCreateResponse'];
  PromptStageRequestInput: PromptStageRequestInput;
  StagesPromptStagesUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesPromptStagesUpdateResponse'];
  StagesPromptStagesPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesPromptStagesPartialUpdateResponse'];
  PatchedPromptStageRequestInput: PatchedPromptStageRequestInput;
  StagesPromptStagesDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['StagesPromptStagesDestroyResponse'];
  StagesSourceCreateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesSourceCreateResponse'];
  SourceStageRequestInput: SourceStageRequestInput;
  StagesSourceUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesSourceUpdateResponse'];
  StagesSourcePartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesSourcePartialUpdateResponse'];
  PatchedSourceStageRequestInput: PatchedSourceStageRequestInput;
  StagesSourceDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['StagesSourceDestroyResponse'];
  StagesUserDeleteCreateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesUserDeleteCreateResponse'];
  UserDeleteStageRequestInput: UserDeleteStageRequestInput;
  StagesUserDeleteUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesUserDeleteUpdateResponse'];
  StagesUserDeletePartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesUserDeletePartialUpdateResponse'];
  PatchedUserDeleteStageRequestInput: PatchedUserDeleteStageRequestInput;
  StagesUserDeleteDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['StagesUserDeleteDestroyResponse'];
  StagesUserLoginCreateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesUserLoginCreateResponse'];
  UserLoginStageRequestInput: UserLoginStageRequestInput;
  StagesUserLoginUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesUserLoginUpdateResponse'];
  StagesUserLoginPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesUserLoginPartialUpdateResponse'];
  PatchedUserLoginStageRequestInput: PatchedUserLoginStageRequestInput;
  StagesUserLoginDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['StagesUserLoginDestroyResponse'];
  StagesUserLogoutCreateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesUserLogoutCreateResponse'];
  UserLogoutStageRequestInput: UserLogoutStageRequestInput;
  StagesUserLogoutUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesUserLogoutUpdateResponse'];
  StagesUserLogoutPartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesUserLogoutPartialUpdateResponse'];
  PatchedUserLogoutStageRequestInput: PatchedUserLogoutStageRequestInput;
  StagesUserLogoutDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['StagesUserLogoutDestroyResponse'];
  StagesUserWriteCreateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesUserWriteCreateResponse'];
  UserWriteStageRequestInput: UserWriteStageRequestInput;
  StagesUserWriteUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesUserWriteUpdateResponse'];
  StagesUserWritePartialUpdateResponse: ResolversUnionTypes<ResolversParentTypes>['StagesUserWritePartialUpdateResponse'];
  PatchedUserWriteStageRequestInput: PatchedUserWriteStageRequestInput;
  StagesUserWriteDestroyResponse: ResolversUnionTypes<ResolversParentTypes>['StagesUserWriteDestroyResponse'];
  ObjMap: Scalars['ObjMap']['output'];
  ResolveToSourceArgs: Scalars['ResolveToSourceArgs']['output'];
}>;

export type resolveRootDirectiveArgs = {
  subgraph?: Maybe<Scalars['String']['input']>;
};

export type resolveRootDirectiveResolver<Result, Parent, ContextType = MeshContext, Args = resolveRootDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type statusCodeTypeNameDirectiveArgs = {
  subgraph?: Maybe<Scalars['String']['input']>;
  typeName?: Maybe<Scalars['String']['input']>;
  statusCode?: Maybe<Scalars['ID']['input']>;
};

export type statusCodeTypeNameDirectiveResolver<Result, Parent, ContextType = MeshContext, Args = statusCodeTypeNameDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type lengthDirectiveArgs = {
  subgraph?: Maybe<Scalars['String']['input']>;
  min?: Maybe<Scalars['Int']['input']>;
  max?: Maybe<Scalars['Int']['input']>;
};

export type lengthDirectiveResolver<Result, Parent, ContextType = MeshContext, Args = lengthDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type enumDirectiveArgs = {
  subgraph?: Maybe<Scalars['String']['input']>;
  value?: Maybe<Scalars['String']['input']>;
};

export type enumDirectiveResolver<Result, Parent, ContextType = MeshContext, Args = enumDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type regexpDirectiveArgs = {
  subgraph?: Maybe<Scalars['String']['input']>;
  pattern?: Maybe<Scalars['String']['input']>;
};

export type regexpDirectiveResolver<Result, Parent, ContextType = MeshContext, Args = regexpDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type typescriptDirectiveArgs = {
  subgraph?: Maybe<Scalars['String']['input']>;
  type?: Maybe<Scalars['String']['input']>;
};

export type typescriptDirectiveResolver<Result, Parent, ContextType = MeshContext, Args = typescriptDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type discriminatorDirectiveArgs = {
  subgraph?: Maybe<Scalars['String']['input']>;
  field?: Maybe<Scalars['String']['input']>;
  mapping?: Maybe<Scalars['ObjMap']['input']>;
};

export type discriminatorDirectiveResolver<Result, Parent, ContextType = MeshContext, Args = discriminatorDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type httpOperationDirectiveArgs = {
  subgraph?: Maybe<Scalars['String']['input']>;
  path?: Maybe<Scalars['String']['input']>;
  operationSpecificHeaders?: Maybe<Array<Maybe<Array<Maybe<Scalars['String']['input']>>>>>;
  httpMethod?: Maybe<HttpMethod>;
  isBinary?: Maybe<Scalars['Boolean']['input']>;
  requestBaseBody?: Maybe<Scalars['ObjMap']['input']>;
  queryParamArgMap?: Maybe<Scalars['ObjMap']['input']>;
  queryStringOptionsByParam?: Maybe<Scalars['ObjMap']['input']>;
  jsonApiFields?: Maybe<Scalars['Boolean']['input']>;
  queryStringOptions?: Maybe<Scalars['ObjMap']['input']>;
};

export type httpOperationDirectiveResolver<Result, Parent, ContextType = MeshContext, Args = httpOperationDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type transportDirectiveArgs = {
  subgraph?: Maybe<Scalars['String']['input']>;
  kind?: Maybe<Scalars['String']['input']>;
  location?: Maybe<Scalars['String']['input']>;
  headers?: Maybe<Array<Maybe<Array<Maybe<Scalars['String']['input']>>>>>;
  queryStringOptions?: Maybe<Scalars['ObjMap']['input']>;
  queryParams?: Maybe<Array<Maybe<Array<Maybe<Scalars['String']['input']>>>>>;
};

export type transportDirectiveResolver<Result, Parent, ContextType = MeshContext, Args = transportDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type resolveToDirectiveArgs = {
  requiredSelectionSet?: Maybe<Scalars['String']['input']>;
  sourceName: Scalars['String']['input'];
  sourceTypeName: Scalars['String']['input'];
  sourceFieldName: Scalars['String']['input'];
  sourceSelectionSet?: Maybe<Scalars['String']['input']>;
  sourceArgs?: Maybe<Scalars['ResolveToSourceArgs']['input']>;
  keyField?: Maybe<Scalars['String']['input']>;
  keysArg?: Maybe<Scalars['String']['input']>;
  pubsubTopic?: Maybe<Scalars['String']['input']>;
  filterBy?: Maybe<Scalars['String']['input']>;
  additionalArgs?: Maybe<Scalars['ResolveToSourceArgs']['input']>;
  result?: Maybe<Scalars['String']['input']>;
  resultType?: Maybe<Scalars['String']['input']>;
};

export type resolveToDirectiveResolver<Result, Parent, ContextType = MeshContext, Args = resolveToDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type QueryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = ResolversObject<{
  group?: Resolver<ResolversTypes['ChurrosGroup'], ParentType, ContextType, RequireFields<QuerygroupArgs, 'uid'>>;
  me?: Resolver<ResolversTypes['ChurrosUser'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['ChurrosUser'], ParentType, ContextType, Partial<QueryuserArgs>>;
  applications?: Resolver<Maybe<ResolversTypes['CoreApplicationsListResponse']>, ParentType, ContextType, Partial<QueryapplicationsArgs>>;
  application?: Resolver<Maybe<ResolversTypes['CoreApplicationsRetrieveResponse']>, ParentType, ContextType, RequireFields<QueryapplicationArgs, 'slug'>>;
  coreApplicationsCheckAccessRetrieve?: Resolver<Maybe<ResolversTypes['CoreApplicationsCheckAccessRetrieveResponse']>, ParentType, ContextType, RequireFields<QuerycoreApplicationsCheckAccessRetrieveArgs, 'slug'>>;
  applicationMetrics?: Resolver<Maybe<Array<Maybe<ResolversTypes['CoreApplicationsMetricsListResponse']>>>, ParentType, ContextType, RequireFields<QueryapplicationMetricsArgs, 'slug'>>;
  coreApplicationsUsedByList?: Resolver<Maybe<Array<Maybe<ResolversTypes['CoreApplicationsUsedByListResponse']>>>, ParentType, ContextType, RequireFields<QuerycoreApplicationsUsedByListArgs, 'slug'>>;
  flowsBindingsList?: Resolver<Maybe<ResolversTypes['FlowsBindingsListResponse']>, ParentType, ContextType, Partial<QueryflowsBindingsListArgs>>;
  flowsBindingsRetrieve?: Resolver<Maybe<ResolversTypes['FlowsBindingsRetrieveResponse']>, ParentType, ContextType, RequireFields<QueryflowsBindingsRetrieveArgs, 'fsbUuid'>>;
  flowsBindingsUsedByList?: Resolver<Maybe<Array<Maybe<ResolversTypes['FlowsBindingsUsedByListResponse']>>>, ParentType, ContextType, RequireFields<QueryflowsBindingsUsedByListArgs, 'fsbUuid'>>;
  flowsExecutorGet?: Resolver<Maybe<ResolversTypes['FlowsExecutorGetResponse']>, ParentType, ContextType, RequireFields<QueryflowsExecutorGetArgs, 'flowSlug' | 'query'>>;
  flowsInspectorGet?: Resolver<Maybe<ResolversTypes['FlowsInspectorGetResponse']>, ParentType, ContextType, RequireFields<QueryflowsInspectorGetArgs, 'flowSlug'>>;
  flowsInstancesList?: Resolver<Maybe<ResolversTypes['FlowsInstancesListResponse']>, ParentType, ContextType, Partial<QueryflowsInstancesListArgs>>;
  flowsInstancesRetrieve?: Resolver<Maybe<ResolversTypes['FlowsInstancesRetrieveResponse']>, ParentType, ContextType, RequireFields<QueryflowsInstancesRetrieveArgs, 'slug'>>;
  flowsInstancesDiagramRetrieve?: Resolver<Maybe<ResolversTypes['FlowsInstancesDiagramRetrieveResponse']>, ParentType, ContextType, RequireFields<QueryflowsInstancesDiagramRetrieveArgs, 'slug'>>;
  flowsInstancesExecuteRetrieve?: Resolver<Maybe<ResolversTypes['FlowsInstancesExecuteRetrieveResponse']>, ParentType, ContextType, RequireFields<QueryflowsInstancesExecuteRetrieveArgs, 'slug'>>;
  flowsInstancesExportRetrieve?: Resolver<Maybe<ResolversTypes['FlowsInstancesExportRetrieveResponse']>, ParentType, ContextType, RequireFields<QueryflowsInstancesExportRetrieveArgs, 'slug'>>;
  flowsInstancesUsedByList?: Resolver<Maybe<Array<Maybe<ResolversTypes['FlowsInstancesUsedByListResponse']>>>, ParentType, ContextType, RequireFields<QueryflowsInstancesUsedByListArgs, 'slug'>>;
  flowsInstancesCacheInfoRetrieve?: Resolver<Maybe<ResolversTypes['FlowsInstancesCacheInfoRetrieveResponse']>, ParentType, ContextType>;
  providers?: Resolver<Maybe<ResolversTypes['ProvidersAllListResponse']>, ParentType, ContextType, Partial<QueryprovidersArgs>>;
  provider?: Resolver<Maybe<ResolversTypes['ProvidersAllRetrieveResponse']>, ParentType, ContextType, RequireFields<QueryproviderArgs, 'id'>>;
  providersAllUsedByList?: Resolver<Maybe<Array<Maybe<ResolversTypes['ProvidersAllUsedByListResponse']>>>, ParentType, ContextType, RequireFields<QueryprovidersAllUsedByListArgs, 'id'>>;
  providersAllTypesList?: Resolver<Maybe<Array<Maybe<ResolversTypes['ProvidersAllTypesListResponse']>>>, ParentType, ContextType>;
}>;

export type SubscriptionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Subscription'] = ResolversParentTypes['Subscription']> = ResolversObject<{
  announcementsNow?: SubscriptionResolver<Array<ResolversTypes['ChurrosAnnouncement']>, "announcementsNow", ParentType, ContextType>;
  article?: SubscriptionResolver<ResolversTypes['ChurrosArticle'], "article", ParentType, ContextType, RequireFields<SubscriptionarticleArgs, 'id'>>;
  event?: SubscriptionResolver<ResolversTypes['ChurrosEvent'], "event", ParentType, ContextType, Partial<SubscriptioneventArgs>>;
  form?: SubscriptionResolver<Maybe<ResolversTypes['ChurrosForm']>, "form", ParentType, ContextType, RequireFields<SubscriptionformArgs, 'localId'>>;
  homepage?: SubscriptionResolver<ResolversTypes['ChurrosQueryHomepageConnection'], "homepage", ParentType, ContextType, Partial<SubscriptionhomepageArgs>>;
  kioskReload?: SubscriptionResolver<ResolversTypes['Boolean'], "kioskReload", ParentType, ContextType>;
  registration?: SubscriptionResolver<ResolversTypes['ChurrosSubscriptionRegistrationResult'], "registration", ParentType, ContextType, RequireFields<SubscriptionregistrationArgs, 'id'>>;
  thirdPartyApp?: SubscriptionResolver<ResolversTypes['ChurrosThirdPartyApp'], "thirdPartyApp", ParentType, ContextType, RequireFields<SubscriptionthirdPartyAppArgs, 'id'>>;
}>;

export type ChurrosAnnouncementResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosAnnouncement'] = ResolversParentTypes['ChurrosAnnouncement']> = ResolversObject<{
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHtml?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  by?: Resolver<Maybe<ResolversTypes['ChurrosUser']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  endsAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  localID?: Resolver<ResolversTypes['ChurrosLocalID'], ParentType, ContextType>;
  startsAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  warning?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosAnswerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosAnswer'] = ResolversParentTypes['ChurrosAnswer']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosAnswerDate' | 'ChurrosAnswerFileUpload' | 'ChurrosAnswerLongText' | 'ChurrosAnswerNumber' | 'ChurrosAnswerScale' | 'ChurrosAnswerSelectMultiple' | 'ChurrosAnswerSelectOne' | 'ChurrosAnswerText' | 'ChurrosAnswerTime', ParentType, ContextType>;
  answerString?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  booking?: Resolver<Maybe<ResolversTypes['ChurrosRegistration']>, ParentType, ContextType>;
  checkboxIsMarked?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['ChurrosUser']>, ParentType, ContextType>;
  form?: Resolver<ResolversTypes['ChurrosForm'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  question?: Resolver<ResolversTypes['ChurrosQuestion'], ParentType, ContextType>;
  section?: Resolver<ResolversTypes['ChurrosFormSection'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
}>;

export type ChurrosAnswerDateResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosAnswerDate'] = ResolversParentTypes['ChurrosAnswerDate']> = ResolversObject<{
  answerString?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  booking?: Resolver<Maybe<ResolversTypes['ChurrosRegistration']>, ParentType, ContextType>;
  checkboxIsMarked?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['ChurrosUser']>, ParentType, ContextType>;
  form?: Resolver<ResolversTypes['ChurrosForm'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  question?: Resolver<ResolversTypes['ChurrosQuestionScalar'], ParentType, ContextType>;
  rawValue?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  section?: Resolver<ResolversTypes['ChurrosFormSection'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosAnswerFileUploadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosAnswerFileUpload'] = ResolversParentTypes['ChurrosAnswerFileUpload']> = ResolversObject<{
  answerString?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  booking?: Resolver<Maybe<ResolversTypes['ChurrosRegistration']>, ParentType, ContextType>;
  checkboxIsMarked?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['ChurrosUser']>, ParentType, ContextType>;
  form?: Resolver<ResolversTypes['ChurrosForm'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  question?: Resolver<ResolversTypes['ChurrosQuestionFileUpload'], ParentType, ContextType>;
  section?: Resolver<ResolversTypes['ChurrosFormSection'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosAnswerLongTextResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosAnswerLongText'] = ResolversParentTypes['ChurrosAnswerLongText']> = ResolversObject<{
  answerString?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  booking?: Resolver<Maybe<ResolversTypes['ChurrosRegistration']>, ParentType, ContextType>;
  checkboxIsMarked?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['ChurrosUser']>, ParentType, ContextType>;
  form?: Resolver<ResolversTypes['ChurrosForm'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  question?: Resolver<ResolversTypes['ChurrosQuestionScalar'], ParentType, ContextType>;
  section?: Resolver<ResolversTypes['ChurrosFormSection'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosAnswerNumberResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosAnswerNumber'] = ResolversParentTypes['ChurrosAnswerNumber']> = ResolversObject<{
  answerString?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  booking?: Resolver<Maybe<ResolversTypes['ChurrosRegistration']>, ParentType, ContextType>;
  checkboxIsMarked?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['ChurrosUser']>, ParentType, ContextType>;
  form?: Resolver<ResolversTypes['ChurrosForm'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  question?: Resolver<ResolversTypes['ChurrosQuestionScalar'], ParentType, ContextType>;
  section?: Resolver<ResolversTypes['ChurrosFormSection'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosAnswerScaleResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosAnswerScale'] = ResolversParentTypes['ChurrosAnswerScale']> = ResolversObject<{
  answerString?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  booking?: Resolver<Maybe<ResolversTypes['ChurrosRegistration']>, ParentType, ContextType>;
  checkboxIsMarked?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['ChurrosUser']>, ParentType, ContextType>;
  form?: Resolver<ResolversTypes['ChurrosForm'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  normalizedValue?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  question?: Resolver<ResolversTypes['ChurrosQuestionScale'], ParentType, ContextType>;
  section?: Resolver<ResolversTypes['ChurrosFormSection'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosAnswerSearchResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosAnswerSearchResult'] = ResolversParentTypes['ChurrosAnswerSearchResult']> = ResolversObject<{
  answer?: Resolver<ResolversTypes['ChurrosAnswer'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  rank?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  similarity?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosAnswerSelectMultipleResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosAnswerSelectMultiple'] = ResolversParentTypes['ChurrosAnswerSelectMultiple']> = ResolversObject<{
  answerString?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  booking?: Resolver<Maybe<ResolversTypes['ChurrosRegistration']>, ParentType, ContextType>;
  checkboxIsMarked?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['ChurrosUser']>, ParentType, ContextType>;
  form?: Resolver<ResolversTypes['ChurrosForm'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  question?: Resolver<ResolversTypes['ChurrosQuestionSelectMultiple'], ParentType, ContextType>;
  section?: Resolver<ResolversTypes['ChurrosFormSection'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  value?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosAnswerSelectOneResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosAnswerSelectOne'] = ResolversParentTypes['ChurrosAnswerSelectOne']> = ResolversObject<{
  answerString?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  booking?: Resolver<Maybe<ResolversTypes['ChurrosRegistration']>, ParentType, ContextType>;
  checkboxIsMarked?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['ChurrosUser']>, ParentType, ContextType>;
  form?: Resolver<ResolversTypes['ChurrosForm'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  question?: Resolver<ResolversTypes['ChurrosQuestionSelectOne'], ParentType, ContextType>;
  section?: Resolver<ResolversTypes['ChurrosFormSection'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosAnswerTextResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosAnswerText'] = ResolversParentTypes['ChurrosAnswerText']> = ResolversObject<{
  answerString?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  booking?: Resolver<Maybe<ResolversTypes['ChurrosRegistration']>, ParentType, ContextType>;
  checkboxIsMarked?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['ChurrosUser']>, ParentType, ContextType>;
  form?: Resolver<ResolversTypes['ChurrosForm'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  question?: Resolver<ResolversTypes['ChurrosQuestionScalar'], ParentType, ContextType>;
  section?: Resolver<ResolversTypes['ChurrosFormSection'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosAnswerTimeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosAnswerTime'] = ResolversParentTypes['ChurrosAnswerTime']> = ResolversObject<{
  answer?: Resolver<ResolversTypes['ChurrosAnswer'], ParentType, ContextType>;
  answerString?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  booking?: Resolver<Maybe<ResolversTypes['ChurrosRegistration']>, ParentType, ContextType>;
  checkboxIsMarked?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['ChurrosUser']>, ParentType, ContextType>;
  form?: Resolver<ResolversTypes['ChurrosForm'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  question?: Resolver<ResolversTypes['ChurrosQuestionScalar'], ParentType, ContextType>;
  rawValue?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  section?: Resolver<ResolversTypes['ChurrosFormSection'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosAnswersOfUserResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosAnswersOfUser'] = ResolversParentTypes['ChurrosAnswersOfUser']> = ResolversObject<{
  answers?: Resolver<Array<ResolversTypes['ChurrosAnswer']>, ParentType, ContextType>;
  date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['ChurrosUser'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosApiRateLimitHitsResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosApiRateLimitHits'] = ResolversParentTypes['ChurrosApiRateLimitHits']> = ResolversObject<{
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  queryName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  queryType?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['ChurrosUser']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosApiUsageResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosApiUsage'] = ResolversParentTypes['ChurrosApiUsage']> = ResolversObject<{
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  queryName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  queryType?: Resolver<ResolversTypes['ChurrosApiUsageQueryType'], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['ChurrosUser']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosArticleResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosArticle'] = ResolversParentTypes['ChurrosArticle']> = ResolversObject<{
  author?: Resolver<Maybe<ResolversTypes['ChurrosUser']>, ParentType, ContextType>;
  authorId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHtml?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyPreview?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  canBeEdited?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  comments?: Resolver<ResolversTypes['ChurrosCommentsConnection'], ParentType, ContextType, Partial<ChurrosArticlecommentsArgs>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  event?: Resolver<Maybe<ResolversTypes['ChurrosEvent']>, ParentType, ContextType>;
  eventId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  group?: Resolver<ResolversTypes['ChurrosGroup'], ParentType, ContextType>;
  groupId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  links?: Resolver<Array<ResolversTypes['ChurrosLink']>, ParentType, ContextType>;
  localID?: Resolver<ResolversTypes['ChurrosLocalID'], ParentType, ContextType>;
  myReactions?: Resolver<ResolversTypes['ChurrosBooleanMap'], ParentType, ContextType>;
  notifiedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  pictureFile?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pictureFileDark?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pictureURL?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<ChurrosArticlepictureURLArgs, 'dark'>>;
  published?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  publishedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  reacted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType, RequireFields<ChurrosArticlereactedArgs, 'emoji'>>;
  reactionCounts?: Resolver<ResolversTypes['ChurrosCounts'], ParentType, ContextType>;
  reactions?: Resolver<ResolversTypes['Int'], ParentType, ContextType, RequireFields<ChurrosArticlereactionsArgs, 'emoji'>>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  uid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  visibility?: Resolver<ResolversTypes['ChurrosVisibility'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosArticleSearchResultTypeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosArticleSearchResultType'] = ResolversParentTypes['ChurrosArticleSearchResultType']> = ResolversObject<{
  article?: Resolver<ResolversTypes['ChurrosArticle'], ParentType, ContextType>;
  highlightedTitle?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  rank?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  similarity?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosAwaitingValidationErrorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosAwaitingValidationError'] = ResolversParentTypes['ChurrosAwaitingValidationError']> = ResolversObject<{
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosBarWeekResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosBarWeek'] = ResolversParentTypes['ChurrosBarWeek']> = ResolversObject<{
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  descriptionHtml?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  endsAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  groups?: Resolver<Array<ResolversTypes['ChurrosGroup']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  localID?: Resolver<ResolversTypes['ChurrosLocalID'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  startsAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  uid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface ChurrosBooleanMapScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['ChurrosBooleanMap'], any> {
  name: 'ChurrosBooleanMap';
}

export type ChurrosBuildInfoResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosBuildInfo'] = ResolversParentTypes['ChurrosBuildInfo']> = ResolversObject<{
  commit?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosChangelogReleaseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosChangelogRelease'] = ResolversParentTypes['ChurrosChangelogRelease']> = ResolversObject<{
  changes?: Resolver<ResolversTypes['ChurrosReleaseChangesMaps'], ParentType, ContextType>;
  date?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  descriptionHtml?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosCommentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosComment'] = ResolversParentTypes['ChurrosComment']> = ResolversObject<{
  author?: Resolver<Maybe<ResolversTypes['ChurrosUser']>, ParentType, ContextType>;
  authorId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHtml?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  document?: Resolver<Maybe<ResolversTypes['ChurrosDocument']>, ParentType, ContextType>;
  documentId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  inReplyTo?: Resolver<Maybe<ResolversTypes['ChurrosComment']>, ParentType, ContextType>;
  inReplyToId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  localID?: Resolver<ResolversTypes['ChurrosLocalID'], ParentType, ContextType>;
  reacted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType, RequireFields<ChurrosCommentreactedArgs, 'emoji'>>;
  reactions?: Resolver<ResolversTypes['Int'], ParentType, ContextType, RequireFields<ChurrosCommentreactionsArgs, 'emoji'>>;
  replies?: Resolver<Array<ResolversTypes['ChurrosComment']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosCommentableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosCommentable'] = ResolversParentTypes['ChurrosCommentable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosArticle' | 'ChurrosDocument', ParentType, ContextType>;
  comments?: Resolver<ResolversTypes['ChurrosCommentsConnection'], ParentType, ContextType, Partial<ChurrosCommentablecommentsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
}>;

export type ChurrosCommentsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosCommentsConnection'] = ResolversParentTypes['ChurrosCommentsConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['ChurrosCommentsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['ChurrosComment']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['ChurrosPageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosCommentsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosCommentsEdge'] = ResolversParentTypes['ChurrosCommentsEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ChurrosComment'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosCompleteSignupResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosCompleteSignupResult'] = ResolversParentTypes['ChurrosCompleteSignupResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosUser' | 'ChurrosUserCandidate', ParentType, ContextType>;
}>;

export type ChurrosContributionOptionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosContributionOption'] = ResolversParentTypes['ChurrosContributionOption']> = ResolversObject<{
  descriptionHtml?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  offeredIn?: Resolver<ResolversTypes['ChurrosSchool'], ParentType, ContextType>;
  paysFor?: Resolver<Array<ResolversTypes['ChurrosStudentAssociation']>, ParentType, ContextType>;
  price?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface ChurrosCountsScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['ChurrosCounts'], any> {
  name: 'ChurrosCounts';
}

export type ChurrosCredentialResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosCredential'] = ResolversParentTypes['ChurrosCredential']> = ResolversObject<{
  active?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  expiresAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  token?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['ChurrosCredentialType'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['ChurrosUser'], ParentType, ContextType>;
  userAgent?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosDatabaseHealthCheckResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosDatabaseHealthCheck'] = ResolversParentTypes['ChurrosDatabaseHealthCheck']> = ResolversObject<{
  prisma?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface DateTimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['DateTime'], any> {
  name: 'DateTime';
}

export type ChurrosDocumentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosDocument'] = ResolversParentTypes['ChurrosDocument']> = ResolversObject<{
  comments?: Resolver<ResolversTypes['ChurrosCommentsConnection'], ParentType, ContextType, Partial<ChurrosDocumentcommentsArgs>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  descriptionHtml?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  localID?: Resolver<ResolversTypes['ChurrosLocalID'], ParentType, ContextType>;
  paperPaths?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  reacted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType, RequireFields<ChurrosDocumentreactedArgs, 'emoji'>>;
  reactions?: Resolver<ResolversTypes['Int'], ParentType, ContextType, RequireFields<ChurrosDocumentreactionsArgs, 'emoji'>>;
  schoolYear?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  solutionPaths?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  subject?: Resolver<Maybe<ResolversTypes['ChurrosSubject']>, ParentType, ContextType>;
  subjectId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['ChurrosDocumentType'], ParentType, ContextType>;
  uid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  uploader?: Resolver<Maybe<ResolversTypes['ChurrosUser']>, ParentType, ContextType>;
  uploaderId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosDocumentSearchResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosDocumentSearchResult'] = ResolversParentTypes['ChurrosDocumentSearchResult']> = ResolversObject<{
  document?: Resolver<ResolversTypes['ChurrosDocument'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  rank?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  similarity?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosEmailChangeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosEmailChange'] = ResolversParentTypes['ChurrosEmailChange']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pending?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['ChurrosUser'], ParentType, ContextType>;
  userId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosErrorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosError'] = ResolversParentTypes['ChurrosError']> = ResolversObject<{
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosErrorInterfaceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosErrorInterface'] = ResolversParentTypes['ChurrosErrorInterface']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosNotFoundError' | 'ChurrosZodError', ParentType, ContextType>;
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
}>;

export type ChurrosEvenSearchResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosEvenSearchResult'] = ResolversParentTypes['ChurrosEvenSearchResult']> = ResolversObject<{
  event?: Resolver<ResolversTypes['ChurrosEvent'], ParentType, ContextType>;
  highlightedTitle?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  rank?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  similarity?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosEvent'] = ResolversParentTypes['ChurrosEvent']> = ResolversObject<{
  articles?: Resolver<Array<ResolversTypes['ChurrosArticle']>, ParentType, ContextType>;
  author?: Resolver<Maybe<ResolversTypes['ChurrosUser']>, ParentType, ContextType>;
  authorId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  bannedUsers?: Resolver<Array<ResolversTypes['ChurrosUser']>, ParentType, ContextType>;
  beneficiary?: Resolver<Maybe<ResolversTypes['ChurrosLydiaAccount']>, ParentType, ContextType>;
  bookings?: Resolver<ResolversTypes['ChurrosEventBookingsConnection'], ParentType, ContextType, Partial<ChurrosEventbookingsArgs>>;
  bookingsCounts?: Resolver<ResolversTypes['ChurrosRegistrationsCounts'], ParentType, ContextType>;
  bookingsCsv?: Resolver<ResolversTypes['ChurrosEventBookingsCsvResult'], ParentType, ContextType>;
  canEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  canEditManagers?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  canScanBookings?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  canSeeBookings?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  canSeeLogs?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  capacity?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  coOrganizers?: Resolver<Array<ResolversTypes['ChurrosGroup']>, ParentType, ContextType>;
  contactMail?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  descriptionHtml?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  descriptionPreview?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  endsAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  forms?: Resolver<Array<ResolversTypes['ChurrosForm']>, ParentType, ContextType>;
  frequency?: Resolver<ResolversTypes['ChurrosEventFrequency'], ParentType, ContextType>;
  group?: Resolver<ResolversTypes['ChurrosGroup'], ParentType, ContextType>;
  groupId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  includeInKiosk?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  links?: Resolver<Array<ResolversTypes['ChurrosLink']>, ParentType, ContextType>;
  localID?: Resolver<ResolversTypes['ChurrosLocalID'], ParentType, ContextType>;
  location?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  logs?: Resolver<ResolversTypes['ChurrosEventLogsConnection'], ParentType, ContextType, Partial<ChurrosEventlogsArgs>>;
  lydiaAccountId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  managers?: Resolver<Array<ResolversTypes['ChurrosEventManager']>, ParentType, ContextType>;
  myBookings?: Resolver<ResolversTypes['ChurrosEventMyBookingsResult'], ParentType, ContextType>;
  myReactions?: Resolver<ResolversTypes['ChurrosBooleanMap'], ParentType, ContextType>;
  mySoonestShotgunOpensAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  pictureFile?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pictureFileDark?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pictureURL?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<ChurrosEventpictureURLArgs, 'dark'>>;
  placesLeft?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  profitsBreakdown?: Resolver<ResolversTypes['ChurrosProfitsBreakdown'], ParentType, ContextType>;
  reacted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType, RequireFields<ChurrosEventreactedArgs, 'emoji'>>;
  reactionCounts?: Resolver<ResolversTypes['ChurrosCounts'], ParentType, ContextType>;
  reactions?: Resolver<ResolversTypes['Int'], ParentType, ContextType, RequireFields<ChurrosEventreactionsArgs, 'emoji'>>;
  recurringUntil?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  searchBookings?: Resolver<Array<ResolversTypes['ChurrosRegistrationSearchResult']>, ParentType, ContextType, RequireFields<ChurrosEventsearchBookingsArgs, 'q'>>;
  showPlacesLeft?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  startsAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  ticket?: Resolver<Maybe<ResolversTypes['ChurrosTicket']>, ParentType, ContextType, RequireFields<ChurrosEventticketArgs, 'slug'>>;
  ticketGroups?: Resolver<Array<ResolversTypes['ChurrosTicketGroup']>, ParentType, ContextType>;
  tickets?: Resolver<Array<ResolversTypes['ChurrosTicket']>, ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  uid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  visibility?: Resolver<ResolversTypes['ChurrosVisibility'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosEventBookingsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosEventBookingsConnection'] = ResolversParentTypes['ChurrosEventBookingsConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['ChurrosEventBookingsConnectionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['ChurrosRegistration']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['ChurrosPageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosEventBookingsConnectionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosEventBookingsConnectionEdge'] = ResolversParentTypes['ChurrosEventBookingsConnectionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ChurrosRegistration'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosEventBookingsCsvResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosEventBookingsCsvResult'] = ResolversParentTypes['ChurrosEventBookingsCsvResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosEventBookingsCsvSuccess', ParentType, ContextType>;
}>;

export type ChurrosEventBookingsCsvSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosEventBookingsCsvSuccess'] = ResolversParentTypes['ChurrosEventBookingsCsvSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosEventLogsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosEventLogsConnection'] = ResolversParentTypes['ChurrosEventLogsConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['ChurrosEventLogsConnectionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['ChurrosLogEntry']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['ChurrosPageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosEventLogsConnectionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosEventLogsConnectionEdge'] = ResolversParentTypes['ChurrosEventLogsConnectionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ChurrosLogEntry'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosEventManagerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosEventManager'] = ResolversParentTypes['ChurrosEventManager']> = ResolversObject<{
  canEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  canEditPermissions?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  canVerifyRegistrations?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  event?: Resolver<ResolversTypes['ChurrosEvent'], ParentType, ContextType>;
  power?: Resolver<ResolversTypes['ChurrosEventManagerPowerLevel'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['ChurrosUser'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosEventMyBookingsResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosEventMyBookingsResult'] = ResolversParentTypes['ChurrosEventMyBookingsResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosEventMyBookingsSuccess', ParentType, ContextType>;
}>;

export type ChurrosEventMyBookingsSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosEventMyBookingsSuccess'] = ResolversParentTypes['ChurrosEventMyBookingsSuccess']> = ResolversObject<{
  data?: Resolver<Array<ResolversTypes['ChurrosRegistration']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosEventsByDayResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosEventsByDay'] = ResolversParentTypes['ChurrosEventsByDay']> = ResolversObject<{
  date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  happening?: Resolver<Array<ResolversTypes['ChurrosEvent']>, ParentType, ContextType>;
  shotgunning?: Resolver<Array<ResolversTypes['ChurrosEvent']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosFamilyTreeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosFamilyTree'] = ResolversParentTypes['ChurrosFamilyTree']> = ResolversObject<{
  nesting?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  users?: Resolver<Array<ResolversTypes['ChurrosUser']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface ChurrosFileScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['ChurrosFile'], any> {
  name: 'ChurrosFile';
}

export type ChurrosFormResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosForm'] = ResolversParentTypes['ChurrosForm']> = ResolversObject<{
  answerCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  answers?: Resolver<ResolversTypes['ChurrosFormAnswersConnection'], ParentType, ContextType, Partial<ChurrosFormanswersArgs>>;
  answersByUser?: Resolver<ResolversTypes['ChurrosFormAnswersByUserConnection'], ParentType, ContextType, Partial<ChurrosFormanswersByUserArgs>>;
  answersExport?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<ChurrosFormanswersExportArgs, 'format'>>;
  canAnswer?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  canEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  canModifyAnswers?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  canSeeAnswerStats?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  canSeeAnswers?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  canSetCheckboxes?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  checkboxesAreEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  closesAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['ChurrosUser']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  descriptionHtml?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  event?: Resolver<Maybe<ResolversTypes['ChurrosEvent']>, ParentType, ContextType>;
  group?: Resolver<Maybe<ResolversTypes['ChurrosGroup']>, ParentType, ContextType>;
  hasSections?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  linkedGoogleSheetUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  localID?: Resolver<ResolversTypes['ChurrosLocalID'], ParentType, ContextType>;
  localId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  myAnswers?: Resolver<Array<ResolversTypes['ChurrosAnswer']>, ParentType, ContextType>;
  opensAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  questions?: Resolver<ResolversTypes['ChurrosFormQuestionsConnection'], ParentType, ContextType, Partial<ChurrosFormquestionsArgs>>;
  searchAnswers?: Resolver<Array<ResolversTypes['ChurrosAnswerSearchResult']>, ParentType, ContextType, RequireFields<ChurrosFormsearchAnswersArgs, 'q'>>;
  section?: Resolver<ResolversTypes['ChurrosFormSection'], ParentType, ContextType, Partial<ChurrosFormsectionArgs>>;
  sections?: Resolver<Array<ResolversTypes['ChurrosFormSection']>, ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  visibility?: Resolver<ResolversTypes['ChurrosVisibility'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosFormAnswersByUserConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosFormAnswersByUserConnection'] = ResolversParentTypes['ChurrosFormAnswersByUserConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['ChurrosFormAnswersByUserConnectionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['ChurrosAnswersOfUser']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['ChurrosPageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosFormAnswersByUserConnectionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosFormAnswersByUserConnectionEdge'] = ResolversParentTypes['ChurrosFormAnswersByUserConnectionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ChurrosAnswersOfUser'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosFormAnswersConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosFormAnswersConnection'] = ResolversParentTypes['ChurrosFormAnswersConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['ChurrosFormAnswersConnectionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['ChurrosAnswer']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['ChurrosPageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosFormAnswersConnectionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosFormAnswersConnectionEdge'] = ResolversParentTypes['ChurrosFormAnswersConnectionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ChurrosAnswer'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosFormQuestionsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosFormQuestionsConnection'] = ResolversParentTypes['ChurrosFormQuestionsConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['ChurrosFormQuestionsConnectionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['ChurrosQuestion']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['ChurrosPageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosFormQuestionsConnectionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosFormQuestionsConnectionEdge'] = ResolversParentTypes['ChurrosFormQuestionsConnectionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ChurrosQuestion'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosFormSearchResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosFormSearchResult'] = ResolversParentTypes['ChurrosFormSearchResult']> = ResolversObject<{
  form?: Resolver<ResolversTypes['ChurrosForm'], ParentType, ContextType>;
  highlightedDescription?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  rank?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  similarity?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosFormSectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosFormSection'] = ResolversParentTypes['ChurrosFormSection']> = ResolversObject<{
  answers?: Resolver<ResolversTypes['ChurrosFormSectionAnswersConnection'], ParentType, ContextType, Partial<ChurrosFormSectionanswersArgs>>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  descriptionHtml?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  form?: Resolver<ResolversTypes['ChurrosForm'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  localId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  nextSection?: Resolver<Maybe<ResolversTypes['ChurrosFormSection']>, ParentType, ContextType>;
  order?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  questions?: Resolver<Array<ResolversTypes['ChurrosQuestion']>, ParentType, ContextType>;
  restrictedToGroups?: Resolver<Array<ResolversTypes['ChurrosGroup']>, ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosFormSectionAnswersConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosFormSectionAnswersConnection'] = ResolversParentTypes['ChurrosFormSectionAnswersConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['ChurrosFormSectionAnswersConnectionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['ChurrosAnswer']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['ChurrosPageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosFormSectionAnswersConnectionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosFormSectionAnswersConnectionEdge'] = ResolversParentTypes['ChurrosFormSectionAnswersConnectionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ChurrosAnswer'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosGodparentRequestResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosGodparentRequest'] = ResolversParentTypes['ChurrosGodparentRequest']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  godchild?: Resolver<ResolversTypes['ChurrosUser'], ParentType, ContextType>;
  godparent?: Resolver<ResolversTypes['ChurrosUser'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosGroupResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosGroup'] = ResolversParentTypes['ChurrosGroup']> = ResolversObject<{
  address?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  ancestors?: Resolver<Array<ResolversTypes['ChurrosGroup']>, ParentType, ContextType>;
  articles?: Resolver<Array<ResolversTypes['ChurrosArticle']>, ParentType, ContextType>;
  boardMembers?: Resolver<Array<ResolversTypes['ChurrosGroupMember']>, ParentType, ContextType>;
  canEditDetails?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  canEditPages?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  canListPages?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  children?: Resolver<Array<ResolversTypes['ChurrosGroup']>, ParentType, ContextType>;
  coOrganizedEvents?: Resolver<Array<ResolversTypes['ChurrosEvent']>, ParentType, ContextType>;
  color?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  events?: Resolver<ResolversTypes['ChurrosGroupEventsConnection'], ParentType, ContextType, Partial<ChurrosGroupeventsArgs>>;
  familyChildren?: Resolver<Array<ResolversTypes['ChurrosGroup']>, ParentType, ContextType>;
  familyId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  forms?: Resolver<Array<ResolversTypes['ChurrosForm']>, ParentType, ContextType>;
  groupId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  ldapUid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  links?: Resolver<Array<ResolversTypes['ChurrosLink']>, ParentType, ContextType>;
  localID?: Resolver<ResolversTypes['ChurrosLocalID'], ParentType, ContextType>;
  longDescription?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  longDescriptionHtml?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  lydiaAccounts?: Resolver<Array<ResolversTypes['ChurrosLydiaAccount']>, ParentType, ContextType>;
  mailingList?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  members?: Resolver<Array<ResolversTypes['ChurrosGroupMember']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  ownEvents?: Resolver<Array<ResolversTypes['ChurrosEvent']>, ParentType, ContextType>;
  page?: Resolver<Maybe<ResolversTypes['ChurrosPage']>, ParentType, ContextType, RequireFields<ChurrosGrouppageArgs, 'path'>>;
  pages?: Resolver<ResolversTypes['ChurrosPagesConnection'], ParentType, ContextType, Partial<ChurrosGrouppagesArgs>>;
  parent?: Resolver<Maybe<ResolversTypes['ChurrosGroup']>, ParentType, ContextType>;
  parentId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  pictureFile?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pictureFileDark?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pictureURL?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<ChurrosGrouppictureURLArgs, 'dark'>>;
  president?: Resolver<Maybe<ResolversTypes['ChurrosGroupMember']>, ParentType, ContextType>;
  related?: Resolver<Array<ResolversTypes['ChurrosGroup']>, ParentType, ContextType>;
  roomIsOpen?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  root?: Resolver<Maybe<ResolversTypes['ChurrosGroup']>, ParentType, ContextType>;
  secretaries?: Resolver<Array<ResolversTypes['ChurrosGroupMember']>, ParentType, ContextType>;
  selfJoinable?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  services?: Resolver<Array<ResolversTypes['ChurrosService']>, ParentType, ContextType>;
  shopItem?: Resolver<Maybe<ResolversTypes['ChurrosShopItem']>, ParentType, ContextType, RequireFields<ChurrosGroupshopItemArgs, 'id'>>;
  shopItems?: Resolver<ResolversTypes['ChurrosGroupShopItemsConnection'], ParentType, ContextType, Partial<ChurrosGroupshopItemsArgs>>;
  shopOrders?: Resolver<Array<ResolversTypes['ChurrosShopPayment']>, ParentType, ContextType>;
  studentAssociation?: Resolver<Maybe<ResolversTypes['ChurrosStudentAssociation']>, ParentType, ContextType>;
  treasurers?: Resolver<Array<ResolversTypes['ChurrosGroupMember']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['ChurrosGroupType'], ParentType, ContextType>;
  uid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  vicePresidents?: Resolver<Array<ResolversTypes['ChurrosGroupMember']>, ParentType, ContextType>;
  website?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosGroupEventsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosGroupEventsConnection'] = ResolversParentTypes['ChurrosGroupEventsConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['ChurrosGroupEventsConnectionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['ChurrosEvent']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['ChurrosPageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosGroupEventsConnectionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosGroupEventsConnectionEdge'] = ResolversParentTypes['ChurrosGroupEventsConnectionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ChurrosEvent'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosGroupMemberResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosGroupMember'] = ResolversParentTypes['ChurrosGroupMember']> = ResolversObject<{
  canEditArticles?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  canEditMembers?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  canScanEvents?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  group?: Resolver<ResolversTypes['ChurrosGroup'], ParentType, ContextType>;
  groupId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isDeveloper?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  member?: Resolver<ResolversTypes['ChurrosUser'], ParentType, ContextType>;
  memberId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  president?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  secretary?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  treasurer?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  vicePresident?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosGroupSearchResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosGroupSearchResult'] = ResolversParentTypes['ChurrosGroupSearchResult']> = ResolversObject<{
  group?: Resolver<ResolversTypes['ChurrosGroup'], ParentType, ContextType>;
  highlightedDescription?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  rank?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  similarity?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosGroupShopItemsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosGroupShopItemsConnection'] = ResolversParentTypes['ChurrosGroupShopItemsConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['ChurrosGroupShopItemsConnectionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['ChurrosShopItem']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['ChurrosPageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosGroupShopItemsConnectionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosGroupShopItemsConnectionEdge'] = ResolversParentTypes['ChurrosGroupShopItemsConnectionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ChurrosShopItem'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosHealthCheckResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosHealthCheck'] = ResolversParentTypes['ChurrosHealthCheck']> = ResolversObject<{
  database?: Resolver<ResolversTypes['ChurrosDatabaseHealthCheck'], ParentType, ContextType>;
  ldap?: Resolver<ResolversTypes['ChurrosLdapHealthCheck'], ParentType, ContextType>;
  mail?: Resolver<ResolversTypes['ChurrosMailHealthCheck'], ParentType, ContextType>;
  redis?: Resolver<ResolversTypes['ChurrosRedisHealthCheck'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosIssueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosIssue'] = ResolversParentTypes['ChurrosIssue']> = ResolversObject<{
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHtml?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  comments?: Resolver<Array<ResolversTypes['ChurrosIssueComment']>, ParentType, ContextType>;
  deployedIn?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  difficulty?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  duplicatedFrom?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  importance?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  number?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['ChurrosIssueState'], ParentType, ContextType>;
  submittedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosIssueCommentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosIssueComment'] = ResolversParentTypes['ChurrosIssueComment']> = ResolversObject<{
  addedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  authorAvatarUrl?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  authorGitlabUrl?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  authorName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHtml?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosLdapHealthCheckResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosLdapHealthCheck'] = ResolversParentTypes['ChurrosLdapHealthCheck']> = ResolversObject<{
  internal?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  school?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosLinkResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosLink'] = ResolversParentTypes['ChurrosLink']> = ResolversObject<{
  computedValue?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  localID?: Resolver<ResolversTypes['ChurrosLocalID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface ChurrosLocalIDScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['ChurrosLocalID'], any> {
  name: 'ChurrosLocalID';
}

export type ChurrosLogEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosLogEntry'] = ResolversParentTypes['ChurrosLogEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  area?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  happenedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  localID?: Resolver<ResolversTypes['ChurrosLocalID'], ParentType, ContextType>;
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  target?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['ChurrosUser']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosLydiaAccountResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosLydiaAccount'] = ResolversParentTypes['ChurrosLydiaAccount']> = ResolversObject<{
  events?: Resolver<Array<ResolversTypes['ChurrosEvent']>, ParentType, ContextType>;
  group?: Resolver<Maybe<ResolversTypes['ChurrosGroup']>, ParentType, ContextType>;
  groupId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  studentAssociation?: Resolver<Maybe<ResolversTypes['ChurrosStudentAssociation']>, ParentType, ContextType>;
  studentAssociationId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMailHealthCheckResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMailHealthCheck'] = ResolversParentTypes['ChurrosMailHealthCheck']> = ResolversObject<{
  smtp?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMajorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMajor'] = ResolversParentTypes['ChurrosMajor']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  ldapSchool?: Resolver<Maybe<ResolversTypes['ChurrosSchool']>, ParentType, ContextType>;
  minors?: Resolver<Array<ResolversTypes['ChurrosMinor']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  schools?: Resolver<Array<ResolversTypes['ChurrosSchool']>, ParentType, ContextType>;
  shortName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  subjects?: Resolver<Array<ResolversTypes['ChurrosSubject']>, ParentType, ContextType, Partial<ChurrosMajorsubjectsArgs>>;
  uid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMinorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMinor'] = ResolversParentTypes['ChurrosMinor']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  localID?: Resolver<ResolversTypes['ChurrosLocalID'], ParentType, ContextType>;
  majors?: Resolver<Array<ResolversTypes['ChurrosMajor']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  shortName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  subjects?: Resolver<Array<ResolversTypes['ChurrosSubject']>, ParentType, ContextType>;
  uid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  users?: Resolver<Array<ResolversTypes['ChurrosUser']>, ParentType, ContextType>;
  yearTier?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMutationAcceptRegistrationResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationAcceptRegistrationResult'] = ResolversParentTypes['ChurrosMutationAcceptRegistrationResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosMutationAcceptRegistrationSuccess', ParentType, ContextType>;
}>;

export type ChurrosMutationAcceptRegistrationSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationAcceptRegistrationSuccess'] = ResolversParentTypes['ChurrosMutationAcceptRegistrationSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['ChurrosUser'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMutationAddFileToPageResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationAddFileToPageResult'] = ResolversParentTypes['ChurrosMutationAddFileToPageResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosMutationAddFileToPageSuccess' | 'ChurrosZodError', ParentType, ContextType>;
}>;

export type ChurrosMutationAddFileToPageSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationAddFileToPageSuccess'] = ResolversParentTypes['ChurrosMutationAddFileToPageSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['ChurrosPage'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMutationAddGroupMemberResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationAddGroupMemberResult'] = ResolversParentTypes['ChurrosMutationAddGroupMemberResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosMutationAddGroupMemberSuccess', ParentType, ContextType>;
}>;

export type ChurrosMutationAddGroupMemberSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationAddGroupMemberSuccess'] = ResolversParentTypes['ChurrosMutationAddGroupMemberSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['ChurrosGroupMember'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMutationAnswerFormSectionResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationAnswerFormSectionResult'] = ResolversParentTypes['ChurrosMutationAnswerFormSectionResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosMutationAnswerFormSectionSuccess', ParentType, ContextType>;
}>;

export type ChurrosMutationAnswerFormSectionSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationAnswerFormSectionSuccess'] = ResolversParentTypes['ChurrosMutationAnswerFormSectionSuccess']> = ResolversObject<{
  data?: Resolver<Array<ResolversTypes['ChurrosAnswer']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMutationAuthorizeResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationAuthorizeResult'] = ResolversParentTypes['ChurrosMutationAuthorizeResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosMutationAuthorizeSuccess' | 'ChurrosOAuth2Error', ParentType, ContextType>;
}>;

export type ChurrosMutationAuthorizeSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationAuthorizeSuccess'] = ResolversParentTypes['ChurrosMutationAuthorizeSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMutationCancelRegistrationResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationCancelRegistrationResult'] = ResolversParentTypes['ChurrosMutationCancelRegistrationResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosMutationCancelRegistrationSuccess', ParentType, ContextType>;
}>;

export type ChurrosMutationCancelRegistrationSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationCancelRegistrationSuccess'] = ResolversParentTypes['ChurrosMutationCancelRegistrationSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMutationCompleteRegistrationResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationCompleteRegistrationResult'] = ResolversParentTypes['ChurrosMutationCompleteRegistrationResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosMutationCompleteRegistrationSuccess' | 'ChurrosZodError', ParentType, ContextType>;
}>;

export type ChurrosMutationCompleteRegistrationSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationCompleteRegistrationSuccess'] = ResolversParentTypes['ChurrosMutationCompleteRegistrationSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['ChurrosCompleteSignupResult'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMutationContributeResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationContributeResult'] = ResolversParentTypes['ChurrosMutationContributeResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosMutationContributeSuccess', ParentType, ContextType>;
}>;

export type ChurrosMutationContributeSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationContributeSuccess'] = ResolversParentTypes['ChurrosMutationContributeSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMutationCreatePasswordResetResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationCreatePasswordResetResult'] = ResolversParentTypes['ChurrosMutationCreatePasswordResetResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosMutationCreatePasswordResetSuccess', ParentType, ContextType>;
}>;

export type ChurrosMutationCreatePasswordResetSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationCreatePasswordResetSuccess'] = ResolversParentTypes['ChurrosMutationCreatePasswordResetSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMutationDeletePageResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationDeletePageResult'] = ResolversParentTypes['ChurrosMutationDeletePageResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosMutationDeletePageSuccess' | 'ChurrosZodError', ParentType, ContextType>;
}>;

export type ChurrosMutationDeletePageSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationDeletePageSuccess'] = ResolversParentTypes['ChurrosMutationDeletePageSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['ChurrosPage'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMutationDeleteShopItemResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationDeleteShopItemResult'] = ResolversParentTypes['ChurrosMutationDeleteShopItemResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosMutationDeleteShopItemSuccess', ParentType, ContextType>;
}>;

export type ChurrosMutationDeleteShopItemSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationDeleteShopItemSuccess'] = ResolversParentTypes['ChurrosMutationDeleteShopItemSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMutationFinishPaypalRegistrationPaymentResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationFinishPaypalRegistrationPaymentResult'] = ResolversParentTypes['ChurrosMutationFinishPaypalRegistrationPaymentResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosMutationFinishPaypalRegistrationPaymentSuccess', ParentType, ContextType>;
}>;

export type ChurrosMutationFinishPaypalRegistrationPaymentSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationFinishPaypalRegistrationPaymentSuccess'] = ResolversParentTypes['ChurrosMutationFinishPaypalRegistrationPaymentSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMutationLoginResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationLoginResult'] = ResolversParentTypes['ChurrosMutationLoginResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosAwaitingValidationError' | 'ChurrosError' | 'ChurrosMutationLoginSuccess', ParentType, ContextType>;
}>;

export type ChurrosMutationLoginSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationLoginSuccess'] = ResolversParentTypes['ChurrosMutationLoginSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['ChurrosCredential'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMutationMailFormAnswersResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationMailFormAnswersResult'] = ResolversParentTypes['ChurrosMutationMailFormAnswersResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosMutationMailFormAnswersSuccess', ParentType, ContextType>;
}>;

export type ChurrosMutationMailFormAnswersSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationMailFormAnswersSuccess'] = ResolversParentTypes['ChurrosMutationMailFormAnswersSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMutationOpposeRegistrationResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationOpposeRegistrationResult'] = ResolversParentTypes['ChurrosMutationOpposeRegistrationResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosMutationOpposeRegistrationSuccess', ParentType, ContextType>;
}>;

export type ChurrosMutationOpposeRegistrationSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationOpposeRegistrationSuccess'] = ResolversParentTypes['ChurrosMutationOpposeRegistrationSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMutationPaidRegistrationResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationPaidRegistrationResult'] = ResolversParentTypes['ChurrosMutationPaidRegistrationResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosMutationPaidRegistrationSuccess', ParentType, ContextType>;
}>;

export type ChurrosMutationPaidRegistrationSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationPaidRegistrationSuccess'] = ResolversParentTypes['ChurrosMutationPaidRegistrationSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMutationPaidShopPaymentResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationPaidShopPaymentResult'] = ResolversParentTypes['ChurrosMutationPaidShopPaymentResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosMutationPaidShopPaymentSuccess', ParentType, ContextType>;
}>;

export type ChurrosMutationPaidShopPaymentSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationPaidShopPaymentSuccess'] = ResolversParentTypes['ChurrosMutationPaidShopPaymentSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['ChurrosShopPayment'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMutationRegisterGoogleCredentialResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationRegisterGoogleCredentialResult'] = ResolversParentTypes['ChurrosMutationRegisterGoogleCredentialResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosMutationRegisterGoogleCredentialSuccess', ParentType, ContextType>;
}>;

export type ChurrosMutationRegisterGoogleCredentialSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationRegisterGoogleCredentialSuccess'] = ResolversParentTypes['ChurrosMutationRegisterGoogleCredentialSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMutationRemoveFileFromPageResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationRemoveFileFromPageResult'] = ResolversParentTypes['ChurrosMutationRemoveFileFromPageResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosMutationRemoveFileFromPageSuccess' | 'ChurrosZodError', ParentType, ContextType>;
}>;

export type ChurrosMutationRemoveFileFromPageSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationRemoveFileFromPageSuccess'] = ResolversParentTypes['ChurrosMutationRemoveFileFromPageSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['ChurrosPage'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMutationRequestEmailChangeResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationRequestEmailChangeResult'] = ResolversParentTypes['ChurrosMutationRequestEmailChangeResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosMutationRequestEmailChangeSuccess', ParentType, ContextType>;
}>;

export type ChurrosMutationRequestEmailChangeSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationRequestEmailChangeSuccess'] = ResolversParentTypes['ChurrosMutationRequestEmailChangeSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMutationResetPasswordResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationResetPasswordResult'] = ResolversParentTypes['ChurrosMutationResetPasswordResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosMutationResetPasswordSuccess', ParentType, ContextType>;
}>;

export type ChurrosMutationResetPasswordSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationResetPasswordSuccess'] = ResolversParentTypes['ChurrosMutationResetPasswordSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMutationStartRegistrationResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationStartRegistrationResult'] = ResolversParentTypes['ChurrosMutationStartRegistrationResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosMutationStartRegistrationSuccess' | 'ChurrosZodError', ParentType, ContextType>;
}>;

export type ChurrosMutationStartRegistrationSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationStartRegistrationSuccess'] = ResolversParentTypes['ChurrosMutationStartRegistrationSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMutationUpdateUserCandidateResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationUpdateUserCandidateResult'] = ResolversParentTypes['ChurrosMutationUpdateUserCandidateResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosMutationUpdateUserCandidateSuccess' | 'ChurrosZodError', ParentType, ContextType>;
}>;

export type ChurrosMutationUpdateUserCandidateSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationUpdateUserCandidateSuccess'] = ResolversParentTypes['ChurrosMutationUpdateUserCandidateSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMutationUpdateUserResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationUpdateUserResult'] = ResolversParentTypes['ChurrosMutationUpdateUserResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosMutationUpdateUserSuccess', ParentType, ContextType>;
}>;

export type ChurrosMutationUpdateUserSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationUpdateUserSuccess'] = ResolversParentTypes['ChurrosMutationUpdateUserSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['ChurrosUser'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMutationUpsertAnnouncementResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationUpsertAnnouncementResult'] = ResolversParentTypes['ChurrosMutationUpsertAnnouncementResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosMutationUpsertAnnouncementSuccess' | 'ChurrosZodError', ParentType, ContextType>;
}>;

export type ChurrosMutationUpsertAnnouncementSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationUpsertAnnouncementSuccess'] = ResolversParentTypes['ChurrosMutationUpsertAnnouncementSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['ChurrosAnnouncement'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMutationUpsertArticleResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationUpsertArticleResult'] = ResolversParentTypes['ChurrosMutationUpsertArticleResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosMutationUpsertArticleSuccess' | 'ChurrosZodError', ParentType, ContextType>;
}>;

export type ChurrosMutationUpsertArticleSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationUpsertArticleSuccess'] = ResolversParentTypes['ChurrosMutationUpsertArticleSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['ChurrosArticle'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMutationUpsertBarWeekResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationUpsertBarWeekResult'] = ResolversParentTypes['ChurrosMutationUpsertBarWeekResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosMutationUpsertBarWeekSuccess', ParentType, ContextType>;
}>;

export type ChurrosMutationUpsertBarWeekSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationUpsertBarWeekSuccess'] = ResolversParentTypes['ChurrosMutationUpsertBarWeekSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['ChurrosBarWeek'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMutationUpsertDocumentResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationUpsertDocumentResult'] = ResolversParentTypes['ChurrosMutationUpsertDocumentResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosMutationUpsertDocumentSuccess', ParentType, ContextType>;
}>;

export type ChurrosMutationUpsertDocumentSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationUpsertDocumentSuccess'] = ResolversParentTypes['ChurrosMutationUpsertDocumentSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['ChurrosDocument'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMutationUpsertEventResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationUpsertEventResult'] = ResolversParentTypes['ChurrosMutationUpsertEventResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosMutationUpsertEventSuccess', ParentType, ContextType>;
}>;

export type ChurrosMutationUpsertEventSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationUpsertEventSuccess'] = ResolversParentTypes['ChurrosMutationUpsertEventSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['ChurrosEvent'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMutationUpsertGodparentRequestResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationUpsertGodparentRequestResult'] = ResolversParentTypes['ChurrosMutationUpsertGodparentRequestResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosMutationUpsertGodparentRequestSuccess', ParentType, ContextType>;
}>;

export type ChurrosMutationUpsertGodparentRequestSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationUpsertGodparentRequestSuccess'] = ResolversParentTypes['ChurrosMutationUpsertGodparentRequestSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['ChurrosGodparentRequest'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMutationUpsertGroupResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationUpsertGroupResult'] = ResolversParentTypes['ChurrosMutationUpsertGroupResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosMutationUpsertGroupSuccess' | 'ChurrosZodError', ParentType, ContextType>;
}>;

export type ChurrosMutationUpsertGroupSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationUpsertGroupSuccess'] = ResolversParentTypes['ChurrosMutationUpsertGroupSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['ChurrosGroup'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMutationUpsertPageResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationUpsertPageResult'] = ResolversParentTypes['ChurrosMutationUpsertPageResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosMutationUpsertPageSuccess' | 'ChurrosZodError', ParentType, ContextType>;
}>;

export type ChurrosMutationUpsertPageSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationUpsertPageSuccess'] = ResolversParentTypes['ChurrosMutationUpsertPageSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['ChurrosPage'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMutationUpsertRegistrationResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationUpsertRegistrationResult'] = ResolversParentTypes['ChurrosMutationUpsertRegistrationResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosMutationUpsertRegistrationSuccess', ParentType, ContextType>;
}>;

export type ChurrosMutationUpsertRegistrationSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationUpsertRegistrationSuccess'] = ResolversParentTypes['ChurrosMutationUpsertRegistrationSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['ChurrosRegistration'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMutationUpsertServiceResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationUpsertServiceResult'] = ResolversParentTypes['ChurrosMutationUpsertServiceResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosMutationUpsertServiceSuccess', ParentType, ContextType>;
}>;

export type ChurrosMutationUpsertServiceSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationUpsertServiceSuccess'] = ResolversParentTypes['ChurrosMutationUpsertServiceSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['ChurrosService'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMutationUpsertShopItemResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationUpsertShopItemResult'] = ResolversParentTypes['ChurrosMutationUpsertShopItemResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosMutationUpsertShopItemSuccess', ParentType, ContextType>;
}>;

export type ChurrosMutationUpsertShopItemSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationUpsertShopItemSuccess'] = ResolversParentTypes['ChurrosMutationUpsertShopItemSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['ChurrosShopItem'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMutationUpsertShopPaymentResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationUpsertShopPaymentResult'] = ResolversParentTypes['ChurrosMutationUpsertShopPaymentResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosMutationUpsertShopPaymentSuccess', ParentType, ContextType>;
}>;

export type ChurrosMutationUpsertShopPaymentSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationUpsertShopPaymentSuccess'] = ResolversParentTypes['ChurrosMutationUpsertShopPaymentSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['ChurrosShopPayment'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMutationUsePasswordResetResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationUsePasswordResetResult'] = ResolversParentTypes['ChurrosMutationUsePasswordResetResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosMutationUsePasswordResetSuccess', ParentType, ContextType>;
}>;

export type ChurrosMutationUsePasswordResetSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationUsePasswordResetSuccess'] = ResolversParentTypes['ChurrosMutationUsePasswordResetSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMutationValidateEmailResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationValidateEmailResult'] = ResolversParentTypes['ChurrosMutationValidateEmailResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosMutationValidateEmailSuccess', ParentType, ContextType>;
}>;

export type ChurrosMutationValidateEmailSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationValidateEmailSuccess'] = ResolversParentTypes['ChurrosMutationValidateEmailSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosMutationVerifyBookingResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationVerifyBookingResult'] = ResolversParentTypes['ChurrosMutationVerifyBookingResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosMutationVerifyBookingSuccess', ParentType, ContextType>;
}>;

export type ChurrosMutationVerifyBookingSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosMutationVerifyBookingSuccess'] = ResolversParentTypes['ChurrosMutationVerifyBookingSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['ChurrosRegistrationVerificationResult'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosNodeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosNode'] = ResolversParentTypes['ChurrosNode']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosAnnouncement' | 'ChurrosArticle' | 'ChurrosBarWeek' | 'ChurrosComment' | 'ChurrosDocument' | 'ChurrosEvent' | 'ChurrosForm' | 'ChurrosGroup' | 'ChurrosLink' | 'ChurrosLogEntry' | 'ChurrosMinor' | 'ChurrosNotification' | 'ChurrosQuickSignup' | 'ChurrosReaction' | 'ChurrosRegistration' | 'ChurrosService' | 'ChurrosShopItem' | 'ChurrosTicket' | 'ChurrosTicketGroup' | 'ChurrosUser' | 'ChurrosUserCandidate', ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  localID?: Resolver<ResolversTypes['ChurrosLocalID'], ParentType, ContextType>;
}>;

export type ChurrosNotFoundErrorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosNotFoundError'] = ResolversParentTypes['ChurrosNotFoundError']> = ResolversObject<{
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosNotificationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosNotification'] = ResolversParentTypes['ChurrosNotification']> = ResolversObject<{
  actions?: Resolver<Array<ResolversTypes['ChurrosLink']>, ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  channel?: Resolver<ResolversTypes['ChurrosNotificationChannel'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  goto?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  group?: Resolver<Maybe<ResolversTypes['ChurrosGroup']>, ParentType, ContextType>;
  groupId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  imageFile?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  localID?: Resolver<ResolversTypes['ChurrosLocalID'], ParentType, ContextType>;
  subscription?: Resolver<ResolversTypes['ChurrosNotificationSubscription'], ParentType, ContextType>;
  subscriptionId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  timestamp?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  vibrate?: Resolver<Array<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosNotificationSubscriptionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosNotificationSubscription'] = ResolversParentTypes['ChurrosNotificationSubscription']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  endpoint?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  expiresAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  owner?: Resolver<ResolversTypes['ChurrosUser'], ParentType, ContextType>;
  ownerId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosOAuth2ErrorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosOAuth2Error'] = ResolversParentTypes['ChurrosOAuth2Error']> = ResolversObject<{
  code?: Resolver<ResolversTypes['ChurrosOAuth2ErrorCode'], ParentType, ContextType>;
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosPageResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosPage'] = ResolversParentTypes['ChurrosPage']> = ResolversObject<{
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHtml?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  canBeEdited?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  files?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  filesURLs?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  group?: Resolver<Maybe<ResolversTypes['ChurrosGroup']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  lastAuthor?: Resolver<Maybe<ResolversTypes['ChurrosUser']>, ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  studentAssociation?: Resolver<Maybe<ResolversTypes['ChurrosStudentAssociation']>, ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosPageInfoResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosPageInfo'] = ResolversParentTypes['ChurrosPageInfo']> = ResolversObject<{
  endCursor?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  hasNextPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasPreviousPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  startCursor?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosPagesConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosPagesConnection'] = ResolversParentTypes['ChurrosPagesConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['ChurrosPagesEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['ChurrosPage']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['ChurrosPageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosPagesEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosPagesEdge'] = ResolversParentTypes['ChurrosPagesEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ChurrosPage'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosPictureResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosPicture'] = ResolversParentTypes['ChurrosPicture']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  position?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosPicturedResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosPictured'] = ResolversParentTypes['ChurrosPictured']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosArticle' | 'ChurrosEvent' | 'ChurrosGroup' | 'ChurrosSchool' | 'ChurrosStudentAssociation' | 'ChurrosUser', ParentType, ContextType>;
  pictureFile?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pictureFileDark?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pictureURL?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<ChurrosPicturedpictureURLArgs, 'dark'>>;
}>;

export type ChurrosProfitsBreakdownResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosProfitsBreakdown'] = ResolversParentTypes['ChurrosProfitsBreakdown']> = ResolversObject<{
  byPaymentMethod?: Resolver<ResolversTypes['ChurrosProfitsBreakdownByPaymentMethod'], ParentType, ContextType>;
  byTicket?: Resolver<Array<ResolversTypes['ChurrosProfitsBreakdownByTicket']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosProfitsBreakdownByPaymentMethodResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosProfitsBreakdownByPaymentMethod'] = ResolversParentTypes['ChurrosProfitsBreakdownByPaymentMethod']> = ResolversObject<{
  Card?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  Cash?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  Check?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  Lydia?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  Other?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  PayPal?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  Transfer?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosProfitsBreakdownByTicketResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosProfitsBreakdownByTicket'] = ResolversParentTypes['ChurrosProfitsBreakdownByTicket']> = ResolversObject<{
  amount?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQRCodeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQRCode'] = ResolversParentTypes['ChurrosQRCode']> = ResolversObject<{
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  viewbox?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQueryAllFormsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryAllFormsConnection'] = ResolversParentTypes['ChurrosQueryAllFormsConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['ChurrosQueryAllFormsConnectionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['ChurrosForm']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['ChurrosPageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQueryAllFormsConnectionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryAllFormsConnectionEdge'] = ResolversParentTypes['ChurrosQueryAllFormsConnectionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ChurrosForm'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQueryAllUsersConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryAllUsersConnection'] = ResolversParentTypes['ChurrosQueryAllUsersConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['ChurrosQueryAllUsersConnectionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['ChurrosUser']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['ChurrosPageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQueryAllUsersConnectionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryAllUsersConnectionEdge'] = ResolversParentTypes['ChurrosQueryAllUsersConnectionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ChurrosUser'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQueryAnnouncementsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryAnnouncementsConnection'] = ResolversParentTypes['ChurrosQueryAnnouncementsConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['ChurrosQueryAnnouncementsConnectionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['ChurrosAnnouncement']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['ChurrosPageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQueryAnnouncementsConnectionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryAnnouncementsConnectionEdge'] = ResolversParentTypes['ChurrosQueryAnnouncementsConnectionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ChurrosAnnouncement'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQueryCodeContributorsResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryCodeContributorsResult'] = ResolversParentTypes['ChurrosQueryCodeContributorsResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosQueryCodeContributorsSuccess', ParentType, ContextType>;
}>;

export type ChurrosQueryCodeContributorsSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryCodeContributorsSuccess'] = ResolversParentTypes['ChurrosQueryCodeContributorsSuccess']> = ResolversObject<{
  data?: Resolver<Array<ResolversTypes['ChurrosUser']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQueryCombinedChangelogResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryCombinedChangelogResult'] = ResolversParentTypes['ChurrosQueryCombinedChangelogResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosQueryCombinedChangelogSuccess', ParentType, ContextType>;
}>;

export type ChurrosQueryCombinedChangelogSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryCombinedChangelogSuccess'] = ResolversParentTypes['ChurrosQueryCombinedChangelogSuccess']> = ResolversObject<{
  data?: Resolver<Array<ResolversTypes['ChurrosChangelogRelease']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQueryDocumentsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryDocumentsConnection'] = ResolversParentTypes['ChurrosQueryDocumentsConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['ChurrosQueryDocumentsConnectionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['ChurrosDocument']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['ChurrosPageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQueryDocumentsConnectionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryDocumentsConnectionEdge'] = ResolversParentTypes['ChurrosQueryDocumentsConnectionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ChurrosDocument'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQueryEventsByDayConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryEventsByDayConnection'] = ResolversParentTypes['ChurrosQueryEventsByDayConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['ChurrosQueryEventsByDayConnectionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['ChurrosEventsByDay']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['ChurrosPageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQueryEventsByDayConnectionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryEventsByDayConnectionEdge'] = ResolversParentTypes['ChurrosQueryEventsByDayConnectionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ChurrosEventsByDay'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQueryEventsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryEventsConnection'] = ResolversParentTypes['ChurrosQueryEventsConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['ChurrosQueryEventsConnectionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['ChurrosEvent']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['ChurrosPageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQueryEventsConnectionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryEventsConnectionEdge'] = ResolversParentTypes['ChurrosQueryEventsConnectionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ChurrosEvent'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQueryFormsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryFormsConnection'] = ResolversParentTypes['ChurrosQueryFormsConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['ChurrosQueryFormsConnectionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['ChurrosForm']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['ChurrosPageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQueryFormsConnectionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryFormsConnectionEdge'] = ResolversParentTypes['ChurrosQueryFormsConnectionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ChurrosForm'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQueryGroupMembersCsvResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryGroupMembersCsvResult'] = ResolversParentTypes['ChurrosQueryGroupMembersCsvResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosQueryGroupMembersCsvSuccess', ParentType, ContextType>;
}>;

export type ChurrosQueryGroupMembersCsvSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryGroupMembersCsvSuccess'] = ResolversParentTypes['ChurrosQueryGroupMembersCsvSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQueryHomepageConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryHomepageConnection'] = ResolversParentTypes['ChurrosQueryHomepageConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['ChurrosQueryHomepageConnectionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['ChurrosArticle']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['ChurrosPageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQueryHomepageConnectionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryHomepageConnectionEdge'] = ResolversParentTypes['ChurrosQueryHomepageConnectionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ChurrosArticle'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQueryLogsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryLogsConnection'] = ResolversParentTypes['ChurrosQueryLogsConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['ChurrosQueryLogsConnectionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['ChurrosLogEntry']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['ChurrosPageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQueryLogsConnectionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryLogsConnectionEdge'] = ResolversParentTypes['ChurrosQueryLogsConnectionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ChurrosLogEntry'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQueryMinorsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryMinorsConnection'] = ResolversParentTypes['ChurrosQueryMinorsConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['ChurrosQueryMinorsConnectionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['ChurrosMinor']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['ChurrosPageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQueryMinorsConnectionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryMinorsConnectionEdge'] = ResolversParentTypes['ChurrosQueryMinorsConnectionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ChurrosMinor'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQueryNotificationsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryNotificationsConnection'] = ResolversParentTypes['ChurrosQueryNotificationsConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['ChurrosQueryNotificationsConnectionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['ChurrosNotification']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['ChurrosPageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQueryNotificationsConnectionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryNotificationsConnectionEdge'] = ResolversParentTypes['ChurrosQueryNotificationsConnectionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ChurrosNotification'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQueryPagesConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryPagesConnection'] = ResolversParentTypes['ChurrosQueryPagesConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['ChurrosQueryPagesConnectionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['ChurrosPage']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['ChurrosPageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQueryPagesConnectionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryPagesConnectionEdge'] = ResolversParentTypes['ChurrosQueryPagesConnectionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ChurrosPage'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQueryQuickSignupsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryQuickSignupsConnection'] = ResolversParentTypes['ChurrosQueryQuickSignupsConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['ChurrosQueryQuickSignupsConnectionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['ChurrosQuickSignup']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['ChurrosPageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQueryQuickSignupsConnectionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryQuickSignupsConnectionEdge'] = ResolversParentTypes['ChurrosQueryQuickSignupsConnectionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ChurrosQuickSignup'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQueryReactionsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryReactionsConnection'] = ResolversParentTypes['ChurrosQueryReactionsConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['ChurrosQueryReactionsConnectionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['ChurrosReaction']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['ChurrosPageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQueryReactionsConnectionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryReactionsConnectionEdge'] = ResolversParentTypes['ChurrosQueryReactionsConnectionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ChurrosReaction'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQueryRegistrationResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryRegistrationResult'] = ResolversParentTypes['ChurrosQueryRegistrationResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosQueryRegistrationSuccess', ParentType, ContextType>;
}>;

export type ChurrosQueryRegistrationSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryRegistrationSuccess'] = ResolversParentTypes['ChurrosQueryRegistrationSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['ChurrosRegistration'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQueryRegistrationsOfUserConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryRegistrationsOfUserConnection'] = ResolversParentTypes['ChurrosQueryRegistrationsOfUserConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['ChurrosQueryRegistrationsOfUserConnectionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['ChurrosRegistration']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['ChurrosPageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQueryRegistrationsOfUserConnectionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryRegistrationsOfUserConnectionEdge'] = ResolversParentTypes['ChurrosQueryRegistrationsOfUserConnectionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ChurrosRegistration'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQueryUpcomingChangelogResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryUpcomingChangelogResult'] = ResolversParentTypes['ChurrosQueryUpcomingChangelogResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosQueryUpcomingChangelogSuccess', ParentType, ContextType>;
}>;

export type ChurrosQueryUpcomingChangelogSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryUpcomingChangelogSuccess'] = ResolversParentTypes['ChurrosQueryUpcomingChangelogSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['ChurrosChangelogRelease'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQueryUserCandidatesConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryUserCandidatesConnection'] = ResolversParentTypes['ChurrosQueryUserCandidatesConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['ChurrosQueryUserCandidatesConnectionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['ChurrosUserCandidate']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['ChurrosPageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQueryUserCandidatesConnectionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQueryUserCandidatesConnectionEdge'] = ResolversParentTypes['ChurrosQueryUserCandidatesConnectionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ChurrosUserCandidate'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQuestionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQuestion'] = ResolversParentTypes['ChurrosQuestion']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosQuestionFileUpload' | 'ChurrosQuestionScalar' | 'ChurrosQuestionScale' | 'ChurrosQuestionSelectMultiple' | 'ChurrosQuestionSelectOne', ParentType, ContextType>;
  anonymous?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  answers?: Resolver<ResolversTypes['ChurrosQuestionAnswersConnection'], ParentType, ContextType, Partial<ChurrosQuestionanswersArgs>>;
  defaultAnswer?: Resolver<Maybe<ResolversTypes['ChurrosAnswer']>, ParentType, ContextType>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  descriptionHtml?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  mandatory?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  myAnswer?: Resolver<Maybe<ResolversTypes['ChurrosAnswer']>, ParentType, ContextType>;
  order?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  section?: Resolver<ResolversTypes['ChurrosFormSection'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  totalAnswers?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['ChurrosQuestionKind'], ParentType, ContextType>;
}>;

export type ChurrosQuestionAnswersConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQuestionAnswersConnection'] = ResolversParentTypes['ChurrosQuestionAnswersConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['ChurrosQuestionAnswersConnectionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['ChurrosAnswer']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['ChurrosPageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQuestionAnswersConnectionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQuestionAnswersConnectionEdge'] = ResolversParentTypes['ChurrosQuestionAnswersConnectionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ChurrosAnswer'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQuestionFileUploadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQuestionFileUpload'] = ResolversParentTypes['ChurrosQuestionFileUpload']> = ResolversObject<{
  allowedFileTypes?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  anonymous?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  answers?: Resolver<ResolversTypes['ChurrosQuestionAnswersConnection'], ParentType, ContextType, Partial<ChurrosQuestionFileUploadanswersArgs>>;
  defaultAnswer?: Resolver<Maybe<ResolversTypes['ChurrosAnswer']>, ParentType, ContextType>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  descriptionHtml?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  mandatory?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  myAnswer?: Resolver<Maybe<ResolversTypes['ChurrosAnswer']>, ParentType, ContextType>;
  order?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  section?: Resolver<ResolversTypes['ChurrosFormSection'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  totalAnswers?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['ChurrosQuestionKind'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQuestionScalarResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQuestionScalar'] = ResolversParentTypes['ChurrosQuestionScalar']> = ResolversObject<{
  anonymous?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  answers?: Resolver<ResolversTypes['ChurrosQuestionAnswersConnection'], ParentType, ContextType, Partial<ChurrosQuestionScalaranswersArgs>>;
  defaultAnswer?: Resolver<Maybe<ResolversTypes['ChurrosAnswer']>, ParentType, ContextType>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  descriptionHtml?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  mandatory?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  myAnswer?: Resolver<Maybe<ResolversTypes['ChurrosAnswer']>, ParentType, ContextType>;
  order?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  section?: Resolver<ResolversTypes['ChurrosFormSection'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  totalAnswers?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['ChurrosQuestionKind'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQuestionScaleResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQuestionScale'] = ResolversParentTypes['ChurrosQuestionScale']> = ResolversObject<{
  anonymous?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  answerCounts?: Resolver<Array<ResolversTypes['ChurrosStringToIntMapping']>, ParentType, ContextType>;
  answers?: Resolver<ResolversTypes['ChurrosQuestionAnswersConnection'], ParentType, ContextType, Partial<ChurrosQuestionScaleanswersArgs>>;
  defaultAnswer?: Resolver<Maybe<ResolversTypes['ChurrosAnswer']>, ParentType, ContextType>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  descriptionHtml?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  labels?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  mandatory?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  maximum?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  maximumLabel?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  minimum?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  minimumLabel?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  myAnswer?: Resolver<Maybe<ResolversTypes['ChurrosAnswer']>, ParentType, ContextType>;
  options?: Resolver<Array<ResolversTypes['Int']>, ParentType, ContextType>;
  order?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  section?: Resolver<ResolversTypes['ChurrosFormSection'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  totalAnswers?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['ChurrosQuestionKind'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQuestionSelectMultipleResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQuestionSelectMultiple'] = ResolversParentTypes['ChurrosQuestionSelectMultiple']> = ResolversObject<{
  allowOptionsOther?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  anonymous?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  answerCounts?: Resolver<Array<ResolversTypes['ChurrosStringToIntMapping']>, ParentType, ContextType>;
  answers?: Resolver<ResolversTypes['ChurrosQuestionAnswersConnection'], ParentType, ContextType, Partial<ChurrosQuestionSelectMultipleanswersArgs>>;
  defaultAnswer?: Resolver<Maybe<ResolversTypes['ChurrosAnswer']>, ParentType, ContextType>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  descriptionHtml?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  mandatory?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  myAnswer?: Resolver<Maybe<ResolversTypes['ChurrosAnswer']>, ParentType, ContextType>;
  options?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  order?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  section?: Resolver<ResolversTypes['ChurrosFormSection'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  totalAnswers?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['ChurrosQuestionKind'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQuestionSelectOneResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQuestionSelectOne'] = ResolversParentTypes['ChurrosQuestionSelectOne']> = ResolversObject<{
  allowOptionsOther?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  anonymous?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  answerCounts?: Resolver<Array<ResolversTypes['ChurrosStringToIntMapping']>, ParentType, ContextType>;
  answers?: Resolver<ResolversTypes['ChurrosQuestionAnswersConnection'], ParentType, ContextType, Partial<ChurrosQuestionSelectOneanswersArgs>>;
  defaultAnswer?: Resolver<Maybe<ResolversTypes['ChurrosAnswer']>, ParentType, ContextType>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  descriptionHtml?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  groups?: Resolver<Array<Maybe<ResolversTypes['ChurrosGroup']>>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  jumps?: Resolver<Array<Maybe<ResolversTypes['ChurrosFormSection']>>, ParentType, ContextType>;
  mandatory?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  myAnswer?: Resolver<Maybe<ResolversTypes['ChurrosAnswer']>, ParentType, ContextType>;
  options?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  order?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  section?: Resolver<ResolversTypes['ChurrosFormSection'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  totalAnswers?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['ChurrosQuestionKind'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosQuickSignupResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosQuickSignup'] = ResolversParentTypes['ChurrosQuickSignup']> = ResolversObject<{
  code?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  expired?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  localID?: Resolver<ResolversTypes['ChurrosLocalID'], ParentType, ContextType>;
  school?: Resolver<ResolversTypes['ChurrosSchool'], ParentType, ContextType>;
  schoolId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  validUntil?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosReactableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosReactable'] = ResolversParentTypes['ChurrosReactable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosArticle' | 'ChurrosComment' | 'ChurrosDocument' | 'ChurrosEvent', ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  reacted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType, RequireFields<ChurrosReactablereactedArgs, 'emoji'>>;
  reactions?: Resolver<ResolversTypes['Int'], ParentType, ContextType, RequireFields<ChurrosReactablereactionsArgs, 'emoji'>>;
}>;

export type ChurrosReactionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosReaction'] = ResolversParentTypes['ChurrosReaction']> = ResolversObject<{
  author?: Resolver<Maybe<ResolversTypes['ChurrosUser']>, ParentType, ContextType>;
  authorId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  comment?: Resolver<Maybe<ResolversTypes['ChurrosComment']>, ParentType, ContextType>;
  commentId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  document?: Resolver<Maybe<ResolversTypes['ChurrosDocument']>, ParentType, ContextType>;
  documentId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  emoji?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  localID?: Resolver<ResolversTypes['ChurrosLocalID'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosRedisHealthCheckResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosRedisHealthCheck'] = ResolversParentTypes['ChurrosRedisHealthCheck']> = ResolversObject<{
  publish?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  subscribe?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosRegistrationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosRegistration'] = ResolversParentTypes['ChurrosRegistration']> = ResolversObject<{
  author?: Resolver<Maybe<ResolversTypes['ChurrosUser']>, ParentType, ContextType>;
  authorEmail?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  authorId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  authorIsBeneficiary?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  beneficiary?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  beneficiaryUser?: Resolver<Maybe<ResolversTypes['ChurrosUser']>, ParentType, ContextType>;
  cancelled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  cancelledAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  cancelledBy?: Resolver<Maybe<ResolversTypes['ChurrosUser']>, ParentType, ContextType>;
  code?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  localID?: Resolver<ResolversTypes['ChurrosLocalID'], ParentType, ContextType>;
  opposed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  opposedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  opposedBy?: Resolver<Maybe<ResolversTypes['ChurrosUser']>, ParentType, ContextType>;
  paid?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  paymentMethod?: Resolver<Maybe<ResolversTypes['ChurrosPaymentMethod']>, ParentType, ContextType>;
  ticket?: Resolver<ResolversTypes['ChurrosTicket'], ParentType, ContextType>;
  ticketId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  verified?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  verifiedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  verifiedBy?: Resolver<Maybe<ResolversTypes['ChurrosUser']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosRegistrationSearchResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosRegistrationSearchResult'] = ResolversParentTypes['ChurrosRegistrationSearchResult']> = ResolversObject<{
  highlightedBeneficiary?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  rank?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  registration?: Resolver<ResolversTypes['ChurrosRegistration'], ParentType, ContextType>;
  similarity?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosRegistrationVerificationResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosRegistrationVerificationResult'] = ResolversParentTypes['ChurrosRegistrationVerificationResult']> = ResolversObject<{
  registration?: Resolver<Maybe<ResolversTypes['ChurrosRegistration']>, ParentType, ContextType>;
  state?: Resolver<ResolversTypes['ChurrosRegistrationVerificationState'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosRegistrationsCountsResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosRegistrationsCounts'] = ResolversParentTypes['ChurrosRegistrationsCounts']> = ResolversObject<{
  cancelled?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  paid?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  unpaidLydia?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  verified?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosReleaseChangeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosReleaseChange'] = ResolversParentTypes['ChurrosReleaseChange']> = ResolversObject<{
  authors?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  html?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  issues?: Resolver<Array<ResolversTypes['Int']>, ParentType, ContextType>;
  mergeRequests?: Resolver<Array<ResolversTypes['Int']>, ParentType, ContextType>;
  reporters?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  text?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosReleaseChangesMapsResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosReleaseChangesMaps'] = ResolversParentTypes['ChurrosReleaseChangesMaps']> = ResolversObject<{
  added?: Resolver<Array<ResolversTypes['ChurrosReleaseChange']>, ParentType, ContextType>;
  fixed?: Resolver<Array<ResolversTypes['ChurrosReleaseChange']>, ParentType, ContextType>;
  improved?: Resolver<Array<ResolversTypes['ChurrosReleaseChange']>, ParentType, ContextType>;
  other?: Resolver<Array<ResolversTypes['ChurrosReleaseChange']>, ParentType, ContextType>;
  security?: Resolver<Array<ResolversTypes['ChurrosReleaseChange']>, ParentType, ContextType>;
  technical?: Resolver<Array<ResolversTypes['ChurrosReleaseChange']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosSchoolResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosSchool'] = ResolversParentTypes['ChurrosSchool']> = ResolversObject<{
  address?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  aliasMailDomains?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  color?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  majors?: Resolver<Array<ResolversTypes['ChurrosMajor']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pictureFile?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pictureFileDark?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pictureURL?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<ChurrosSchoolpictureURLArgs, 'dark'>>;
  services?: Resolver<Array<ResolversTypes['ChurrosService']>, ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  studentAssociations?: Resolver<Array<ResolversTypes['ChurrosStudentAssociation']>, ParentType, ContextType>;
  studentMailDomain?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  uid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosSchoolGroupResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosSchoolGroup'] = ResolversParentTypes['ChurrosSchoolGroup']> = ResolversObject<{
  majors?: Resolver<Array<ResolversTypes['ChurrosMajor']>, ParentType, ContextType>;
  names?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosServiceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosService'] = ResolversParentTypes['ChurrosService']> = ResolversObject<{
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  group?: Resolver<Maybe<ResolversTypes['ChurrosGroup']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importance?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  localID?: Resolver<ResolversTypes['ChurrosLocalID'], ParentType, ContextType>;
  logo?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  logoSourceType?: Resolver<ResolversTypes['ChurrosLogoSourceType'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  school?: Resolver<Maybe<ResolversTypes['ChurrosSchool']>, ParentType, ContextType>;
  studentAssociation?: Resolver<Maybe<ResolversTypes['ChurrosStudentAssociation']>, ParentType, ContextType>;
  url?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosShopItemResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosShopItem'] = ResolversParentTypes['ChurrosShopItem']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  descriptionHtml?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  endsAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  group?: Resolver<ResolversTypes['ChurrosGroup'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  itemOptions?: Resolver<Array<ResolversTypes['ChurrosShopItemOption']>, ParentType, ContextType>;
  localID?: Resolver<ResolversTypes['ChurrosLocalID'], ParentType, ContextType>;
  lydiaAccount?: Resolver<Maybe<ResolversTypes['ChurrosLydiaAccount']>, ParentType, ContextType>;
  max?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  paymentMethods?: Resolver<Array<ResolversTypes['ChurrosPaymentMethod']>, ParentType, ContextType>;
  pictures?: Resolver<Array<ResolversTypes['ChurrosPicture']>, ParentType, ContextType>;
  price?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  shopPayments?: Resolver<Array<ResolversTypes['ChurrosShopPayment']>, ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  startsAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  stock?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  stockLeft?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  uid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  visibility?: Resolver<ResolversTypes['ChurrosVisibility'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosShopItemAnswerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosShopItemAnswer'] = ResolversParentTypes['ChurrosShopItemAnswer']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  options?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  shopPayment?: Resolver<ResolversTypes['ChurrosShopPayment'], ParentType, ContextType>;
  shopPaymentId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosShopItemOptionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosShopItemOption'] = ResolversParentTypes['ChurrosShopItemOption']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  options?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  otherToggle?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  required?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  shopItem?: Resolver<ResolversTypes['ChurrosShopItem'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosShopPaymentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosShopPayment'] = ResolversParentTypes['ChurrosShopPayment']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  paid?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  paymentMethod?: Resolver<ResolversTypes['ChurrosPaymentMethod'], ParentType, ContextType>;
  quantity?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  shopItem?: Resolver<ResolversTypes['ChurrosShopItem'], ParentType, ContextType>;
  shopItemAnswer?: Resolver<Maybe<ResolversTypes['ChurrosShopItemAnswer']>, ParentType, ContextType>;
  totalPrice?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['ChurrosUser'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosStringToIntMappingResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosStringToIntMapping'] = ResolversParentTypes['ChurrosStringToIntMapping']> = ResolversObject<{
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosStudentAssociationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosStudentAssociation'] = ResolversParentTypes['ChurrosStudentAssociation']> = ResolversObject<{
  canCreateGroups?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType, Partial<ChurrosStudentAssociationcanCreateGroupsArgs>>;
  canEditPages?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  canListPages?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  contributionOptions?: Resolver<Array<ResolversTypes['ChurrosContributionOption']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  groups?: Resolver<ResolversTypes['ChurrosStudentAssociationGroupsConnection'], ParentType, ContextType, Partial<ChurrosStudentAssociationgroupsArgs>>;
  groupsCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  links?: Resolver<Array<ResolversTypes['ChurrosLink']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  page?: Resolver<Maybe<ResolversTypes['ChurrosPage']>, ParentType, ContextType, RequireFields<ChurrosStudentAssociationpageArgs, 'path'>>;
  pages?: Resolver<ResolversTypes['ChurrosPagesConnection'], ParentType, ContextType, Partial<ChurrosStudentAssociationpagesArgs>>;
  pictureFile?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pictureFileDark?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pictureURL?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<ChurrosStudentAssociationpictureURLArgs, 'dark'>>;
  school?: Resolver<ResolversTypes['ChurrosSchool'], ParentType, ContextType>;
  schoolId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  uid?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosStudentAssociationGroupsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosStudentAssociationGroupsConnection'] = ResolversParentTypes['ChurrosStudentAssociationGroupsConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['ChurrosStudentAssociationGroupsConnectionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['ChurrosGroup']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['ChurrosPageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosStudentAssociationGroupsConnectionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosStudentAssociationGroupsConnectionEdge'] = ResolversParentTypes['ChurrosStudentAssociationGroupsConnectionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ChurrosGroup'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosSubjectResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosSubject'] = ResolversParentTypes['ChurrosSubject']> = ResolversObject<{
  apogeeCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  documents?: Resolver<ResolversTypes['ChurrosSubjectDocumentsConnection'], ParentType, ContextType, Partial<ChurrosSubjectdocumentsArgs>>;
  documentsCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  emoji?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  forApprentices?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  links?: Resolver<Array<ResolversTypes['ChurrosLink']>, ParentType, ContextType>;
  majors?: Resolver<Array<ResolversTypes['ChurrosMajor']>, ParentType, ContextType>;
  minors?: Resolver<Array<ResolversTypes['ChurrosMinor']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  nextExamAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  semester?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  shortName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  uid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  unit?: Resolver<Maybe<ResolversTypes['ChurrosTeachingUnit']>, ParentType, ContextType>;
  unitId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  yearTier?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosSubjectDocumentsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosSubjectDocumentsConnection'] = ResolversParentTypes['ChurrosSubjectDocumentsConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['ChurrosSubjectDocumentsConnectionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['ChurrosDocument']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['ChurrosPageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosSubjectDocumentsConnectionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosSubjectDocumentsConnectionEdge'] = ResolversParentTypes['ChurrosSubjectDocumentsConnectionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ChurrosDocument'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosSubscriptionRegistrationResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosSubscriptionRegistrationResult'] = ResolversParentTypes['ChurrosSubscriptionRegistrationResult']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ChurrosError' | 'ChurrosSubscriptionRegistrationSuccess', ParentType, ContextType>;
}>;

export type ChurrosSubscriptionRegistrationSuccessResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosSubscriptionRegistrationSuccess'] = ResolversParentTypes['ChurrosSubscriptionRegistrationSuccess']> = ResolversObject<{
  data?: Resolver<ResolversTypes['ChurrosRegistration'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosTeachingUnitResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosTeachingUnit'] = ResolversParentTypes['ChurrosTeachingUnit']> = ResolversObject<{
  apogeeCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  shortName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  subjects?: Resolver<Array<ResolversTypes['ChurrosSubject']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosThirdPartyAppResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosThirdPartyApp'] = ResolversParentTypes['ChurrosThirdPartyApp']> = ResolversObject<{
  active?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  allowedRedirectUris?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  apiUsage?: Resolver<ResolversTypes['ChurrosThirdPartyAppApiUsageConnection'], ParentType, ContextType, Partial<ChurrosThirdPartyAppapiUsageArgs>>;
  clientId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  faviconUrl?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  logs?: Resolver<ResolversTypes['ChurrosThirdPartyAppLogsConnection'], ParentType, ContextType, Partial<ChurrosThirdPartyApplogsArgs>>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  owner?: Resolver<ResolversTypes['ChurrosGroup'], ParentType, ContextType>;
  rateLimitHits?: Resolver<ResolversTypes['ChurrosThirdPartyAppRateLimitHitsConnection'], ParentType, ContextType, Partial<ChurrosThirdPartyApprateLimitHitsArgs>>;
  secretLength?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  updatedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  users?: Resolver<ResolversTypes['ChurrosThirdPartyAppUsersConnection'], ParentType, ContextType, Partial<ChurrosThirdPartyAppusersArgs>>;
  usersCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  website?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosThirdPartyAppApiUsageConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosThirdPartyAppApiUsageConnection'] = ResolversParentTypes['ChurrosThirdPartyAppApiUsageConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['ChurrosThirdPartyAppApiUsageConnectionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['ChurrosApiUsage']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['ChurrosPageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosThirdPartyAppApiUsageConnectionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosThirdPartyAppApiUsageConnectionEdge'] = ResolversParentTypes['ChurrosThirdPartyAppApiUsageConnectionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ChurrosApiUsage'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosThirdPartyAppLogsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosThirdPartyAppLogsConnection'] = ResolversParentTypes['ChurrosThirdPartyAppLogsConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['ChurrosThirdPartyAppLogsConnectionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['ChurrosLogEntry']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['ChurrosPageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosThirdPartyAppLogsConnectionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosThirdPartyAppLogsConnectionEdge'] = ResolversParentTypes['ChurrosThirdPartyAppLogsConnectionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ChurrosLogEntry'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosThirdPartyAppRateLimitHitsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosThirdPartyAppRateLimitHitsConnection'] = ResolversParentTypes['ChurrosThirdPartyAppRateLimitHitsConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['ChurrosThirdPartyAppRateLimitHitsConnectionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['ChurrosApiRateLimitHits']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['ChurrosPageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosThirdPartyAppRateLimitHitsConnectionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosThirdPartyAppRateLimitHitsConnectionEdge'] = ResolversParentTypes['ChurrosThirdPartyAppRateLimitHitsConnectionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ChurrosApiRateLimitHits'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosThirdPartyAppRegistrationResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosThirdPartyAppRegistrationResponse'] = ResolversParentTypes['ChurrosThirdPartyAppRegistrationResponse']> = ResolversObject<{
  client_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  client_secret?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosThirdPartyAppUsersConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosThirdPartyAppUsersConnection'] = ResolversParentTypes['ChurrosThirdPartyAppUsersConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['ChurrosThirdPartyAppUsersConnectionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['ChurrosUser']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['ChurrosPageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosThirdPartyAppUsersConnectionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosThirdPartyAppUsersConnectionEdge'] = ResolversParentTypes['ChurrosThirdPartyAppUsersConnectionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ChurrosUser'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosTicketResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosTicket'] = ResolversParentTypes['ChurrosTicket']> = ResolversObject<{
  allowedPaymentMethods?: Resolver<Array<ResolversTypes['ChurrosPaymentMethod']>, ParentType, ContextType>;
  autojoinGroups?: Resolver<Array<ResolversTypes['ChurrosGroup']>, ParentType, ContextType>;
  basePrice?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  capacity?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  closesAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  descriptionHtml?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  event?: Resolver<ResolversTypes['ChurrosEvent'], ParentType, ContextType>;
  eventId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  fullName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  godsonLimit?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  group?: Resolver<Maybe<ResolversTypes['ChurrosTicketGroup']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  links?: Resolver<Array<ResolversTypes['ChurrosLink']>, ParentType, ContextType>;
  localID?: Resolver<ResolversTypes['ChurrosLocalID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  onlyManagersCanProvide?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  openToAlumni?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  openToApprentices?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  openToContributors?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  openToExternal?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  openToGroups?: Resolver<Array<ResolversTypes['ChurrosGroup']>, ParentType, ContextType>;
  openToMajors?: Resolver<Array<ResolversTypes['ChurrosMajor']>, ParentType, ContextType>;
  openToPromotions?: Resolver<Array<ResolversTypes['Int']>, ParentType, ContextType>;
  openToSchools?: Resolver<Array<ResolversTypes['ChurrosSchool']>, ParentType, ContextType>;
  opensAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  placesLeft?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  price?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  registrations?: Resolver<Array<ResolversTypes['ChurrosRegistration']>, ParentType, ContextType>;
  remainingGodsons?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  ticketGroupId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  uid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosTicketGroupResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosTicketGroup'] = ResolversParentTypes['ChurrosTicketGroup']> = ResolversObject<{
  capacity?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  event?: Resolver<ResolversTypes['ChurrosEvent'], ParentType, ContextType>;
  eventId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  localID?: Resolver<ResolversTypes['ChurrosLocalID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  tickets?: Resolver<Array<ResolversTypes['ChurrosTicket']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface ChurrosUIDScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['ChurrosUID'], any> {
  name: 'ChurrosUID';
}

export type ChurrosUserResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosUser'] = ResolversParentTypes['ChurrosUser']> = ResolversObject<{
  address?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  admin?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  adminOf?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType, RequireFields<ChurrosUseradminOfArgs, 'studentAssociation'>>;
  allowedApps?: Resolver<Array<ResolversTypes['ChurrosThirdPartyApp']>, ParentType, ContextType>;
  answeredForms?: Resolver<ResolversTypes['ChurrosUserAnsweredFormsConnection'], ParentType, ContextType, Partial<ChurrosUseransweredFormsArgs>>;
  apprentice?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  articles?: Resolver<ResolversTypes['ChurrosUserArticlesConnection'], ParentType, ContextType, Partial<ChurrosUserarticlesArgs>>;
  authorizedApps?: Resolver<Array<ResolversTypes['ChurrosThirdPartyApp']>, ParentType, ContextType>;
  birthday?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  boardMemberships?: Resolver<Array<ResolversTypes['ChurrosGroupMember']>, ParentType, ContextType>;
  booking?: Resolver<ResolversTypes['ChurrosRegistration'], ParentType, ContextType, RequireFields<ChurrosUserbookingArgs, 'event'>>;
  bookings?: Resolver<ResolversTypes['ChurrosUserBookingsConnection'], ParentType, ContextType, Partial<ChurrosUserbookingsArgs>>;
  bot?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  canAccessDocuments?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  canBeEdited?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  canCreatePostsOn?: Resolver<Array<ResolversTypes['ChurrosGroup']>, ParentType, ContextType>;
  canEditGroup?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType, RequireFields<ChurrosUsercanEditGroupArgs, 'uid'>>;
  canEditGroups?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  cededImageRightsToTVn7?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  contributesTo?: Resolver<Array<ResolversTypes['ChurrosStudentAssociation']>, ParentType, ContextType>;
  contributesWith?: Resolver<Array<ResolversTypes['ChurrosContributionOption']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  credentials?: Resolver<Array<ResolversTypes['ChurrosCredential']>, ParentType, ContextType>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  descriptionHtml?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  emailChangeRequests?: Resolver<Array<ResolversTypes['ChurrosEmailChange']>, ParentType, ContextType>;
  enabledNotificationChannels?: Resolver<Array<ResolversTypes['ChurrosNotificationChannel']>, ParentType, ContextType>;
  external?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  familyTree?: Resolver<ResolversTypes['ChurrosFamilyTree'], ParentType, ContextType>;
  firstName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  fullName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  godchildren?: Resolver<Array<ResolversTypes['ChurrosUser']>, ParentType, ContextType>;
  godparent?: Resolver<Maybe<ResolversTypes['ChurrosUser']>, ParentType, ContextType>;
  graduationYear?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  groups?: Resolver<Array<ResolversTypes['ChurrosGroupMember']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  incomingGodparentRequests?: Resolver<Array<ResolversTypes['ChurrosGodparentRequest']>, ParentType, ContextType>;
  lastName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  latestVersionSeenInChangelog?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  links?: Resolver<Array<ResolversTypes['ChurrosLink']>, ParentType, ContextType>;
  localID?: Resolver<ResolversTypes['ChurrosLocalID'], ParentType, ContextType>;
  major?: Resolver<Maybe<ResolversTypes['ChurrosMajor']>, ParentType, ContextType>;
  majorId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  managedEvents?: Resolver<Array<ResolversTypes['ChurrosEventManager']>, ParentType, ContextType>;
  minor?: Resolver<Maybe<ResolversTypes['ChurrosMinor']>, ParentType, ContextType>;
  nickname?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  otherEmails?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  outgoingGodparentRequests?: Resolver<Array<ResolversTypes['ChurrosGodparentRequest']>, ParentType, ContextType>;
  partiallyAnsweredForms?: Resolver<ResolversTypes['ChurrosUserPartiallyAnsweredFormsConnection'], ParentType, ContextType, Partial<ChurrosUserpartiallyAnsweredFormsArgs>>;
  pendingContributions?: Resolver<Array<ResolversTypes['ChurrosContributionOption']>, ParentType, ContextType>;
  phone?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pictureFile?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pictureFileDark?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pictureURL?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<ChurrosUserpictureURLArgs, 'dark'>>;
  schoolUid?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  studentAssociationAdmin?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  uid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  yearTier?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosUserAnsweredFormsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosUserAnsweredFormsConnection'] = ResolversParentTypes['ChurrosUserAnsweredFormsConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['ChurrosUserAnsweredFormsConnectionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['ChurrosForm']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['ChurrosPageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosUserAnsweredFormsConnectionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosUserAnsweredFormsConnectionEdge'] = ResolversParentTypes['ChurrosUserAnsweredFormsConnectionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ChurrosForm'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosUserArticlesConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosUserArticlesConnection'] = ResolversParentTypes['ChurrosUserArticlesConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['ChurrosUserArticlesConnectionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['ChurrosArticle']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['ChurrosPageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosUserArticlesConnectionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosUserArticlesConnectionEdge'] = ResolversParentTypes['ChurrosUserArticlesConnectionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ChurrosArticle'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosUserBookingsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosUserBookingsConnection'] = ResolversParentTypes['ChurrosUserBookingsConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['ChurrosUserBookingsConnectionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['ChurrosRegistration']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['ChurrosPageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosUserBookingsConnectionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosUserBookingsConnectionEdge'] = ResolversParentTypes['ChurrosUserBookingsConnectionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ChurrosRegistration'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosUserCandidateResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosUserCandidate'] = ResolversParentTypes['ChurrosUserCandidate']> = ResolversObject<{
  address?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  apprentice?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  birthday?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  cededImageRightsToTVn7?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  emailIsSchoolEmail?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  emailValidated?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  firstName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  fullName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  graduationYear?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  lastName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  localID?: Resolver<ResolversTypes['ChurrosLocalID'], ParentType, ContextType>;
  major?: Resolver<Maybe<ResolversTypes['ChurrosMajor']>, ParentType, ContextType>;
  majorId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  needsManualValidation?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  needsManualValidationForMajor?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<ChurrosUserCandidateneedsManualValidationForMajorArgs, 'major'>>;
  phone?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  schoolEmail?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  schoolServer?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  schoolUid?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  suggestedUid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  uid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  usingQuickSignup?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosUserPartiallyAnsweredFormsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosUserPartiallyAnsweredFormsConnection'] = ResolversParentTypes['ChurrosUserPartiallyAnsweredFormsConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['ChurrosUserPartiallyAnsweredFormsConnectionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['ChurrosForm']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['ChurrosPageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosUserPartiallyAnsweredFormsConnectionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosUserPartiallyAnsweredFormsConnectionEdge'] = ResolversParentTypes['ChurrosUserPartiallyAnsweredFormsConnectionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ChurrosForm'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosUserSearchResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosUserSearchResult'] = ResolversParentTypes['ChurrosUserSearchResult']> = ResolversObject<{
  highlightedDescription?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  rank?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  similarity?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['ChurrosUser'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosZodErrorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosZodError'] = ResolversParentTypes['ChurrosZodError']> = ResolversObject<{
  fieldErrors?: Resolver<Array<ResolversTypes['ChurrosZodFieldError']>, ParentType, ContextType>;
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChurrosZodFieldErrorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChurrosZodFieldError'] = ResolversParentTypes['ChurrosZodFieldError']> = ResolversObject<{
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  path?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MutationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation']> = ResolversObject<{
  coreApplicationsCreate?: Resolver<Maybe<ResolversTypes['CoreApplicationsCreateResponse']>, ParentType, ContextType, Partial<MutationcoreApplicationsCreateArgs>>;
  coreApplicationsUpdate?: Resolver<Maybe<ResolversTypes['CoreApplicationsUpdateResponse']>, ParentType, ContextType, RequireFields<MutationcoreApplicationsUpdateArgs, 'slug'>>;
  coreApplicationsPartialUpdate?: Resolver<Maybe<ResolversTypes['CoreApplicationsPartialUpdateResponse']>, ParentType, ContextType, RequireFields<MutationcoreApplicationsPartialUpdateArgs, 'slug'>>;
  coreApplicationsDestroy?: Resolver<Maybe<ResolversTypes['CoreApplicationsDestroyResponse']>, ParentType, ContextType, RequireFields<MutationcoreApplicationsDestroyArgs, 'slug'>>;
  coreApplicationsSetIconCreate?: Resolver<Maybe<ResolversTypes['GenericError']>, ParentType, ContextType, RequireFields<MutationcoreApplicationsSetIconCreateArgs, 'slug'>>;
  coreApplicationsSetIconUrlCreate?: Resolver<Maybe<ResolversTypes['GenericError']>, ParentType, ContextType, RequireFields<MutationcoreApplicationsSetIconUrlCreateArgs, 'slug'>>;
  flowsBindingsCreate?: Resolver<Maybe<ResolversTypes['FlowsBindingsCreateResponse']>, ParentType, ContextType, Partial<MutationflowsBindingsCreateArgs>>;
  flowsBindingsUpdate?: Resolver<Maybe<ResolversTypes['FlowsBindingsUpdateResponse']>, ParentType, ContextType, RequireFields<MutationflowsBindingsUpdateArgs, 'fsbUuid'>>;
  flowsBindingsPartialUpdate?: Resolver<Maybe<ResolversTypes['FlowsBindingsPartialUpdateResponse']>, ParentType, ContextType, RequireFields<MutationflowsBindingsPartialUpdateArgs, 'fsbUuid'>>;
  flowsBindingsDestroy?: Resolver<Maybe<ResolversTypes['FlowsBindingsDestroyResponse']>, ParentType, ContextType, RequireFields<MutationflowsBindingsDestroyArgs, 'fsbUuid'>>;
  flowsExecutorSolve?: Resolver<Maybe<ResolversTypes['FlowsExecutorSolveResponse']>, ParentType, ContextType, RequireFields<MutationflowsExecutorSolveArgs, 'flowSlug' | 'query'>>;
  flowsInstancesCreate?: Resolver<Maybe<ResolversTypes['FlowsInstancesCreateResponse']>, ParentType, ContextType, Partial<MutationflowsInstancesCreateArgs>>;
  flowsInstancesUpdate?: Resolver<Maybe<ResolversTypes['FlowsInstancesUpdateResponse']>, ParentType, ContextType, RequireFields<MutationflowsInstancesUpdateArgs, 'slug'>>;
  flowsInstancesPartialUpdate?: Resolver<Maybe<ResolversTypes['FlowsInstancesPartialUpdateResponse']>, ParentType, ContextType, RequireFields<MutationflowsInstancesPartialUpdateArgs, 'slug'>>;
  flowsInstancesDestroy?: Resolver<Maybe<ResolversTypes['FlowsInstancesDestroyResponse']>, ParentType, ContextType, RequireFields<MutationflowsInstancesDestroyArgs, 'slug'>>;
  flowsInstancesSetBackgroundCreate?: Resolver<Maybe<ResolversTypes['GenericError']>, ParentType, ContextType, RequireFields<MutationflowsInstancesSetBackgroundCreateArgs, 'slug'>>;
  flowsInstancesSetBackgroundUrlCreate?: Resolver<Maybe<ResolversTypes['GenericError']>, ParentType, ContextType, RequireFields<MutationflowsInstancesSetBackgroundUrlCreateArgs, 'slug'>>;
  flowsInstancesCacheClearCreate?: Resolver<Maybe<ResolversTypes['FlowsInstancesCacheClearCreateResponse']>, ParentType, ContextType>;
  flowsInstancesImportCreate?: Resolver<Maybe<ResolversTypes['FlowsInstancesImportCreateResponse']>, ParentType, ContextType, Partial<MutationflowsInstancesImportCreateArgs>>;
  providersAllDestroy?: Resolver<Maybe<ResolversTypes['ProvidersAllDestroyResponse']>, ParentType, ContextType, RequireFields<MutationprovidersAllDestroyArgs, 'id'>>;
}>;

export type AdminAppsListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AdminAppsListResponse'] = ResolversParentTypes['AdminAppsListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'App' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AppResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['App'] = ResolversParentTypes['App']> = ResolversObject<{
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ValidationErrorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ValidationError'] = ResolversParentTypes['ValidationError']> = ResolversObject<{
  nonFieldErrors?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  code?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  additionalProperties?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface JSONScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['JSON'], any> {
  name: 'JSON';
}

export type GenericErrorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['GenericError'] = ResolversParentTypes['GenericError']> = ResolversObject<{
  detail?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  code?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AdminMetricsRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AdminMetricsRetrieveResponse'] = ResolversParentTypes['AdminMetricsRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'LoginMetrics' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type LoginMetricsResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LoginMetrics'] = ResolversParentTypes['LoginMetrics']> = ResolversObject<{
  logins?: Resolver<Array<Maybe<ResolversTypes['Coordinate']>>, ParentType, ContextType>;
  loginsFailed?: Resolver<Array<Maybe<ResolversTypes['Coordinate']>>, ParentType, ContextType>;
  authorizations?: Resolver<Array<Maybe<ResolversTypes['Coordinate']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CoordinateResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Coordinate'] = ResolversParentTypes['Coordinate']> = ResolversObject<{
  xCord?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  yCord?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AdminModelsListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AdminModelsListResponse'] = ResolversParentTypes['AdminModelsListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'App' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AdminSettingsRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AdminSettingsRetrieveResponse'] = ResolversParentTypes['AdminSettingsRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Settings' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SettingsResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Settings'] = ResolversParentTypes['Settings']> = ResolversObject<{
  avatars?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  defaultUserChangeName?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  defaultUserChangeEmail?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  defaultUserChangeUsername?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  eventRetention?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  footerLinks?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  gdprCompliance?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  impersonation?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  defaultTokenDuration?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  defaultTokenLength?: Resolver<Maybe<ResolversTypes['PositiveInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface PositiveIntScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['PositiveInt'], any> {
  name: 'PositiveInt';
}

export type AdminSystemRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AdminSystemRetrieveResponse'] = ResolversParentTypes['AdminSystemRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'SystemInfo' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SystemInfoResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SystemInfo'] = ResolversParentTypes['SystemInfo']> = ResolversObject<{
  httpHeaders?: Resolver<ResolversTypes['JSON'], ParentType, ContextType>;
  httpHost?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  httpIsSecure?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  runtime?: Resolver<ResolversTypes['QueryAdminSystemRetrieveOneOf_0Runtime'], ParentType, ContextType>;
  brand?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  serverTime?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  embeddedOutpostDisabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  embeddedOutpostHost?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type QueryAdminSystemRetrieveOneOf_0RuntimeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['QueryAdminSystemRetrieveOneOf_0Runtime'] = ResolversParentTypes['QueryAdminSystemRetrieveOneOf_0Runtime']> = ResolversObject<{
  pythonVersion?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  gunicornVersion?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  environment?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  architecture?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  platform?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  uname?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AdminVersionRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AdminVersionRetrieveResponse'] = ResolversParentTypes['AdminVersionRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Version' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type VersionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Version'] = ResolversParentTypes['Version']> = ResolversObject<{
  versionCurrent?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  versionLatest?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  versionLatestValid?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  buildHash?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  outdated?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AdminWorkersRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AdminWorkersRetrieveResponse'] = ResolversParentTypes['AdminWorkersRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Workers' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type WorkersResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Workers'] = ResolversParentTypes['Workers']> = ResolversObject<{
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AuthenticatorsAdminAllListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsAdminAllListResponse'] = ResolversParentTypes['AuthenticatorsAdminAllListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Device' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type DeviceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Device'] = ResolversParentTypes['Device']> = ResolversObject<{
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pk?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  confirmed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AuthenticatorsAdminDuoListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsAdminDuoListResponse'] = ResolversParentTypes['AuthenticatorsAdminDuoListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedDuoDeviceList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedDuoDeviceListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedDuoDeviceList'] = ResolversParentTypes['PaginatedDuoDeviceList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['DuoDevice']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PaginationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Pagination'] = ResolversParentTypes['Pagination']> = ResolversObject<{
  next?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  previous?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  count?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  current?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  totalPages?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  startIndex?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  endIndex?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DuoDeviceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DuoDevice'] = ResolversParentTypes['DuoDevice']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['QueryAuthenticatorsAdminDuoListOneOf_0ResultsItemsName'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface QueryAuthenticatorsAdminDuoListOneOf_0ResultsItemsNameScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['QueryAuthenticatorsAdminDuoListOneOf_0ResultsItemsName'], any> {
  name: 'QueryAuthenticatorsAdminDuoListOneOf_0ResultsItemsName';
}

export type AuthenticatorsAdminDuoRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsAdminDuoRetrieveResponse'] = ResolversParentTypes['AuthenticatorsAdminDuoRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'DuoDevice' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsAdminSmsListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsAdminSmsListResponse'] = ResolversParentTypes['AuthenticatorsAdminSmsListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedSmsDeviceList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedSmsDeviceListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedSmsDeviceList'] = ResolversParentTypes['PaginatedSmsDeviceList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['SmsDevice']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SmsDeviceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SmsDevice'] = ResolversParentTypes['SmsDevice']> = ResolversObject<{
  name?: Resolver<ResolversTypes['QueryAuthenticatorsAdminSmsListOneOf_0ResultsItemsName'], ParentType, ContextType>;
  pk?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  phoneNumber?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface QueryAuthenticatorsAdminSmsListOneOf_0ResultsItemsNameScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['QueryAuthenticatorsAdminSmsListOneOf_0ResultsItemsName'], any> {
  name: 'QueryAuthenticatorsAdminSmsListOneOf_0ResultsItemsName';
}

export type AuthenticatorsAdminSmsRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsAdminSmsRetrieveResponse'] = ResolversParentTypes['AuthenticatorsAdminSmsRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'SmsDevice' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsAdminStaticListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsAdminStaticListResponse'] = ResolversParentTypes['AuthenticatorsAdminStaticListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedStaticDeviceList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedStaticDeviceListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedStaticDeviceList'] = ResolversParentTypes['PaginatedStaticDeviceList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['StaticDevice']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StaticDeviceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StaticDevice'] = ResolversParentTypes['StaticDevice']> = ResolversObject<{
  name?: Resolver<ResolversTypes['QueryAuthenticatorsAdminStaticListOneOf_0ResultsItemsName'], ParentType, ContextType>;
  tokenSet?: Resolver<Array<Maybe<ResolversTypes['StaticDeviceToken']>>, ParentType, ContextType>;
  pk?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface QueryAuthenticatorsAdminStaticListOneOf_0ResultsItemsNameScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['QueryAuthenticatorsAdminStaticListOneOf_0ResultsItemsName'], any> {
  name: 'QueryAuthenticatorsAdminStaticListOneOf_0ResultsItemsName';
}

export type StaticDeviceTokenResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StaticDeviceToken'] = ResolversParentTypes['StaticDeviceToken']> = ResolversObject<{
  token?: Resolver<ResolversTypes['QueryAuthenticatorsAdminStaticListOneOf_0ResultsItemsTokenSetItemsToken'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface QueryAuthenticatorsAdminStaticListOneOf_0ResultsItemsTokenSetItemsTokenScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['QueryAuthenticatorsAdminStaticListOneOf_0ResultsItemsTokenSetItemsToken'], any> {
  name: 'QueryAuthenticatorsAdminStaticListOneOf_0ResultsItemsTokenSetItemsToken';
}

export type AuthenticatorsAdminStaticRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsAdminStaticRetrieveResponse'] = ResolversParentTypes['AuthenticatorsAdminStaticRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'StaticDevice' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsAdminTotpListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsAdminTotpListResponse'] = ResolversParentTypes['AuthenticatorsAdminTotpListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedTotpDeviceList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedTotpDeviceListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedTotpDeviceList'] = ResolversParentTypes['PaginatedTotpDeviceList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['TotpDevice']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TotpDeviceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TotpDevice'] = ResolversParentTypes['TotpDevice']> = ResolversObject<{
  name?: Resolver<ResolversTypes['QueryAuthenticatorsAdminTotpListOneOf_0ResultsItemsName'], ParentType, ContextType>;
  pk?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface QueryAuthenticatorsAdminTotpListOneOf_0ResultsItemsNameScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['QueryAuthenticatorsAdminTotpListOneOf_0ResultsItemsName'], any> {
  name: 'QueryAuthenticatorsAdminTotpListOneOf_0ResultsItemsName';
}

export type AuthenticatorsAdminTotpRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsAdminTotpRetrieveResponse'] = ResolversParentTypes['AuthenticatorsAdminTotpRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'TotpDevice' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsAdminWebauthnListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsAdminWebauthnListResponse'] = ResolversParentTypes['AuthenticatorsAdminWebauthnListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedWebAuthnDeviceList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedWebAuthnDeviceListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedWebAuthnDeviceList'] = ResolversParentTypes['PaginatedWebAuthnDeviceList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['WebAuthnDevice']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type WebAuthnDeviceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['WebAuthnDevice'] = ResolversParentTypes['WebAuthnDevice']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['QueryAuthenticatorsAdminWebauthnListOneOf_0ResultsItemsName'], ParentType, ContextType>;
  createdOn?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  deviceType?: Resolver<ResolversTypes['WebAuthnDeviceType'], ParentType, ContextType>;
  aaguid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface QueryAuthenticatorsAdminWebauthnListOneOf_0ResultsItemsNameScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['QueryAuthenticatorsAdminWebauthnListOneOf_0ResultsItemsName'], any> {
  name: 'QueryAuthenticatorsAdminWebauthnListOneOf_0ResultsItemsName';
}

export type WebAuthnDeviceTypeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['WebAuthnDeviceType'] = ResolversParentTypes['WebAuthnDeviceType']> = ResolversObject<{
  aaguid?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface UUIDScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['UUID'], any> {
  name: 'UUID';
}

export type AuthenticatorsAdminWebauthnRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsAdminWebauthnRetrieveResponse'] = ResolversParentTypes['AuthenticatorsAdminWebauthnRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'WebAuthnDevice' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsAllListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsAllListResponse'] = ResolversParentTypes['AuthenticatorsAllListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Device' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsDuoListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsDuoListResponse'] = ResolversParentTypes['AuthenticatorsDuoListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedDuoDeviceList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsDuoRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsDuoRetrieveResponse'] = ResolversParentTypes['AuthenticatorsDuoRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'DuoDevice' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsDuoUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsDuoUsedByListResponse'] = ResolversParentTypes['AuthenticatorsDuoUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type UsedByResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UsedBy'] = ResolversParentTypes['UsedBy']> = ResolversObject<{
  app?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  modelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pk?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  action?: Resolver<ResolversTypes['UsedByActionEnum'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AuthenticatorsSmsListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsSmsListResponse'] = ResolversParentTypes['AuthenticatorsSmsListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedSmsDeviceList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsSmsRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsSmsRetrieveResponse'] = ResolversParentTypes['AuthenticatorsSmsRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'SmsDevice' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsSmsUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsSmsUsedByListResponse'] = ResolversParentTypes['AuthenticatorsSmsUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsStaticListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsStaticListResponse'] = ResolversParentTypes['AuthenticatorsStaticListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedStaticDeviceList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsStaticRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsStaticRetrieveResponse'] = ResolversParentTypes['AuthenticatorsStaticRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'StaticDevice' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsStaticUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsStaticUsedByListResponse'] = ResolversParentTypes['AuthenticatorsStaticUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsTotpListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsTotpListResponse'] = ResolversParentTypes['AuthenticatorsTotpListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedTotpDeviceList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsTotpRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsTotpRetrieveResponse'] = ResolversParentTypes['AuthenticatorsTotpRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'TotpDevice' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsTotpUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsTotpUsedByListResponse'] = ResolversParentTypes['AuthenticatorsTotpUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsWebauthnListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsWebauthnListResponse'] = ResolversParentTypes['AuthenticatorsWebauthnListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedWebAuthnDeviceList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsWebauthnRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsWebauthnRetrieveResponse'] = ResolversParentTypes['AuthenticatorsWebauthnRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'WebAuthnDevice' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsWebauthnUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsWebauthnUsedByListResponse'] = ResolversParentTypes['AuthenticatorsWebauthnUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CoreApplicationsListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreApplicationsListResponse'] = ResolversParentTypes['CoreApplicationsListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedApplicationList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedApplicationListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedApplicationList'] = ResolversParentTypes['PaginatedApplicationList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['Application']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ApplicationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Application'] = ResolversParentTypes['Application']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['QueryCoreApplicationsListOneOf_0ResultsItemsSlug'], ParentType, ContextType>;
  provider?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  providerObj?: Resolver<ResolversTypes['Provider'], ParentType, ContextType>;
  backchannelProviders?: Resolver<Maybe<Array<Maybe<ResolversTypes['Int']>>>, ParentType, ContextType>;
  backchannelProvidersObj?: Resolver<Array<Maybe<ResolversTypes['Provider']>>, ParentType, ContextType>;
  launchUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  openInNewTab?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  metaLaunchUrl?: Resolver<Maybe<ResolversTypes['URL']>, ParentType, ContextType>;
  metaIcon?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  metaDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  metaPublisher?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  policyEngineMode?: Resolver<Maybe<ResolversTypes['PolicyEngineMode']>, ParentType, ContextType>;
  groupSlug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  churrosGroup?: Resolver<ResolversTypes['ChurrosGroup'], ParentType, ContextType>;
  metrics?: Resolver<Maybe<Array<Maybe<ResolversTypes['CoreApplicationsMetricsListResponse']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface QueryCoreApplicationsListOneOf_0ResultsItemsSlugScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['QueryCoreApplicationsListOneOf_0ResultsItemsSlug'], any> {
  name: 'QueryCoreApplicationsListOneOf_0ResultsItemsSlug';
}

export type ProviderResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Provider'] = ResolversParentTypes['Provider']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  authenticationFlow?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  authorizationFlow?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  propertyMappings?: Resolver<Maybe<Array<Maybe<ResolversTypes['UUID']>>>, ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  assignedApplicationSlug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  assignedApplicationName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  assignedBackchannelApplicationSlug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  assignedBackchannelApplicationName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  additionalProperties?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  application?: Resolver<Maybe<ResolversTypes['CoreApplicationsRetrieveResponse']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface URLScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['URL'], any> {
  name: 'URL';
}

export type CoreApplicationsRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreApplicationsRetrieveResponse'] = ResolversParentTypes['CoreApplicationsRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Application' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CoreApplicationsCheckAccessRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreApplicationsCheckAccessRetrieveResponse'] = ResolversParentTypes['CoreApplicationsCheckAccessRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PolicyTestResult' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PolicyTestResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PolicyTestResult'] = ResolversParentTypes['PolicyTestResult']> = ResolversObject<{
  passing?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  messages?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  logMessages?: Resolver<Array<Maybe<ResolversTypes['LogEvent']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LogEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LogEvent'] = ResolversParentTypes['LogEvent']> = ResolversObject<{
  timestamp?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  logLevel?: Resolver<ResolversTypes['LogLevelEnum'], ParentType, ContextType>;
  logger?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  event?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  attributes?: Resolver<ResolversTypes['JSON'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CoreApplicationsMetricsListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreApplicationsMetricsListResponse'] = ResolversParentTypes['CoreApplicationsMetricsListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Coordinate' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CoreApplicationsUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreApplicationsUsedByListResponse'] = ResolversParentTypes['CoreApplicationsUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CoreAuthenticatedSessionsListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreAuthenticatedSessionsListResponse'] = ResolversParentTypes['CoreAuthenticatedSessionsListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedAuthenticatedSessionList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedAuthenticatedSessionListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedAuthenticatedSessionList'] = ResolversParentTypes['PaginatedAuthenticatedSessionList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['AuthenticatedSession']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AuthenticatedSessionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatedSession'] = ResolversParentTypes['AuthenticatedSession']> = ResolversObject<{
  uuid?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  current?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  userAgent?: Resolver<ResolversTypes['QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgent'], ParentType, ContextType>;
  geoIp?: Resolver<Maybe<ResolversTypes['QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsGeoIp']>, ParentType, ContextType>;
  asn?: Resolver<Maybe<ResolversTypes['QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsAsn']>, ParentType, ContextType>;
  user?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  lastIp?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  lastUserAgent?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastUsed?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  expires?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgent'] = ResolversParentTypes['QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgent']> = ResolversObject<{
  device?: Resolver<ResolversTypes['QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentDevice'], ParentType, ContextType>;
  os?: Resolver<ResolversTypes['QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentOs'], ParentType, ContextType>;
  userAgent?: Resolver<ResolversTypes['QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentUserAgent'], ParentType, ContextType>;
  string?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentDeviceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentDevice'] = ResolversParentTypes['QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentDevice']> = ResolversObject<{
  brand?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  family?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  model?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentOsResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentOs'] = ResolversParentTypes['QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentOs']> = ResolversObject<{
  family?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  major?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  minor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  patch?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  patchMinor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentUserAgentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentUserAgent'] = ResolversParentTypes['QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentUserAgent']> = ResolversObject<{
  family?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  major?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  minor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  patch?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsGeoIpResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsGeoIp'] = ResolversParentTypes['QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsGeoIp']> = ResolversObject<{
  continent?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  country?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  lat?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  long?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  city?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsAsnResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsAsn'] = ResolversParentTypes['QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsAsn']> = ResolversObject<{
  asn?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  asOrg?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  network?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CoreAuthenticatedSessionsRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreAuthenticatedSessionsRetrieveResponse'] = ResolversParentTypes['CoreAuthenticatedSessionsRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'AuthenticatedSession' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CoreAuthenticatedSessionsUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreAuthenticatedSessionsUsedByListResponse'] = ResolversParentTypes['CoreAuthenticatedSessionsUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CoreBrandsListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreBrandsListResponse'] = ResolversParentTypes['CoreBrandsListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedBrandList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedBrandListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedBrandList'] = ResolversParentTypes['PaginatedBrandList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['Brand']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type BrandResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Brand'] = ResolversParentTypes['Brand']> = ResolversObject<{
  brandUuid?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  domain?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  default?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  brandingTitle?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  brandingLogo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  brandingFavicon?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  flowAuthentication?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  flowInvalidation?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  flowRecovery?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  flowUnenrollment?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  flowUserSettings?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  flowDeviceCode?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  webCertificate?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  attributes?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CoreBrandsRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreBrandsRetrieveResponse'] = ResolversParentTypes['CoreBrandsRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Brand' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CoreBrandsUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreBrandsUsedByListResponse'] = ResolversParentTypes['CoreBrandsUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CoreBrandsCurrentRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreBrandsCurrentRetrieveResponse'] = ResolversParentTypes['CoreBrandsCurrentRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'CurrentBrand' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CurrentBrandResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CurrentBrand'] = ResolversParentTypes['CurrentBrand']> = ResolversObject<{
  matchedDomain?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  brandingTitle?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  brandingLogo?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  brandingFavicon?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  uiFooterLinks?: Resolver<Array<Maybe<ResolversTypes['FooterLink']>>, ParentType, ContextType>;
  uiTheme?: Resolver<ResolversTypes['UiThemeEnum'], ParentType, ContextType>;
  flowAuthentication?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  flowInvalidation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  flowRecovery?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  flowUnenrollment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  flowUserSettings?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  flowDeviceCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  defaultLocale?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type FooterLinkResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['FooterLink'] = ResolversParentTypes['FooterLink']> = ResolversObject<{
  href?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CoreGroupsListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreGroupsListResponse'] = ResolversParentTypes['CoreGroupsListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedGroupList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedGroupListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedGroupList'] = ResolversParentTypes['PaginatedGroupList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['Group']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GroupResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Group'] = ResolversParentTypes['Group']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  numPk?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['QueryCoreGroupsListOneOf_0ResultsItemsName'], ParentType, ContextType>;
  isSuperuser?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  parent?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  parentName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  users?: Resolver<Maybe<Array<Maybe<ResolversTypes['Int']>>>, ParentType, ContextType>;
  usersObj?: Resolver<Maybe<Array<Maybe<ResolversTypes['GroupMember']>>>, ParentType, ContextType>;
  attributes?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  roles?: Resolver<Maybe<Array<Maybe<ResolversTypes['UUID']>>>, ParentType, ContextType>;
  rolesObj?: Resolver<Array<Maybe<ResolversTypes['Role']>>, ParentType, ContextType>;
  additionalProperties?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface QueryCoreGroupsListOneOf_0ResultsItemsNameScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['QueryCoreGroupsListOneOf_0ResultsItemsName'], any> {
  name: 'QueryCoreGroupsListOneOf_0ResultsItemsName';
}

export type GroupMemberResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['GroupMember'] = ResolversParentTypes['GroupMember']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  username?: Resolver<ResolversTypes['QueryCoreGroupsListOneOf_0ResultsItemsUsersObjItemsUsername'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  isActive?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  lastLogin?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['EmailAddress']>, ParentType, ContextType>;
  attributes?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  uid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  additionalProperties?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface QueryCoreGroupsListOneOf_0ResultsItemsUsersObjItemsUsernameScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['QueryCoreGroupsListOneOf_0ResultsItemsUsersObjItemsUsername'], any> {
  name: 'QueryCoreGroupsListOneOf_0ResultsItemsUsersObjItemsUsername';
}

export interface EmailAddressScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['EmailAddress'], any> {
  name: 'EmailAddress';
}

export type RoleResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Role'] = ResolversParentTypes['Role']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['QueryCoreGroupsListOneOf_0ResultsItemsRolesObjItemsName'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface QueryCoreGroupsListOneOf_0ResultsItemsRolesObjItemsNameScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['QueryCoreGroupsListOneOf_0ResultsItemsRolesObjItemsName'], any> {
  name: 'QueryCoreGroupsListOneOf_0ResultsItemsRolesObjItemsName';
}

export type CoreGroupsRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreGroupsRetrieveResponse'] = ResolversParentTypes['CoreGroupsRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Group' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CoreGroupsUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreGroupsUsedByListResponse'] = ResolversParentTypes['CoreGroupsUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CoreTokensListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreTokensListResponse'] = ResolversParentTypes['CoreTokensListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedTokenList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedTokenListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedTokenList'] = ResolversParentTypes['PaginatedTokenList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['Token']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TokenResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Token'] = ResolversParentTypes['Token']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  managed?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  identifier?: Resolver<ResolversTypes['QueryCoreTokensListOneOf_0ResultsItemsIdentifier'], ParentType, ContextType>;
  intent?: Resolver<Maybe<ResolversTypes['IntentEnum']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  userObj?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  expires?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  expiring?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  additionalProperties?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface QueryCoreTokensListOneOf_0ResultsItemsIdentifierScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['QueryCoreTokensListOneOf_0ResultsItemsIdentifier'], any> {
  name: 'QueryCoreTokensListOneOf_0ResultsItemsIdentifier';
}

export type UserResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  username?: Resolver<ResolversTypes['QueryCoreTokensListOneOf_0ResultsItemsUserObjUsername'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  isActive?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  lastLogin?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  isSuperuser?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  groups?: Resolver<Maybe<Array<Maybe<ResolversTypes['UUID']>>>, ParentType, ContextType>;
  groupsObj?: Resolver<Maybe<Array<Maybe<ResolversTypes['UserGroup']>>>, ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['EmailAddress']>, ParentType, ContextType>;
  avatar?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  attributes?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  uid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  path?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['UserTypeEnum']>, ParentType, ContextType>;
  uuid?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  additionalProperties?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface QueryCoreTokensListOneOf_0ResultsItemsUserObjUsernameScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['QueryCoreTokensListOneOf_0ResultsItemsUserObjUsername'], any> {
  name: 'QueryCoreTokensListOneOf_0ResultsItemsUserObjUsername';
}

export type UserGroupResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UserGroup'] = ResolversParentTypes['UserGroup']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  numPk?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['QueryCoreTokensListOneOf_0ResultsItemsUserObjGroupsObjItemsName'], ParentType, ContextType>;
  isSuperuser?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  parent?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  parentName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  attributes?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  additionalProperties?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface QueryCoreTokensListOneOf_0ResultsItemsUserObjGroupsObjItemsNameScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['QueryCoreTokensListOneOf_0ResultsItemsUserObjGroupsObjItemsName'], any> {
  name: 'QueryCoreTokensListOneOf_0ResultsItemsUserObjGroupsObjItemsName';
}

export type CoreTokensRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreTokensRetrieveResponse'] = ResolversParentTypes['CoreTokensRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Token' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CoreTokensUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreTokensUsedByListResponse'] = ResolversParentTypes['CoreTokensUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CoreTokensViewKeyRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreTokensViewKeyRetrieveResponse'] = ResolversParentTypes['CoreTokensViewKeyRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'TokenView' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type TokenViewResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TokenView'] = ResolversParentTypes['TokenView']> = ResolversObject<{
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CoreUserConsentListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreUserConsentListResponse'] = ResolversParentTypes['CoreUserConsentListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedUserConsentList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedUserConsentListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedUserConsentList'] = ResolversParentTypes['PaginatedUserConsentList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['UserConsent']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserConsentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UserConsent'] = ResolversParentTypes['UserConsent']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  expires?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  expiring?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  user?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  application?: Resolver<ResolversTypes['Application'], ParentType, ContextType>;
  permissions?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CoreUserConsentRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreUserConsentRetrieveResponse'] = ResolversParentTypes['CoreUserConsentRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UserConsent' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CoreUserConsentUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreUserConsentUsedByListResponse'] = ResolversParentTypes['CoreUserConsentUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CoreUsersListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreUsersListResponse'] = ResolversParentTypes['CoreUsersListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedUserList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedUserListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedUserList'] = ResolversParentTypes['PaginatedUserList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['User']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CoreUsersRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreUsersRetrieveResponse'] = ResolversParentTypes['CoreUsersRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'User' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CoreUsersMetricsRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreUsersMetricsRetrieveResponse'] = ResolversParentTypes['CoreUsersMetricsRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UserMetrics' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type UserMetricsResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UserMetrics'] = ResolversParentTypes['UserMetrics']> = ResolversObject<{
  logins?: Resolver<Array<Maybe<ResolversTypes['Coordinate']>>, ParentType, ContextType>;
  loginsFailed?: Resolver<Array<Maybe<ResolversTypes['Coordinate']>>, ParentType, ContextType>;
  authorizations?: Resolver<Array<Maybe<ResolversTypes['Coordinate']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CoreUsersUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreUsersUsedByListResponse'] = ResolversParentTypes['CoreUsersUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CoreUsersImpersonateEndRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreUsersImpersonateEndRetrieveResponse'] = ResolversParentTypes['CoreUsersImpersonateEndRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type VoidContainerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['VoidContainer'] = ResolversParentTypes['VoidContainer']> = ResolversObject<{
  void?: Resolver<Maybe<ResolversTypes['Void']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface VoidScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Void'], any> {
  name: 'Void';
}

export type CoreUsersMeRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreUsersMeRetrieveResponse'] = ResolversParentTypes['CoreUsersMeRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'SessionUser' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SessionUserResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SessionUser'] = ResolversParentTypes['SessionUser']> = ResolversObject<{
  user?: Resolver<ResolversTypes['UserSelf'], ParentType, ContextType>;
  original?: Resolver<Maybe<ResolversTypes['UserSelf']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserSelfResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UserSelf'] = ResolversParentTypes['UserSelf']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  username?: Resolver<ResolversTypes['QueryCoreUsersMeRetrieveOneOf_0UserUsername'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  isActive?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isSuperuser?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  groups?: Resolver<Array<Maybe<ResolversTypes['UserSelfGroups']>>, ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['EmailAddress']>, ParentType, ContextType>;
  avatar?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  uid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  settings?: Resolver<ResolversTypes['JSON'], ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['UserTypeEnum']>, ParentType, ContextType>;
  systemPermissions?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface QueryCoreUsersMeRetrieveOneOf_0UserUsernameScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['QueryCoreUsersMeRetrieveOneOf_0UserUsername'], any> {
  name: 'QueryCoreUsersMeRetrieveOneOf_0UserUsername';
}

export type UserSelfGroupsResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UserSelfGroups'] = ResolversParentTypes['UserSelfGroups']> = ResolversObject<{
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pk?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CoreUsersPathsRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreUsersPathsRetrieveResponse'] = ResolversParentTypes['CoreUsersPathsRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UserPath' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type UserPathResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UserPath'] = ResolversParentTypes['UserPath']> = ResolversObject<{
  paths?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CryptoCertificatekeypairsListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CryptoCertificatekeypairsListResponse'] = ResolversParentTypes['CryptoCertificatekeypairsListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedCertificateKeyPairList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedCertificateKeyPairListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedCertificateKeyPairList'] = ResolversParentTypes['PaginatedCertificateKeyPairList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['CertificateKeyPair']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CertificateKeyPairResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CertificateKeyPair'] = ResolversParentTypes['CertificateKeyPair']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  fingerprintSha256?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fingerprintSha1?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  certExpiry?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  certSubject?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  privateKeyAvailable?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  privateKeyType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  certificateDownloadUrl?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  privateKeyDownloadUrl?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  managed?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CryptoCertificatekeypairsRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CryptoCertificatekeypairsRetrieveResponse'] = ResolversParentTypes['CryptoCertificatekeypairsRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'CertificateKeyPair' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CryptoCertificatekeypairsUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CryptoCertificatekeypairsUsedByListResponse'] = ResolversParentTypes['CryptoCertificatekeypairsUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CryptoCertificatekeypairsViewCertificateRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CryptoCertificatekeypairsViewCertificateRetrieveResponse'] = ResolversParentTypes['CryptoCertificatekeypairsViewCertificateRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'CertificateData' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CertificateDataResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CertificateData'] = ResolversParentTypes['CertificateData']> = ResolversObject<{
  data?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CryptoCertificatekeypairsViewPrivateKeyRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CryptoCertificatekeypairsViewPrivateKeyRetrieveResponse'] = ResolversParentTypes['CryptoCertificatekeypairsViewPrivateKeyRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'CertificateData' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type EnterpriseLicenseListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseLicenseListResponse'] = ResolversParentTypes['EnterpriseLicenseListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedLicenseList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedLicenseListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedLicenseList'] = ResolversParentTypes['PaginatedLicenseList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['License']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LicenseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['License'] = ResolversParentTypes['License']> = ResolversObject<{
  licenseUuid?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  expiry?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  internalUsers?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  externalUsers?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterpriseLicenseRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseLicenseRetrieveResponse'] = ResolversParentTypes['EnterpriseLicenseRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'License' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type EnterpriseLicenseUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseLicenseUsedByListResponse'] = ResolversParentTypes['EnterpriseLicenseUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type EnterpriseLicenseForecastRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseLicenseForecastRetrieveResponse'] = ResolversParentTypes['EnterpriseLicenseForecastRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'LicenseForecast' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type LicenseForecastResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LicenseForecast'] = ResolversParentTypes['LicenseForecast']> = ResolversObject<{
  internalUsers?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  externalUsers?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  forecastedInternalUsers?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  forecastedExternalUsers?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterpriseLicenseGetInstallIdRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseLicenseGetInstallIdRetrieveResponse'] = ResolversParentTypes['EnterpriseLicenseGetInstallIdRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'InstallId' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type InstallIdResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['InstallId'] = ResolversParentTypes['InstallId']> = ResolversObject<{
  installId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterpriseLicenseSummaryRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseLicenseSummaryRetrieveResponse'] = ResolversParentTypes['EnterpriseLicenseSummaryRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'LicenseSummary' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type LicenseSummaryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LicenseSummary'] = ResolversParentTypes['LicenseSummary']> = ResolversObject<{
  internalUsers?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  externalUsers?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  valid?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  showAdminWarning?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  showUserWarning?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  readOnly?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  latestValid?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  hasLicense?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EventsEventsListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EventsEventsListResponse'] = ResolversParentTypes['EventsEventsListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedEventList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedEventListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedEventList'] = ResolversParentTypes['PaginatedEventList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['Event']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Event'] = ResolversParentTypes['Event']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  action?: Resolver<ResolversTypes['EventActions'], ParentType, ContextType>;
  app?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  context?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  clientIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  created?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  expires?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  brand?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EventsEventsRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EventsEventsRetrieveResponse'] = ResolversParentTypes['EventsEventsRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Event' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type EventsEventsActionsListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EventsEventsActionsListResponse'] = ResolversParentTypes['EventsEventsActionsListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'TypeCreate' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type TypeCreateResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TypeCreate'] = ResolversParentTypes['TypeCreate']> = ResolversObject<{
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  modelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  requiresEnterprise?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EventsEventsPerMonthListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EventsEventsPerMonthListResponse'] = ResolversParentTypes['EventsEventsPerMonthListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Coordinate' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type EventsEventsTopPerUserListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EventsEventsTopPerUserListResponse'] = ResolversParentTypes['EventsEventsTopPerUserListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'EventTopPerUser' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type EventTopPerUserResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EventTopPerUser'] = ResolversParentTypes['EventTopPerUser']> = ResolversObject<{
  application?: Resolver<ResolversTypes['JSON'], ParentType, ContextType>;
  countedEvents?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  uniqueUsers?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EventsEventsVolumeListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EventsEventsVolumeListResponse'] = ResolversParentTypes['EventsEventsVolumeListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Coordinate' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type EventsNotificationsListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EventsNotificationsListResponse'] = ResolversParentTypes['EventsNotificationsListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedNotificationList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedNotificationListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedNotificationList'] = ResolversParentTypes['PaginatedNotificationList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['Notification']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type NotificationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Notification'] = ResolversParentTypes['Notification']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  severity?: Resolver<ResolversTypes['SeverityEnum'], ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  created?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  event?: Resolver<Maybe<ResolversTypes['Event']>, ParentType, ContextType>;
  seen?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EventsNotificationsRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EventsNotificationsRetrieveResponse'] = ResolversParentTypes['EventsNotificationsRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Notification' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type EventsNotificationsUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EventsNotificationsUsedByListResponse'] = ResolversParentTypes['EventsNotificationsUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type EventsRulesListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EventsRulesListResponse'] = ResolversParentTypes['EventsRulesListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedNotificationRuleList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedNotificationRuleListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedNotificationRuleList'] = ResolversParentTypes['PaginatedNotificationRuleList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['NotificationRule']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type NotificationRuleResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['NotificationRule'] = ResolversParentTypes['NotificationRule']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  transports?: Resolver<Maybe<Array<Maybe<ResolversTypes['UUID']>>>, ParentType, ContextType>;
  severity?: Resolver<Maybe<ResolversTypes['SeverityEnum']>, ParentType, ContextType>;
  group?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  groupObj?: Resolver<ResolversTypes['Group'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EventsRulesRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EventsRulesRetrieveResponse'] = ResolversParentTypes['EventsRulesRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'NotificationRule' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type EventsRulesUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EventsRulesUsedByListResponse'] = ResolversParentTypes['EventsRulesUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type EventsSystemTasksListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EventsSystemTasksListResponse'] = ResolversParentTypes['EventsSystemTasksListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedSystemTaskList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedSystemTaskListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedSystemTaskList'] = ResolversParentTypes['PaginatedSystemTaskList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['SystemTask']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SystemTaskResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SystemTask'] = ResolversParentTypes['SystemTask']> = ResolversObject<{
  uuid?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  fullName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  uid?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  startTimestamp?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  finishTimestamp?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  duration?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  status?: Resolver<ResolversTypes['SystemTaskStatusEnum'], ParentType, ContextType>;
  messages?: Resolver<Array<Maybe<ResolversTypes['LogEvent']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EventsSystemTasksRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EventsSystemTasksRetrieveResponse'] = ResolversParentTypes['EventsSystemTasksRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'SystemTask' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type EventsTransportsListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EventsTransportsListResponse'] = ResolversParentTypes['EventsTransportsListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedNotificationTransportList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedNotificationTransportListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedNotificationTransportList'] = ResolversParentTypes['PaginatedNotificationTransportList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['NotificationTransport']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type NotificationTransportResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['NotificationTransport'] = ResolversParentTypes['NotificationTransport']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  mode?: Resolver<Maybe<ResolversTypes['NotificationTransportModeEnum']>, ParentType, ContextType>;
  modeVerbose?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  webhookUrl?: Resolver<Maybe<ResolversTypes['URL']>, ParentType, ContextType>;
  webhookMapping?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  sendOnce?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EventsTransportsRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EventsTransportsRetrieveResponse'] = ResolversParentTypes['EventsTransportsRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'NotificationTransport' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type EventsTransportsUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EventsTransportsUsedByListResponse'] = ResolversParentTypes['EventsTransportsUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type FlowsBindingsListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['FlowsBindingsListResponse'] = ResolversParentTypes['FlowsBindingsListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedFlowStageBindingList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedFlowStageBindingListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedFlowStageBindingList'] = ResolversParentTypes['PaginatedFlowStageBindingList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['FlowStageBinding']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type FlowStageBindingResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['FlowStageBinding'] = ResolversParentTypes['FlowStageBinding']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  policybindingmodelPtrId?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  target?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  stage?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  stageObj?: Resolver<ResolversTypes['Stage'], ParentType, ContextType>;
  evaluateOnPlan?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  reEvaluatePolicies?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  order?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  policyEngineMode?: Resolver<Maybe<ResolversTypes['PolicyEngineMode']>, ParentType, ContextType>;
  invalidResponseAction?: Resolver<Maybe<ResolversTypes['InvalidResponseActionEnum']>, ParentType, ContextType>;
  additionalProperties?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StageResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Stage'] = ResolversParentTypes['Stage']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  flowSet?: Resolver<Maybe<Array<Maybe<ResolversTypes['FlowSet']>>>, ParentType, ContextType>;
  additionalProperties?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type FlowSetResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['FlowSet'] = ResolversParentTypes['FlowSet']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  policybindingmodelPtrId?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['QueryFlowsBindingsListOneOf_0ResultsItemsStageObjFlowSetItemsSlug'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  designation?: Resolver<ResolversTypes['FlowDesignationEnum'], ParentType, ContextType>;
  background?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  policyEngineMode?: Resolver<Maybe<ResolversTypes['PolicyEngineMode']>, ParentType, ContextType>;
  compatibilityMode?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  exportUrl?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  layout?: Resolver<Maybe<ResolversTypes['FlowLayoutEnum']>, ParentType, ContextType>;
  deniedAction?: Resolver<Maybe<ResolversTypes['DeniedActionEnum']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface QueryFlowsBindingsListOneOf_0ResultsItemsStageObjFlowSetItemsSlugScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['QueryFlowsBindingsListOneOf_0ResultsItemsStageObjFlowSetItemsSlug'], any> {
  name: 'QueryFlowsBindingsListOneOf_0ResultsItemsStageObjFlowSetItemsSlug';
}

export type FlowsBindingsRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['FlowsBindingsRetrieveResponse'] = ResolversParentTypes['FlowsBindingsRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'FlowStageBinding' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type FlowsBindingsUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['FlowsBindingsUsedByListResponse'] = ResolversParentTypes['FlowsBindingsUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type FlowsExecutorGetResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['FlowsExecutorGetResponse'] = ResolversParentTypes['FlowsExecutorGetResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'AccessDeniedChallenge' | 'AppleLoginChallenge' | 'AuthenticatorDuoChallenge' | 'AuthenticatorSmsChallenge' | 'AuthenticatorStaticChallenge' | 'AuthenticatorTotpChallenge' | 'AuthenticatorValidationChallenge' | 'AuthenticatorWebAuthnChallenge' | 'AutosubmitChallenge' | 'CaptchaChallenge' | 'ConsentChallenge' | 'EmailChallenge' | 'FlowErrorChallenge' | 'IdentificationChallenge' | 'OAuthDeviceCodeChallenge' | 'OAuthDeviceCodeFinishChallenge' | 'PasswordChallenge' | 'PlexAuthenticationChallenge' | 'PromptChallenge' | 'RedirectChallenge' | 'ShellChallenge' | 'UserLoginChallenge' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AccessDeniedChallengeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AccessDeniedChallenge'] = ResolversParentTypes['AccessDeniedChallenge']> = ResolversObject<{
  type?: Resolver<ResolversTypes['ChallengeChoices'], ParentType, ContextType>;
  flowInfo?: Resolver<Maybe<ResolversTypes['ContextualFlowInfo']>, ParentType, ContextType>;
  component?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  responseErrors?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  pendingUser?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pendingUserAvatar?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  errorMessage?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ContextualFlowInfoResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ContextualFlowInfo'] = ResolversParentTypes['ContextualFlowInfo']> = ResolversObject<{
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  background?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  cancelUrl?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  layout?: Resolver<ResolversTypes['ContextualFlowInfoLayoutEnum'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AppleLoginChallengeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AppleLoginChallenge'] = ResolversParentTypes['AppleLoginChallenge']> = ResolversObject<{
  type?: Resolver<ResolversTypes['ChallengeChoices'], ParentType, ContextType>;
  flowInfo?: Resolver<Maybe<ResolversTypes['ContextualFlowInfo']>, ParentType, ContextType>;
  component?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  responseErrors?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  clientId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  scope?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  redirectUri?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AuthenticatorDuoChallengeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorDuoChallenge'] = ResolversParentTypes['AuthenticatorDuoChallenge']> = ResolversObject<{
  type?: Resolver<ResolversTypes['ChallengeChoices'], ParentType, ContextType>;
  flowInfo?: Resolver<Maybe<ResolversTypes['ContextualFlowInfo']>, ParentType, ContextType>;
  component?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  responseErrors?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  pendingUser?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pendingUserAvatar?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  activationBarcode?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  activationCode?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stageUuid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AuthenticatorSmsChallengeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorSmsChallenge'] = ResolversParentTypes['AuthenticatorSmsChallenge']> = ResolversObject<{
  type?: Resolver<ResolversTypes['ChallengeChoices'], ParentType, ContextType>;
  flowInfo?: Resolver<Maybe<ResolversTypes['ContextualFlowInfo']>, ParentType, ContextType>;
  component?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  responseErrors?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  pendingUser?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pendingUserAvatar?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  phoneNumberRequired?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AuthenticatorStaticChallengeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorStaticChallenge'] = ResolversParentTypes['AuthenticatorStaticChallenge']> = ResolversObject<{
  type?: Resolver<ResolversTypes['ChallengeChoices'], ParentType, ContextType>;
  flowInfo?: Resolver<Maybe<ResolversTypes['ContextualFlowInfo']>, ParentType, ContextType>;
  component?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  responseErrors?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  pendingUser?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pendingUserAvatar?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  codes?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AuthenticatorTotpChallengeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorTotpChallenge'] = ResolversParentTypes['AuthenticatorTotpChallenge']> = ResolversObject<{
  type?: Resolver<ResolversTypes['ChallengeChoices'], ParentType, ContextType>;
  flowInfo?: Resolver<Maybe<ResolversTypes['ContextualFlowInfo']>, ParentType, ContextType>;
  component?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  responseErrors?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  pendingUser?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pendingUserAvatar?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  configUrl?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AuthenticatorValidationChallengeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorValidationChallenge'] = ResolversParentTypes['AuthenticatorValidationChallenge']> = ResolversObject<{
  type?: Resolver<ResolversTypes['ChallengeChoices'], ParentType, ContextType>;
  flowInfo?: Resolver<Maybe<ResolversTypes['ContextualFlowInfo']>, ParentType, ContextType>;
  component?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  responseErrors?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  pendingUser?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pendingUserAvatar?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  deviceChallenges?: Resolver<Array<Maybe<ResolversTypes['DeviceChallenge']>>, ParentType, ContextType>;
  configurationStages?: Resolver<Array<Maybe<ResolversTypes['SelectableStage']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeviceChallengeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeviceChallenge'] = ResolversParentTypes['DeviceChallenge']> = ResolversObject<{
  deviceClass?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  deviceUid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  challenge?: Resolver<ResolversTypes['JSON'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SelectableStageResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SelectableStage'] = ResolversParentTypes['SelectableStage']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AuthenticatorWebAuthnChallengeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorWebAuthnChallenge'] = ResolversParentTypes['AuthenticatorWebAuthnChallenge']> = ResolversObject<{
  type?: Resolver<ResolversTypes['ChallengeChoices'], ParentType, ContextType>;
  flowInfo?: Resolver<Maybe<ResolversTypes['ContextualFlowInfo']>, ParentType, ContextType>;
  component?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  responseErrors?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  pendingUser?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pendingUserAvatar?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  registration?: Resolver<ResolversTypes['JSON'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AutosubmitChallengeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AutosubmitChallenge'] = ResolversParentTypes['AutosubmitChallenge']> = ResolversObject<{
  type?: Resolver<ResolversTypes['ChallengeChoices'], ParentType, ContextType>;
  flowInfo?: Resolver<Maybe<ResolversTypes['ContextualFlowInfo']>, ParentType, ContextType>;
  component?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  responseErrors?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  url?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  attrs?: Resolver<ResolversTypes['JSON'], ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CaptchaChallengeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CaptchaChallenge'] = ResolversParentTypes['CaptchaChallenge']> = ResolversObject<{
  type?: Resolver<ResolversTypes['ChallengeChoices'], ParentType, ContextType>;
  flowInfo?: Resolver<Maybe<ResolversTypes['ContextualFlowInfo']>, ParentType, ContextType>;
  component?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  responseErrors?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  pendingUser?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pendingUserAvatar?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  siteKey?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  jsUrl?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ConsentChallengeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ConsentChallenge'] = ResolversParentTypes['ConsentChallenge']> = ResolversObject<{
  type?: Resolver<ResolversTypes['ChallengeChoices'], ParentType, ContextType>;
  flowInfo?: Resolver<Maybe<ResolversTypes['ContextualFlowInfo']>, ParentType, ContextType>;
  component?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  responseErrors?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  pendingUser?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pendingUserAvatar?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  headerText?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  permissions?: Resolver<Array<Maybe<ResolversTypes['ConsentPermission']>>, ParentType, ContextType>;
  additionalPermissions?: Resolver<Array<Maybe<ResolversTypes['ConsentPermission']>>, ParentType, ContextType>;
  token?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ConsentPermissionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ConsentPermission'] = ResolversParentTypes['ConsentPermission']> = ResolversObject<{
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EmailChallengeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EmailChallenge'] = ResolversParentTypes['EmailChallenge']> = ResolversObject<{
  type?: Resolver<ResolversTypes['ChallengeChoices'], ParentType, ContextType>;
  flowInfo?: Resolver<Maybe<ResolversTypes['ContextualFlowInfo']>, ParentType, ContextType>;
  component?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  responseErrors?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type FlowErrorChallengeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['FlowErrorChallenge'] = ResolversParentTypes['FlowErrorChallenge']> = ResolversObject<{
  type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  flowInfo?: Resolver<Maybe<ResolversTypes['ContextualFlowInfo']>, ParentType, ContextType>;
  component?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  responseErrors?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  requestId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  error?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  traceback?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IdentificationChallengeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['IdentificationChallenge'] = ResolversParentTypes['IdentificationChallenge']> = ResolversObject<{
  type?: Resolver<ResolversTypes['ChallengeChoices'], ParentType, ContextType>;
  flowInfo?: Resolver<Maybe<ResolversTypes['ContextualFlowInfo']>, ParentType, ContextType>;
  component?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  responseErrors?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  userFields?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  passwordFields?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  applicationPre?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  flowDesignation?: Resolver<ResolversTypes['FlowDesignationEnum'], ParentType, ContextType>;
  enrollUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  recoveryUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  passwordlessUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  primaryAction?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  sources?: Resolver<Maybe<Array<Maybe<ResolversTypes['LoginSource']>>>, ParentType, ContextType>;
  showSourceLabels?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LoginSourceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LoginSource'] = ResolversParentTypes['LoginSource']> = ResolversObject<{
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  iconUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  challenge?: Resolver<ResolversTypes['LoginChallengeTypes'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LoginChallengeTypesResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LoginChallengeTypes'] = ResolversParentTypes['LoginChallengeTypes']> = ResolversObject<{
  __resolveType: TypeResolveFn<'RedirectChallenge' | 'PlexAuthenticationChallenge' | 'AppleLoginChallenge', ParentType, ContextType>;
}>;

export type RedirectChallengeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RedirectChallenge'] = ResolversParentTypes['RedirectChallenge']> = ResolversObject<{
  type?: Resolver<ResolversTypes['ChallengeChoices'], ParentType, ContextType>;
  flowInfo?: Resolver<Maybe<ResolversTypes['ContextualFlowInfo']>, ParentType, ContextType>;
  component?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  responseErrors?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  to?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PlexAuthenticationChallengeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PlexAuthenticationChallenge'] = ResolversParentTypes['PlexAuthenticationChallenge']> = ResolversObject<{
  type?: Resolver<ResolversTypes['ChallengeChoices'], ParentType, ContextType>;
  flowInfo?: Resolver<Maybe<ResolversTypes['ContextualFlowInfo']>, ParentType, ContextType>;
  component?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  responseErrors?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  clientId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OAuthDeviceCodeChallengeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OAuthDeviceCodeChallenge'] = ResolversParentTypes['OAuthDeviceCodeChallenge']> = ResolversObject<{
  type?: Resolver<ResolversTypes['ChallengeChoices'], ParentType, ContextType>;
  flowInfo?: Resolver<Maybe<ResolversTypes['ContextualFlowInfo']>, ParentType, ContextType>;
  component?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  responseErrors?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OAuthDeviceCodeFinishChallengeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OAuthDeviceCodeFinishChallenge'] = ResolversParentTypes['OAuthDeviceCodeFinishChallenge']> = ResolversObject<{
  type?: Resolver<ResolversTypes['ChallengeChoices'], ParentType, ContextType>;
  flowInfo?: Resolver<Maybe<ResolversTypes['ContextualFlowInfo']>, ParentType, ContextType>;
  component?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  responseErrors?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PasswordChallengeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PasswordChallenge'] = ResolversParentTypes['PasswordChallenge']> = ResolversObject<{
  type?: Resolver<ResolversTypes['ChallengeChoices'], ParentType, ContextType>;
  flowInfo?: Resolver<Maybe<ResolversTypes['ContextualFlowInfo']>, ParentType, ContextType>;
  component?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  responseErrors?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  pendingUser?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pendingUserAvatar?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  recoveryUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PromptChallengeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PromptChallenge'] = ResolversParentTypes['PromptChallenge']> = ResolversObject<{
  type?: Resolver<ResolversTypes['ChallengeChoices'], ParentType, ContextType>;
  flowInfo?: Resolver<Maybe<ResolversTypes['ContextualFlowInfo']>, ParentType, ContextType>;
  component?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  responseErrors?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  fields?: Resolver<Array<Maybe<ResolversTypes['StagePrompt']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StagePromptResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagePrompt'] = ResolversParentTypes['StagePrompt']> = ResolversObject<{
  fieldKey?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['PromptTypeEnum'], ParentType, ContextType>;
  required?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  placeholder?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  initialValue?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  order?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  subText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  choices?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ShellChallengeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ShellChallenge'] = ResolversParentTypes['ShellChallenge']> = ResolversObject<{
  type?: Resolver<ResolversTypes['ChallengeChoices'], ParentType, ContextType>;
  flowInfo?: Resolver<Maybe<ResolversTypes['ContextualFlowInfo']>, ParentType, ContextType>;
  component?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  responseErrors?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserLoginChallengeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UserLoginChallenge'] = ResolversParentTypes['UserLoginChallenge']> = ResolversObject<{
  type?: Resolver<ResolversTypes['ChallengeChoices'], ParentType, ContextType>;
  flowInfo?: Resolver<Maybe<ResolversTypes['ContextualFlowInfo']>, ParentType, ContextType>;
  component?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  responseErrors?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  pendingUser?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pendingUserAvatar?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type FlowsInspectorGetResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['FlowsInspectorGetResponse'] = ResolversParentTypes['FlowsInspectorGetResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'FlowInspection' | 'GenericError', ParentType, ContextType>;
}>;

export type FlowInspectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['FlowInspection'] = ResolversParentTypes['FlowInspection']> = ResolversObject<{
  plans?: Resolver<Array<Maybe<ResolversTypes['FlowInspectorPlan']>>, ParentType, ContextType>;
  currentPlan?: Resolver<Maybe<ResolversTypes['FlowInspectorPlan']>, ParentType, ContextType>;
  isCompleted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type FlowInspectorPlanResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['FlowInspectorPlan'] = ResolversParentTypes['FlowInspectorPlan']> = ResolversObject<{
  currentStage?: Resolver<ResolversTypes['FlowStageBinding'], ParentType, ContextType>;
  nextPlannedStage?: Resolver<ResolversTypes['FlowStageBinding'], ParentType, ContextType>;
  planContext?: Resolver<ResolversTypes['JSON'], ParentType, ContextType>;
  sessionId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type FlowsInstancesListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['FlowsInstancesListResponse'] = ResolversParentTypes['FlowsInstancesListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedFlowList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedFlowListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedFlowList'] = ResolversParentTypes['PaginatedFlowList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['Flow']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type FlowResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Flow'] = ResolversParentTypes['Flow']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  policybindingmodelPtrId?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['QueryFlowsInstancesListOneOf_0ResultsItemsSlug'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  designation?: Resolver<ResolversTypes['FlowDesignationEnum'], ParentType, ContextType>;
  background?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stages?: Resolver<Array<Maybe<ResolversTypes['UUID']>>, ParentType, ContextType>;
  policies?: Resolver<Array<Maybe<ResolversTypes['UUID']>>, ParentType, ContextType>;
  cacheCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  policyEngineMode?: Resolver<Maybe<ResolversTypes['PolicyEngineMode']>, ParentType, ContextType>;
  compatibilityMode?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  exportUrl?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  layout?: Resolver<Maybe<ResolversTypes['FlowLayoutEnum']>, ParentType, ContextType>;
  deniedAction?: Resolver<Maybe<ResolversTypes['DeniedActionEnum']>, ParentType, ContextType>;
  authentication?: Resolver<Maybe<ResolversTypes['AuthenticationEnum']>, ParentType, ContextType>;
  additionalProperties?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface QueryFlowsInstancesListOneOf_0ResultsItemsSlugScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['QueryFlowsInstancesListOneOf_0ResultsItemsSlug'], any> {
  name: 'QueryFlowsInstancesListOneOf_0ResultsItemsSlug';
}

export type FlowsInstancesRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['FlowsInstancesRetrieveResponse'] = ResolversParentTypes['FlowsInstancesRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Flow' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type FlowsInstancesDiagramRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['FlowsInstancesDiagramRetrieveResponse'] = ResolversParentTypes['FlowsInstancesDiagramRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'FlowDiagram' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type FlowDiagramResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['FlowDiagram'] = ResolversParentTypes['FlowDiagram']> = ResolversObject<{
  diagram?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type FlowsInstancesExecuteRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['FlowsInstancesExecuteRetrieveResponse'] = ResolversParentTypes['FlowsInstancesExecuteRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Link' | 'GenericError', ParentType, ContextType>;
}>;

export type LinkResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Link'] = ResolversParentTypes['Link']> = ResolversObject<{
  link?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type FlowsInstancesExportRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['FlowsInstancesExportRetrieveResponse'] = ResolversParentTypes['FlowsInstancesExportRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'FileContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type FileContainerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['FileContainer'] = ResolversParentTypes['FileContainer']> = ResolversObject<{
  file?: Resolver<Maybe<ResolversTypes['File']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface FileScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['File'], any> {
  name: 'File';
}

export type FlowsInstancesUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['FlowsInstancesUsedByListResponse'] = ResolversParentTypes['FlowsInstancesUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type FlowsInstancesCacheInfoRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['FlowsInstancesCacheInfoRetrieveResponse'] = ResolversParentTypes['FlowsInstancesCacheInfoRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Cache' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CacheResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Cache'] = ResolversParentTypes['Cache']> = ResolversObject<{
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ManagedBlueprintsListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ManagedBlueprintsListResponse'] = ResolversParentTypes['ManagedBlueprintsListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedBlueprintInstanceList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedBlueprintInstanceListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedBlueprintInstanceList'] = ResolversParentTypes['PaginatedBlueprintInstanceList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['BlueprintInstance']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type BlueprintInstanceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['BlueprintInstance'] = ResolversParentTypes['BlueprintInstance']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  path?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  context?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  lastApplied?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastAppliedHash?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<ResolversTypes['BlueprintInstanceStatusEnum'], ParentType, ContextType>;
  enabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  managedModels?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  metadata?: Resolver<ResolversTypes['JSON'], ParentType, ContextType>;
  content?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ManagedBlueprintsRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ManagedBlueprintsRetrieveResponse'] = ResolversParentTypes['ManagedBlueprintsRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'BlueprintInstance' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ManagedBlueprintsUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ManagedBlueprintsUsedByListResponse'] = ResolversParentTypes['ManagedBlueprintsUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ManagedBlueprintsAvailableListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ManagedBlueprintsAvailableListResponse'] = ResolversParentTypes['ManagedBlueprintsAvailableListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'BlueprintFile' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type BlueprintFileResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['BlueprintFile'] = ResolversParentTypes['BlueprintFile']> = ResolversObject<{
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  lastM?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  hash?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  meta?: Resolver<ResolversTypes['Metadata'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MetadataResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Metadata'] = ResolversParentTypes['Metadata']> = ResolversObject<{
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  labels?: Resolver<ResolversTypes['JSON'], ParentType, ContextType>;
  additionalProperties?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Oauth2AccessTokensListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Oauth2AccessTokensListResponse'] = ResolversParentTypes['Oauth2AccessTokensListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedTokenModelList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedTokenModelListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedTokenModelList'] = ResolversParentTypes['PaginatedTokenModelList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['TokenModel']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TokenModelResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TokenModel'] = ResolversParentTypes['TokenModel']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  provider?: Resolver<ResolversTypes['OAuth2Provider'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  isExpired?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  expires?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  scope?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  idToken?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  revoked?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OAuth2ProviderResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OAuth2Provider'] = ResolversParentTypes['OAuth2Provider']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  authenticationFlow?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  authorizationFlow?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  propertyMappings?: Resolver<Maybe<Array<Maybe<ResolversTypes['UUID']>>>, ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  assignedApplicationSlug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  assignedApplicationName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  assignedBackchannelApplicationSlug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  assignedBackchannelApplicationName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  clientType?: Resolver<Maybe<ResolversTypes['ClientTypeEnum']>, ParentType, ContextType>;
  clientId?: Resolver<Maybe<ResolversTypes['QueryOauth2AccessTokensListOneOf_0ResultsItemsProviderClientId']>, ParentType, ContextType>;
  clientSecret?: Resolver<Maybe<ResolversTypes['QueryOauth2AccessTokensListOneOf_0ResultsItemsProviderClientSecret']>, ParentType, ContextType>;
  accessCodeValidity?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  accessTokenValidity?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  refreshTokenValidity?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  includeClaimsInIdToken?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  signingKey?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  redirectUris?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  subMode?: Resolver<Maybe<ResolversTypes['SubModeEnum']>, ParentType, ContextType>;
  issuerMode?: Resolver<Maybe<ResolversTypes['IssuerModeEnum']>, ParentType, ContextType>;
  jwksSources?: Resolver<Maybe<Array<Maybe<ResolversTypes['UUID']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface QueryOauth2AccessTokensListOneOf_0ResultsItemsProviderClientIdScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['QueryOauth2AccessTokensListOneOf_0ResultsItemsProviderClientId'], any> {
  name: 'QueryOauth2AccessTokensListOneOf_0ResultsItemsProviderClientId';
}

export interface QueryOauth2AccessTokensListOneOf_0ResultsItemsProviderClientSecretScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['QueryOauth2AccessTokensListOneOf_0ResultsItemsProviderClientSecret'], any> {
  name: 'QueryOauth2AccessTokensListOneOf_0ResultsItemsProviderClientSecret';
}

export type Oauth2AccessTokensRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Oauth2AccessTokensRetrieveResponse'] = ResolversParentTypes['Oauth2AccessTokensRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'TokenModel' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type Oauth2AccessTokensUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Oauth2AccessTokensUsedByListResponse'] = ResolversParentTypes['Oauth2AccessTokensUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type Oauth2AuthorizationCodesListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Oauth2AuthorizationCodesListResponse'] = ResolversParentTypes['Oauth2AuthorizationCodesListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedExpiringBaseGrantModelList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedExpiringBaseGrantModelListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedExpiringBaseGrantModelList'] = ResolversParentTypes['PaginatedExpiringBaseGrantModelList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['ExpiringBaseGrantModel']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ExpiringBaseGrantModelResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ExpiringBaseGrantModel'] = ResolversParentTypes['ExpiringBaseGrantModel']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  provider?: Resolver<ResolversTypes['OAuth2Provider'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  isExpired?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  expires?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  scope?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Oauth2AuthorizationCodesRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Oauth2AuthorizationCodesRetrieveResponse'] = ResolversParentTypes['Oauth2AuthorizationCodesRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ExpiringBaseGrantModel' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type Oauth2AuthorizationCodesUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Oauth2AuthorizationCodesUsedByListResponse'] = ResolversParentTypes['Oauth2AuthorizationCodesUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type Oauth2RefreshTokensListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Oauth2RefreshTokensListResponse'] = ResolversParentTypes['Oauth2RefreshTokensListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedTokenModelList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type Oauth2RefreshTokensRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Oauth2RefreshTokensRetrieveResponse'] = ResolversParentTypes['Oauth2RefreshTokensRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'TokenModel' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type Oauth2RefreshTokensUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Oauth2RefreshTokensUsedByListResponse'] = ResolversParentTypes['Oauth2RefreshTokensUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type OutpostsInstancesListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OutpostsInstancesListResponse'] = ResolversParentTypes['OutpostsInstancesListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedOutpostList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedOutpostListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedOutpostList'] = ResolversParentTypes['PaginatedOutpostList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['Outpost']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OutpostResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Outpost'] = ResolversParentTypes['Outpost']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['OutpostTypeEnum'], ParentType, ContextType>;
  providers?: Resolver<Array<Maybe<ResolversTypes['Int']>>, ParentType, ContextType>;
  providersObj?: Resolver<Array<Maybe<ResolversTypes['Provider']>>, ParentType, ContextType>;
  serviceConnection?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  serviceConnectionObj?: Resolver<ResolversTypes['ServiceConnection'], ParentType, ContextType>;
  tokenIdentifier?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  config?: Resolver<ResolversTypes['JSON'], ParentType, ContextType>;
  managed?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ServiceConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ServiceConnection'] = ResolversParentTypes['ServiceConnection']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  local?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  additionalProperties?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OutpostsInstancesRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OutpostsInstancesRetrieveResponse'] = ResolversParentTypes['OutpostsInstancesRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Outpost' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type OutpostsInstancesHealthListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OutpostsInstancesHealthListResponse'] = ResolversParentTypes['OutpostsInstancesHealthListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'OutpostHealth' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type OutpostHealthResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OutpostHealth'] = ResolversParentTypes['OutpostHealth']> = ResolversObject<{
  uid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  lastSeen?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  versionShould?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  versionOutdated?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  buildHash?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  buildHashShould?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  hostname?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OutpostsInstancesUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OutpostsInstancesUsedByListResponse'] = ResolversParentTypes['OutpostsInstancesUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type OutpostsInstancesDefaultSettingsRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OutpostsInstancesDefaultSettingsRetrieveResponse'] = ResolversParentTypes['OutpostsInstancesDefaultSettingsRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'OutpostDefaultConfig' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type OutpostDefaultConfigResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OutpostDefaultConfig'] = ResolversParentTypes['OutpostDefaultConfig']> = ResolversObject<{
  config?: Resolver<ResolversTypes['JSON'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OutpostsLdapListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OutpostsLdapListResponse'] = ResolversParentTypes['OutpostsLdapListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedLdapOutpostConfigList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedLdapOutpostConfigListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedLdapOutpostConfigList'] = ResolversParentTypes['PaginatedLdapOutpostConfigList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['LdapOutpostConfig']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LdapOutpostConfigResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LdapOutpostConfig'] = ResolversParentTypes['LdapOutpostConfig']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  baseDn?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  bindFlowSlug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  applicationSlug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  searchGroup?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  certificate?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  tlsServerName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  uidStartNumber?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  gidStartNumber?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  searchMode?: Resolver<Maybe<ResolversTypes['LdapapiAccessMode']>, ParentType, ContextType>;
  bindMode?: Resolver<Maybe<ResolversTypes['LdapapiAccessMode']>, ParentType, ContextType>;
  mfaSupport?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OutpostsLdapRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OutpostsLdapRetrieveResponse'] = ResolversParentTypes['OutpostsLdapRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'LdapOutpostConfig' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type OutpostsProxyListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OutpostsProxyListResponse'] = ResolversParentTypes['OutpostsProxyListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedProxyOutpostConfigList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedProxyOutpostConfigListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedProxyOutpostConfigList'] = ResolversParentTypes['PaginatedProxyOutpostConfigList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['ProxyOutpostConfig']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProxyOutpostConfigResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProxyOutpostConfig'] = ResolversParentTypes['ProxyOutpostConfig']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  internalHost?: Resolver<Maybe<ResolversTypes['URL']>, ParentType, ContextType>;
  externalHost?: Resolver<ResolversTypes['URL'], ParentType, ContextType>;
  internalHostSslValidation?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  clientId?: Resolver<Maybe<ResolversTypes['QueryOutpostsProxyListOneOf_0ResultsItemsClientId']>, ParentType, ContextType>;
  clientSecret?: Resolver<Maybe<ResolversTypes['QueryOutpostsProxyListOneOf_0ResultsItemsClientSecret']>, ParentType, ContextType>;
  oidcConfiguration?: Resolver<ResolversTypes['OpenIdConnectConfiguration'], ParentType, ContextType>;
  cookieSecret?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  certificate?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  skipPathRegex?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  basicAuthEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  basicAuthPasswordAttribute?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  basicAuthUserAttribute?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  mode?: Resolver<Maybe<ResolversTypes['ProxyMode']>, ParentType, ContextType>;
  cookieDomain?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  accessTokenValidity?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  interceptHeaderAuth?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  scopesToRequest?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  assignedApplicationSlug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  assignedApplicationName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface QueryOutpostsProxyListOneOf_0ResultsItemsClientIdScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['QueryOutpostsProxyListOneOf_0ResultsItemsClientId'], any> {
  name: 'QueryOutpostsProxyListOneOf_0ResultsItemsClientId';
}

export interface QueryOutpostsProxyListOneOf_0ResultsItemsClientSecretScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['QueryOutpostsProxyListOneOf_0ResultsItemsClientSecret'], any> {
  name: 'QueryOutpostsProxyListOneOf_0ResultsItemsClientSecret';
}

export type OpenIdConnectConfigurationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OpenIdConnectConfiguration'] = ResolversParentTypes['OpenIdConnectConfiguration']> = ResolversObject<{
  issuer?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  authorizationEndpoint?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  tokenEndpoint?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  userinfoEndpoint?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  endSessionEndpoint?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  introspectionEndpoint?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  jwksUri?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  responseTypesSupported?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  idTokenSigningAlgValuesSupported?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  subjectTypesSupported?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  tokenEndpointAuthMethodsSupported?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  additionalProperties?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OutpostsProxyRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OutpostsProxyRetrieveResponse'] = ResolversParentTypes['OutpostsProxyRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ProxyOutpostConfig' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type OutpostsRadiusListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OutpostsRadiusListResponse'] = ResolversParentTypes['OutpostsRadiusListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedRadiusOutpostConfigList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedRadiusOutpostConfigListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedRadiusOutpostConfigList'] = ResolversParentTypes['PaginatedRadiusOutpostConfigList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['RadiusOutpostConfig']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RadiusOutpostConfigResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RadiusOutpostConfig'] = ResolversParentTypes['RadiusOutpostConfig']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  applicationSlug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  authFlowSlug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  clientNetworks?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sharedSecret?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  mfaSupport?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OutpostsRadiusRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OutpostsRadiusRetrieveResponse'] = ResolversParentTypes['OutpostsRadiusRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'RadiusOutpostConfig' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type OutpostsServiceConnectionsAllListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OutpostsServiceConnectionsAllListResponse'] = ResolversParentTypes['OutpostsServiceConnectionsAllListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedServiceConnectionList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedServiceConnectionListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedServiceConnectionList'] = ResolversParentTypes['PaginatedServiceConnectionList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['ServiceConnection']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OutpostsServiceConnectionsAllRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OutpostsServiceConnectionsAllRetrieveResponse'] = ResolversParentTypes['OutpostsServiceConnectionsAllRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ServiceConnection' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type OutpostsServiceConnectionsAllStateRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OutpostsServiceConnectionsAllStateRetrieveResponse'] = ResolversParentTypes['OutpostsServiceConnectionsAllStateRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ServiceConnectionState' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ServiceConnectionStateResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ServiceConnectionState'] = ResolversParentTypes['ServiceConnectionState']> = ResolversObject<{
  healthy?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OutpostsServiceConnectionsAllUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OutpostsServiceConnectionsAllUsedByListResponse'] = ResolversParentTypes['OutpostsServiceConnectionsAllUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type OutpostsServiceConnectionsAllTypesListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OutpostsServiceConnectionsAllTypesListResponse'] = ResolversParentTypes['OutpostsServiceConnectionsAllTypesListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'TypeCreate' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type OutpostsServiceConnectionsDockerListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OutpostsServiceConnectionsDockerListResponse'] = ResolversParentTypes['OutpostsServiceConnectionsDockerListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedDockerServiceConnectionList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedDockerServiceConnectionListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedDockerServiceConnectionList'] = ResolversParentTypes['PaginatedDockerServiceConnectionList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['DockerServiceConnection']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DockerServiceConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DockerServiceConnection'] = ResolversParentTypes['DockerServiceConnection']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  local?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  tlsVerification?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  tlsAuthentication?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OutpostsServiceConnectionsDockerRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OutpostsServiceConnectionsDockerRetrieveResponse'] = ResolversParentTypes['OutpostsServiceConnectionsDockerRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'DockerServiceConnection' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type OutpostsServiceConnectionsDockerUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OutpostsServiceConnectionsDockerUsedByListResponse'] = ResolversParentTypes['OutpostsServiceConnectionsDockerUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type OutpostsServiceConnectionsKubernetesListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OutpostsServiceConnectionsKubernetesListResponse'] = ResolversParentTypes['OutpostsServiceConnectionsKubernetesListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedKubernetesServiceConnectionList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedKubernetesServiceConnectionListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedKubernetesServiceConnectionList'] = ResolversParentTypes['PaginatedKubernetesServiceConnectionList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['KubernetesServiceConnection']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type KubernetesServiceConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['KubernetesServiceConnection'] = ResolversParentTypes['KubernetesServiceConnection']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  local?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  kubeconfig?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  verifySsl?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OutpostsServiceConnectionsKubernetesRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OutpostsServiceConnectionsKubernetesRetrieveResponse'] = ResolversParentTypes['OutpostsServiceConnectionsKubernetesRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'KubernetesServiceConnection' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type OutpostsServiceConnectionsKubernetesUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OutpostsServiceConnectionsKubernetesUsedByListResponse'] = ResolversParentTypes['OutpostsServiceConnectionsKubernetesUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesAllListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesAllListResponse'] = ResolversParentTypes['PoliciesAllListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedPolicyList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedPolicyListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedPolicyList'] = ResolversParentTypes['PaginatedPolicyList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['Policy']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PolicyResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Policy'] = ResolversParentTypes['Policy']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  executionLogging?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  boundTo?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  additionalProperties?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PoliciesAllRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesAllRetrieveResponse'] = ResolversParentTypes['PoliciesAllRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Policy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesAllUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesAllUsedByListResponse'] = ResolversParentTypes['PoliciesAllUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesAllCacheInfoRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesAllCacheInfoRetrieveResponse'] = ResolversParentTypes['PoliciesAllCacheInfoRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Cache' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesAllTypesListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesAllTypesListResponse'] = ResolversParentTypes['PoliciesAllTypesListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'TypeCreate' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesBindingsListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesBindingsListResponse'] = ResolversParentTypes['PoliciesBindingsListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedPolicyBindingList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedPolicyBindingListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedPolicyBindingList'] = ResolversParentTypes['PaginatedPolicyBindingList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['PolicyBinding']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PolicyBindingResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PolicyBinding'] = ResolversParentTypes['PolicyBinding']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  policy?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  group?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  policyObj?: Resolver<ResolversTypes['Policy'], ParentType, ContextType>;
  groupObj?: Resolver<ResolversTypes['Group'], ParentType, ContextType>;
  userObj?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  target?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  negate?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  enabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  order?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  timeout?: Resolver<Maybe<ResolversTypes['NonNegativeInt']>, ParentType, ContextType>;
  failureResult?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface NonNegativeIntScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['NonNegativeInt'], any> {
  name: 'NonNegativeInt';
}

export type PoliciesBindingsRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesBindingsRetrieveResponse'] = ResolversParentTypes['PoliciesBindingsRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PolicyBinding' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesBindingsUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesBindingsUsedByListResponse'] = ResolversParentTypes['PoliciesBindingsUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesDummyListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesDummyListResponse'] = ResolversParentTypes['PoliciesDummyListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedDummyPolicyList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedDummyPolicyListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedDummyPolicyList'] = ResolversParentTypes['PaginatedDummyPolicyList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['DummyPolicy']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DummyPolicyResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DummyPolicy'] = ResolversParentTypes['DummyPolicy']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  executionLogging?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  boundTo?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  result?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  waitMin?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  waitMax?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PoliciesDummyRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesDummyRetrieveResponse'] = ResolversParentTypes['PoliciesDummyRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'DummyPolicy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesDummyUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesDummyUsedByListResponse'] = ResolversParentTypes['PoliciesDummyUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesEventMatcherListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesEventMatcherListResponse'] = ResolversParentTypes['PoliciesEventMatcherListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedEventMatcherPolicyList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedEventMatcherPolicyListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedEventMatcherPolicyList'] = ResolversParentTypes['PaginatedEventMatcherPolicyList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['EventMatcherPolicy']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EventMatcherPolicyResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EventMatcherPolicy'] = ResolversParentTypes['EventMatcherPolicy']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  executionLogging?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  boundTo?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  action?: Resolver<Maybe<ResolversTypes['EventActions']>, ParentType, ContextType>;
  clientIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  app?: Resolver<Maybe<ResolversTypes['AppEnum']>, ParentType, ContextType>;
  model?: Resolver<Maybe<ResolversTypes['ModelEnum']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PoliciesEventMatcherRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesEventMatcherRetrieveResponse'] = ResolversParentTypes['PoliciesEventMatcherRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'EventMatcherPolicy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesEventMatcherUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesEventMatcherUsedByListResponse'] = ResolversParentTypes['PoliciesEventMatcherUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesExpressionListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesExpressionListResponse'] = ResolversParentTypes['PoliciesExpressionListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedExpressionPolicyList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedExpressionPolicyListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedExpressionPolicyList'] = ResolversParentTypes['PaginatedExpressionPolicyList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['ExpressionPolicy']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ExpressionPolicyResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ExpressionPolicy'] = ResolversParentTypes['ExpressionPolicy']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  executionLogging?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  boundTo?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  expression?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PoliciesExpressionRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesExpressionRetrieveResponse'] = ResolversParentTypes['PoliciesExpressionRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ExpressionPolicy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesExpressionUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesExpressionUsedByListResponse'] = ResolversParentTypes['PoliciesExpressionUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesPasswordListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesPasswordListResponse'] = ResolversParentTypes['PoliciesPasswordListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedPasswordPolicyList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedPasswordPolicyListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedPasswordPolicyList'] = ResolversParentTypes['PaginatedPasswordPolicyList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['PasswordPolicy']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PasswordPolicyResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PasswordPolicy'] = ResolversParentTypes['PasswordPolicy']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  executionLogging?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  boundTo?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  passwordField?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  amountDigits?: Resolver<Maybe<ResolversTypes['NonNegativeInt']>, ParentType, ContextType>;
  amountUppercase?: Resolver<Maybe<ResolversTypes['NonNegativeInt']>, ParentType, ContextType>;
  amountLowercase?: Resolver<Maybe<ResolversTypes['NonNegativeInt']>, ParentType, ContextType>;
  amountSymbols?: Resolver<Maybe<ResolversTypes['NonNegativeInt']>, ParentType, ContextType>;
  lengthMin?: Resolver<Maybe<ResolversTypes['NonNegativeInt']>, ParentType, ContextType>;
  symbolCharset?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  errorMessage?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  checkStaticRules?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  checkHaveIBeenPwned?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  checkZxcvbn?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  hibpAllowedCount?: Resolver<Maybe<ResolversTypes['NonNegativeInt']>, ParentType, ContextType>;
  zxcvbnScoreThreshold?: Resolver<Maybe<ResolversTypes['NonNegativeInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PoliciesPasswordRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesPasswordRetrieveResponse'] = ResolversParentTypes['PoliciesPasswordRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PasswordPolicy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesPasswordUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesPasswordUsedByListResponse'] = ResolversParentTypes['PoliciesPasswordUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesPasswordExpiryListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesPasswordExpiryListResponse'] = ResolversParentTypes['PoliciesPasswordExpiryListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedPasswordExpiryPolicyList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedPasswordExpiryPolicyListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedPasswordExpiryPolicyList'] = ResolversParentTypes['PaginatedPasswordExpiryPolicyList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['PasswordExpiryPolicy']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PasswordExpiryPolicyResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PasswordExpiryPolicy'] = ResolversParentTypes['PasswordExpiryPolicy']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  executionLogging?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  boundTo?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  days?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  denyOnly?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PoliciesPasswordExpiryRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesPasswordExpiryRetrieveResponse'] = ResolversParentTypes['PoliciesPasswordExpiryRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PasswordExpiryPolicy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesPasswordExpiryUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesPasswordExpiryUsedByListResponse'] = ResolversParentTypes['PoliciesPasswordExpiryUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesReputationListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesReputationListResponse'] = ResolversParentTypes['PoliciesReputationListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedReputationPolicyList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedReputationPolicyListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedReputationPolicyList'] = ResolversParentTypes['PaginatedReputationPolicyList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['ReputationPolicy']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReputationPolicyResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ReputationPolicy'] = ResolversParentTypes['ReputationPolicy']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  executionLogging?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  boundTo?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  checkIp?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  checkUsername?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  threshold?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PoliciesReputationRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesReputationRetrieveResponse'] = ResolversParentTypes['PoliciesReputationRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ReputationPolicy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesReputationUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesReputationUsedByListResponse'] = ResolversParentTypes['PoliciesReputationUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesReputationScoresListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesReputationScoresListResponse'] = ResolversParentTypes['PoliciesReputationScoresListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedReputationList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedReputationListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedReputationList'] = ResolversParentTypes['PaginatedReputationList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['Reputation']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReputationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Reputation'] = ResolversParentTypes['Reputation']> = ResolversObject<{
  pk?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  identifier?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  ip?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  ipGeoData?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  ipAsnData?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  score?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  updated?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface BigIntScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['BigInt'], any> {
  name: 'BigInt';
}

export type PoliciesReputationScoresRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesReputationScoresRetrieveResponse'] = ResolversParentTypes['PoliciesReputationScoresRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Reputation' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesReputationScoresUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesReputationScoresUsedByListResponse'] = ResolversParentTypes['PoliciesReputationScoresUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertymappingsAllListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsAllListResponse'] = ResolversParentTypes['PropertymappingsAllListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedPropertyMappingList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedPropertyMappingListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedPropertyMappingList'] = ResolversParentTypes['PaginatedPropertyMappingList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['PropertyMapping']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PropertyMappingResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertyMapping'] = ResolversParentTypes['PropertyMapping']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  managed?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  expression?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PropertymappingsAllRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsAllRetrieveResponse'] = ResolversParentTypes['PropertymappingsAllRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PropertyMapping' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertymappingsAllUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsAllUsedByListResponse'] = ResolversParentTypes['PropertymappingsAllUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertymappingsAllTypesListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsAllTypesListResponse'] = ResolversParentTypes['PropertymappingsAllTypesListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'TypeCreate' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertymappingsLdapListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsLdapListResponse'] = ResolversParentTypes['PropertymappingsLdapListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedLdapPropertyMappingList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedLdapPropertyMappingListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedLdapPropertyMappingList'] = ResolversParentTypes['PaginatedLdapPropertyMappingList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['LdapPropertyMapping']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LdapPropertyMappingResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LdapPropertyMapping'] = ResolversParentTypes['LdapPropertyMapping']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  managed?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  expression?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  objectField?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PropertymappingsLdapRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsLdapRetrieveResponse'] = ResolversParentTypes['PropertymappingsLdapRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'LdapPropertyMapping' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertymappingsLdapUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsLdapUsedByListResponse'] = ResolversParentTypes['PropertymappingsLdapUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertymappingsNotificationListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsNotificationListResponse'] = ResolversParentTypes['PropertymappingsNotificationListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedNotificationWebhookMappingList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedNotificationWebhookMappingListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedNotificationWebhookMappingList'] = ResolversParentTypes['PaginatedNotificationWebhookMappingList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['NotificationWebhookMapping']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type NotificationWebhookMappingResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['NotificationWebhookMapping'] = ResolversParentTypes['NotificationWebhookMapping']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  expression?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PropertymappingsNotificationRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsNotificationRetrieveResponse'] = ResolversParentTypes['PropertymappingsNotificationRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'NotificationWebhookMapping' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertymappingsNotificationUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsNotificationUsedByListResponse'] = ResolversParentTypes['PropertymappingsNotificationUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertymappingsRacListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsRacListResponse'] = ResolversParentTypes['PropertymappingsRacListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedRacPropertyMappingList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedRacPropertyMappingListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedRacPropertyMappingList'] = ResolversParentTypes['PaginatedRacPropertyMappingList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['RacPropertyMapping']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RacPropertyMappingResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RacPropertyMapping'] = ResolversParentTypes['RacPropertyMapping']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  managed?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  expression?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  staticSettings?: Resolver<ResolversTypes['JSON'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PropertymappingsRacRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsRacRetrieveResponse'] = ResolversParentTypes['PropertymappingsRacRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'RacPropertyMapping' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertymappingsRacUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsRacUsedByListResponse'] = ResolversParentTypes['PropertymappingsRacUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertymappingsSamlListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsSamlListResponse'] = ResolversParentTypes['PropertymappingsSamlListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedSamlPropertyMappingList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedSamlPropertyMappingListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedSamlPropertyMappingList'] = ResolversParentTypes['PaginatedSamlPropertyMappingList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['SamlPropertyMapping']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SamlPropertyMappingResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SamlPropertyMapping'] = ResolversParentTypes['SamlPropertyMapping']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  managed?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  expression?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  samlName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  friendlyName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PropertymappingsSamlRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsSamlRetrieveResponse'] = ResolversParentTypes['PropertymappingsSamlRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'SamlPropertyMapping' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertymappingsSamlUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsSamlUsedByListResponse'] = ResolversParentTypes['PropertymappingsSamlUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertymappingsScimListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsScimListResponse'] = ResolversParentTypes['PropertymappingsScimListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedScimMappingList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedScimMappingListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedScimMappingList'] = ResolversParentTypes['PaginatedScimMappingList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['ScimMapping']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ScimMappingResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ScimMapping'] = ResolversParentTypes['ScimMapping']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  managed?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  expression?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PropertymappingsScimRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsScimRetrieveResponse'] = ResolversParentTypes['PropertymappingsScimRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ScimMapping' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertymappingsScimUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsScimUsedByListResponse'] = ResolversParentTypes['PropertymappingsScimUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertymappingsScopeListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsScopeListResponse'] = ResolversParentTypes['PropertymappingsScopeListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedScopeMappingList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedScopeMappingListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedScopeMappingList'] = ResolversParentTypes['PaginatedScopeMappingList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['ScopeMapping']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ScopeMappingResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ScopeMapping'] = ResolversParentTypes['ScopeMapping']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  managed?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  expression?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  scopeName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PropertymappingsScopeRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsScopeRetrieveResponse'] = ResolversParentTypes['PropertymappingsScopeRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ScopeMapping' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertymappingsScopeUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsScopeUsedByListResponse'] = ResolversParentTypes['PropertymappingsScopeUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersAllListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersAllListResponse'] = ResolversParentTypes['ProvidersAllListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedProviderList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedProviderListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedProviderList'] = ResolversParentTypes['PaginatedProviderList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['Provider']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProvidersAllRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersAllRetrieveResponse'] = ResolversParentTypes['ProvidersAllRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Provider' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersAllUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersAllUsedByListResponse'] = ResolversParentTypes['ProvidersAllUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersAllTypesListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersAllTypesListResponse'] = ResolversParentTypes['ProvidersAllTypesListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'TypeCreate' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersLdapListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersLdapListResponse'] = ResolversParentTypes['ProvidersLdapListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedLdapProviderList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedLdapProviderListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedLdapProviderList'] = ResolversParentTypes['PaginatedLdapProviderList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['LdapProvider']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LdapProviderResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LdapProvider'] = ResolversParentTypes['LdapProvider']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  authenticationFlow?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  authorizationFlow?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  propertyMappings?: Resolver<Maybe<Array<Maybe<ResolversTypes['UUID']>>>, ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  assignedApplicationSlug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  assignedApplicationName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  assignedBackchannelApplicationSlug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  assignedBackchannelApplicationName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  baseDn?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  searchGroup?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  certificate?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  tlsServerName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  uidStartNumber?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  gidStartNumber?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  outpostSet?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  searchMode?: Resolver<Maybe<ResolversTypes['LdapapiAccessMode']>, ParentType, ContextType>;
  bindMode?: Resolver<Maybe<ResolversTypes['LdapapiAccessMode']>, ParentType, ContextType>;
  mfaSupport?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProvidersLdapRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersLdapRetrieveResponse'] = ResolversParentTypes['ProvidersLdapRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'LdapProvider' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersLdapUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersLdapUsedByListResponse'] = ResolversParentTypes['ProvidersLdapUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersOauth2ListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersOauth2ListResponse'] = ResolversParentTypes['ProvidersOauth2ListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedOAuth2ProviderList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedOAuth2ProviderListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedOAuth2ProviderList'] = ResolversParentTypes['PaginatedOAuth2ProviderList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['OAuth2Provider']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProvidersOauth2RetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersOauth2RetrieveResponse'] = ResolversParentTypes['ProvidersOauth2RetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'OAuth2Provider' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersOauth2PreviewUserRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersOauth2PreviewUserRetrieveResponse'] = ResolversParentTypes['ProvidersOauth2PreviewUserRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PropertyMappingPreview' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertyMappingPreviewResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertyMappingPreview'] = ResolversParentTypes['PropertyMappingPreview']> = ResolversObject<{
  preview?: Resolver<ResolversTypes['JSON'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProvidersOauth2SetupUrlsRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersOauth2SetupUrlsRetrieveResponse'] = ResolversParentTypes['ProvidersOauth2SetupUrlsRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'OAuth2ProviderSetupUrLs' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type OAuth2ProviderSetupUrLsResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OAuth2ProviderSetupUrLs'] = ResolversParentTypes['OAuth2ProviderSetupUrLs']> = ResolversObject<{
  issuer?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  authorize?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  token?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  userInfo?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  providerInfo?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  logout?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  jwks?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProvidersOauth2UsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersOauth2UsedByListResponse'] = ResolversParentTypes['ProvidersOauth2UsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersProxyListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersProxyListResponse'] = ResolversParentTypes['ProvidersProxyListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedProxyProviderList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedProxyProviderListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedProxyProviderList'] = ResolversParentTypes['PaginatedProxyProviderList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['ProxyProvider']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProxyProviderResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProxyProvider'] = ResolversParentTypes['ProxyProvider']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  authenticationFlow?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  authorizationFlow?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  propertyMappings?: Resolver<Maybe<Array<Maybe<ResolversTypes['UUID']>>>, ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  assignedApplicationSlug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  assignedApplicationName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  assignedBackchannelApplicationSlug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  assignedBackchannelApplicationName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  clientId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  internalHost?: Resolver<Maybe<ResolversTypes['URL']>, ParentType, ContextType>;
  externalHost?: Resolver<ResolversTypes['URL'], ParentType, ContextType>;
  internalHostSslValidation?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  certificate?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  skipPathRegex?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  basicAuthEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  basicAuthPasswordAttribute?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  basicAuthUserAttribute?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  mode?: Resolver<Maybe<ResolversTypes['ProxyMode']>, ParentType, ContextType>;
  interceptHeaderAuth?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  redirectUris?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  cookieDomain?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  jwksSources?: Resolver<Maybe<Array<Maybe<ResolversTypes['UUID']>>>, ParentType, ContextType>;
  accessTokenValidity?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  refreshTokenValidity?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  outpostSet?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProvidersProxyRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersProxyRetrieveResponse'] = ResolversParentTypes['ProvidersProxyRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ProxyProvider' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersProxyUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersProxyUsedByListResponse'] = ResolversParentTypes['ProvidersProxyUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersRacListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersRacListResponse'] = ResolversParentTypes['ProvidersRacListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedRacProviderList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedRacProviderListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedRacProviderList'] = ResolversParentTypes['PaginatedRacProviderList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['RacProvider']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RacProviderResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RacProvider'] = ResolversParentTypes['RacProvider']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  authenticationFlow?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  authorizationFlow?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  propertyMappings?: Resolver<Maybe<Array<Maybe<ResolversTypes['UUID']>>>, ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  assignedApplicationSlug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  assignedApplicationName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  assignedBackchannelApplicationSlug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  assignedBackchannelApplicationName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  settings?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  outpostSet?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  connectionExpiry?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deleteTokenOnDisconnect?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  additionalProperties?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProvidersRacRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersRacRetrieveResponse'] = ResolversParentTypes['ProvidersRacRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'RacProvider' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersRacUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersRacUsedByListResponse'] = ResolversParentTypes['ProvidersRacUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersRadiusListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersRadiusListResponse'] = ResolversParentTypes['ProvidersRadiusListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedRadiusProviderList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedRadiusProviderListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedRadiusProviderList'] = ResolversParentTypes['PaginatedRadiusProviderList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['RadiusProvider']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RadiusProviderResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RadiusProvider'] = ResolversParentTypes['RadiusProvider']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  authenticationFlow?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  authorizationFlow?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  propertyMappings?: Resolver<Maybe<Array<Maybe<ResolversTypes['UUID']>>>, ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  assignedApplicationSlug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  assignedApplicationName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  assignedBackchannelApplicationSlug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  assignedBackchannelApplicationName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  clientNetworks?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sharedSecret?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  outpostSet?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  mfaSupport?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProvidersRadiusRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersRadiusRetrieveResponse'] = ResolversParentTypes['ProvidersRadiusRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'RadiusProvider' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersRadiusUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersRadiusUsedByListResponse'] = ResolversParentTypes['ProvidersRadiusUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersSamlListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersSamlListResponse'] = ResolversParentTypes['ProvidersSamlListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedSamlProviderList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedSamlProviderListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedSamlProviderList'] = ResolversParentTypes['PaginatedSamlProviderList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['SamlProvider']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SamlProviderResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SamlProvider'] = ResolversParentTypes['SamlProvider']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  authenticationFlow?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  authorizationFlow?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  propertyMappings?: Resolver<Maybe<Array<Maybe<ResolversTypes['UUID']>>>, ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  assignedApplicationSlug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  assignedApplicationName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  assignedBackchannelApplicationSlug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  assignedBackchannelApplicationName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  acsUrl?: Resolver<ResolversTypes['URL'], ParentType, ContextType>;
  audience?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  issuer?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  assertionValidNotBefore?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  assertionValidNotOnOrAfter?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sessionValidNotOnOrAfter?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nameIdMapping?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  digestAlgorithm?: Resolver<Maybe<ResolversTypes['DigestAlgorithmEnum']>, ParentType, ContextType>;
  signatureAlgorithm?: Resolver<Maybe<ResolversTypes['SignatureAlgorithmEnum']>, ParentType, ContextType>;
  signingKp?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  verificationKp?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  spBinding?: Resolver<Maybe<ResolversTypes['ServiceProviderBinding']>, ParentType, ContextType>;
  defaultRelayState?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  urlDownloadMetadata?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  urlSsoPost?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  urlSsoRedirect?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  urlSsoInit?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  urlSloPost?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  urlSloRedirect?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ServiceProviderBindingResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ServiceProviderBinding'] = ResolversParentTypes['ServiceProviderBinding']> = ResolversObject<{
  spBindingEnum?: Resolver<Maybe<ResolversTypes['SpBindingEnum']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProvidersSamlRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersSamlRetrieveResponse'] = ResolversParentTypes['ProvidersSamlRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'SamlProvider' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersSamlMetadataRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersSamlMetadataRetrieveResponse'] = ResolversParentTypes['ProvidersSamlMetadataRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'SamlMetadata' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SamlMetadataResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SamlMetadata'] = ResolversParentTypes['SamlMetadata']> = ResolversObject<{
  metadata?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  downloadUrl?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProvidersSamlPreviewUserRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersSamlPreviewUserRetrieveResponse'] = ResolversParentTypes['ProvidersSamlPreviewUserRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PropertyMappingPreview' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersSamlUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersSamlUsedByListResponse'] = ResolversParentTypes['ProvidersSamlUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersScimListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersScimListResponse'] = ResolversParentTypes['ProvidersScimListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedScimProviderList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedScimProviderListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedScimProviderList'] = ResolversParentTypes['PaginatedScimProviderList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['ScimProvider']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ScimProviderResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ScimProvider'] = ResolversParentTypes['ScimProvider']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  propertyMappings?: Resolver<Maybe<Array<Maybe<ResolversTypes['UUID']>>>, ParentType, ContextType>;
  propertyMappingsGroup?: Resolver<Maybe<Array<Maybe<ResolversTypes['UUID']>>>, ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  assignedBackchannelApplicationSlug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  assignedBackchannelApplicationName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  token?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  excludeUsersServiceAccount?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  filterGroup?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProvidersScimRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersScimRetrieveResponse'] = ResolversParentTypes['ProvidersScimRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ScimProvider' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersScimSyncStatusRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersScimSyncStatusRetrieveResponse'] = ResolversParentTypes['ProvidersScimSyncStatusRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ScimSyncStatus' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ScimSyncStatusResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ScimSyncStatus'] = ResolversParentTypes['ScimSyncStatus']> = ResolversObject<{
  isRunning?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  tasks?: Resolver<Array<Maybe<ResolversTypes['SystemTask']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProvidersScimUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersScimUsedByListResponse'] = ResolversParentTypes['ProvidersScimUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type RacConnectionTokensListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RacConnectionTokensListResponse'] = ResolversParentTypes['RacConnectionTokensListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedConnectionTokenList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedConnectionTokenListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedConnectionTokenList'] = ResolversParentTypes['PaginatedConnectionTokenList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['ConnectionToken']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ConnectionTokenResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ConnectionToken'] = ResolversParentTypes['ConnectionToken']> = ResolversObject<{
  pk?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  provider?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  providerObj?: Resolver<ResolversTypes['RacProvider'], ParentType, ContextType>;
  endpoint?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  endpointObj?: Resolver<ResolversTypes['Endpoint'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['GroupMember'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EndpointResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Endpoint'] = ResolversParentTypes['Endpoint']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  provider?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  providerObj?: Resolver<ResolversTypes['RacProvider'], ParentType, ContextType>;
  protocol?: Resolver<ResolversTypes['ProtocolEnum'], ParentType, ContextType>;
  host?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  settings?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  propertyMappings?: Resolver<Maybe<Array<Maybe<ResolversTypes['UUID']>>>, ParentType, ContextType>;
  authMode?: Resolver<ResolversTypes['AuthModeEnum'], ParentType, ContextType>;
  launchUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  maximumConnections?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  additionalProperties?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RacConnectionTokensRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RacConnectionTokensRetrieveResponse'] = ResolversParentTypes['RacConnectionTokensRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ConnectionToken' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type RacConnectionTokensUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RacConnectionTokensUsedByListResponse'] = ResolversParentTypes['RacConnectionTokensUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type RacEndpointsListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RacEndpointsListResponse'] = ResolversParentTypes['RacEndpointsListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedEndpointList' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedEndpointListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedEndpointList'] = ResolversParentTypes['PaginatedEndpointList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['Endpoint']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RacEndpointsRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RacEndpointsRetrieveResponse'] = ResolversParentTypes['RacEndpointsRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Endpoint' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type RacEndpointsUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RacEndpointsUsedByListResponse'] = ResolversParentTypes['RacEndpointsUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type RbacPermissionsListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RbacPermissionsListResponse'] = ResolversParentTypes['RbacPermissionsListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedPermissionList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedPermissionListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedPermissionList'] = ResolversParentTypes['PaginatedPermissionList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['Permission']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PermissionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Permission'] = ResolversParentTypes['Permission']> = ResolversObject<{
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['QueryRbacPermissionsListOneOf_0ResultsItemsName'], ParentType, ContextType>;
  codename?: Resolver<ResolversTypes['QueryRbacPermissionsListOneOf_0ResultsItemsCodename'], ParentType, ContextType>;
  model?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  appLabel?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  appLabelVerbose?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  modelVerbose?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface QueryRbacPermissionsListOneOf_0ResultsItemsNameScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['QueryRbacPermissionsListOneOf_0ResultsItemsName'], any> {
  name: 'QueryRbacPermissionsListOneOf_0ResultsItemsName';
}

export interface QueryRbacPermissionsListOneOf_0ResultsItemsCodenameScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['QueryRbacPermissionsListOneOf_0ResultsItemsCodename'], any> {
  name: 'QueryRbacPermissionsListOneOf_0ResultsItemsCodename';
}

export type RbacPermissionsRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RbacPermissionsRetrieveResponse'] = ResolversParentTypes['RbacPermissionsRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Permission' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type RbacPermissionsAssignedByRolesListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RbacPermissionsAssignedByRolesListResponse'] = ResolversParentTypes['RbacPermissionsAssignedByRolesListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedRoleAssignedObjectPermissionList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedRoleAssignedObjectPermissionListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedRoleAssignedObjectPermissionList'] = ResolversParentTypes['PaginatedRoleAssignedObjectPermissionList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['RoleAssignedObjectPermission']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RoleAssignedObjectPermissionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RoleAssignedObjectPermission'] = ResolversParentTypes['RoleAssignedObjectPermission']> = ResolversObject<{
  rolePk?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  permissions?: Resolver<Array<Maybe<ResolversTypes['RoleObjectPermission']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RoleObjectPermissionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RoleObjectPermission'] = ResolversParentTypes['RoleObjectPermission']> = ResolversObject<{
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  codename?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  model?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  appLabel?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  objectPk?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RbacPermissionsAssignedByUsersListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RbacPermissionsAssignedByUsersListResponse'] = ResolversParentTypes['RbacPermissionsAssignedByUsersListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedUserAssignedObjectPermissionList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedUserAssignedObjectPermissionListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedUserAssignedObjectPermissionList'] = ResolversParentTypes['PaginatedUserAssignedObjectPermissionList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['UserAssignedObjectPermission']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserAssignedObjectPermissionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UserAssignedObjectPermission'] = ResolversParentTypes['UserAssignedObjectPermission']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  username?: Resolver<ResolversTypes['QueryRbacPermissionsAssignedByUsersListOneOf_0ResultsItemsUsername'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  isActive?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  lastLogin?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['EmailAddress']>, ParentType, ContextType>;
  attributes?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  uid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  permissions?: Resolver<Array<Maybe<ResolversTypes['UserObjectPermission']>>, ParentType, ContextType>;
  isSuperuser?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface QueryRbacPermissionsAssignedByUsersListOneOf_0ResultsItemsUsernameScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['QueryRbacPermissionsAssignedByUsersListOneOf_0ResultsItemsUsername'], any> {
  name: 'QueryRbacPermissionsAssignedByUsersListOneOf_0ResultsItemsUsername';
}

export type UserObjectPermissionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UserObjectPermission'] = ResolversParentTypes['UserObjectPermission']> = ResolversObject<{
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  codename?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  model?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  appLabel?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  objectPk?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RbacPermissionsRolesListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RbacPermissionsRolesListResponse'] = ResolversParentTypes['RbacPermissionsRolesListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedExtraRoleObjectPermissionList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedExtraRoleObjectPermissionListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedExtraRoleObjectPermissionList'] = ResolversParentTypes['PaginatedExtraRoleObjectPermissionList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['ExtraRoleObjectPermission']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ExtraRoleObjectPermissionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ExtraRoleObjectPermission'] = ResolversParentTypes['ExtraRoleObjectPermission']> = ResolversObject<{
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  codename?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  model?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  appLabel?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  objectPk?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  appLabelVerbose?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  modelVerbose?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  objectDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RbacPermissionsUsersListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RbacPermissionsUsersListResponse'] = ResolversParentTypes['RbacPermissionsUsersListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedExtraUserObjectPermissionList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedExtraUserObjectPermissionListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedExtraUserObjectPermissionList'] = ResolversParentTypes['PaginatedExtraUserObjectPermissionList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['ExtraUserObjectPermission']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ExtraUserObjectPermissionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ExtraUserObjectPermission'] = ResolversParentTypes['ExtraUserObjectPermission']> = ResolversObject<{
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  codename?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  model?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  appLabel?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  objectPk?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  appLabelVerbose?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  modelVerbose?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  objectDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RbacRolesListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RbacRolesListResponse'] = ResolversParentTypes['RbacRolesListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedRoleList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedRoleListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedRoleList'] = ResolversParentTypes['PaginatedRoleList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['Role']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RbacRolesRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RbacRolesRetrieveResponse'] = ResolversParentTypes['RbacRolesRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Role' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type RbacRolesUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RbacRolesUsedByListResponse'] = ResolversParentTypes['RbacRolesUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type RootConfigRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RootConfigRetrieveResponse'] = ResolversParentTypes['RootConfigRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Config' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ConfigResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Config'] = ResolversParentTypes['Config']> = ResolversObject<{
  errorReporting?: Resolver<ResolversTypes['ErrorReportingConfig'], ParentType, ContextType>;
  capabilities?: Resolver<Array<Maybe<ResolversTypes['CapabilitiesEnum']>>, ParentType, ContextType>;
  cacheTimeout?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  cacheTimeoutFlows?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  cacheTimeoutPolicies?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  cacheTimeoutReputation?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ErrorReportingConfigResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ErrorReportingConfig'] = ResolversParentTypes['ErrorReportingConfig']> = ResolversObject<{
  enabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  sentryDsn?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  environment?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  sendPii?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  tracesSampleRate?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SchemaRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SchemaRetrieveResponse'] = ResolversParentTypes['SchemaRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'JsonContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type JsonContainerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['JsonContainer'] = ResolversParentTypes['JsonContainer']> = ResolversObject<{
  json?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SourcesAllListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesAllListResponse'] = ResolversParentTypes['SourcesAllListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedSourceList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedSourceListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedSourceList'] = ResolversParentTypes['PaginatedSourceList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['Source']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SourceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Source'] = ResolversParentTypes['Source']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['QuerySourcesAllListOneOf_0ResultsItemsSlug'], ParentType, ContextType>;
  enabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  authenticationFlow?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  enrollmentFlow?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  policyEngineMode?: Resolver<Maybe<ResolversTypes['PolicyEngineMode']>, ParentType, ContextType>;
  userMatchingMode?: Resolver<Maybe<ResolversTypes['UserMatchingModeEnum']>, ParentType, ContextType>;
  managed?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userPathTemplate?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  icon?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  additionalProperties?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface QuerySourcesAllListOneOf_0ResultsItemsSlugScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['QuerySourcesAllListOneOf_0ResultsItemsSlug'], any> {
  name: 'QuerySourcesAllListOneOf_0ResultsItemsSlug';
}

export type SourcesAllRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesAllRetrieveResponse'] = ResolversParentTypes['SourcesAllRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Source' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesAllUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesAllUsedByListResponse'] = ResolversParentTypes['SourcesAllUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesAllTypesListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesAllTypesListResponse'] = ResolversParentTypes['SourcesAllTypesListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'TypeCreate' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesAllUserSettingsListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesAllUserSettingsListResponse'] = ResolversParentTypes['SourcesAllUserSettingsListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UserSetting' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type UserSettingResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UserSetting'] = ResolversParentTypes['UserSetting']> = ResolversObject<{
  objectUid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  configureUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  iconUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SourcesLdapListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesLdapListResponse'] = ResolversParentTypes['SourcesLdapListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedLdapSourceList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedLdapSourceListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedLdapSourceList'] = ResolversParentTypes['PaginatedLdapSourceList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['LdapSource']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LdapSourceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LdapSource'] = ResolversParentTypes['LdapSource']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['QuerySourcesLdapListOneOf_0ResultsItemsSlug'], ParentType, ContextType>;
  enabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  authenticationFlow?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  enrollmentFlow?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  policyEngineMode?: Resolver<Maybe<ResolversTypes['PolicyEngineMode']>, ParentType, ContextType>;
  userMatchingMode?: Resolver<Maybe<ResolversTypes['UserMatchingModeEnum']>, ParentType, ContextType>;
  managed?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userPathTemplate?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  icon?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  serverUri?: Resolver<ResolversTypes['URL'], ParentType, ContextType>;
  peerCertificate?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  clientCertificate?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  bindCn?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  startTls?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  sni?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  baseDn?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  additionalUserDn?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  additionalGroupDn?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userObjectFilter?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  groupObjectFilter?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  groupMembershipField?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  objectUniquenessField?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  passwordLoginUpdateInternalPassword?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  syncUsers?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  syncUsersPassword?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  syncGroups?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  syncParentGroup?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  propertyMappings?: Resolver<Maybe<Array<Maybe<ResolversTypes['UUID']>>>, ParentType, ContextType>;
  propertyMappingsGroup?: Resolver<Maybe<Array<Maybe<ResolversTypes['UUID']>>>, ParentType, ContextType>;
  connectivity?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface QuerySourcesLdapListOneOf_0ResultsItemsSlugScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['QuerySourcesLdapListOneOf_0ResultsItemsSlug'], any> {
  name: 'QuerySourcesLdapListOneOf_0ResultsItemsSlug';
}

export type SourcesLdapRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesLdapRetrieveResponse'] = ResolversParentTypes['SourcesLdapRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'LdapSource' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesLdapDebugRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesLdapDebugRetrieveResponse'] = ResolversParentTypes['SourcesLdapDebugRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'LdapDebug' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type LdapDebugResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LdapDebug'] = ResolversParentTypes['LdapDebug']> = ResolversObject<{
  user?: Resolver<Array<Maybe<ResolversTypes['JSON']>>, ParentType, ContextType>;
  group?: Resolver<Array<Maybe<ResolversTypes['JSON']>>, ParentType, ContextType>;
  membership?: Resolver<Array<Maybe<ResolversTypes['JSON']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SourcesLdapSyncStatusRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesLdapSyncStatusRetrieveResponse'] = ResolversParentTypes['SourcesLdapSyncStatusRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'LdapSyncStatus' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type LdapSyncStatusResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LdapSyncStatus'] = ResolversParentTypes['LdapSyncStatus']> = ResolversObject<{
  isRunning?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  tasks?: Resolver<Array<Maybe<ResolversTypes['SystemTask']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SourcesLdapUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesLdapUsedByListResponse'] = ResolversParentTypes['SourcesLdapUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesOauthListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesOauthListResponse'] = ResolversParentTypes['SourcesOauthListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedOAuthSourceList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedOAuthSourceListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedOAuthSourceList'] = ResolversParentTypes['PaginatedOAuthSourceList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['OAuthSource']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OAuthSourceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OAuthSource'] = ResolversParentTypes['OAuthSource']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['QuerySourcesOauthListOneOf_0ResultsItemsSlug'], ParentType, ContextType>;
  enabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  authenticationFlow?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  enrollmentFlow?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  policyEngineMode?: Resolver<Maybe<ResolversTypes['PolicyEngineMode']>, ParentType, ContextType>;
  userMatchingMode?: Resolver<Maybe<ResolversTypes['UserMatchingModeEnum']>, ParentType, ContextType>;
  managed?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userPathTemplate?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  icon?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  providerType?: Resolver<ResolversTypes['ProviderTypeEnum'], ParentType, ContextType>;
  requestTokenUrl?: Resolver<Maybe<ResolversTypes['QuerySourcesOauthListOneOf_0ResultsItemsRequestTokenUrl']>, ParentType, ContextType>;
  authorizationUrl?: Resolver<Maybe<ResolversTypes['QuerySourcesOauthListOneOf_0ResultsItemsAuthorizationUrl']>, ParentType, ContextType>;
  accessTokenUrl?: Resolver<Maybe<ResolversTypes['QuerySourcesOauthListOneOf_0ResultsItemsAccessTokenUrl']>, ParentType, ContextType>;
  profileUrl?: Resolver<Maybe<ResolversTypes['QuerySourcesOauthListOneOf_0ResultsItemsProfileUrl']>, ParentType, ContextType>;
  consumerKey?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  callbackUrl?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  additionalScopes?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['SourceType'], ParentType, ContextType>;
  oidcWellKnownUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  oidcJwksUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  oidcJwks?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface QuerySourcesOauthListOneOf_0ResultsItemsSlugScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['QuerySourcesOauthListOneOf_0ResultsItemsSlug'], any> {
  name: 'QuerySourcesOauthListOneOf_0ResultsItemsSlug';
}

export interface QuerySourcesOauthListOneOf_0ResultsItemsRequestTokenUrlScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['QuerySourcesOauthListOneOf_0ResultsItemsRequestTokenUrl'], any> {
  name: 'QuerySourcesOauthListOneOf_0ResultsItemsRequestTokenUrl';
}

export interface QuerySourcesOauthListOneOf_0ResultsItemsAuthorizationUrlScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['QuerySourcesOauthListOneOf_0ResultsItemsAuthorizationUrl'], any> {
  name: 'QuerySourcesOauthListOneOf_0ResultsItemsAuthorizationUrl';
}

export interface QuerySourcesOauthListOneOf_0ResultsItemsAccessTokenUrlScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['QuerySourcesOauthListOneOf_0ResultsItemsAccessTokenUrl'], any> {
  name: 'QuerySourcesOauthListOneOf_0ResultsItemsAccessTokenUrl';
}

export interface QuerySourcesOauthListOneOf_0ResultsItemsProfileUrlScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['QuerySourcesOauthListOneOf_0ResultsItemsProfileUrl'], any> {
  name: 'QuerySourcesOauthListOneOf_0ResultsItemsProfileUrl';
}

export type SourceTypeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourceType'] = ResolversParentTypes['SourceType']> = ResolversObject<{
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  urlsCustomizable?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  requestTokenUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  authorizationUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  accessTokenUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  profileUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  oidcWellKnownUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  oidcJwksUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  additionalProperties?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SourcesOauthRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesOauthRetrieveResponse'] = ResolversParentTypes['SourcesOauthRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'OAuthSource' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesOauthUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesOauthUsedByListResponse'] = ResolversParentTypes['SourcesOauthUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesOauthSourceTypesListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesOauthSourceTypesListResponse'] = ResolversParentTypes['SourcesOauthSourceTypesListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'SourceType' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesPlexListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesPlexListResponse'] = ResolversParentTypes['SourcesPlexListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedPlexSourceList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedPlexSourceListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedPlexSourceList'] = ResolversParentTypes['PaginatedPlexSourceList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['PlexSource']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PlexSourceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PlexSource'] = ResolversParentTypes['PlexSource']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['QuerySourcesPlexListOneOf_0ResultsItemsSlug'], ParentType, ContextType>;
  enabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  authenticationFlow?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  enrollmentFlow?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  policyEngineMode?: Resolver<Maybe<ResolversTypes['PolicyEngineMode']>, ParentType, ContextType>;
  userMatchingMode?: Resolver<Maybe<ResolversTypes['UserMatchingModeEnum']>, ParentType, ContextType>;
  managed?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userPathTemplate?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  icon?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  clientId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  allowedServers?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  allowFriends?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  plexToken?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface QuerySourcesPlexListOneOf_0ResultsItemsSlugScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['QuerySourcesPlexListOneOf_0ResultsItemsSlug'], any> {
  name: 'QuerySourcesPlexListOneOf_0ResultsItemsSlug';
}

export type SourcesPlexRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesPlexRetrieveResponse'] = ResolversParentTypes['SourcesPlexRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PlexSource' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesPlexUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesPlexUsedByListResponse'] = ResolversParentTypes['SourcesPlexUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesSamlListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesSamlListResponse'] = ResolversParentTypes['SourcesSamlListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedSamlSourceList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedSamlSourceListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedSamlSourceList'] = ResolversParentTypes['PaginatedSamlSourceList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['SamlSource']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SamlSourceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SamlSource'] = ResolversParentTypes['SamlSource']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['QuerySourcesSamlListOneOf_0ResultsItemsSlug'], ParentType, ContextType>;
  enabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  authenticationFlow?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  enrollmentFlow?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  policyEngineMode?: Resolver<Maybe<ResolversTypes['PolicyEngineMode']>, ParentType, ContextType>;
  userMatchingMode?: Resolver<Maybe<ResolversTypes['UserMatchingModeEnum']>, ParentType, ContextType>;
  managed?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userPathTemplate?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  icon?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  preAuthenticationFlow?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  issuer?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ssoUrl?: Resolver<ResolversTypes['URL'], ParentType, ContextType>;
  sloUrl?: Resolver<Maybe<ResolversTypes['URL']>, ParentType, ContextType>;
  allowIdpInitiated?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  nameIdPolicy?: Resolver<Maybe<ResolversTypes['NameIdPolicyEnum']>, ParentType, ContextType>;
  bindingType?: Resolver<Maybe<ResolversTypes['BindingTypeEnum']>, ParentType, ContextType>;
  verificationKp?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  signingKp?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  digestAlgorithm?: Resolver<Maybe<ResolversTypes['DigestAlgorithmEnum']>, ParentType, ContextType>;
  signatureAlgorithm?: Resolver<Maybe<ResolversTypes['SignatureAlgorithmEnum']>, ParentType, ContextType>;
  temporaryUserDeleteAfter?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface QuerySourcesSamlListOneOf_0ResultsItemsSlugScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['QuerySourcesSamlListOneOf_0ResultsItemsSlug'], any> {
  name: 'QuerySourcesSamlListOneOf_0ResultsItemsSlug';
}

export type SourcesSamlRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesSamlRetrieveResponse'] = ResolversParentTypes['SourcesSamlRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'SamlSource' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesSamlMetadataRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesSamlMetadataRetrieveResponse'] = ResolversParentTypes['SourcesSamlMetadataRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'SamlMetadata' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesSamlUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesSamlUsedByListResponse'] = ResolversParentTypes['SourcesSamlUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesScimListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesScimListResponse'] = ResolversParentTypes['SourcesScimListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedScimSourceList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedScimSourceListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedScimSourceList'] = ResolversParentTypes['PaginatedScimSourceList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['ScimSource']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ScimSourceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ScimSource'] = ResolversParentTypes['ScimSource']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['QuerySourcesScimListOneOf_0ResultsItemsSlug'], ParentType, ContextType>;
  enabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  userMatchingMode?: Resolver<Maybe<ResolversTypes['UserMatchingModeEnum']>, ParentType, ContextType>;
  managed?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userPathTemplate?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  rootUrl?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  tokenObj?: Resolver<ResolversTypes['Token'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface QuerySourcesScimListOneOf_0ResultsItemsSlugScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['QuerySourcesScimListOneOf_0ResultsItemsSlug'], any> {
  name: 'QuerySourcesScimListOneOf_0ResultsItemsSlug';
}

export type SourcesScimRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesScimRetrieveResponse'] = ResolversParentTypes['SourcesScimRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ScimSource' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesScimUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesScimUsedByListResponse'] = ResolversParentTypes['SourcesScimUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesScimGroupsListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesScimGroupsListResponse'] = ResolversParentTypes['SourcesScimGroupsListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedScimSourceGroupList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedScimSourceGroupListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedScimSourceGroupList'] = ResolversParentTypes['PaginatedScimSourceGroupList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['ScimSourceGroup']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ScimSourceGroupResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ScimSourceGroup'] = ResolversParentTypes['ScimSourceGroup']> = ResolversObject<{
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  group?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  groupObj?: Resolver<ResolversTypes['UserGroup'], ParentType, ContextType>;
  source?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  attributes?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SourcesScimGroupsRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesScimGroupsRetrieveResponse'] = ResolversParentTypes['SourcesScimGroupsRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ScimSourceGroup' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesScimGroupsUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesScimGroupsUsedByListResponse'] = ResolversParentTypes['SourcesScimGroupsUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesScimUsersListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesScimUsersListResponse'] = ResolversParentTypes['SourcesScimUsersListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedScimSourceUserList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedScimSourceUserListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedScimSourceUserList'] = ResolversParentTypes['PaginatedScimSourceUserList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['ScimSourceUser']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ScimSourceUserResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ScimSourceUser'] = ResolversParentTypes['ScimSourceUser']> = ResolversObject<{
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  userObj?: Resolver<ResolversTypes['GroupMember'], ParentType, ContextType>;
  source?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  attributes?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SourcesScimUsersRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesScimUsersRetrieveResponse'] = ResolversParentTypes['SourcesScimUsersRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ScimSourceUser' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesScimUsersUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesScimUsersUsedByListResponse'] = ResolversParentTypes['SourcesScimUsersUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesUserConnectionsAllListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesUserConnectionsAllListResponse'] = ResolversParentTypes['SourcesUserConnectionsAllListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedUserSourceConnectionList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedUserSourceConnectionListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedUserSourceConnectionList'] = ResolversParentTypes['PaginatedUserSourceConnectionList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['UserSourceConnection']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserSourceConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UserSourceConnection'] = ResolversParentTypes['UserSourceConnection']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  source?: Resolver<ResolversTypes['Source'], ParentType, ContextType>;
  created?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SourcesUserConnectionsAllRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesUserConnectionsAllRetrieveResponse'] = ResolversParentTypes['SourcesUserConnectionsAllRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UserSourceConnection' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesUserConnectionsAllUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesUserConnectionsAllUsedByListResponse'] = ResolversParentTypes['SourcesUserConnectionsAllUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesUserConnectionsOauthListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesUserConnectionsOauthListResponse'] = ResolversParentTypes['SourcesUserConnectionsOauthListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedUserOAuthSourceConnectionList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedUserOAuthSourceConnectionListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedUserOAuthSourceConnectionList'] = ResolversParentTypes['PaginatedUserOAuthSourceConnectionList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['UserOAuthSourceConnection']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserOAuthSourceConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UserOAuthSourceConnection'] = ResolversParentTypes['UserOAuthSourceConnection']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  source?: Resolver<ResolversTypes['Source'], ParentType, ContextType>;
  identifier?: Resolver<ResolversTypes['QuerySourcesUserConnectionsOauthListOneOf_0ResultsItemsIdentifier'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface QuerySourcesUserConnectionsOauthListOneOf_0ResultsItemsIdentifierScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['QuerySourcesUserConnectionsOauthListOneOf_0ResultsItemsIdentifier'], any> {
  name: 'QuerySourcesUserConnectionsOauthListOneOf_0ResultsItemsIdentifier';
}

export type SourcesUserConnectionsOauthRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesUserConnectionsOauthRetrieveResponse'] = ResolversParentTypes['SourcesUserConnectionsOauthRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UserOAuthSourceConnection' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesUserConnectionsOauthUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesUserConnectionsOauthUsedByListResponse'] = ResolversParentTypes['SourcesUserConnectionsOauthUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesUserConnectionsPlexListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesUserConnectionsPlexListResponse'] = ResolversParentTypes['SourcesUserConnectionsPlexListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedPlexSourceConnectionList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedPlexSourceConnectionListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedPlexSourceConnectionList'] = ResolversParentTypes['PaginatedPlexSourceConnectionList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['PlexSourceConnection']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PlexSourceConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PlexSourceConnection'] = ResolversParentTypes['PlexSourceConnection']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  source?: Resolver<ResolversTypes['Source'], ParentType, ContextType>;
  identifier?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  plexToken?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SourcesUserConnectionsPlexRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesUserConnectionsPlexRetrieveResponse'] = ResolversParentTypes['SourcesUserConnectionsPlexRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PlexSourceConnection' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesUserConnectionsPlexUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesUserConnectionsPlexUsedByListResponse'] = ResolversParentTypes['SourcesUserConnectionsPlexUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesUserConnectionsSamlListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesUserConnectionsSamlListResponse'] = ResolversParentTypes['SourcesUserConnectionsSamlListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedUserSamlSourceConnectionList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedUserSamlSourceConnectionListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedUserSamlSourceConnectionList'] = ResolversParentTypes['PaginatedUserSamlSourceConnectionList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['UserSamlSourceConnection']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserSamlSourceConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UserSamlSourceConnection'] = ResolversParentTypes['UserSamlSourceConnection']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  source?: Resolver<ResolversTypes['Source'], ParentType, ContextType>;
  identifier?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SourcesUserConnectionsSamlRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesUserConnectionsSamlRetrieveResponse'] = ResolversParentTypes['SourcesUserConnectionsSamlRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UserSamlSourceConnection' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesUserConnectionsSamlUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesUserConnectionsSamlUsedByListResponse'] = ResolversParentTypes['SourcesUserConnectionsSamlUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAllListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAllListResponse'] = ResolversParentTypes['StagesAllListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedStageList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedStageListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedStageList'] = ResolversParentTypes['PaginatedStageList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['Stage']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StagesAllRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAllRetrieveResponse'] = ResolversParentTypes['StagesAllRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Stage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAllUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAllUsedByListResponse'] = ResolversParentTypes['StagesAllUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAllTypesListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAllTypesListResponse'] = ResolversParentTypes['StagesAllTypesListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'TypeCreate' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAllUserSettingsListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAllUserSettingsListResponse'] = ResolversParentTypes['StagesAllUserSettingsListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UserSetting' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAuthenticatorDuoListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorDuoListResponse'] = ResolversParentTypes['StagesAuthenticatorDuoListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedAuthenticatorDuoStageList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedAuthenticatorDuoStageListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedAuthenticatorDuoStageList'] = ResolversParentTypes['PaginatedAuthenticatorDuoStageList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['AuthenticatorDuoStage']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AuthenticatorDuoStageResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorDuoStage'] = ResolversParentTypes['AuthenticatorDuoStage']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  flowSet?: Resolver<Maybe<Array<Maybe<ResolversTypes['FlowSet']>>>, ParentType, ContextType>;
  configureFlow?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  friendlyName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  clientId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  apiHostname?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  adminIntegrationKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StagesAuthenticatorDuoRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorDuoRetrieveResponse'] = ResolversParentTypes['StagesAuthenticatorDuoRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'AuthenticatorDuoStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAuthenticatorDuoUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorDuoUsedByListResponse'] = ResolversParentTypes['StagesAuthenticatorDuoUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAuthenticatorSmsListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorSmsListResponse'] = ResolversParentTypes['StagesAuthenticatorSmsListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedAuthenticatorSmsStageList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedAuthenticatorSmsStageListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedAuthenticatorSmsStageList'] = ResolversParentTypes['PaginatedAuthenticatorSmsStageList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['AuthenticatorSmsStage']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AuthenticatorSmsStageResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorSmsStage'] = ResolversParentTypes['AuthenticatorSmsStage']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  flowSet?: Resolver<Maybe<Array<Maybe<ResolversTypes['FlowSet']>>>, ParentType, ContextType>;
  configureFlow?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  friendlyName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  provider?: Resolver<ResolversTypes['ProviderEnum'], ParentType, ContextType>;
  fromNumber?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  accountSid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  auth?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  authPassword?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  authType?: Resolver<Maybe<ResolversTypes['AuthTypeEnum']>, ParentType, ContextType>;
  verifyOnly?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  mapping?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StagesAuthenticatorSmsRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorSmsRetrieveResponse'] = ResolversParentTypes['StagesAuthenticatorSmsRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'AuthenticatorSmsStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAuthenticatorSmsUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorSmsUsedByListResponse'] = ResolversParentTypes['StagesAuthenticatorSmsUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAuthenticatorStaticListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorStaticListResponse'] = ResolversParentTypes['StagesAuthenticatorStaticListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedAuthenticatorStaticStageList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedAuthenticatorStaticStageListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedAuthenticatorStaticStageList'] = ResolversParentTypes['PaginatedAuthenticatorStaticStageList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['AuthenticatorStaticStage']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AuthenticatorStaticStageResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorStaticStage'] = ResolversParentTypes['AuthenticatorStaticStage']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  flowSet?: Resolver<Maybe<Array<Maybe<ResolversTypes['FlowSet']>>>, ParentType, ContextType>;
  configureFlow?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  friendlyName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  tokenCount?: Resolver<Maybe<ResolversTypes['NonNegativeInt']>, ParentType, ContextType>;
  tokenLength?: Resolver<Maybe<ResolversTypes['NonNegativeInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StagesAuthenticatorStaticRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorStaticRetrieveResponse'] = ResolversParentTypes['StagesAuthenticatorStaticRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'AuthenticatorStaticStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAuthenticatorStaticUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorStaticUsedByListResponse'] = ResolversParentTypes['StagesAuthenticatorStaticUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAuthenticatorTotpListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorTotpListResponse'] = ResolversParentTypes['StagesAuthenticatorTotpListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedAuthenticatorTotpStageList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedAuthenticatorTotpStageListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedAuthenticatorTotpStageList'] = ResolversParentTypes['PaginatedAuthenticatorTotpStageList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['AuthenticatorTotpStage']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AuthenticatorTotpStageResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorTotpStage'] = ResolversParentTypes['AuthenticatorTotpStage']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  flowSet?: Resolver<Maybe<Array<Maybe<ResolversTypes['FlowSet']>>>, ParentType, ContextType>;
  configureFlow?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  friendlyName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  digits?: Resolver<ResolversTypes['DigitsEnum'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StagesAuthenticatorTotpRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorTotpRetrieveResponse'] = ResolversParentTypes['StagesAuthenticatorTotpRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'AuthenticatorTotpStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAuthenticatorTotpUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorTotpUsedByListResponse'] = ResolversParentTypes['StagesAuthenticatorTotpUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAuthenticatorValidateListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorValidateListResponse'] = ResolversParentTypes['StagesAuthenticatorValidateListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedAuthenticatorValidateStageList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedAuthenticatorValidateStageListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedAuthenticatorValidateStageList'] = ResolversParentTypes['PaginatedAuthenticatorValidateStageList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['AuthenticatorValidateStage']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AuthenticatorValidateStageResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorValidateStage'] = ResolversParentTypes['AuthenticatorValidateStage']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  flowSet?: Resolver<Maybe<Array<Maybe<ResolversTypes['FlowSet']>>>, ParentType, ContextType>;
  notConfiguredAction?: Resolver<Maybe<ResolversTypes['NotConfiguredActionEnum']>, ParentType, ContextType>;
  deviceClasses?: Resolver<Maybe<Array<Maybe<ResolversTypes['DeviceClassesEnum']>>>, ParentType, ContextType>;
  configurationStages?: Resolver<Maybe<Array<Maybe<ResolversTypes['UUID']>>>, ParentType, ContextType>;
  lastAuthThreshold?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  webauthnUserVerification?: Resolver<Maybe<ResolversTypes['UserVerificationEnum']>, ParentType, ContextType>;
  webauthnAllowedDeviceTypes?: Resolver<Maybe<Array<Maybe<ResolversTypes['UUID']>>>, ParentType, ContextType>;
  webauthnAllowedDeviceTypesObj?: Resolver<Array<Maybe<ResolversTypes['WebAuthnDeviceType']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StagesAuthenticatorValidateRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorValidateRetrieveResponse'] = ResolversParentTypes['StagesAuthenticatorValidateRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'AuthenticatorValidateStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAuthenticatorValidateUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorValidateUsedByListResponse'] = ResolversParentTypes['StagesAuthenticatorValidateUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAuthenticatorWebauthnListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorWebauthnListResponse'] = ResolversParentTypes['StagesAuthenticatorWebauthnListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedAuthenticatorWebAuthnStageList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedAuthenticatorWebAuthnStageListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedAuthenticatorWebAuthnStageList'] = ResolversParentTypes['PaginatedAuthenticatorWebAuthnStageList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['AuthenticatorWebAuthnStage']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AuthenticatorWebAuthnStageResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorWebAuthnStage'] = ResolversParentTypes['AuthenticatorWebAuthnStage']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  flowSet?: Resolver<Maybe<Array<Maybe<ResolversTypes['FlowSet']>>>, ParentType, ContextType>;
  configureFlow?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  friendlyName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userVerification?: Resolver<Maybe<ResolversTypes['UserVerificationEnum']>, ParentType, ContextType>;
  authenticatorAttachment?: Resolver<Maybe<ResolversTypes['AuthenticatorAttachmentEnum']>, ParentType, ContextType>;
  residentKeyRequirement?: Resolver<Maybe<ResolversTypes['ResidentKeyRequirementEnum']>, ParentType, ContextType>;
  deviceTypeRestrictions?: Resolver<Maybe<Array<Maybe<ResolversTypes['UUID']>>>, ParentType, ContextType>;
  deviceTypeRestrictionsObj?: Resolver<Array<Maybe<ResolversTypes['WebAuthnDeviceType']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StagesAuthenticatorWebauthnRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorWebauthnRetrieveResponse'] = ResolversParentTypes['StagesAuthenticatorWebauthnRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'AuthenticatorWebAuthnStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAuthenticatorWebauthnUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorWebauthnUsedByListResponse'] = ResolversParentTypes['StagesAuthenticatorWebauthnUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAuthenticatorWebauthnDeviceTypesListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorWebauthnDeviceTypesListResponse'] = ResolversParentTypes['StagesAuthenticatorWebauthnDeviceTypesListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedWebAuthnDeviceTypeList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedWebAuthnDeviceTypeListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedWebAuthnDeviceTypeList'] = ResolversParentTypes['PaginatedWebAuthnDeviceTypeList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['WebAuthnDeviceType']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StagesAuthenticatorWebauthnDeviceTypesRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorWebauthnDeviceTypesRetrieveResponse'] = ResolversParentTypes['StagesAuthenticatorWebauthnDeviceTypesRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'WebAuthnDeviceType' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesCaptchaListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesCaptchaListResponse'] = ResolversParentTypes['StagesCaptchaListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedCaptchaStageList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedCaptchaStageListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedCaptchaStageList'] = ResolversParentTypes['PaginatedCaptchaStageList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['CaptchaStage']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CaptchaStageResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CaptchaStage'] = ResolversParentTypes['CaptchaStage']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  flowSet?: Resolver<Maybe<Array<Maybe<ResolversTypes['FlowSet']>>>, ParentType, ContextType>;
  publicKey?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  jsUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  apiUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StagesCaptchaRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesCaptchaRetrieveResponse'] = ResolversParentTypes['StagesCaptchaRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'CaptchaStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesCaptchaUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesCaptchaUsedByListResponse'] = ResolversParentTypes['StagesCaptchaUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesConsentListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesConsentListResponse'] = ResolversParentTypes['StagesConsentListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedConsentStageList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedConsentStageListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedConsentStageList'] = ResolversParentTypes['PaginatedConsentStageList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['ConsentStage']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ConsentStageResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ConsentStage'] = ResolversParentTypes['ConsentStage']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  flowSet?: Resolver<Maybe<Array<Maybe<ResolversTypes['FlowSet']>>>, ParentType, ContextType>;
  mode?: Resolver<Maybe<ResolversTypes['ConsentStageModeEnum']>, ParentType, ContextType>;
  consentExpireIn?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StagesConsentRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesConsentRetrieveResponse'] = ResolversParentTypes['StagesConsentRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ConsentStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesConsentUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesConsentUsedByListResponse'] = ResolversParentTypes['StagesConsentUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesDenyListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesDenyListResponse'] = ResolversParentTypes['StagesDenyListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedDenyStageList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedDenyStageListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedDenyStageList'] = ResolversParentTypes['PaginatedDenyStageList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['DenyStage']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DenyStageResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DenyStage'] = ResolversParentTypes['DenyStage']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  flowSet?: Resolver<Maybe<Array<Maybe<ResolversTypes['FlowSet']>>>, ParentType, ContextType>;
  denyMessage?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StagesDenyRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesDenyRetrieveResponse'] = ResolversParentTypes['StagesDenyRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'DenyStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesDenyUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesDenyUsedByListResponse'] = ResolversParentTypes['StagesDenyUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesDummyListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesDummyListResponse'] = ResolversParentTypes['StagesDummyListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedDummyStageList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedDummyStageListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedDummyStageList'] = ResolversParentTypes['PaginatedDummyStageList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['DummyStage']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DummyStageResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DummyStage'] = ResolversParentTypes['DummyStage']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  flowSet?: Resolver<Maybe<Array<Maybe<ResolversTypes['FlowSet']>>>, ParentType, ContextType>;
  throwError?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StagesDummyRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesDummyRetrieveResponse'] = ResolversParentTypes['StagesDummyRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'DummyStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesDummyUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesDummyUsedByListResponse'] = ResolversParentTypes['StagesDummyUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesEmailListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesEmailListResponse'] = ResolversParentTypes['StagesEmailListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedEmailStageList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedEmailStageListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedEmailStageList'] = ResolversParentTypes['PaginatedEmailStageList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['EmailStage']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EmailStageResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EmailStage'] = ResolversParentTypes['EmailStage']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  flowSet?: Resolver<Maybe<Array<Maybe<ResolversTypes['FlowSet']>>>, ParentType, ContextType>;
  useGlobalSettings?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  host?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  port?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  username?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  useTls?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  useSsl?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  timeout?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  fromAddress?: Resolver<Maybe<ResolversTypes['EmailAddress']>, ParentType, ContextType>;
  tokenExpiry?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  subject?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  activateUserOnSuccess?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StagesEmailRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesEmailRetrieveResponse'] = ResolversParentTypes['StagesEmailRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'EmailStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesEmailUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesEmailUsedByListResponse'] = ResolversParentTypes['StagesEmailUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesEmailTemplatesListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesEmailTemplatesListResponse'] = ResolversParentTypes['StagesEmailTemplatesListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'TypeCreate' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesIdentificationListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesIdentificationListResponse'] = ResolversParentTypes['StagesIdentificationListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedIdentificationStageList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedIdentificationStageListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedIdentificationStageList'] = ResolversParentTypes['PaginatedIdentificationStageList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['IdentificationStage']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IdentificationStageResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['IdentificationStage'] = ResolversParentTypes['IdentificationStage']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  flowSet?: Resolver<Maybe<Array<Maybe<ResolversTypes['FlowSet']>>>, ParentType, ContextType>;
  userFields?: Resolver<Maybe<Array<Maybe<ResolversTypes['UserFieldsEnum']>>>, ParentType, ContextType>;
  passwordStage?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  caseInsensitiveMatching?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  showMatchedUser?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  enrollmentFlow?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  recoveryFlow?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  passwordlessFlow?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  sources?: Resolver<Maybe<Array<Maybe<ResolversTypes['UUID']>>>, ParentType, ContextType>;
  showSourceLabels?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  pretendUserExists?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StagesIdentificationRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesIdentificationRetrieveResponse'] = ResolversParentTypes['StagesIdentificationRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'IdentificationStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesIdentificationUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesIdentificationUsedByListResponse'] = ResolversParentTypes['StagesIdentificationUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesInvitationInvitationsListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesInvitationInvitationsListResponse'] = ResolversParentTypes['StagesInvitationInvitationsListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedInvitationList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedInvitationListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedInvitationList'] = ResolversParentTypes['PaginatedInvitationList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['Invitation']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type InvitationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Invitation'] = ResolversParentTypes['Invitation']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['QueryStagesInvitationInvitationsListOneOf_0ResultsItemsName'], ParentType, ContextType>;
  expires?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  fixedData?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  createdBy?: Resolver<ResolversTypes['GroupMember'], ParentType, ContextType>;
  singleUse?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  flow?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  flowObj?: Resolver<ResolversTypes['Flow'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface QueryStagesInvitationInvitationsListOneOf_0ResultsItemsNameScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['QueryStagesInvitationInvitationsListOneOf_0ResultsItemsName'], any> {
  name: 'QueryStagesInvitationInvitationsListOneOf_0ResultsItemsName';
}

export type StagesInvitationInvitationsRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesInvitationInvitationsRetrieveResponse'] = ResolversParentTypes['StagesInvitationInvitationsRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Invitation' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesInvitationInvitationsUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesInvitationInvitationsUsedByListResponse'] = ResolversParentTypes['StagesInvitationInvitationsUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesInvitationStagesListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesInvitationStagesListResponse'] = ResolversParentTypes['StagesInvitationStagesListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedInvitationStageList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedInvitationStageListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedInvitationStageList'] = ResolversParentTypes['PaginatedInvitationStageList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['InvitationStage']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type InvitationStageResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['InvitationStage'] = ResolversParentTypes['InvitationStage']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  flowSet?: Resolver<Maybe<Array<Maybe<ResolversTypes['FlowSet']>>>, ParentType, ContextType>;
  continueFlowWithoutInvitation?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StagesInvitationStagesRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesInvitationStagesRetrieveResponse'] = ResolversParentTypes['StagesInvitationStagesRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'InvitationStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesInvitationStagesUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesInvitationStagesUsedByListResponse'] = ResolversParentTypes['StagesInvitationStagesUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesPasswordListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesPasswordListResponse'] = ResolversParentTypes['StagesPasswordListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedPasswordStageList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedPasswordStageListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedPasswordStageList'] = ResolversParentTypes['PaginatedPasswordStageList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['PasswordStage']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PasswordStageResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PasswordStage'] = ResolversParentTypes['PasswordStage']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  flowSet?: Resolver<Maybe<Array<Maybe<ResolversTypes['FlowSet']>>>, ParentType, ContextType>;
  backends?: Resolver<Array<Maybe<ResolversTypes['BackendsEnum']>>, ParentType, ContextType>;
  configureFlow?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  failedAttemptsBeforeCancel?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StagesPasswordRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesPasswordRetrieveResponse'] = ResolversParentTypes['StagesPasswordRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PasswordStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesPasswordUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesPasswordUsedByListResponse'] = ResolversParentTypes['StagesPasswordUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesPromptPromptsListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesPromptPromptsListResponse'] = ResolversParentTypes['StagesPromptPromptsListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedPromptList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedPromptListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedPromptList'] = ResolversParentTypes['PaginatedPromptList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['Prompt']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PromptResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Prompt'] = ResolversParentTypes['Prompt']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  fieldKey?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['PromptTypeEnum'], ParentType, ContextType>;
  required?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  placeholder?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  initialValue?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  promptstageSet?: Resolver<Maybe<Array<Maybe<ResolversTypes['Stage']>>>, ParentType, ContextType>;
  subText?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  placeholderExpression?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  initialValueExpression?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StagesPromptPromptsRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesPromptPromptsRetrieveResponse'] = ResolversParentTypes['StagesPromptPromptsRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Prompt' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesPromptPromptsUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesPromptPromptsUsedByListResponse'] = ResolversParentTypes['StagesPromptPromptsUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesPromptStagesListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesPromptStagesListResponse'] = ResolversParentTypes['StagesPromptStagesListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedPromptStageList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedPromptStageListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedPromptStageList'] = ResolversParentTypes['PaginatedPromptStageList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['PromptStage']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PromptStageResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PromptStage'] = ResolversParentTypes['PromptStage']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  flowSet?: Resolver<Maybe<Array<Maybe<ResolversTypes['FlowSet']>>>, ParentType, ContextType>;
  fields?: Resolver<Array<Maybe<ResolversTypes['UUID']>>, ParentType, ContextType>;
  validationPolicies?: Resolver<Maybe<Array<Maybe<ResolversTypes['UUID']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StagesPromptStagesRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesPromptStagesRetrieveResponse'] = ResolversParentTypes['StagesPromptStagesRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PromptStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesPromptStagesUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesPromptStagesUsedByListResponse'] = ResolversParentTypes['StagesPromptStagesUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesSourceListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesSourceListResponse'] = ResolversParentTypes['StagesSourceListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedSourceStageList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedSourceStageListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedSourceStageList'] = ResolversParentTypes['PaginatedSourceStageList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['SourceStage']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SourceStageResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourceStage'] = ResolversParentTypes['SourceStage']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  flowSet?: Resolver<Maybe<Array<Maybe<ResolversTypes['FlowSet']>>>, ParentType, ContextType>;
  source?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  resumeTimeout?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StagesSourceRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesSourceRetrieveResponse'] = ResolversParentTypes['StagesSourceRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'SourceStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesSourceUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesSourceUsedByListResponse'] = ResolversParentTypes['StagesSourceUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesUserDeleteListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesUserDeleteListResponse'] = ResolversParentTypes['StagesUserDeleteListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedUserDeleteStageList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedUserDeleteStageListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedUserDeleteStageList'] = ResolversParentTypes['PaginatedUserDeleteStageList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['UserDeleteStage']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserDeleteStageResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UserDeleteStage'] = ResolversParentTypes['UserDeleteStage']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  flowSet?: Resolver<Maybe<Array<Maybe<ResolversTypes['FlowSet']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StagesUserDeleteRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesUserDeleteRetrieveResponse'] = ResolversParentTypes['StagesUserDeleteRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UserDeleteStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesUserDeleteUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesUserDeleteUsedByListResponse'] = ResolversParentTypes['StagesUserDeleteUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesUserLoginListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesUserLoginListResponse'] = ResolversParentTypes['StagesUserLoginListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedUserLoginStageList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedUserLoginStageListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedUserLoginStageList'] = ResolversParentTypes['PaginatedUserLoginStageList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['UserLoginStage']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserLoginStageResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UserLoginStage'] = ResolversParentTypes['UserLoginStage']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  flowSet?: Resolver<Maybe<Array<Maybe<ResolversTypes['FlowSet']>>>, ParentType, ContextType>;
  sessionDuration?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  terminateOtherSessions?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  rememberMeOffset?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  networkBinding?: Resolver<Maybe<ResolversTypes['NetworkBindingEnum']>, ParentType, ContextType>;
  geoipBinding?: Resolver<Maybe<ResolversTypes['GeoipBindingEnum']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StagesUserLoginRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesUserLoginRetrieveResponse'] = ResolversParentTypes['StagesUserLoginRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UserLoginStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesUserLoginUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesUserLoginUsedByListResponse'] = ResolversParentTypes['StagesUserLoginUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesUserLogoutListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesUserLogoutListResponse'] = ResolversParentTypes['StagesUserLogoutListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedUserLogoutStageList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedUserLogoutStageListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedUserLogoutStageList'] = ResolversParentTypes['PaginatedUserLogoutStageList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['UserLogoutStage']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserLogoutStageResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UserLogoutStage'] = ResolversParentTypes['UserLogoutStage']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  flowSet?: Resolver<Maybe<Array<Maybe<ResolversTypes['FlowSet']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StagesUserLogoutRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesUserLogoutRetrieveResponse'] = ResolversParentTypes['StagesUserLogoutRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UserLogoutStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesUserLogoutUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesUserLogoutUsedByListResponse'] = ResolversParentTypes['StagesUserLogoutUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesUserWriteListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesUserWriteListResponse'] = ResolversParentTypes['StagesUserWriteListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PaginatedUserWriteStageList' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PaginatedUserWriteStageListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaginatedUserWriteStageList'] = ResolversParentTypes['PaginatedUserWriteStageList']> = ResolversObject<{
  pagination?: Resolver<ResolversTypes['Pagination'], ParentType, ContextType>;
  results?: Resolver<Array<Maybe<ResolversTypes['UserWriteStage']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserWriteStageResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UserWriteStage'] = ResolversParentTypes['UserWriteStage']> = ResolversObject<{
  pk?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  component?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verboseNamePlural?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metaModelName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  flowSet?: Resolver<Maybe<Array<Maybe<ResolversTypes['FlowSet']>>>, ParentType, ContextType>;
  userCreationMode?: Resolver<Maybe<ResolversTypes['UserCreationModeEnum']>, ParentType, ContextType>;
  createUsersAsInactive?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  createUsersGroup?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  userType?: Resolver<Maybe<ResolversTypes['UserTypeEnum']>, ParentType, ContextType>;
  userPathTemplate?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StagesUserWriteRetrieveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesUserWriteRetrieveResponse'] = ResolversParentTypes['StagesUserWriteRetrieveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UserWriteStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesUserWriteUsedByListResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesUserWriteUsedByListResponse'] = ResolversParentTypes['StagesUserWriteUsedByListResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UsedBy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AdminSettingsUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AdminSettingsUpdateResponse'] = ResolversParentTypes['AdminSettingsUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Settings' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export interface NonEmptyStringScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['NonEmptyString'], any> {
  name: 'NonEmptyString';
}

export type AdminSettingsPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AdminSettingsPartialUpdateResponse'] = ResolversParentTypes['AdminSettingsPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Settings' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AdminSystemCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AdminSystemCreateResponse'] = ResolversParentTypes['AdminSystemCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'SystemInfo' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsAdminDuoCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsAdminDuoCreateResponse'] = ResolversParentTypes['AuthenticatorsAdminDuoCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'DuoDevice' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export interface MutationInputAuthenticatorsAdminDuoCreateInputNameScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputAuthenticatorsAdminDuoCreateInputName'], any> {
  name: 'MutationInputAuthenticatorsAdminDuoCreateInputName';
}

export type AuthenticatorsAdminDuoUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsAdminDuoUpdateResponse'] = ResolversParentTypes['AuthenticatorsAdminDuoUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'DuoDevice' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsAdminDuoPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsAdminDuoPartialUpdateResponse'] = ResolversParentTypes['AuthenticatorsAdminDuoPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'DuoDevice' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export interface MutationInputAuthenticatorsAdminDuoPartialUpdateInputNameScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputAuthenticatorsAdminDuoPartialUpdateInputName'], any> {
  name: 'MutationInputAuthenticatorsAdminDuoPartialUpdateInputName';
}

export type AuthenticatorsAdminDuoDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsAdminDuoDestroyResponse'] = ResolversParentTypes['AuthenticatorsAdminDuoDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsAdminSmsCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsAdminSmsCreateResponse'] = ResolversParentTypes['AuthenticatorsAdminSmsCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'SmsDevice' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export interface MutationInputAuthenticatorsAdminSmsCreateInputNameScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputAuthenticatorsAdminSmsCreateInputName'], any> {
  name: 'MutationInputAuthenticatorsAdminSmsCreateInputName';
}

export type AuthenticatorsAdminSmsUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsAdminSmsUpdateResponse'] = ResolversParentTypes['AuthenticatorsAdminSmsUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'SmsDevice' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsAdminSmsPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsAdminSmsPartialUpdateResponse'] = ResolversParentTypes['AuthenticatorsAdminSmsPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'SmsDevice' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export interface MutationInputAuthenticatorsAdminSmsPartialUpdateInputNameScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputAuthenticatorsAdminSmsPartialUpdateInputName'], any> {
  name: 'MutationInputAuthenticatorsAdminSmsPartialUpdateInputName';
}

export type AuthenticatorsAdminSmsDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsAdminSmsDestroyResponse'] = ResolversParentTypes['AuthenticatorsAdminSmsDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsAdminStaticCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsAdminStaticCreateResponse'] = ResolversParentTypes['AuthenticatorsAdminStaticCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'StaticDevice' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export interface MutationInputAuthenticatorsAdminStaticCreateInputNameScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputAuthenticatorsAdminStaticCreateInputName'], any> {
  name: 'MutationInputAuthenticatorsAdminStaticCreateInputName';
}

export type AuthenticatorsAdminStaticUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsAdminStaticUpdateResponse'] = ResolversParentTypes['AuthenticatorsAdminStaticUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'StaticDevice' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsAdminStaticPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsAdminStaticPartialUpdateResponse'] = ResolversParentTypes['AuthenticatorsAdminStaticPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'StaticDevice' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export interface MutationInputAuthenticatorsAdminStaticPartialUpdateInputNameScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputAuthenticatorsAdminStaticPartialUpdateInputName'], any> {
  name: 'MutationInputAuthenticatorsAdminStaticPartialUpdateInputName';
}

export type AuthenticatorsAdminStaticDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsAdminStaticDestroyResponse'] = ResolversParentTypes['AuthenticatorsAdminStaticDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsAdminTotpCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsAdminTotpCreateResponse'] = ResolversParentTypes['AuthenticatorsAdminTotpCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'TotpDevice' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export interface MutationInputAuthenticatorsAdminTotpCreateInputNameScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputAuthenticatorsAdminTotpCreateInputName'], any> {
  name: 'MutationInputAuthenticatorsAdminTotpCreateInputName';
}

export type AuthenticatorsAdminTotpUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsAdminTotpUpdateResponse'] = ResolversParentTypes['AuthenticatorsAdminTotpUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'TotpDevice' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsAdminTotpPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsAdminTotpPartialUpdateResponse'] = ResolversParentTypes['AuthenticatorsAdminTotpPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'TotpDevice' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export interface MutationInputAuthenticatorsAdminTotpPartialUpdateInputNameScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputAuthenticatorsAdminTotpPartialUpdateInputName'], any> {
  name: 'MutationInputAuthenticatorsAdminTotpPartialUpdateInputName';
}

export type AuthenticatorsAdminTotpDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsAdminTotpDestroyResponse'] = ResolversParentTypes['AuthenticatorsAdminTotpDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsAdminWebauthnCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsAdminWebauthnCreateResponse'] = ResolversParentTypes['AuthenticatorsAdminWebauthnCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'WebAuthnDevice' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export interface MutationInputAuthenticatorsAdminWebauthnCreateInputNameScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputAuthenticatorsAdminWebauthnCreateInputName'], any> {
  name: 'MutationInputAuthenticatorsAdminWebauthnCreateInputName';
}

export type AuthenticatorsAdminWebauthnUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsAdminWebauthnUpdateResponse'] = ResolversParentTypes['AuthenticatorsAdminWebauthnUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'WebAuthnDevice' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsAdminWebauthnPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsAdminWebauthnPartialUpdateResponse'] = ResolversParentTypes['AuthenticatorsAdminWebauthnPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'WebAuthnDevice' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export interface MutationInputAuthenticatorsAdminWebauthnPartialUpdateInputNameScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputAuthenticatorsAdminWebauthnPartialUpdateInputName'], any> {
  name: 'MutationInputAuthenticatorsAdminWebauthnPartialUpdateInputName';
}

export type AuthenticatorsAdminWebauthnDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsAdminWebauthnDestroyResponse'] = ResolversParentTypes['AuthenticatorsAdminWebauthnDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsDuoUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsDuoUpdateResponse'] = ResolversParentTypes['AuthenticatorsDuoUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'DuoDevice' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsDuoPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsDuoPartialUpdateResponse'] = ResolversParentTypes['AuthenticatorsDuoPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'DuoDevice' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsDuoDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsDuoDestroyResponse'] = ResolversParentTypes['AuthenticatorsDuoDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsSmsUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsSmsUpdateResponse'] = ResolversParentTypes['AuthenticatorsSmsUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'SmsDevice' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsSmsPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsSmsPartialUpdateResponse'] = ResolversParentTypes['AuthenticatorsSmsPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'SmsDevice' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsSmsDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsSmsDestroyResponse'] = ResolversParentTypes['AuthenticatorsSmsDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsStaticUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsStaticUpdateResponse'] = ResolversParentTypes['AuthenticatorsStaticUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'StaticDevice' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsStaticPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsStaticPartialUpdateResponse'] = ResolversParentTypes['AuthenticatorsStaticPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'StaticDevice' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsStaticDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsStaticDestroyResponse'] = ResolversParentTypes['AuthenticatorsStaticDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsTotpUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsTotpUpdateResponse'] = ResolversParentTypes['AuthenticatorsTotpUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'TotpDevice' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsTotpPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsTotpPartialUpdateResponse'] = ResolversParentTypes['AuthenticatorsTotpPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'TotpDevice' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsTotpDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsTotpDestroyResponse'] = ResolversParentTypes['AuthenticatorsTotpDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsWebauthnUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsWebauthnUpdateResponse'] = ResolversParentTypes['AuthenticatorsWebauthnUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'WebAuthnDevice' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsWebauthnPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsWebauthnPartialUpdateResponse'] = ResolversParentTypes['AuthenticatorsWebauthnPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'WebAuthnDevice' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorsWebauthnDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorsWebauthnDestroyResponse'] = ResolversParentTypes['AuthenticatorsWebauthnDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CoreApplicationsCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreApplicationsCreateResponse'] = ResolversParentTypes['CoreApplicationsCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Application' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export interface MutationInputCoreApplicationsCreateInputSlugScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputCoreApplicationsCreateInputSlug'], any> {
  name: 'MutationInputCoreApplicationsCreateInputSlug';
}

export type CoreApplicationsUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreApplicationsUpdateResponse'] = ResolversParentTypes['CoreApplicationsUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Application' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CoreApplicationsPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreApplicationsPartialUpdateResponse'] = ResolversParentTypes['CoreApplicationsPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Application' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export interface MutationInputCoreApplicationsPartialUpdateInputSlugScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputCoreApplicationsPartialUpdateInputSlug'], any> {
  name: 'MutationInputCoreApplicationsPartialUpdateInputSlug';
}

export type CoreApplicationsDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreApplicationsDestroyResponse'] = ResolversParentTypes['CoreApplicationsDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CoreAuthenticatedSessionsDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreAuthenticatedSessionsDestroyResponse'] = ResolversParentTypes['CoreAuthenticatedSessionsDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CoreBrandsCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreBrandsCreateResponse'] = ResolversParentTypes['CoreBrandsCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Brand' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CoreBrandsUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreBrandsUpdateResponse'] = ResolversParentTypes['CoreBrandsUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Brand' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CoreBrandsPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreBrandsPartialUpdateResponse'] = ResolversParentTypes['CoreBrandsPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Brand' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CoreBrandsDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreBrandsDestroyResponse'] = ResolversParentTypes['CoreBrandsDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CoreGroupsCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreGroupsCreateResponse'] = ResolversParentTypes['CoreGroupsCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Group' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export interface MutationInputCoreGroupsCreateInputNameScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputCoreGroupsCreateInputName'], any> {
  name: 'MutationInputCoreGroupsCreateInputName';
}

export type CoreGroupsUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreGroupsUpdateResponse'] = ResolversParentTypes['CoreGroupsUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Group' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CoreGroupsPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreGroupsPartialUpdateResponse'] = ResolversParentTypes['CoreGroupsPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Group' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export interface MutationInputCoreGroupsPartialUpdateInputNameScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputCoreGroupsPartialUpdateInputName'], any> {
  name: 'MutationInputCoreGroupsPartialUpdateInputName';
}

export type CoreGroupsDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreGroupsDestroyResponse'] = ResolversParentTypes['CoreGroupsDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CoreGroupsAddUserCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreGroupsAddUserCreateResponse'] = ResolversParentTypes['CoreGroupsAddUserCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CoreGroupsRemoveUserCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreGroupsRemoveUserCreateResponse'] = ResolversParentTypes['CoreGroupsRemoveUserCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CoreTokensCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreTokensCreateResponse'] = ResolversParentTypes['CoreTokensCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Token' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export interface MutationInputCoreTokensCreateInputIdentifierScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputCoreTokensCreateInputIdentifier'], any> {
  name: 'MutationInputCoreTokensCreateInputIdentifier';
}

export type CoreTokensUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreTokensUpdateResponse'] = ResolversParentTypes['CoreTokensUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Token' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CoreTokensPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreTokensPartialUpdateResponse'] = ResolversParentTypes['CoreTokensPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Token' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export interface MutationInputCoreTokensPartialUpdateInputIdentifierScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputCoreTokensPartialUpdateInputIdentifier'], any> {
  name: 'MutationInputCoreTokensPartialUpdateInputIdentifier';
}

export type CoreTokensDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreTokensDestroyResponse'] = ResolversParentTypes['CoreTokensDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CoreTokensSetKeyCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreTokensSetKeyCreateResponse'] = ResolversParentTypes['CoreTokensSetKeyCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'GenericError', ParentType, ContextType>;
}>;

export type CoreTransactionalApplicationsUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreTransactionalApplicationsUpdateResponse'] = ResolversParentTypes['CoreTransactionalApplicationsUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'TransactionApplicationResponse' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type TransactionApplicationResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TransactionApplicationResponse'] = ResolversParentTypes['TransactionApplicationResponse']> = ResolversObject<{
  applied?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  logs?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface MutationInputCoreTransactionalApplicationsUpdateInputProviderOneOf_1ClientIdScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputCoreTransactionalApplicationsUpdateInputProviderOneOf_1ClientId'], any> {
  name: 'MutationInputCoreTransactionalApplicationsUpdateInputProviderOneOf_1ClientId';
}

export interface MutationInputCoreTransactionalApplicationsUpdateInputProviderOneOf_1ClientSecretScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputCoreTransactionalApplicationsUpdateInputProviderOneOf_1ClientSecret'], any> {
  name: 'MutationInputCoreTransactionalApplicationsUpdateInputProviderOneOf_1ClientSecret';
}

export type CoreUserConsentDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreUserConsentDestroyResponse'] = ResolversParentTypes['CoreUserConsentDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CoreUsersCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreUsersCreateResponse'] = ResolversParentTypes['CoreUsersCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'User' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export interface MutationInputCoreUsersCreateInputUsernameScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputCoreUsersCreateInputUsername'], any> {
  name: 'MutationInputCoreUsersCreateInputUsername';
}

export type CoreUsersUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreUsersUpdateResponse'] = ResolversParentTypes['CoreUsersUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'User' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CoreUsersPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreUsersPartialUpdateResponse'] = ResolversParentTypes['CoreUsersPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'User' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export interface MutationInputCoreUsersPartialUpdateInputUsernameScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputCoreUsersPartialUpdateInputUsername'], any> {
  name: 'MutationInputCoreUsersPartialUpdateInputUsername';
}

export type CoreUsersDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreUsersDestroyResponse'] = ResolversParentTypes['CoreUsersDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CoreUsersImpersonateCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreUsersImpersonateCreateResponse'] = ResolversParentTypes['CoreUsersImpersonateCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CoreUsersRecoveryCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreUsersRecoveryCreateResponse'] = ResolversParentTypes['CoreUsersRecoveryCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Link' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CoreUsersRecoveryEmailCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreUsersRecoveryEmailCreateResponse'] = ResolversParentTypes['CoreUsersRecoveryEmailCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CoreUsersSetPasswordCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreUsersSetPasswordCreateResponse'] = ResolversParentTypes['CoreUsersSetPasswordCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'GenericError', ParentType, ContextType>;
}>;

export type CoreUsersServiceAccountCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CoreUsersServiceAccountCreateResponse'] = ResolversParentTypes['CoreUsersServiceAccountCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UserServiceAccountResponse' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type UserServiceAccountResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UserServiceAccountResponse'] = ResolversParentTypes['UserServiceAccountResponse']> = ResolversObject<{
  username?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  token?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  userUid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  userPk?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  groupPk?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CryptoCertificatekeypairsCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CryptoCertificatekeypairsCreateResponse'] = ResolversParentTypes['CryptoCertificatekeypairsCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'CertificateKeyPair' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CryptoCertificatekeypairsUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CryptoCertificatekeypairsUpdateResponse'] = ResolversParentTypes['CryptoCertificatekeypairsUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'CertificateKeyPair' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CryptoCertificatekeypairsPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CryptoCertificatekeypairsPartialUpdateResponse'] = ResolversParentTypes['CryptoCertificatekeypairsPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'CertificateKeyPair' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CryptoCertificatekeypairsDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CryptoCertificatekeypairsDestroyResponse'] = ResolversParentTypes['CryptoCertificatekeypairsDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type CryptoCertificatekeypairsGenerateCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CryptoCertificatekeypairsGenerateCreateResponse'] = ResolversParentTypes['CryptoCertificatekeypairsGenerateCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'CertificateKeyPair' | 'GenericError', ParentType, ContextType>;
}>;

export type EnterpriseLicenseCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseLicenseCreateResponse'] = ResolversParentTypes['EnterpriseLicenseCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'License' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type EnterpriseLicenseUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseLicenseUpdateResponse'] = ResolversParentTypes['EnterpriseLicenseUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'License' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type EnterpriseLicensePartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseLicensePartialUpdateResponse'] = ResolversParentTypes['EnterpriseLicensePartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'License' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type EnterpriseLicenseDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseLicenseDestroyResponse'] = ResolversParentTypes['EnterpriseLicenseDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type EventsEventsCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EventsEventsCreateResponse'] = ResolversParentTypes['EventsEventsCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Event' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type EventsEventsUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EventsEventsUpdateResponse'] = ResolversParentTypes['EventsEventsUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Event' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type EventsEventsPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EventsEventsPartialUpdateResponse'] = ResolversParentTypes['EventsEventsPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Event' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type EventsEventsDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EventsEventsDestroyResponse'] = ResolversParentTypes['EventsEventsDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type EventsNotificationsUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EventsNotificationsUpdateResponse'] = ResolversParentTypes['EventsNotificationsUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Notification' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type EventsNotificationsPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EventsNotificationsPartialUpdateResponse'] = ResolversParentTypes['EventsNotificationsPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Notification' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type EventsNotificationsDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EventsNotificationsDestroyResponse'] = ResolversParentTypes['EventsNotificationsDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type EventsNotificationsMarkAllSeenCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EventsNotificationsMarkAllSeenCreateResponse'] = ResolversParentTypes['EventsNotificationsMarkAllSeenCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type EventsRulesCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EventsRulesCreateResponse'] = ResolversParentTypes['EventsRulesCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'NotificationRule' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type EventsRulesUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EventsRulesUpdateResponse'] = ResolversParentTypes['EventsRulesUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'NotificationRule' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type EventsRulesPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EventsRulesPartialUpdateResponse'] = ResolversParentTypes['EventsRulesPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'NotificationRule' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type EventsRulesDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EventsRulesDestroyResponse'] = ResolversParentTypes['EventsRulesDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type EventsSystemTasksRunCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EventsSystemTasksRunCreateResponse'] = ResolversParentTypes['EventsSystemTasksRunCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type EventsTransportsCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EventsTransportsCreateResponse'] = ResolversParentTypes['EventsTransportsCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'NotificationTransport' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type EventsTransportsUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EventsTransportsUpdateResponse'] = ResolversParentTypes['EventsTransportsUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'NotificationTransport' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type EventsTransportsPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EventsTransportsPartialUpdateResponse'] = ResolversParentTypes['EventsTransportsPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'NotificationTransport' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type EventsTransportsDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EventsTransportsDestroyResponse'] = ResolversParentTypes['EventsTransportsDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type EventsTransportsTestCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EventsTransportsTestCreateResponse'] = ResolversParentTypes['EventsTransportsTestCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'NotificationTransportTest' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type NotificationTransportTestResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['NotificationTransportTest'] = ResolversParentTypes['NotificationTransportTest']> = ResolversObject<{
  messages?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type FlowsBindingsCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['FlowsBindingsCreateResponse'] = ResolversParentTypes['FlowsBindingsCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'FlowStageBinding' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type FlowsBindingsUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['FlowsBindingsUpdateResponse'] = ResolversParentTypes['FlowsBindingsUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'FlowStageBinding' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type FlowsBindingsPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['FlowsBindingsPartialUpdateResponse'] = ResolversParentTypes['FlowsBindingsPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'FlowStageBinding' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type FlowsBindingsDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['FlowsBindingsDestroyResponse'] = ResolversParentTypes['FlowsBindingsDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type FlowsExecutorSolveResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['FlowsExecutorSolveResponse'] = ResolversParentTypes['FlowsExecutorSolveResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'AccessDeniedChallenge' | 'AppleLoginChallenge' | 'AuthenticatorDuoChallenge' | 'AuthenticatorSmsChallenge' | 'AuthenticatorStaticChallenge' | 'AuthenticatorTotpChallenge' | 'AuthenticatorValidationChallenge' | 'AuthenticatorWebAuthnChallenge' | 'AutosubmitChallenge' | 'CaptchaChallenge' | 'ConsentChallenge' | 'EmailChallenge' | 'FlowErrorChallenge' | 'IdentificationChallenge' | 'OAuthDeviceCodeChallenge' | 'OAuthDeviceCodeFinishChallenge' | 'PasswordChallenge' | 'PlexAuthenticationChallenge' | 'PromptChallenge' | 'RedirectChallenge' | 'ShellChallenge' | 'UserLoginChallenge' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type FlowsInstancesCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['FlowsInstancesCreateResponse'] = ResolversParentTypes['FlowsInstancesCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Flow' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export interface MutationInputFlowsInstancesCreateInputSlugScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputFlowsInstancesCreateInputSlug'], any> {
  name: 'MutationInputFlowsInstancesCreateInputSlug';
}

export type FlowsInstancesUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['FlowsInstancesUpdateResponse'] = ResolversParentTypes['FlowsInstancesUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Flow' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type FlowsInstancesPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['FlowsInstancesPartialUpdateResponse'] = ResolversParentTypes['FlowsInstancesPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Flow' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export interface MutationInputFlowsInstancesPartialUpdateInputSlugScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputFlowsInstancesPartialUpdateInputSlug'], any> {
  name: 'MutationInputFlowsInstancesPartialUpdateInputSlug';
}

export type FlowsInstancesDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['FlowsInstancesDestroyResponse'] = ResolversParentTypes['FlowsInstancesDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type FlowsInstancesCacheClearCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['FlowsInstancesCacheClearCreateResponse'] = ResolversParentTypes['FlowsInstancesCacheClearCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'GenericError', ParentType, ContextType>;
}>;

export type FlowsInstancesImportCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['FlowsInstancesImportCreateResponse'] = ResolversParentTypes['FlowsInstancesImportCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'FlowImportResult' | 'GenericError', ParentType, ContextType>;
}>;

export type FlowImportResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['FlowImportResult'] = ResolversParentTypes['FlowImportResult']> = ResolversObject<{
  logs?: Resolver<Array<Maybe<ResolversTypes['LogEvent']>>, ParentType, ContextType>;
  success?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ManagedBlueprintsCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ManagedBlueprintsCreateResponse'] = ResolversParentTypes['ManagedBlueprintsCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'BlueprintInstance' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ManagedBlueprintsUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ManagedBlueprintsUpdateResponse'] = ResolversParentTypes['ManagedBlueprintsUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'BlueprintInstance' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ManagedBlueprintsPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ManagedBlueprintsPartialUpdateResponse'] = ResolversParentTypes['ManagedBlueprintsPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'BlueprintInstance' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ManagedBlueprintsDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ManagedBlueprintsDestroyResponse'] = ResolversParentTypes['ManagedBlueprintsDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ManagedBlueprintsApplyCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ManagedBlueprintsApplyCreateResponse'] = ResolversParentTypes['ManagedBlueprintsApplyCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'BlueprintInstance' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type Oauth2AccessTokensDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Oauth2AccessTokensDestroyResponse'] = ResolversParentTypes['Oauth2AccessTokensDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type Oauth2AuthorizationCodesDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Oauth2AuthorizationCodesDestroyResponse'] = ResolversParentTypes['Oauth2AuthorizationCodesDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type Oauth2RefreshTokensDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Oauth2RefreshTokensDestroyResponse'] = ResolversParentTypes['Oauth2RefreshTokensDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type OutpostsInstancesCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OutpostsInstancesCreateResponse'] = ResolversParentTypes['OutpostsInstancesCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Outpost' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type OutpostsInstancesUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OutpostsInstancesUpdateResponse'] = ResolversParentTypes['OutpostsInstancesUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Outpost' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type OutpostsInstancesPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OutpostsInstancesPartialUpdateResponse'] = ResolversParentTypes['OutpostsInstancesPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Outpost' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type OutpostsInstancesDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OutpostsInstancesDestroyResponse'] = ResolversParentTypes['OutpostsInstancesDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type OutpostsServiceConnectionsAllDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OutpostsServiceConnectionsAllDestroyResponse'] = ResolversParentTypes['OutpostsServiceConnectionsAllDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type OutpostsServiceConnectionsDockerCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OutpostsServiceConnectionsDockerCreateResponse'] = ResolversParentTypes['OutpostsServiceConnectionsDockerCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'DockerServiceConnection' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type OutpostsServiceConnectionsDockerUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OutpostsServiceConnectionsDockerUpdateResponse'] = ResolversParentTypes['OutpostsServiceConnectionsDockerUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'DockerServiceConnection' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type OutpostsServiceConnectionsDockerPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OutpostsServiceConnectionsDockerPartialUpdateResponse'] = ResolversParentTypes['OutpostsServiceConnectionsDockerPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'DockerServiceConnection' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type OutpostsServiceConnectionsDockerDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OutpostsServiceConnectionsDockerDestroyResponse'] = ResolversParentTypes['OutpostsServiceConnectionsDockerDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type OutpostsServiceConnectionsKubernetesCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OutpostsServiceConnectionsKubernetesCreateResponse'] = ResolversParentTypes['OutpostsServiceConnectionsKubernetesCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'KubernetesServiceConnection' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type OutpostsServiceConnectionsKubernetesUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OutpostsServiceConnectionsKubernetesUpdateResponse'] = ResolversParentTypes['OutpostsServiceConnectionsKubernetesUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'KubernetesServiceConnection' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type OutpostsServiceConnectionsKubernetesPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OutpostsServiceConnectionsKubernetesPartialUpdateResponse'] = ResolversParentTypes['OutpostsServiceConnectionsKubernetesPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'KubernetesServiceConnection' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type OutpostsServiceConnectionsKubernetesDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OutpostsServiceConnectionsKubernetesDestroyResponse'] = ResolversParentTypes['OutpostsServiceConnectionsKubernetesDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesAllDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesAllDestroyResponse'] = ResolversParentTypes['PoliciesAllDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesAllTestCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesAllTestCreateResponse'] = ResolversParentTypes['PoliciesAllTestCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PolicyTestResult' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesAllCacheClearCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesAllCacheClearCreateResponse'] = ResolversParentTypes['PoliciesAllCacheClearCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesBindingsCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesBindingsCreateResponse'] = ResolversParentTypes['PoliciesBindingsCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PolicyBinding' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesBindingsUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesBindingsUpdateResponse'] = ResolversParentTypes['PoliciesBindingsUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PolicyBinding' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesBindingsPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesBindingsPartialUpdateResponse'] = ResolversParentTypes['PoliciesBindingsPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PolicyBinding' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesBindingsDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesBindingsDestroyResponse'] = ResolversParentTypes['PoliciesBindingsDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesDummyCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesDummyCreateResponse'] = ResolversParentTypes['PoliciesDummyCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'DummyPolicy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesDummyUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesDummyUpdateResponse'] = ResolversParentTypes['PoliciesDummyUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'DummyPolicy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesDummyPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesDummyPartialUpdateResponse'] = ResolversParentTypes['PoliciesDummyPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'DummyPolicy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesDummyDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesDummyDestroyResponse'] = ResolversParentTypes['PoliciesDummyDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesEventMatcherCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesEventMatcherCreateResponse'] = ResolversParentTypes['PoliciesEventMatcherCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'EventMatcherPolicy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesEventMatcherUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesEventMatcherUpdateResponse'] = ResolversParentTypes['PoliciesEventMatcherUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'EventMatcherPolicy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesEventMatcherPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesEventMatcherPartialUpdateResponse'] = ResolversParentTypes['PoliciesEventMatcherPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'EventMatcherPolicy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesEventMatcherDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesEventMatcherDestroyResponse'] = ResolversParentTypes['PoliciesEventMatcherDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesExpressionCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesExpressionCreateResponse'] = ResolversParentTypes['PoliciesExpressionCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ExpressionPolicy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesExpressionUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesExpressionUpdateResponse'] = ResolversParentTypes['PoliciesExpressionUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ExpressionPolicy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesExpressionPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesExpressionPartialUpdateResponse'] = ResolversParentTypes['PoliciesExpressionPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ExpressionPolicy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesExpressionDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesExpressionDestroyResponse'] = ResolversParentTypes['PoliciesExpressionDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesPasswordCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesPasswordCreateResponse'] = ResolversParentTypes['PoliciesPasswordCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PasswordPolicy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesPasswordUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesPasswordUpdateResponse'] = ResolversParentTypes['PoliciesPasswordUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PasswordPolicy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesPasswordPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesPasswordPartialUpdateResponse'] = ResolversParentTypes['PoliciesPasswordPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PasswordPolicy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesPasswordDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesPasswordDestroyResponse'] = ResolversParentTypes['PoliciesPasswordDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesPasswordExpiryCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesPasswordExpiryCreateResponse'] = ResolversParentTypes['PoliciesPasswordExpiryCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PasswordExpiryPolicy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesPasswordExpiryUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesPasswordExpiryUpdateResponse'] = ResolversParentTypes['PoliciesPasswordExpiryUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PasswordExpiryPolicy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesPasswordExpiryPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesPasswordExpiryPartialUpdateResponse'] = ResolversParentTypes['PoliciesPasswordExpiryPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PasswordExpiryPolicy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesPasswordExpiryDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesPasswordExpiryDestroyResponse'] = ResolversParentTypes['PoliciesPasswordExpiryDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesReputationCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesReputationCreateResponse'] = ResolversParentTypes['PoliciesReputationCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ReputationPolicy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesReputationUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesReputationUpdateResponse'] = ResolversParentTypes['PoliciesReputationUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ReputationPolicy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesReputationPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesReputationPartialUpdateResponse'] = ResolversParentTypes['PoliciesReputationPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ReputationPolicy' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesReputationDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesReputationDestroyResponse'] = ResolversParentTypes['PoliciesReputationDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PoliciesReputationScoresDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PoliciesReputationScoresDestroyResponse'] = ResolversParentTypes['PoliciesReputationScoresDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertymappingsAllDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsAllDestroyResponse'] = ResolversParentTypes['PropertymappingsAllDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertymappingsAllTestCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsAllTestCreateResponse'] = ResolversParentTypes['PropertymappingsAllTestCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PropertyMappingTestResult' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertyMappingTestResultResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertyMappingTestResult'] = ResolversParentTypes['PropertyMappingTestResult']> = ResolversObject<{
  result?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  successful?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PropertymappingsLdapCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsLdapCreateResponse'] = ResolversParentTypes['PropertymappingsLdapCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'LdapPropertyMapping' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertymappingsLdapUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsLdapUpdateResponse'] = ResolversParentTypes['PropertymappingsLdapUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'LdapPropertyMapping' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertymappingsLdapPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsLdapPartialUpdateResponse'] = ResolversParentTypes['PropertymappingsLdapPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'LdapPropertyMapping' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertymappingsLdapDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsLdapDestroyResponse'] = ResolversParentTypes['PropertymappingsLdapDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertymappingsNotificationCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsNotificationCreateResponse'] = ResolversParentTypes['PropertymappingsNotificationCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'NotificationWebhookMapping' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertymappingsNotificationUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsNotificationUpdateResponse'] = ResolversParentTypes['PropertymappingsNotificationUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'NotificationWebhookMapping' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertymappingsNotificationPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsNotificationPartialUpdateResponse'] = ResolversParentTypes['PropertymappingsNotificationPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'NotificationWebhookMapping' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertymappingsNotificationDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsNotificationDestroyResponse'] = ResolversParentTypes['PropertymappingsNotificationDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertymappingsRacCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsRacCreateResponse'] = ResolversParentTypes['PropertymappingsRacCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'RacPropertyMapping' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertymappingsRacUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsRacUpdateResponse'] = ResolversParentTypes['PropertymappingsRacUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'RacPropertyMapping' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertymappingsRacPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsRacPartialUpdateResponse'] = ResolversParentTypes['PropertymappingsRacPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'RacPropertyMapping' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertymappingsRacDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsRacDestroyResponse'] = ResolversParentTypes['PropertymappingsRacDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertymappingsSamlCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsSamlCreateResponse'] = ResolversParentTypes['PropertymappingsSamlCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'SamlPropertyMapping' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertymappingsSamlUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsSamlUpdateResponse'] = ResolversParentTypes['PropertymappingsSamlUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'SamlPropertyMapping' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertymappingsSamlPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsSamlPartialUpdateResponse'] = ResolversParentTypes['PropertymappingsSamlPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'SamlPropertyMapping' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertymappingsSamlDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsSamlDestroyResponse'] = ResolversParentTypes['PropertymappingsSamlDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertymappingsScimCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsScimCreateResponse'] = ResolversParentTypes['PropertymappingsScimCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ScimMapping' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertymappingsScimUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsScimUpdateResponse'] = ResolversParentTypes['PropertymappingsScimUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ScimMapping' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertymappingsScimPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsScimPartialUpdateResponse'] = ResolversParentTypes['PropertymappingsScimPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ScimMapping' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertymappingsScimDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsScimDestroyResponse'] = ResolversParentTypes['PropertymappingsScimDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertymappingsScopeCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsScopeCreateResponse'] = ResolversParentTypes['PropertymappingsScopeCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ScopeMapping' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertymappingsScopeUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsScopeUpdateResponse'] = ResolversParentTypes['PropertymappingsScopeUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ScopeMapping' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertymappingsScopePartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsScopePartialUpdateResponse'] = ResolversParentTypes['PropertymappingsScopePartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ScopeMapping' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type PropertymappingsScopeDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PropertymappingsScopeDestroyResponse'] = ResolversParentTypes['PropertymappingsScopeDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersAllDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersAllDestroyResponse'] = ResolversParentTypes['ProvidersAllDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersLdapCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersLdapCreateResponse'] = ResolversParentTypes['ProvidersLdapCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'LdapProvider' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersLdapUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersLdapUpdateResponse'] = ResolversParentTypes['ProvidersLdapUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'LdapProvider' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersLdapPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersLdapPartialUpdateResponse'] = ResolversParentTypes['ProvidersLdapPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'LdapProvider' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersLdapDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersLdapDestroyResponse'] = ResolversParentTypes['ProvidersLdapDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersOauth2CreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersOauth2CreateResponse'] = ResolversParentTypes['ProvidersOauth2CreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'OAuth2Provider' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersOauth2UpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersOauth2UpdateResponse'] = ResolversParentTypes['ProvidersOauth2UpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'OAuth2Provider' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersOauth2PartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersOauth2PartialUpdateResponse'] = ResolversParentTypes['ProvidersOauth2PartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'OAuth2Provider' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export interface MutationInputProvidersOauth2PartialUpdateInputClientIdScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputProvidersOauth2PartialUpdateInputClientId'], any> {
  name: 'MutationInputProvidersOauth2PartialUpdateInputClientId';
}

export interface MutationInputProvidersOauth2PartialUpdateInputClientSecretScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputProvidersOauth2PartialUpdateInputClientSecret'], any> {
  name: 'MutationInputProvidersOauth2PartialUpdateInputClientSecret';
}

export type ProvidersOauth2DestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersOauth2DestroyResponse'] = ResolversParentTypes['ProvidersOauth2DestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersProxyCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersProxyCreateResponse'] = ResolversParentTypes['ProvidersProxyCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ProxyProvider' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersProxyUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersProxyUpdateResponse'] = ResolversParentTypes['ProvidersProxyUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ProxyProvider' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersProxyPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersProxyPartialUpdateResponse'] = ResolversParentTypes['ProvidersProxyPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ProxyProvider' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersProxyDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersProxyDestroyResponse'] = ResolversParentTypes['ProvidersProxyDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersRacCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersRacCreateResponse'] = ResolversParentTypes['ProvidersRacCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'RacProvider' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersRacUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersRacUpdateResponse'] = ResolversParentTypes['ProvidersRacUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'RacProvider' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersRacPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersRacPartialUpdateResponse'] = ResolversParentTypes['ProvidersRacPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'RacProvider' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersRacDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersRacDestroyResponse'] = ResolversParentTypes['ProvidersRacDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersRadiusCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersRadiusCreateResponse'] = ResolversParentTypes['ProvidersRadiusCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'RadiusProvider' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersRadiusUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersRadiusUpdateResponse'] = ResolversParentTypes['ProvidersRadiusUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'RadiusProvider' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersRadiusPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersRadiusPartialUpdateResponse'] = ResolversParentTypes['ProvidersRadiusPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'RadiusProvider' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersRadiusDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersRadiusDestroyResponse'] = ResolversParentTypes['ProvidersRadiusDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersSamlCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersSamlCreateResponse'] = ResolversParentTypes['ProvidersSamlCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'SamlProvider' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersSamlUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersSamlUpdateResponse'] = ResolversParentTypes['ProvidersSamlUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'SamlProvider' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersSamlPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersSamlPartialUpdateResponse'] = ResolversParentTypes['ProvidersSamlPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'SamlProvider' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersSamlDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersSamlDestroyResponse'] = ResolversParentTypes['ProvidersSamlDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersSamlImportMetadataCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersSamlImportMetadataCreateResponse'] = ResolversParentTypes['ProvidersSamlImportMetadataCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersScimCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersScimCreateResponse'] = ResolversParentTypes['ProvidersScimCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ScimProvider' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersScimUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersScimUpdateResponse'] = ResolversParentTypes['ProvidersScimUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ScimProvider' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersScimPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersScimPartialUpdateResponse'] = ResolversParentTypes['ProvidersScimPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ScimProvider' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type ProvidersScimDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersScimDestroyResponse'] = ResolversParentTypes['ProvidersScimDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type RacConnectionTokensUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RacConnectionTokensUpdateResponse'] = ResolversParentTypes['RacConnectionTokensUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ConnectionToken' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type RacConnectionTokensPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RacConnectionTokensPartialUpdateResponse'] = ResolversParentTypes['RacConnectionTokensPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ConnectionToken' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type RacConnectionTokensDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RacConnectionTokensDestroyResponse'] = ResolversParentTypes['RacConnectionTokensDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type RacEndpointsCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RacEndpointsCreateResponse'] = ResolversParentTypes['RacEndpointsCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Endpoint' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type RacEndpointsUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RacEndpointsUpdateResponse'] = ResolversParentTypes['RacEndpointsUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Endpoint' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type RacEndpointsPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RacEndpointsPartialUpdateResponse'] = ResolversParentTypes['RacEndpointsPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Endpoint' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type RacEndpointsDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RacEndpointsDestroyResponse'] = ResolversParentTypes['RacEndpointsDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type RbacPermissionsAssignedByRolesAssignCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RbacPermissionsAssignedByRolesAssignCreateResponse'] = ResolversParentTypes['RbacPermissionsAssignedByRolesAssignCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type RbacPermissionsAssignedByRolesUnassignPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RbacPermissionsAssignedByRolesUnassignPartialUpdateResponse'] = ResolversParentTypes['RbacPermissionsAssignedByRolesUnassignPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type RbacPermissionsAssignedByUsersAssignCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RbacPermissionsAssignedByUsersAssignCreateResponse'] = ResolversParentTypes['RbacPermissionsAssignedByUsersAssignCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type RbacPermissionsAssignedByUsersUnassignPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RbacPermissionsAssignedByUsersUnassignPartialUpdateResponse'] = ResolversParentTypes['RbacPermissionsAssignedByUsersUnassignPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type RbacRolesCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RbacRolesCreateResponse'] = ResolversParentTypes['RbacRolesCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Role' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export interface MutationInputRbacRolesCreateInputNameScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputRbacRolesCreateInputName'], any> {
  name: 'MutationInputRbacRolesCreateInputName';
}

export type RbacRolesUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RbacRolesUpdateResponse'] = ResolversParentTypes['RbacRolesUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Role' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type RbacRolesPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RbacRolesPartialUpdateResponse'] = ResolversParentTypes['RbacRolesPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Role' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export interface MutationInputRbacRolesPartialUpdateInputNameScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputRbacRolesPartialUpdateInputName'], any> {
  name: 'MutationInputRbacRolesPartialUpdateInputName';
}

export type RbacRolesDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RbacRolesDestroyResponse'] = ResolversParentTypes['RbacRolesDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesAllDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesAllDestroyResponse'] = ResolversParentTypes['SourcesAllDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesLdapCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesLdapCreateResponse'] = ResolversParentTypes['SourcesLdapCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'LdapSource' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export interface MutationInputSourcesLdapCreateInputSlugScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputSourcesLdapCreateInputSlug'], any> {
  name: 'MutationInputSourcesLdapCreateInputSlug';
}

export type SourcesLdapUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesLdapUpdateResponse'] = ResolversParentTypes['SourcesLdapUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'LdapSource' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesLdapPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesLdapPartialUpdateResponse'] = ResolversParentTypes['SourcesLdapPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'LdapSource' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export interface MutationInputSourcesLdapPartialUpdateInputSlugScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputSourcesLdapPartialUpdateInputSlug'], any> {
  name: 'MutationInputSourcesLdapPartialUpdateInputSlug';
}

export type SourcesLdapDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesLdapDestroyResponse'] = ResolversParentTypes['SourcesLdapDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesOauthCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesOauthCreateResponse'] = ResolversParentTypes['SourcesOauthCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'OAuthSource' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export interface MutationInputSourcesOauthCreateInputSlugScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputSourcesOauthCreateInputSlug'], any> {
  name: 'MutationInputSourcesOauthCreateInputSlug';
}

export interface MutationInputSourcesOauthCreateInputRequestTokenUrlScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputSourcesOauthCreateInputRequestTokenUrl'], any> {
  name: 'MutationInputSourcesOauthCreateInputRequestTokenUrl';
}

export interface MutationInputSourcesOauthCreateInputAuthorizationUrlScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputSourcesOauthCreateInputAuthorizationUrl'], any> {
  name: 'MutationInputSourcesOauthCreateInputAuthorizationUrl';
}

export interface MutationInputSourcesOauthCreateInputAccessTokenUrlScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputSourcesOauthCreateInputAccessTokenUrl'], any> {
  name: 'MutationInputSourcesOauthCreateInputAccessTokenUrl';
}

export interface MutationInputSourcesOauthCreateInputProfileUrlScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputSourcesOauthCreateInputProfileUrl'], any> {
  name: 'MutationInputSourcesOauthCreateInputProfileUrl';
}

export type SourcesOauthUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesOauthUpdateResponse'] = ResolversParentTypes['SourcesOauthUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'OAuthSource' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesOauthPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesOauthPartialUpdateResponse'] = ResolversParentTypes['SourcesOauthPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'OAuthSource' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export interface MutationInputSourcesOauthPartialUpdateInputSlugScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputSourcesOauthPartialUpdateInputSlug'], any> {
  name: 'MutationInputSourcesOauthPartialUpdateInputSlug';
}

export interface MutationInputSourcesOauthPartialUpdateInputRequestTokenUrlScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputSourcesOauthPartialUpdateInputRequestTokenUrl'], any> {
  name: 'MutationInputSourcesOauthPartialUpdateInputRequestTokenUrl';
}

export interface MutationInputSourcesOauthPartialUpdateInputAuthorizationUrlScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputSourcesOauthPartialUpdateInputAuthorizationUrl'], any> {
  name: 'MutationInputSourcesOauthPartialUpdateInputAuthorizationUrl';
}

export interface MutationInputSourcesOauthPartialUpdateInputAccessTokenUrlScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputSourcesOauthPartialUpdateInputAccessTokenUrl'], any> {
  name: 'MutationInputSourcesOauthPartialUpdateInputAccessTokenUrl';
}

export interface MutationInputSourcesOauthPartialUpdateInputProfileUrlScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputSourcesOauthPartialUpdateInputProfileUrl'], any> {
  name: 'MutationInputSourcesOauthPartialUpdateInputProfileUrl';
}

export type SourcesOauthDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesOauthDestroyResponse'] = ResolversParentTypes['SourcesOauthDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesPlexCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesPlexCreateResponse'] = ResolversParentTypes['SourcesPlexCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PlexSource' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export interface MutationInputSourcesPlexCreateInputSlugScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputSourcesPlexCreateInputSlug'], any> {
  name: 'MutationInputSourcesPlexCreateInputSlug';
}

export type SourcesPlexUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesPlexUpdateResponse'] = ResolversParentTypes['SourcesPlexUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PlexSource' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesPlexPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesPlexPartialUpdateResponse'] = ResolversParentTypes['SourcesPlexPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PlexSource' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export interface MutationInputSourcesPlexPartialUpdateInputSlugScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputSourcesPlexPartialUpdateInputSlug'], any> {
  name: 'MutationInputSourcesPlexPartialUpdateInputSlug';
}

export type SourcesPlexDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesPlexDestroyResponse'] = ResolversParentTypes['SourcesPlexDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesSamlCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesSamlCreateResponse'] = ResolversParentTypes['SourcesSamlCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'SamlSource' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export interface MutationInputSourcesSamlCreateInputSlugScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputSourcesSamlCreateInputSlug'], any> {
  name: 'MutationInputSourcesSamlCreateInputSlug';
}

export type SourcesSamlUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesSamlUpdateResponse'] = ResolversParentTypes['SourcesSamlUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'SamlSource' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesSamlPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesSamlPartialUpdateResponse'] = ResolversParentTypes['SourcesSamlPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'SamlSource' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export interface MutationInputSourcesSamlPartialUpdateInputSlugScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputSourcesSamlPartialUpdateInputSlug'], any> {
  name: 'MutationInputSourcesSamlPartialUpdateInputSlug';
}

export type SourcesSamlDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesSamlDestroyResponse'] = ResolversParentTypes['SourcesSamlDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesScimCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesScimCreateResponse'] = ResolversParentTypes['SourcesScimCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ScimSource' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export interface MutationInputSourcesScimCreateInputSlugScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputSourcesScimCreateInputSlug'], any> {
  name: 'MutationInputSourcesScimCreateInputSlug';
}

export type SourcesScimUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesScimUpdateResponse'] = ResolversParentTypes['SourcesScimUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ScimSource' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesScimPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesScimPartialUpdateResponse'] = ResolversParentTypes['SourcesScimPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ScimSource' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export interface MutationInputSourcesScimPartialUpdateInputSlugScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputSourcesScimPartialUpdateInputSlug'], any> {
  name: 'MutationInputSourcesScimPartialUpdateInputSlug';
}

export type SourcesScimDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesScimDestroyResponse'] = ResolversParentTypes['SourcesScimDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesScimGroupsCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesScimGroupsCreateResponse'] = ResolversParentTypes['SourcesScimGroupsCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ScimSourceGroup' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesScimGroupsUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesScimGroupsUpdateResponse'] = ResolversParentTypes['SourcesScimGroupsUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ScimSourceGroup' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesScimGroupsPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesScimGroupsPartialUpdateResponse'] = ResolversParentTypes['SourcesScimGroupsPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ScimSourceGroup' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesScimGroupsDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesScimGroupsDestroyResponse'] = ResolversParentTypes['SourcesScimGroupsDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesScimUsersCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesScimUsersCreateResponse'] = ResolversParentTypes['SourcesScimUsersCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ScimSourceUser' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesScimUsersUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesScimUsersUpdateResponse'] = ResolversParentTypes['SourcesScimUsersUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ScimSourceUser' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesScimUsersPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesScimUsersPartialUpdateResponse'] = ResolversParentTypes['SourcesScimUsersPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ScimSourceUser' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesScimUsersDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesScimUsersDestroyResponse'] = ResolversParentTypes['SourcesScimUsersDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesUserConnectionsAllUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesUserConnectionsAllUpdateResponse'] = ResolversParentTypes['SourcesUserConnectionsAllUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UserSourceConnection' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesUserConnectionsAllPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesUserConnectionsAllPartialUpdateResponse'] = ResolversParentTypes['SourcesUserConnectionsAllPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UserSourceConnection' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesUserConnectionsAllDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesUserConnectionsAllDestroyResponse'] = ResolversParentTypes['SourcesUserConnectionsAllDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesUserConnectionsOauthCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesUserConnectionsOauthCreateResponse'] = ResolversParentTypes['SourcesUserConnectionsOauthCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UserOAuthSourceConnection' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export interface MutationInputSourcesUserConnectionsOauthCreateInputIdentifierScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputSourcesUserConnectionsOauthCreateInputIdentifier'], any> {
  name: 'MutationInputSourcesUserConnectionsOauthCreateInputIdentifier';
}

export type SourcesUserConnectionsOauthUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesUserConnectionsOauthUpdateResponse'] = ResolversParentTypes['SourcesUserConnectionsOauthUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UserOAuthSourceConnection' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesUserConnectionsOauthPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesUserConnectionsOauthPartialUpdateResponse'] = ResolversParentTypes['SourcesUserConnectionsOauthPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UserOAuthSourceConnection' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export interface MutationInputSourcesUserConnectionsOauthPartialUpdateInputIdentifierScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputSourcesUserConnectionsOauthPartialUpdateInputIdentifier'], any> {
  name: 'MutationInputSourcesUserConnectionsOauthPartialUpdateInputIdentifier';
}

export type SourcesUserConnectionsOauthDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesUserConnectionsOauthDestroyResponse'] = ResolversParentTypes['SourcesUserConnectionsOauthDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesUserConnectionsPlexCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesUserConnectionsPlexCreateResponse'] = ResolversParentTypes['SourcesUserConnectionsPlexCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PlexSourceConnection' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesUserConnectionsPlexUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesUserConnectionsPlexUpdateResponse'] = ResolversParentTypes['SourcesUserConnectionsPlexUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PlexSourceConnection' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesUserConnectionsPlexPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesUserConnectionsPlexPartialUpdateResponse'] = ResolversParentTypes['SourcesUserConnectionsPlexPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PlexSourceConnection' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesUserConnectionsPlexDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesUserConnectionsPlexDestroyResponse'] = ResolversParentTypes['SourcesUserConnectionsPlexDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesUserConnectionsSamlCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesUserConnectionsSamlCreateResponse'] = ResolversParentTypes['SourcesUserConnectionsSamlCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UserSamlSourceConnection' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesUserConnectionsSamlUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesUserConnectionsSamlUpdateResponse'] = ResolversParentTypes['SourcesUserConnectionsSamlUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UserSamlSourceConnection' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesUserConnectionsSamlPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesUserConnectionsSamlPartialUpdateResponse'] = ResolversParentTypes['SourcesUserConnectionsSamlPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UserSamlSourceConnection' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type SourcesUserConnectionsSamlDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SourcesUserConnectionsSamlDestroyResponse'] = ResolversParentTypes['SourcesUserConnectionsSamlDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAllDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAllDestroyResponse'] = ResolversParentTypes['StagesAllDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAuthenticatorDuoCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorDuoCreateResponse'] = ResolversParentTypes['StagesAuthenticatorDuoCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'AuthenticatorDuoStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export interface MutationInputStagesAuthenticatorDuoCreateInputFlowSetItemsSlugScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputStagesAuthenticatorDuoCreateInputFlowSetItemsSlug'], any> {
  name: 'MutationInputStagesAuthenticatorDuoCreateInputFlowSetItemsSlug';
}

export type StagesAuthenticatorDuoUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorDuoUpdateResponse'] = ResolversParentTypes['StagesAuthenticatorDuoUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'AuthenticatorDuoStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAuthenticatorDuoPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorDuoPartialUpdateResponse'] = ResolversParentTypes['StagesAuthenticatorDuoPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'AuthenticatorDuoStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAuthenticatorDuoDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorDuoDestroyResponse'] = ResolversParentTypes['StagesAuthenticatorDuoDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAuthenticatorDuoEnrollmentStatusCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorDuoEnrollmentStatusCreateResponse'] = ResolversParentTypes['StagesAuthenticatorDuoEnrollmentStatusCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'DuoDeviceEnrollmentStatus' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type DuoDeviceEnrollmentStatusResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DuoDeviceEnrollmentStatus'] = ResolversParentTypes['DuoDeviceEnrollmentStatus']> = ResolversObject<{
  duoResponse?: Resolver<ResolversTypes['DuoResponseEnum'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StagesAuthenticatorDuoImportDeviceManualCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorDuoImportDeviceManualCreateResponse'] = ResolversParentTypes['StagesAuthenticatorDuoImportDeviceManualCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAuthenticatorDuoImportDevicesAutomaticCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorDuoImportDevicesAutomaticCreateResponse'] = ResolversParentTypes['StagesAuthenticatorDuoImportDevicesAutomaticCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'AuthenticatorDuoStageDeviceImportResponse' | 'GenericError', ParentType, ContextType>;
}>;

export type AuthenticatorDuoStageDeviceImportResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuthenticatorDuoStageDeviceImportResponse'] = ResolversParentTypes['AuthenticatorDuoStageDeviceImportResponse']> = ResolversObject<{
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  error?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StagesAuthenticatorSmsCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorSmsCreateResponse'] = ResolversParentTypes['StagesAuthenticatorSmsCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'AuthenticatorSmsStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAuthenticatorSmsUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorSmsUpdateResponse'] = ResolversParentTypes['StagesAuthenticatorSmsUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'AuthenticatorSmsStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAuthenticatorSmsPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorSmsPartialUpdateResponse'] = ResolversParentTypes['StagesAuthenticatorSmsPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'AuthenticatorSmsStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAuthenticatorSmsDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorSmsDestroyResponse'] = ResolversParentTypes['StagesAuthenticatorSmsDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAuthenticatorStaticCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorStaticCreateResponse'] = ResolversParentTypes['StagesAuthenticatorStaticCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'AuthenticatorStaticStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAuthenticatorStaticUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorStaticUpdateResponse'] = ResolversParentTypes['StagesAuthenticatorStaticUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'AuthenticatorStaticStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAuthenticatorStaticPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorStaticPartialUpdateResponse'] = ResolversParentTypes['StagesAuthenticatorStaticPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'AuthenticatorStaticStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAuthenticatorStaticDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorStaticDestroyResponse'] = ResolversParentTypes['StagesAuthenticatorStaticDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAuthenticatorTotpCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorTotpCreateResponse'] = ResolversParentTypes['StagesAuthenticatorTotpCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'AuthenticatorTotpStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAuthenticatorTotpUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorTotpUpdateResponse'] = ResolversParentTypes['StagesAuthenticatorTotpUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'AuthenticatorTotpStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAuthenticatorTotpPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorTotpPartialUpdateResponse'] = ResolversParentTypes['StagesAuthenticatorTotpPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'AuthenticatorTotpStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAuthenticatorTotpDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorTotpDestroyResponse'] = ResolversParentTypes['StagesAuthenticatorTotpDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAuthenticatorValidateCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorValidateCreateResponse'] = ResolversParentTypes['StagesAuthenticatorValidateCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'AuthenticatorValidateStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAuthenticatorValidateUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorValidateUpdateResponse'] = ResolversParentTypes['StagesAuthenticatorValidateUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'AuthenticatorValidateStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAuthenticatorValidatePartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorValidatePartialUpdateResponse'] = ResolversParentTypes['StagesAuthenticatorValidatePartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'AuthenticatorValidateStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAuthenticatorValidateDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorValidateDestroyResponse'] = ResolversParentTypes['StagesAuthenticatorValidateDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAuthenticatorWebauthnCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorWebauthnCreateResponse'] = ResolversParentTypes['StagesAuthenticatorWebauthnCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'AuthenticatorWebAuthnStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAuthenticatorWebauthnUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorWebauthnUpdateResponse'] = ResolversParentTypes['StagesAuthenticatorWebauthnUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'AuthenticatorWebAuthnStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAuthenticatorWebauthnPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorWebauthnPartialUpdateResponse'] = ResolversParentTypes['StagesAuthenticatorWebauthnPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'AuthenticatorWebAuthnStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesAuthenticatorWebauthnDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesAuthenticatorWebauthnDestroyResponse'] = ResolversParentTypes['StagesAuthenticatorWebauthnDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesCaptchaCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesCaptchaCreateResponse'] = ResolversParentTypes['StagesCaptchaCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'CaptchaStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesCaptchaUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesCaptchaUpdateResponse'] = ResolversParentTypes['StagesCaptchaUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'CaptchaStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesCaptchaPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesCaptchaPartialUpdateResponse'] = ResolversParentTypes['StagesCaptchaPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'CaptchaStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesCaptchaDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesCaptchaDestroyResponse'] = ResolversParentTypes['StagesCaptchaDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesConsentCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesConsentCreateResponse'] = ResolversParentTypes['StagesConsentCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ConsentStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesConsentUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesConsentUpdateResponse'] = ResolversParentTypes['StagesConsentUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ConsentStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesConsentPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesConsentPartialUpdateResponse'] = ResolversParentTypes['StagesConsentPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ConsentStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesConsentDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesConsentDestroyResponse'] = ResolversParentTypes['StagesConsentDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesDenyCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesDenyCreateResponse'] = ResolversParentTypes['StagesDenyCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'DenyStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesDenyUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesDenyUpdateResponse'] = ResolversParentTypes['StagesDenyUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'DenyStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesDenyPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesDenyPartialUpdateResponse'] = ResolversParentTypes['StagesDenyPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'DenyStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesDenyDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesDenyDestroyResponse'] = ResolversParentTypes['StagesDenyDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesDummyCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesDummyCreateResponse'] = ResolversParentTypes['StagesDummyCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'DummyStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesDummyUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesDummyUpdateResponse'] = ResolversParentTypes['StagesDummyUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'DummyStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesDummyPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesDummyPartialUpdateResponse'] = ResolversParentTypes['StagesDummyPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'DummyStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesDummyDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesDummyDestroyResponse'] = ResolversParentTypes['StagesDummyDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesEmailCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesEmailCreateResponse'] = ResolversParentTypes['StagesEmailCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'EmailStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesEmailUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesEmailUpdateResponse'] = ResolversParentTypes['StagesEmailUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'EmailStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesEmailPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesEmailPartialUpdateResponse'] = ResolversParentTypes['StagesEmailPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'EmailStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesEmailDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesEmailDestroyResponse'] = ResolversParentTypes['StagesEmailDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesIdentificationCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesIdentificationCreateResponse'] = ResolversParentTypes['StagesIdentificationCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'IdentificationStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesIdentificationUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesIdentificationUpdateResponse'] = ResolversParentTypes['StagesIdentificationUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'IdentificationStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesIdentificationPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesIdentificationPartialUpdateResponse'] = ResolversParentTypes['StagesIdentificationPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'IdentificationStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesIdentificationDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesIdentificationDestroyResponse'] = ResolversParentTypes['StagesIdentificationDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesInvitationInvitationsCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesInvitationInvitationsCreateResponse'] = ResolversParentTypes['StagesInvitationInvitationsCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Invitation' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export interface MutationInputStagesInvitationInvitationsCreateInputNameScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputStagesInvitationInvitationsCreateInputName'], any> {
  name: 'MutationInputStagesInvitationInvitationsCreateInputName';
}

export type StagesInvitationInvitationsUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesInvitationInvitationsUpdateResponse'] = ResolversParentTypes['StagesInvitationInvitationsUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Invitation' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesInvitationInvitationsPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesInvitationInvitationsPartialUpdateResponse'] = ResolversParentTypes['StagesInvitationInvitationsPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Invitation' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export interface MutationInputStagesInvitationInvitationsPartialUpdateInputNameScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MutationInputStagesInvitationInvitationsPartialUpdateInputName'], any> {
  name: 'MutationInputStagesInvitationInvitationsPartialUpdateInputName';
}

export type StagesInvitationInvitationsDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesInvitationInvitationsDestroyResponse'] = ResolversParentTypes['StagesInvitationInvitationsDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesInvitationStagesCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesInvitationStagesCreateResponse'] = ResolversParentTypes['StagesInvitationStagesCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'InvitationStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesInvitationStagesUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesInvitationStagesUpdateResponse'] = ResolversParentTypes['StagesInvitationStagesUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'InvitationStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesInvitationStagesPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesInvitationStagesPartialUpdateResponse'] = ResolversParentTypes['StagesInvitationStagesPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'InvitationStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesInvitationStagesDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesInvitationStagesDestroyResponse'] = ResolversParentTypes['StagesInvitationStagesDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesPasswordCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesPasswordCreateResponse'] = ResolversParentTypes['StagesPasswordCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PasswordStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesPasswordUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesPasswordUpdateResponse'] = ResolversParentTypes['StagesPasswordUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PasswordStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesPasswordPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesPasswordPartialUpdateResponse'] = ResolversParentTypes['StagesPasswordPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PasswordStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesPasswordDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesPasswordDestroyResponse'] = ResolversParentTypes['StagesPasswordDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesPromptPromptsCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesPromptPromptsCreateResponse'] = ResolversParentTypes['StagesPromptPromptsCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Prompt' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesPromptPromptsUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesPromptPromptsUpdateResponse'] = ResolversParentTypes['StagesPromptPromptsUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Prompt' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesPromptPromptsPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesPromptPromptsPartialUpdateResponse'] = ResolversParentTypes['StagesPromptPromptsPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Prompt' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesPromptPromptsDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesPromptPromptsDestroyResponse'] = ResolversParentTypes['StagesPromptPromptsDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesPromptPromptsPreviewCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesPromptPromptsPreviewCreateResponse'] = ResolversParentTypes['StagesPromptPromptsPreviewCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PromptChallenge' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesPromptStagesCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesPromptStagesCreateResponse'] = ResolversParentTypes['StagesPromptStagesCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PromptStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesPromptStagesUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesPromptStagesUpdateResponse'] = ResolversParentTypes['StagesPromptStagesUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PromptStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesPromptStagesPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesPromptStagesPartialUpdateResponse'] = ResolversParentTypes['StagesPromptStagesPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'PromptStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesPromptStagesDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesPromptStagesDestroyResponse'] = ResolversParentTypes['StagesPromptStagesDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesSourceCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesSourceCreateResponse'] = ResolversParentTypes['StagesSourceCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'SourceStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesSourceUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesSourceUpdateResponse'] = ResolversParentTypes['StagesSourceUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'SourceStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesSourcePartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesSourcePartialUpdateResponse'] = ResolversParentTypes['StagesSourcePartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'SourceStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesSourceDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesSourceDestroyResponse'] = ResolversParentTypes['StagesSourceDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesUserDeleteCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesUserDeleteCreateResponse'] = ResolversParentTypes['StagesUserDeleteCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UserDeleteStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesUserDeleteUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesUserDeleteUpdateResponse'] = ResolversParentTypes['StagesUserDeleteUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UserDeleteStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesUserDeletePartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesUserDeletePartialUpdateResponse'] = ResolversParentTypes['StagesUserDeletePartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UserDeleteStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesUserDeleteDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesUserDeleteDestroyResponse'] = ResolversParentTypes['StagesUserDeleteDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesUserLoginCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesUserLoginCreateResponse'] = ResolversParentTypes['StagesUserLoginCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UserLoginStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesUserLoginUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesUserLoginUpdateResponse'] = ResolversParentTypes['StagesUserLoginUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UserLoginStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesUserLoginPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesUserLoginPartialUpdateResponse'] = ResolversParentTypes['StagesUserLoginPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UserLoginStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesUserLoginDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesUserLoginDestroyResponse'] = ResolversParentTypes['StagesUserLoginDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesUserLogoutCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesUserLogoutCreateResponse'] = ResolversParentTypes['StagesUserLogoutCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UserLogoutStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesUserLogoutUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesUserLogoutUpdateResponse'] = ResolversParentTypes['StagesUserLogoutUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UserLogoutStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesUserLogoutPartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesUserLogoutPartialUpdateResponse'] = ResolversParentTypes['StagesUserLogoutPartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UserLogoutStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesUserLogoutDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesUserLogoutDestroyResponse'] = ResolversParentTypes['StagesUserLogoutDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesUserWriteCreateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesUserWriteCreateResponse'] = ResolversParentTypes['StagesUserWriteCreateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UserWriteStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesUserWriteUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesUserWriteUpdateResponse'] = ResolversParentTypes['StagesUserWriteUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UserWriteStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesUserWritePartialUpdateResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesUserWritePartialUpdateResponse'] = ResolversParentTypes['StagesUserWritePartialUpdateResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'UserWriteStage' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export type StagesUserWriteDestroyResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StagesUserWriteDestroyResponse'] = ResolversParentTypes['StagesUserWriteDestroyResponse']> = ResolversObject<{
  __resolveType: TypeResolveFn<'VoidContainer' | 'ValidationError' | 'GenericError', ParentType, ContextType>;
}>;

export interface ObjMapScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['ObjMap'], any> {
  name: 'ObjMap';
}

export interface ResolveToSourceArgsScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['ResolveToSourceArgs'], any> {
  name: 'ResolveToSourceArgs';
}

export type Resolvers<ContextType = MeshContext> = ResolversObject<{
  Query?: QueryResolvers<ContextType>;
  Subscription?: SubscriptionResolvers<ContextType>;
  ChurrosAnnouncement?: ChurrosAnnouncementResolvers<ContextType>;
  ChurrosAnswer?: ChurrosAnswerResolvers<ContextType>;
  ChurrosAnswerDate?: ChurrosAnswerDateResolvers<ContextType>;
  ChurrosAnswerFileUpload?: ChurrosAnswerFileUploadResolvers<ContextType>;
  ChurrosAnswerLongText?: ChurrosAnswerLongTextResolvers<ContextType>;
  ChurrosAnswerNumber?: ChurrosAnswerNumberResolvers<ContextType>;
  ChurrosAnswerScale?: ChurrosAnswerScaleResolvers<ContextType>;
  ChurrosAnswerSearchResult?: ChurrosAnswerSearchResultResolvers<ContextType>;
  ChurrosAnswerSelectMultiple?: ChurrosAnswerSelectMultipleResolvers<ContextType>;
  ChurrosAnswerSelectOne?: ChurrosAnswerSelectOneResolvers<ContextType>;
  ChurrosAnswerText?: ChurrosAnswerTextResolvers<ContextType>;
  ChurrosAnswerTime?: ChurrosAnswerTimeResolvers<ContextType>;
  ChurrosAnswersOfUser?: ChurrosAnswersOfUserResolvers<ContextType>;
  ChurrosApiRateLimitHits?: ChurrosApiRateLimitHitsResolvers<ContextType>;
  ChurrosApiUsage?: ChurrosApiUsageResolvers<ContextType>;
  ChurrosArticle?: ChurrosArticleResolvers<ContextType>;
  ChurrosArticleSearchResultType?: ChurrosArticleSearchResultTypeResolvers<ContextType>;
  ChurrosAwaitingValidationError?: ChurrosAwaitingValidationErrorResolvers<ContextType>;
  ChurrosBarWeek?: ChurrosBarWeekResolvers<ContextType>;
  ChurrosBooleanMap?: GraphQLScalarType;
  ChurrosBuildInfo?: ChurrosBuildInfoResolvers<ContextType>;
  ChurrosChangelogRelease?: ChurrosChangelogReleaseResolvers<ContextType>;
  ChurrosComment?: ChurrosCommentResolvers<ContextType>;
  ChurrosCommentable?: ChurrosCommentableResolvers<ContextType>;
  ChurrosCommentsConnection?: ChurrosCommentsConnectionResolvers<ContextType>;
  ChurrosCommentsEdge?: ChurrosCommentsEdgeResolvers<ContextType>;
  ChurrosCompleteSignupResult?: ChurrosCompleteSignupResultResolvers<ContextType>;
  ChurrosContributionOption?: ChurrosContributionOptionResolvers<ContextType>;
  ChurrosCounts?: GraphQLScalarType;
  ChurrosCredential?: ChurrosCredentialResolvers<ContextType>;
  ChurrosDatabaseHealthCheck?: ChurrosDatabaseHealthCheckResolvers<ContextType>;
  DateTime?: GraphQLScalarType;
  ChurrosDocument?: ChurrosDocumentResolvers<ContextType>;
  ChurrosDocumentSearchResult?: ChurrosDocumentSearchResultResolvers<ContextType>;
  ChurrosEmailChange?: ChurrosEmailChangeResolvers<ContextType>;
  ChurrosError?: ChurrosErrorResolvers<ContextType>;
  ChurrosErrorInterface?: ChurrosErrorInterfaceResolvers<ContextType>;
  ChurrosEvenSearchResult?: ChurrosEvenSearchResultResolvers<ContextType>;
  ChurrosEvent?: ChurrosEventResolvers<ContextType>;
  ChurrosEventBookingsConnection?: ChurrosEventBookingsConnectionResolvers<ContextType>;
  ChurrosEventBookingsConnectionEdge?: ChurrosEventBookingsConnectionEdgeResolvers<ContextType>;
  ChurrosEventBookingsCsvResult?: ChurrosEventBookingsCsvResultResolvers<ContextType>;
  ChurrosEventBookingsCsvSuccess?: ChurrosEventBookingsCsvSuccessResolvers<ContextType>;
  ChurrosEventLogsConnection?: ChurrosEventLogsConnectionResolvers<ContextType>;
  ChurrosEventLogsConnectionEdge?: ChurrosEventLogsConnectionEdgeResolvers<ContextType>;
  ChurrosEventManager?: ChurrosEventManagerResolvers<ContextType>;
  ChurrosEventMyBookingsResult?: ChurrosEventMyBookingsResultResolvers<ContextType>;
  ChurrosEventMyBookingsSuccess?: ChurrosEventMyBookingsSuccessResolvers<ContextType>;
  ChurrosEventsByDay?: ChurrosEventsByDayResolvers<ContextType>;
  ChurrosFamilyTree?: ChurrosFamilyTreeResolvers<ContextType>;
  ChurrosFile?: GraphQLScalarType;
  ChurrosForm?: ChurrosFormResolvers<ContextType>;
  ChurrosFormAnswersByUserConnection?: ChurrosFormAnswersByUserConnectionResolvers<ContextType>;
  ChurrosFormAnswersByUserConnectionEdge?: ChurrosFormAnswersByUserConnectionEdgeResolvers<ContextType>;
  ChurrosFormAnswersConnection?: ChurrosFormAnswersConnectionResolvers<ContextType>;
  ChurrosFormAnswersConnectionEdge?: ChurrosFormAnswersConnectionEdgeResolvers<ContextType>;
  ChurrosFormQuestionsConnection?: ChurrosFormQuestionsConnectionResolvers<ContextType>;
  ChurrosFormQuestionsConnectionEdge?: ChurrosFormQuestionsConnectionEdgeResolvers<ContextType>;
  ChurrosFormSearchResult?: ChurrosFormSearchResultResolvers<ContextType>;
  ChurrosFormSection?: ChurrosFormSectionResolvers<ContextType>;
  ChurrosFormSectionAnswersConnection?: ChurrosFormSectionAnswersConnectionResolvers<ContextType>;
  ChurrosFormSectionAnswersConnectionEdge?: ChurrosFormSectionAnswersConnectionEdgeResolvers<ContextType>;
  ChurrosGodparentRequest?: ChurrosGodparentRequestResolvers<ContextType>;
  ChurrosGroup?: ChurrosGroupResolvers<ContextType>;
  ChurrosGroupEventsConnection?: ChurrosGroupEventsConnectionResolvers<ContextType>;
  ChurrosGroupEventsConnectionEdge?: ChurrosGroupEventsConnectionEdgeResolvers<ContextType>;
  ChurrosGroupMember?: ChurrosGroupMemberResolvers<ContextType>;
  ChurrosGroupSearchResult?: ChurrosGroupSearchResultResolvers<ContextType>;
  ChurrosGroupShopItemsConnection?: ChurrosGroupShopItemsConnectionResolvers<ContextType>;
  ChurrosGroupShopItemsConnectionEdge?: ChurrosGroupShopItemsConnectionEdgeResolvers<ContextType>;
  ChurrosHealthCheck?: ChurrosHealthCheckResolvers<ContextType>;
  ChurrosIssue?: ChurrosIssueResolvers<ContextType>;
  ChurrosIssueComment?: ChurrosIssueCommentResolvers<ContextType>;
  ChurrosLdapHealthCheck?: ChurrosLdapHealthCheckResolvers<ContextType>;
  ChurrosLink?: ChurrosLinkResolvers<ContextType>;
  ChurrosLocalID?: GraphQLScalarType;
  ChurrosLogEntry?: ChurrosLogEntryResolvers<ContextType>;
  ChurrosLydiaAccount?: ChurrosLydiaAccountResolvers<ContextType>;
  ChurrosMailHealthCheck?: ChurrosMailHealthCheckResolvers<ContextType>;
  ChurrosMajor?: ChurrosMajorResolvers<ContextType>;
  ChurrosMinor?: ChurrosMinorResolvers<ContextType>;
  ChurrosMutationAcceptRegistrationResult?: ChurrosMutationAcceptRegistrationResultResolvers<ContextType>;
  ChurrosMutationAcceptRegistrationSuccess?: ChurrosMutationAcceptRegistrationSuccessResolvers<ContextType>;
  ChurrosMutationAddFileToPageResult?: ChurrosMutationAddFileToPageResultResolvers<ContextType>;
  ChurrosMutationAddFileToPageSuccess?: ChurrosMutationAddFileToPageSuccessResolvers<ContextType>;
  ChurrosMutationAddGroupMemberResult?: ChurrosMutationAddGroupMemberResultResolvers<ContextType>;
  ChurrosMutationAddGroupMemberSuccess?: ChurrosMutationAddGroupMemberSuccessResolvers<ContextType>;
  ChurrosMutationAnswerFormSectionResult?: ChurrosMutationAnswerFormSectionResultResolvers<ContextType>;
  ChurrosMutationAnswerFormSectionSuccess?: ChurrosMutationAnswerFormSectionSuccessResolvers<ContextType>;
  ChurrosMutationAuthorizeResult?: ChurrosMutationAuthorizeResultResolvers<ContextType>;
  ChurrosMutationAuthorizeSuccess?: ChurrosMutationAuthorizeSuccessResolvers<ContextType>;
  ChurrosMutationCancelRegistrationResult?: ChurrosMutationCancelRegistrationResultResolvers<ContextType>;
  ChurrosMutationCancelRegistrationSuccess?: ChurrosMutationCancelRegistrationSuccessResolvers<ContextType>;
  ChurrosMutationCompleteRegistrationResult?: ChurrosMutationCompleteRegistrationResultResolvers<ContextType>;
  ChurrosMutationCompleteRegistrationSuccess?: ChurrosMutationCompleteRegistrationSuccessResolvers<ContextType>;
  ChurrosMutationContributeResult?: ChurrosMutationContributeResultResolvers<ContextType>;
  ChurrosMutationContributeSuccess?: ChurrosMutationContributeSuccessResolvers<ContextType>;
  ChurrosMutationCreatePasswordResetResult?: ChurrosMutationCreatePasswordResetResultResolvers<ContextType>;
  ChurrosMutationCreatePasswordResetSuccess?: ChurrosMutationCreatePasswordResetSuccessResolvers<ContextType>;
  ChurrosMutationDeletePageResult?: ChurrosMutationDeletePageResultResolvers<ContextType>;
  ChurrosMutationDeletePageSuccess?: ChurrosMutationDeletePageSuccessResolvers<ContextType>;
  ChurrosMutationDeleteShopItemResult?: ChurrosMutationDeleteShopItemResultResolvers<ContextType>;
  ChurrosMutationDeleteShopItemSuccess?: ChurrosMutationDeleteShopItemSuccessResolvers<ContextType>;
  ChurrosMutationFinishPaypalRegistrationPaymentResult?: ChurrosMutationFinishPaypalRegistrationPaymentResultResolvers<ContextType>;
  ChurrosMutationFinishPaypalRegistrationPaymentSuccess?: ChurrosMutationFinishPaypalRegistrationPaymentSuccessResolvers<ContextType>;
  ChurrosMutationLoginResult?: ChurrosMutationLoginResultResolvers<ContextType>;
  ChurrosMutationLoginSuccess?: ChurrosMutationLoginSuccessResolvers<ContextType>;
  ChurrosMutationMailFormAnswersResult?: ChurrosMutationMailFormAnswersResultResolvers<ContextType>;
  ChurrosMutationMailFormAnswersSuccess?: ChurrosMutationMailFormAnswersSuccessResolvers<ContextType>;
  ChurrosMutationOpposeRegistrationResult?: ChurrosMutationOpposeRegistrationResultResolvers<ContextType>;
  ChurrosMutationOpposeRegistrationSuccess?: ChurrosMutationOpposeRegistrationSuccessResolvers<ContextType>;
  ChurrosMutationPaidRegistrationResult?: ChurrosMutationPaidRegistrationResultResolvers<ContextType>;
  ChurrosMutationPaidRegistrationSuccess?: ChurrosMutationPaidRegistrationSuccessResolvers<ContextType>;
  ChurrosMutationPaidShopPaymentResult?: ChurrosMutationPaidShopPaymentResultResolvers<ContextType>;
  ChurrosMutationPaidShopPaymentSuccess?: ChurrosMutationPaidShopPaymentSuccessResolvers<ContextType>;
  ChurrosMutationRegisterGoogleCredentialResult?: ChurrosMutationRegisterGoogleCredentialResultResolvers<ContextType>;
  ChurrosMutationRegisterGoogleCredentialSuccess?: ChurrosMutationRegisterGoogleCredentialSuccessResolvers<ContextType>;
  ChurrosMutationRemoveFileFromPageResult?: ChurrosMutationRemoveFileFromPageResultResolvers<ContextType>;
  ChurrosMutationRemoveFileFromPageSuccess?: ChurrosMutationRemoveFileFromPageSuccessResolvers<ContextType>;
  ChurrosMutationRequestEmailChangeResult?: ChurrosMutationRequestEmailChangeResultResolvers<ContextType>;
  ChurrosMutationRequestEmailChangeSuccess?: ChurrosMutationRequestEmailChangeSuccessResolvers<ContextType>;
  ChurrosMutationResetPasswordResult?: ChurrosMutationResetPasswordResultResolvers<ContextType>;
  ChurrosMutationResetPasswordSuccess?: ChurrosMutationResetPasswordSuccessResolvers<ContextType>;
  ChurrosMutationStartRegistrationResult?: ChurrosMutationStartRegistrationResultResolvers<ContextType>;
  ChurrosMutationStartRegistrationSuccess?: ChurrosMutationStartRegistrationSuccessResolvers<ContextType>;
  ChurrosMutationUpdateUserCandidateResult?: ChurrosMutationUpdateUserCandidateResultResolvers<ContextType>;
  ChurrosMutationUpdateUserCandidateSuccess?: ChurrosMutationUpdateUserCandidateSuccessResolvers<ContextType>;
  ChurrosMutationUpdateUserResult?: ChurrosMutationUpdateUserResultResolvers<ContextType>;
  ChurrosMutationUpdateUserSuccess?: ChurrosMutationUpdateUserSuccessResolvers<ContextType>;
  ChurrosMutationUpsertAnnouncementResult?: ChurrosMutationUpsertAnnouncementResultResolvers<ContextType>;
  ChurrosMutationUpsertAnnouncementSuccess?: ChurrosMutationUpsertAnnouncementSuccessResolvers<ContextType>;
  ChurrosMutationUpsertArticleResult?: ChurrosMutationUpsertArticleResultResolvers<ContextType>;
  ChurrosMutationUpsertArticleSuccess?: ChurrosMutationUpsertArticleSuccessResolvers<ContextType>;
  ChurrosMutationUpsertBarWeekResult?: ChurrosMutationUpsertBarWeekResultResolvers<ContextType>;
  ChurrosMutationUpsertBarWeekSuccess?: ChurrosMutationUpsertBarWeekSuccessResolvers<ContextType>;
  ChurrosMutationUpsertDocumentResult?: ChurrosMutationUpsertDocumentResultResolvers<ContextType>;
  ChurrosMutationUpsertDocumentSuccess?: ChurrosMutationUpsertDocumentSuccessResolvers<ContextType>;
  ChurrosMutationUpsertEventResult?: ChurrosMutationUpsertEventResultResolvers<ContextType>;
  ChurrosMutationUpsertEventSuccess?: ChurrosMutationUpsertEventSuccessResolvers<ContextType>;
  ChurrosMutationUpsertGodparentRequestResult?: ChurrosMutationUpsertGodparentRequestResultResolvers<ContextType>;
  ChurrosMutationUpsertGodparentRequestSuccess?: ChurrosMutationUpsertGodparentRequestSuccessResolvers<ContextType>;
  ChurrosMutationUpsertGroupResult?: ChurrosMutationUpsertGroupResultResolvers<ContextType>;
  ChurrosMutationUpsertGroupSuccess?: ChurrosMutationUpsertGroupSuccessResolvers<ContextType>;
  ChurrosMutationUpsertPageResult?: ChurrosMutationUpsertPageResultResolvers<ContextType>;
  ChurrosMutationUpsertPageSuccess?: ChurrosMutationUpsertPageSuccessResolvers<ContextType>;
  ChurrosMutationUpsertRegistrationResult?: ChurrosMutationUpsertRegistrationResultResolvers<ContextType>;
  ChurrosMutationUpsertRegistrationSuccess?: ChurrosMutationUpsertRegistrationSuccessResolvers<ContextType>;
  ChurrosMutationUpsertServiceResult?: ChurrosMutationUpsertServiceResultResolvers<ContextType>;
  ChurrosMutationUpsertServiceSuccess?: ChurrosMutationUpsertServiceSuccessResolvers<ContextType>;
  ChurrosMutationUpsertShopItemResult?: ChurrosMutationUpsertShopItemResultResolvers<ContextType>;
  ChurrosMutationUpsertShopItemSuccess?: ChurrosMutationUpsertShopItemSuccessResolvers<ContextType>;
  ChurrosMutationUpsertShopPaymentResult?: ChurrosMutationUpsertShopPaymentResultResolvers<ContextType>;
  ChurrosMutationUpsertShopPaymentSuccess?: ChurrosMutationUpsertShopPaymentSuccessResolvers<ContextType>;
  ChurrosMutationUsePasswordResetResult?: ChurrosMutationUsePasswordResetResultResolvers<ContextType>;
  ChurrosMutationUsePasswordResetSuccess?: ChurrosMutationUsePasswordResetSuccessResolvers<ContextType>;
  ChurrosMutationValidateEmailResult?: ChurrosMutationValidateEmailResultResolvers<ContextType>;
  ChurrosMutationValidateEmailSuccess?: ChurrosMutationValidateEmailSuccessResolvers<ContextType>;
  ChurrosMutationVerifyBookingResult?: ChurrosMutationVerifyBookingResultResolvers<ContextType>;
  ChurrosMutationVerifyBookingSuccess?: ChurrosMutationVerifyBookingSuccessResolvers<ContextType>;
  ChurrosNode?: ChurrosNodeResolvers<ContextType>;
  ChurrosNotFoundError?: ChurrosNotFoundErrorResolvers<ContextType>;
  ChurrosNotification?: ChurrosNotificationResolvers<ContextType>;
  ChurrosNotificationSubscription?: ChurrosNotificationSubscriptionResolvers<ContextType>;
  ChurrosOAuth2Error?: ChurrosOAuth2ErrorResolvers<ContextType>;
  ChurrosPage?: ChurrosPageResolvers<ContextType>;
  ChurrosPageInfo?: ChurrosPageInfoResolvers<ContextType>;
  ChurrosPagesConnection?: ChurrosPagesConnectionResolvers<ContextType>;
  ChurrosPagesEdge?: ChurrosPagesEdgeResolvers<ContextType>;
  ChurrosPicture?: ChurrosPictureResolvers<ContextType>;
  ChurrosPictured?: ChurrosPicturedResolvers<ContextType>;
  ChurrosProfitsBreakdown?: ChurrosProfitsBreakdownResolvers<ContextType>;
  ChurrosProfitsBreakdownByPaymentMethod?: ChurrosProfitsBreakdownByPaymentMethodResolvers<ContextType>;
  ChurrosProfitsBreakdownByTicket?: ChurrosProfitsBreakdownByTicketResolvers<ContextType>;
  ChurrosQRCode?: ChurrosQRCodeResolvers<ContextType>;
  ChurrosQueryAllFormsConnection?: ChurrosQueryAllFormsConnectionResolvers<ContextType>;
  ChurrosQueryAllFormsConnectionEdge?: ChurrosQueryAllFormsConnectionEdgeResolvers<ContextType>;
  ChurrosQueryAllUsersConnection?: ChurrosQueryAllUsersConnectionResolvers<ContextType>;
  ChurrosQueryAllUsersConnectionEdge?: ChurrosQueryAllUsersConnectionEdgeResolvers<ContextType>;
  ChurrosQueryAnnouncementsConnection?: ChurrosQueryAnnouncementsConnectionResolvers<ContextType>;
  ChurrosQueryAnnouncementsConnectionEdge?: ChurrosQueryAnnouncementsConnectionEdgeResolvers<ContextType>;
  ChurrosQueryCodeContributorsResult?: ChurrosQueryCodeContributorsResultResolvers<ContextType>;
  ChurrosQueryCodeContributorsSuccess?: ChurrosQueryCodeContributorsSuccessResolvers<ContextType>;
  ChurrosQueryCombinedChangelogResult?: ChurrosQueryCombinedChangelogResultResolvers<ContextType>;
  ChurrosQueryCombinedChangelogSuccess?: ChurrosQueryCombinedChangelogSuccessResolvers<ContextType>;
  ChurrosQueryDocumentsConnection?: ChurrosQueryDocumentsConnectionResolvers<ContextType>;
  ChurrosQueryDocumentsConnectionEdge?: ChurrosQueryDocumentsConnectionEdgeResolvers<ContextType>;
  ChurrosQueryEventsByDayConnection?: ChurrosQueryEventsByDayConnectionResolvers<ContextType>;
  ChurrosQueryEventsByDayConnectionEdge?: ChurrosQueryEventsByDayConnectionEdgeResolvers<ContextType>;
  ChurrosQueryEventsConnection?: ChurrosQueryEventsConnectionResolvers<ContextType>;
  ChurrosQueryEventsConnectionEdge?: ChurrosQueryEventsConnectionEdgeResolvers<ContextType>;
  ChurrosQueryFormsConnection?: ChurrosQueryFormsConnectionResolvers<ContextType>;
  ChurrosQueryFormsConnectionEdge?: ChurrosQueryFormsConnectionEdgeResolvers<ContextType>;
  ChurrosQueryGroupMembersCsvResult?: ChurrosQueryGroupMembersCsvResultResolvers<ContextType>;
  ChurrosQueryGroupMembersCsvSuccess?: ChurrosQueryGroupMembersCsvSuccessResolvers<ContextType>;
  ChurrosQueryHomepageConnection?: ChurrosQueryHomepageConnectionResolvers<ContextType>;
  ChurrosQueryHomepageConnectionEdge?: ChurrosQueryHomepageConnectionEdgeResolvers<ContextType>;
  ChurrosQueryLogsConnection?: ChurrosQueryLogsConnectionResolvers<ContextType>;
  ChurrosQueryLogsConnectionEdge?: ChurrosQueryLogsConnectionEdgeResolvers<ContextType>;
  ChurrosQueryMinorsConnection?: ChurrosQueryMinorsConnectionResolvers<ContextType>;
  ChurrosQueryMinorsConnectionEdge?: ChurrosQueryMinorsConnectionEdgeResolvers<ContextType>;
  ChurrosQueryNotificationsConnection?: ChurrosQueryNotificationsConnectionResolvers<ContextType>;
  ChurrosQueryNotificationsConnectionEdge?: ChurrosQueryNotificationsConnectionEdgeResolvers<ContextType>;
  ChurrosQueryPagesConnection?: ChurrosQueryPagesConnectionResolvers<ContextType>;
  ChurrosQueryPagesConnectionEdge?: ChurrosQueryPagesConnectionEdgeResolvers<ContextType>;
  ChurrosQueryQuickSignupsConnection?: ChurrosQueryQuickSignupsConnectionResolvers<ContextType>;
  ChurrosQueryQuickSignupsConnectionEdge?: ChurrosQueryQuickSignupsConnectionEdgeResolvers<ContextType>;
  ChurrosQueryReactionsConnection?: ChurrosQueryReactionsConnectionResolvers<ContextType>;
  ChurrosQueryReactionsConnectionEdge?: ChurrosQueryReactionsConnectionEdgeResolvers<ContextType>;
  ChurrosQueryRegistrationResult?: ChurrosQueryRegistrationResultResolvers<ContextType>;
  ChurrosQueryRegistrationSuccess?: ChurrosQueryRegistrationSuccessResolvers<ContextType>;
  ChurrosQueryRegistrationsOfUserConnection?: ChurrosQueryRegistrationsOfUserConnectionResolvers<ContextType>;
  ChurrosQueryRegistrationsOfUserConnectionEdge?: ChurrosQueryRegistrationsOfUserConnectionEdgeResolvers<ContextType>;
  ChurrosQueryUpcomingChangelogResult?: ChurrosQueryUpcomingChangelogResultResolvers<ContextType>;
  ChurrosQueryUpcomingChangelogSuccess?: ChurrosQueryUpcomingChangelogSuccessResolvers<ContextType>;
  ChurrosQueryUserCandidatesConnection?: ChurrosQueryUserCandidatesConnectionResolvers<ContextType>;
  ChurrosQueryUserCandidatesConnectionEdge?: ChurrosQueryUserCandidatesConnectionEdgeResolvers<ContextType>;
  ChurrosQuestion?: ChurrosQuestionResolvers<ContextType>;
  ChurrosQuestionAnswersConnection?: ChurrosQuestionAnswersConnectionResolvers<ContextType>;
  ChurrosQuestionAnswersConnectionEdge?: ChurrosQuestionAnswersConnectionEdgeResolvers<ContextType>;
  ChurrosQuestionFileUpload?: ChurrosQuestionFileUploadResolvers<ContextType>;
  ChurrosQuestionScalar?: ChurrosQuestionScalarResolvers<ContextType>;
  ChurrosQuestionScale?: ChurrosQuestionScaleResolvers<ContextType>;
  ChurrosQuestionSelectMultiple?: ChurrosQuestionSelectMultipleResolvers<ContextType>;
  ChurrosQuestionSelectOne?: ChurrosQuestionSelectOneResolvers<ContextType>;
  ChurrosQuickSignup?: ChurrosQuickSignupResolvers<ContextType>;
  ChurrosReactable?: ChurrosReactableResolvers<ContextType>;
  ChurrosReaction?: ChurrosReactionResolvers<ContextType>;
  ChurrosRedisHealthCheck?: ChurrosRedisHealthCheckResolvers<ContextType>;
  ChurrosRegistration?: ChurrosRegistrationResolvers<ContextType>;
  ChurrosRegistrationSearchResult?: ChurrosRegistrationSearchResultResolvers<ContextType>;
  ChurrosRegistrationVerificationResult?: ChurrosRegistrationVerificationResultResolvers<ContextType>;
  ChurrosRegistrationsCounts?: ChurrosRegistrationsCountsResolvers<ContextType>;
  ChurrosReleaseChange?: ChurrosReleaseChangeResolvers<ContextType>;
  ChurrosReleaseChangesMaps?: ChurrosReleaseChangesMapsResolvers<ContextType>;
  ChurrosSchool?: ChurrosSchoolResolvers<ContextType>;
  ChurrosSchoolGroup?: ChurrosSchoolGroupResolvers<ContextType>;
  ChurrosService?: ChurrosServiceResolvers<ContextType>;
  ChurrosShopItem?: ChurrosShopItemResolvers<ContextType>;
  ChurrosShopItemAnswer?: ChurrosShopItemAnswerResolvers<ContextType>;
  ChurrosShopItemOption?: ChurrosShopItemOptionResolvers<ContextType>;
  ChurrosShopPayment?: ChurrosShopPaymentResolvers<ContextType>;
  ChurrosStringToIntMapping?: ChurrosStringToIntMappingResolvers<ContextType>;
  ChurrosStudentAssociation?: ChurrosStudentAssociationResolvers<ContextType>;
  ChurrosStudentAssociationGroupsConnection?: ChurrosStudentAssociationGroupsConnectionResolvers<ContextType>;
  ChurrosStudentAssociationGroupsConnectionEdge?: ChurrosStudentAssociationGroupsConnectionEdgeResolvers<ContextType>;
  ChurrosSubject?: ChurrosSubjectResolvers<ContextType>;
  ChurrosSubjectDocumentsConnection?: ChurrosSubjectDocumentsConnectionResolvers<ContextType>;
  ChurrosSubjectDocumentsConnectionEdge?: ChurrosSubjectDocumentsConnectionEdgeResolvers<ContextType>;
  ChurrosSubscriptionRegistrationResult?: ChurrosSubscriptionRegistrationResultResolvers<ContextType>;
  ChurrosSubscriptionRegistrationSuccess?: ChurrosSubscriptionRegistrationSuccessResolvers<ContextType>;
  ChurrosTeachingUnit?: ChurrosTeachingUnitResolvers<ContextType>;
  ChurrosThirdPartyApp?: ChurrosThirdPartyAppResolvers<ContextType>;
  ChurrosThirdPartyAppApiUsageConnection?: ChurrosThirdPartyAppApiUsageConnectionResolvers<ContextType>;
  ChurrosThirdPartyAppApiUsageConnectionEdge?: ChurrosThirdPartyAppApiUsageConnectionEdgeResolvers<ContextType>;
  ChurrosThirdPartyAppLogsConnection?: ChurrosThirdPartyAppLogsConnectionResolvers<ContextType>;
  ChurrosThirdPartyAppLogsConnectionEdge?: ChurrosThirdPartyAppLogsConnectionEdgeResolvers<ContextType>;
  ChurrosThirdPartyAppRateLimitHitsConnection?: ChurrosThirdPartyAppRateLimitHitsConnectionResolvers<ContextType>;
  ChurrosThirdPartyAppRateLimitHitsConnectionEdge?: ChurrosThirdPartyAppRateLimitHitsConnectionEdgeResolvers<ContextType>;
  ChurrosThirdPartyAppRegistrationResponse?: ChurrosThirdPartyAppRegistrationResponseResolvers<ContextType>;
  ChurrosThirdPartyAppUsersConnection?: ChurrosThirdPartyAppUsersConnectionResolvers<ContextType>;
  ChurrosThirdPartyAppUsersConnectionEdge?: ChurrosThirdPartyAppUsersConnectionEdgeResolvers<ContextType>;
  ChurrosTicket?: ChurrosTicketResolvers<ContextType>;
  ChurrosTicketGroup?: ChurrosTicketGroupResolvers<ContextType>;
  ChurrosUID?: GraphQLScalarType;
  ChurrosUser?: ChurrosUserResolvers<ContextType>;
  ChurrosUserAnsweredFormsConnection?: ChurrosUserAnsweredFormsConnectionResolvers<ContextType>;
  ChurrosUserAnsweredFormsConnectionEdge?: ChurrosUserAnsweredFormsConnectionEdgeResolvers<ContextType>;
  ChurrosUserArticlesConnection?: ChurrosUserArticlesConnectionResolvers<ContextType>;
  ChurrosUserArticlesConnectionEdge?: ChurrosUserArticlesConnectionEdgeResolvers<ContextType>;
  ChurrosUserBookingsConnection?: ChurrosUserBookingsConnectionResolvers<ContextType>;
  ChurrosUserBookingsConnectionEdge?: ChurrosUserBookingsConnectionEdgeResolvers<ContextType>;
  ChurrosUserCandidate?: ChurrosUserCandidateResolvers<ContextType>;
  ChurrosUserPartiallyAnsweredFormsConnection?: ChurrosUserPartiallyAnsweredFormsConnectionResolvers<ContextType>;
  ChurrosUserPartiallyAnsweredFormsConnectionEdge?: ChurrosUserPartiallyAnsweredFormsConnectionEdgeResolvers<ContextType>;
  ChurrosUserSearchResult?: ChurrosUserSearchResultResolvers<ContextType>;
  ChurrosZodError?: ChurrosZodErrorResolvers<ContextType>;
  ChurrosZodFieldError?: ChurrosZodFieldErrorResolvers<ContextType>;
  Mutation?: MutationResolvers<ContextType>;
  AdminAppsListResponse?: AdminAppsListResponseResolvers<ContextType>;
  App?: AppResolvers<ContextType>;
  ValidationError?: ValidationErrorResolvers<ContextType>;
  JSON?: GraphQLScalarType;
  GenericError?: GenericErrorResolvers<ContextType>;
  AdminMetricsRetrieveResponse?: AdminMetricsRetrieveResponseResolvers<ContextType>;
  LoginMetrics?: LoginMetricsResolvers<ContextType>;
  Coordinate?: CoordinateResolvers<ContextType>;
  AdminModelsListResponse?: AdminModelsListResponseResolvers<ContextType>;
  AdminSettingsRetrieveResponse?: AdminSettingsRetrieveResponseResolvers<ContextType>;
  Settings?: SettingsResolvers<ContextType>;
  PositiveInt?: GraphQLScalarType;
  AdminSystemRetrieveResponse?: AdminSystemRetrieveResponseResolvers<ContextType>;
  SystemInfo?: SystemInfoResolvers<ContextType>;
  QueryAdminSystemRetrieveOneOf_0Runtime?: QueryAdminSystemRetrieveOneOf_0RuntimeResolvers<ContextType>;
  AdminVersionRetrieveResponse?: AdminVersionRetrieveResponseResolvers<ContextType>;
  Version?: VersionResolvers<ContextType>;
  AdminWorkersRetrieveResponse?: AdminWorkersRetrieveResponseResolvers<ContextType>;
  Workers?: WorkersResolvers<ContextType>;
  AuthenticatorsAdminAllListResponse?: AuthenticatorsAdminAllListResponseResolvers<ContextType>;
  Device?: DeviceResolvers<ContextType>;
  AuthenticatorsAdminDuoListResponse?: AuthenticatorsAdminDuoListResponseResolvers<ContextType>;
  PaginatedDuoDeviceList?: PaginatedDuoDeviceListResolvers<ContextType>;
  Pagination?: PaginationResolvers<ContextType>;
  DuoDevice?: DuoDeviceResolvers<ContextType>;
  QueryAuthenticatorsAdminDuoListOneOf_0ResultsItemsName?: GraphQLScalarType;
  AuthenticatorsAdminDuoRetrieveResponse?: AuthenticatorsAdminDuoRetrieveResponseResolvers<ContextType>;
  AuthenticatorsAdminSmsListResponse?: AuthenticatorsAdminSmsListResponseResolvers<ContextType>;
  PaginatedSmsDeviceList?: PaginatedSmsDeviceListResolvers<ContextType>;
  SmsDevice?: SmsDeviceResolvers<ContextType>;
  QueryAuthenticatorsAdminSmsListOneOf_0ResultsItemsName?: GraphQLScalarType;
  AuthenticatorsAdminSmsRetrieveResponse?: AuthenticatorsAdminSmsRetrieveResponseResolvers<ContextType>;
  AuthenticatorsAdminStaticListResponse?: AuthenticatorsAdminStaticListResponseResolvers<ContextType>;
  PaginatedStaticDeviceList?: PaginatedStaticDeviceListResolvers<ContextType>;
  StaticDevice?: StaticDeviceResolvers<ContextType>;
  QueryAuthenticatorsAdminStaticListOneOf_0ResultsItemsName?: GraphQLScalarType;
  StaticDeviceToken?: StaticDeviceTokenResolvers<ContextType>;
  QueryAuthenticatorsAdminStaticListOneOf_0ResultsItemsTokenSetItemsToken?: GraphQLScalarType;
  AuthenticatorsAdminStaticRetrieveResponse?: AuthenticatorsAdminStaticRetrieveResponseResolvers<ContextType>;
  AuthenticatorsAdminTotpListResponse?: AuthenticatorsAdminTotpListResponseResolvers<ContextType>;
  PaginatedTotpDeviceList?: PaginatedTotpDeviceListResolvers<ContextType>;
  TotpDevice?: TotpDeviceResolvers<ContextType>;
  QueryAuthenticatorsAdminTotpListOneOf_0ResultsItemsName?: GraphQLScalarType;
  AuthenticatorsAdminTotpRetrieveResponse?: AuthenticatorsAdminTotpRetrieveResponseResolvers<ContextType>;
  AuthenticatorsAdminWebauthnListResponse?: AuthenticatorsAdminWebauthnListResponseResolvers<ContextType>;
  PaginatedWebAuthnDeviceList?: PaginatedWebAuthnDeviceListResolvers<ContextType>;
  WebAuthnDevice?: WebAuthnDeviceResolvers<ContextType>;
  QueryAuthenticatorsAdminWebauthnListOneOf_0ResultsItemsName?: GraphQLScalarType;
  WebAuthnDeviceType?: WebAuthnDeviceTypeResolvers<ContextType>;
  UUID?: GraphQLScalarType;
  AuthenticatorsAdminWebauthnRetrieveResponse?: AuthenticatorsAdminWebauthnRetrieveResponseResolvers<ContextType>;
  AuthenticatorsAllListResponse?: AuthenticatorsAllListResponseResolvers<ContextType>;
  AuthenticatorsDuoListResponse?: AuthenticatorsDuoListResponseResolvers<ContextType>;
  AuthenticatorsDuoRetrieveResponse?: AuthenticatorsDuoRetrieveResponseResolvers<ContextType>;
  AuthenticatorsDuoUsedByListResponse?: AuthenticatorsDuoUsedByListResponseResolvers<ContextType>;
  UsedBy?: UsedByResolvers<ContextType>;
  AuthenticatorsSmsListResponse?: AuthenticatorsSmsListResponseResolvers<ContextType>;
  AuthenticatorsSmsRetrieveResponse?: AuthenticatorsSmsRetrieveResponseResolvers<ContextType>;
  AuthenticatorsSmsUsedByListResponse?: AuthenticatorsSmsUsedByListResponseResolvers<ContextType>;
  AuthenticatorsStaticListResponse?: AuthenticatorsStaticListResponseResolvers<ContextType>;
  AuthenticatorsStaticRetrieveResponse?: AuthenticatorsStaticRetrieveResponseResolvers<ContextType>;
  AuthenticatorsStaticUsedByListResponse?: AuthenticatorsStaticUsedByListResponseResolvers<ContextType>;
  AuthenticatorsTotpListResponse?: AuthenticatorsTotpListResponseResolvers<ContextType>;
  AuthenticatorsTotpRetrieveResponse?: AuthenticatorsTotpRetrieveResponseResolvers<ContextType>;
  AuthenticatorsTotpUsedByListResponse?: AuthenticatorsTotpUsedByListResponseResolvers<ContextType>;
  AuthenticatorsWebauthnListResponse?: AuthenticatorsWebauthnListResponseResolvers<ContextType>;
  AuthenticatorsWebauthnRetrieveResponse?: AuthenticatorsWebauthnRetrieveResponseResolvers<ContextType>;
  AuthenticatorsWebauthnUsedByListResponse?: AuthenticatorsWebauthnUsedByListResponseResolvers<ContextType>;
  CoreApplicationsListResponse?: CoreApplicationsListResponseResolvers<ContextType>;
  PaginatedApplicationList?: PaginatedApplicationListResolvers<ContextType>;
  Application?: ApplicationResolvers<ContextType>;
  QueryCoreApplicationsListOneOf_0ResultsItemsSlug?: GraphQLScalarType;
  Provider?: ProviderResolvers<ContextType>;
  URL?: GraphQLScalarType;
  CoreApplicationsRetrieveResponse?: CoreApplicationsRetrieveResponseResolvers<ContextType>;
  CoreApplicationsCheckAccessRetrieveResponse?: CoreApplicationsCheckAccessRetrieveResponseResolvers<ContextType>;
  PolicyTestResult?: PolicyTestResultResolvers<ContextType>;
  LogEvent?: LogEventResolvers<ContextType>;
  CoreApplicationsMetricsListResponse?: CoreApplicationsMetricsListResponseResolvers<ContextType>;
  CoreApplicationsUsedByListResponse?: CoreApplicationsUsedByListResponseResolvers<ContextType>;
  CoreAuthenticatedSessionsListResponse?: CoreAuthenticatedSessionsListResponseResolvers<ContextType>;
  PaginatedAuthenticatedSessionList?: PaginatedAuthenticatedSessionListResolvers<ContextType>;
  AuthenticatedSession?: AuthenticatedSessionResolvers<ContextType>;
  QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgent?: QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentResolvers<ContextType>;
  QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentDevice?: QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentDeviceResolvers<ContextType>;
  QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentOs?: QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentOsResolvers<ContextType>;
  QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentUserAgent?: QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentUserAgentResolvers<ContextType>;
  QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsGeoIp?: QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsGeoIpResolvers<ContextType>;
  QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsAsn?: QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsAsnResolvers<ContextType>;
  CoreAuthenticatedSessionsRetrieveResponse?: CoreAuthenticatedSessionsRetrieveResponseResolvers<ContextType>;
  CoreAuthenticatedSessionsUsedByListResponse?: CoreAuthenticatedSessionsUsedByListResponseResolvers<ContextType>;
  CoreBrandsListResponse?: CoreBrandsListResponseResolvers<ContextType>;
  PaginatedBrandList?: PaginatedBrandListResolvers<ContextType>;
  Brand?: BrandResolvers<ContextType>;
  CoreBrandsRetrieveResponse?: CoreBrandsRetrieveResponseResolvers<ContextType>;
  CoreBrandsUsedByListResponse?: CoreBrandsUsedByListResponseResolvers<ContextType>;
  CoreBrandsCurrentRetrieveResponse?: CoreBrandsCurrentRetrieveResponseResolvers<ContextType>;
  CurrentBrand?: CurrentBrandResolvers<ContextType>;
  FooterLink?: FooterLinkResolvers<ContextType>;
  CoreGroupsListResponse?: CoreGroupsListResponseResolvers<ContextType>;
  PaginatedGroupList?: PaginatedGroupListResolvers<ContextType>;
  Group?: GroupResolvers<ContextType>;
  QueryCoreGroupsListOneOf_0ResultsItemsName?: GraphQLScalarType;
  GroupMember?: GroupMemberResolvers<ContextType>;
  QueryCoreGroupsListOneOf_0ResultsItemsUsersObjItemsUsername?: GraphQLScalarType;
  EmailAddress?: GraphQLScalarType;
  Role?: RoleResolvers<ContextType>;
  QueryCoreGroupsListOneOf_0ResultsItemsRolesObjItemsName?: GraphQLScalarType;
  CoreGroupsRetrieveResponse?: CoreGroupsRetrieveResponseResolvers<ContextType>;
  CoreGroupsUsedByListResponse?: CoreGroupsUsedByListResponseResolvers<ContextType>;
  CoreTokensListResponse?: CoreTokensListResponseResolvers<ContextType>;
  PaginatedTokenList?: PaginatedTokenListResolvers<ContextType>;
  Token?: TokenResolvers<ContextType>;
  QueryCoreTokensListOneOf_0ResultsItemsIdentifier?: GraphQLScalarType;
  User?: UserResolvers<ContextType>;
  QueryCoreTokensListOneOf_0ResultsItemsUserObjUsername?: GraphQLScalarType;
  UserGroup?: UserGroupResolvers<ContextType>;
  QueryCoreTokensListOneOf_0ResultsItemsUserObjGroupsObjItemsName?: GraphQLScalarType;
  CoreTokensRetrieveResponse?: CoreTokensRetrieveResponseResolvers<ContextType>;
  CoreTokensUsedByListResponse?: CoreTokensUsedByListResponseResolvers<ContextType>;
  CoreTokensViewKeyRetrieveResponse?: CoreTokensViewKeyRetrieveResponseResolvers<ContextType>;
  TokenView?: TokenViewResolvers<ContextType>;
  CoreUserConsentListResponse?: CoreUserConsentListResponseResolvers<ContextType>;
  PaginatedUserConsentList?: PaginatedUserConsentListResolvers<ContextType>;
  UserConsent?: UserConsentResolvers<ContextType>;
  CoreUserConsentRetrieveResponse?: CoreUserConsentRetrieveResponseResolvers<ContextType>;
  CoreUserConsentUsedByListResponse?: CoreUserConsentUsedByListResponseResolvers<ContextType>;
  CoreUsersListResponse?: CoreUsersListResponseResolvers<ContextType>;
  PaginatedUserList?: PaginatedUserListResolvers<ContextType>;
  CoreUsersRetrieveResponse?: CoreUsersRetrieveResponseResolvers<ContextType>;
  CoreUsersMetricsRetrieveResponse?: CoreUsersMetricsRetrieveResponseResolvers<ContextType>;
  UserMetrics?: UserMetricsResolvers<ContextType>;
  CoreUsersUsedByListResponse?: CoreUsersUsedByListResponseResolvers<ContextType>;
  CoreUsersImpersonateEndRetrieveResponse?: CoreUsersImpersonateEndRetrieveResponseResolvers<ContextType>;
  VoidContainer?: VoidContainerResolvers<ContextType>;
  Void?: GraphQLScalarType;
  CoreUsersMeRetrieveResponse?: CoreUsersMeRetrieveResponseResolvers<ContextType>;
  SessionUser?: SessionUserResolvers<ContextType>;
  UserSelf?: UserSelfResolvers<ContextType>;
  QueryCoreUsersMeRetrieveOneOf_0UserUsername?: GraphQLScalarType;
  UserSelfGroups?: UserSelfGroupsResolvers<ContextType>;
  CoreUsersPathsRetrieveResponse?: CoreUsersPathsRetrieveResponseResolvers<ContextType>;
  UserPath?: UserPathResolvers<ContextType>;
  CryptoCertificatekeypairsListResponse?: CryptoCertificatekeypairsListResponseResolvers<ContextType>;
  PaginatedCertificateKeyPairList?: PaginatedCertificateKeyPairListResolvers<ContextType>;
  CertificateKeyPair?: CertificateKeyPairResolvers<ContextType>;
  CryptoCertificatekeypairsRetrieveResponse?: CryptoCertificatekeypairsRetrieveResponseResolvers<ContextType>;
  CryptoCertificatekeypairsUsedByListResponse?: CryptoCertificatekeypairsUsedByListResponseResolvers<ContextType>;
  CryptoCertificatekeypairsViewCertificateRetrieveResponse?: CryptoCertificatekeypairsViewCertificateRetrieveResponseResolvers<ContextType>;
  CertificateData?: CertificateDataResolvers<ContextType>;
  CryptoCertificatekeypairsViewPrivateKeyRetrieveResponse?: CryptoCertificatekeypairsViewPrivateKeyRetrieveResponseResolvers<ContextType>;
  EnterpriseLicenseListResponse?: EnterpriseLicenseListResponseResolvers<ContextType>;
  PaginatedLicenseList?: PaginatedLicenseListResolvers<ContextType>;
  License?: LicenseResolvers<ContextType>;
  EnterpriseLicenseRetrieveResponse?: EnterpriseLicenseRetrieveResponseResolvers<ContextType>;
  EnterpriseLicenseUsedByListResponse?: EnterpriseLicenseUsedByListResponseResolvers<ContextType>;
  EnterpriseLicenseForecastRetrieveResponse?: EnterpriseLicenseForecastRetrieveResponseResolvers<ContextType>;
  LicenseForecast?: LicenseForecastResolvers<ContextType>;
  EnterpriseLicenseGetInstallIdRetrieveResponse?: EnterpriseLicenseGetInstallIdRetrieveResponseResolvers<ContextType>;
  InstallId?: InstallIdResolvers<ContextType>;
  EnterpriseLicenseSummaryRetrieveResponse?: EnterpriseLicenseSummaryRetrieveResponseResolvers<ContextType>;
  LicenseSummary?: LicenseSummaryResolvers<ContextType>;
  EventsEventsListResponse?: EventsEventsListResponseResolvers<ContextType>;
  PaginatedEventList?: PaginatedEventListResolvers<ContextType>;
  Event?: EventResolvers<ContextType>;
  EventsEventsRetrieveResponse?: EventsEventsRetrieveResponseResolvers<ContextType>;
  EventsEventsActionsListResponse?: EventsEventsActionsListResponseResolvers<ContextType>;
  TypeCreate?: TypeCreateResolvers<ContextType>;
  EventsEventsPerMonthListResponse?: EventsEventsPerMonthListResponseResolvers<ContextType>;
  EventsEventsTopPerUserListResponse?: EventsEventsTopPerUserListResponseResolvers<ContextType>;
  EventTopPerUser?: EventTopPerUserResolvers<ContextType>;
  EventsEventsVolumeListResponse?: EventsEventsVolumeListResponseResolvers<ContextType>;
  EventsNotificationsListResponse?: EventsNotificationsListResponseResolvers<ContextType>;
  PaginatedNotificationList?: PaginatedNotificationListResolvers<ContextType>;
  Notification?: NotificationResolvers<ContextType>;
  EventsNotificationsRetrieveResponse?: EventsNotificationsRetrieveResponseResolvers<ContextType>;
  EventsNotificationsUsedByListResponse?: EventsNotificationsUsedByListResponseResolvers<ContextType>;
  EventsRulesListResponse?: EventsRulesListResponseResolvers<ContextType>;
  PaginatedNotificationRuleList?: PaginatedNotificationRuleListResolvers<ContextType>;
  NotificationRule?: NotificationRuleResolvers<ContextType>;
  EventsRulesRetrieveResponse?: EventsRulesRetrieveResponseResolvers<ContextType>;
  EventsRulesUsedByListResponse?: EventsRulesUsedByListResponseResolvers<ContextType>;
  EventsSystemTasksListResponse?: EventsSystemTasksListResponseResolvers<ContextType>;
  PaginatedSystemTaskList?: PaginatedSystemTaskListResolvers<ContextType>;
  SystemTask?: SystemTaskResolvers<ContextType>;
  EventsSystemTasksRetrieveResponse?: EventsSystemTasksRetrieveResponseResolvers<ContextType>;
  EventsTransportsListResponse?: EventsTransportsListResponseResolvers<ContextType>;
  PaginatedNotificationTransportList?: PaginatedNotificationTransportListResolvers<ContextType>;
  NotificationTransport?: NotificationTransportResolvers<ContextType>;
  EventsTransportsRetrieveResponse?: EventsTransportsRetrieveResponseResolvers<ContextType>;
  EventsTransportsUsedByListResponse?: EventsTransportsUsedByListResponseResolvers<ContextType>;
  FlowsBindingsListResponse?: FlowsBindingsListResponseResolvers<ContextType>;
  PaginatedFlowStageBindingList?: PaginatedFlowStageBindingListResolvers<ContextType>;
  FlowStageBinding?: FlowStageBindingResolvers<ContextType>;
  Stage?: StageResolvers<ContextType>;
  FlowSet?: FlowSetResolvers<ContextType>;
  QueryFlowsBindingsListOneOf_0ResultsItemsStageObjFlowSetItemsSlug?: GraphQLScalarType;
  FlowsBindingsRetrieveResponse?: FlowsBindingsRetrieveResponseResolvers<ContextType>;
  FlowsBindingsUsedByListResponse?: FlowsBindingsUsedByListResponseResolvers<ContextType>;
  FlowsExecutorGetResponse?: FlowsExecutorGetResponseResolvers<ContextType>;
  AccessDeniedChallenge?: AccessDeniedChallengeResolvers<ContextType>;
  ContextualFlowInfo?: ContextualFlowInfoResolvers<ContextType>;
  AppleLoginChallenge?: AppleLoginChallengeResolvers<ContextType>;
  AuthenticatorDuoChallenge?: AuthenticatorDuoChallengeResolvers<ContextType>;
  AuthenticatorSmsChallenge?: AuthenticatorSmsChallengeResolvers<ContextType>;
  AuthenticatorStaticChallenge?: AuthenticatorStaticChallengeResolvers<ContextType>;
  AuthenticatorTotpChallenge?: AuthenticatorTotpChallengeResolvers<ContextType>;
  AuthenticatorValidationChallenge?: AuthenticatorValidationChallengeResolvers<ContextType>;
  DeviceChallenge?: DeviceChallengeResolvers<ContextType>;
  SelectableStage?: SelectableStageResolvers<ContextType>;
  AuthenticatorWebAuthnChallenge?: AuthenticatorWebAuthnChallengeResolvers<ContextType>;
  AutosubmitChallenge?: AutosubmitChallengeResolvers<ContextType>;
  CaptchaChallenge?: CaptchaChallengeResolvers<ContextType>;
  ConsentChallenge?: ConsentChallengeResolvers<ContextType>;
  ConsentPermission?: ConsentPermissionResolvers<ContextType>;
  EmailChallenge?: EmailChallengeResolvers<ContextType>;
  FlowErrorChallenge?: FlowErrorChallengeResolvers<ContextType>;
  IdentificationChallenge?: IdentificationChallengeResolvers<ContextType>;
  LoginSource?: LoginSourceResolvers<ContextType>;
  LoginChallengeTypes?: LoginChallengeTypesResolvers<ContextType>;
  RedirectChallenge?: RedirectChallengeResolvers<ContextType>;
  PlexAuthenticationChallenge?: PlexAuthenticationChallengeResolvers<ContextType>;
  OAuthDeviceCodeChallenge?: OAuthDeviceCodeChallengeResolvers<ContextType>;
  OAuthDeviceCodeFinishChallenge?: OAuthDeviceCodeFinishChallengeResolvers<ContextType>;
  PasswordChallenge?: PasswordChallengeResolvers<ContextType>;
  PromptChallenge?: PromptChallengeResolvers<ContextType>;
  StagePrompt?: StagePromptResolvers<ContextType>;
  ShellChallenge?: ShellChallengeResolvers<ContextType>;
  UserLoginChallenge?: UserLoginChallengeResolvers<ContextType>;
  FlowsInspectorGetResponse?: FlowsInspectorGetResponseResolvers<ContextType>;
  FlowInspection?: FlowInspectionResolvers<ContextType>;
  FlowInspectorPlan?: FlowInspectorPlanResolvers<ContextType>;
  FlowsInstancesListResponse?: FlowsInstancesListResponseResolvers<ContextType>;
  PaginatedFlowList?: PaginatedFlowListResolvers<ContextType>;
  Flow?: FlowResolvers<ContextType>;
  QueryFlowsInstancesListOneOf_0ResultsItemsSlug?: GraphQLScalarType;
  FlowsInstancesRetrieveResponse?: FlowsInstancesRetrieveResponseResolvers<ContextType>;
  FlowsInstancesDiagramRetrieveResponse?: FlowsInstancesDiagramRetrieveResponseResolvers<ContextType>;
  FlowDiagram?: FlowDiagramResolvers<ContextType>;
  FlowsInstancesExecuteRetrieveResponse?: FlowsInstancesExecuteRetrieveResponseResolvers<ContextType>;
  Link?: LinkResolvers<ContextType>;
  FlowsInstancesExportRetrieveResponse?: FlowsInstancesExportRetrieveResponseResolvers<ContextType>;
  FileContainer?: FileContainerResolvers<ContextType>;
  File?: GraphQLScalarType;
  FlowsInstancesUsedByListResponse?: FlowsInstancesUsedByListResponseResolvers<ContextType>;
  FlowsInstancesCacheInfoRetrieveResponse?: FlowsInstancesCacheInfoRetrieveResponseResolvers<ContextType>;
  Cache?: CacheResolvers<ContextType>;
  ManagedBlueprintsListResponse?: ManagedBlueprintsListResponseResolvers<ContextType>;
  PaginatedBlueprintInstanceList?: PaginatedBlueprintInstanceListResolvers<ContextType>;
  BlueprintInstance?: BlueprintInstanceResolvers<ContextType>;
  ManagedBlueprintsRetrieveResponse?: ManagedBlueprintsRetrieveResponseResolvers<ContextType>;
  ManagedBlueprintsUsedByListResponse?: ManagedBlueprintsUsedByListResponseResolvers<ContextType>;
  ManagedBlueprintsAvailableListResponse?: ManagedBlueprintsAvailableListResponseResolvers<ContextType>;
  BlueprintFile?: BlueprintFileResolvers<ContextType>;
  Metadata?: MetadataResolvers<ContextType>;
  Oauth2AccessTokensListResponse?: Oauth2AccessTokensListResponseResolvers<ContextType>;
  PaginatedTokenModelList?: PaginatedTokenModelListResolvers<ContextType>;
  TokenModel?: TokenModelResolvers<ContextType>;
  OAuth2Provider?: OAuth2ProviderResolvers<ContextType>;
  QueryOauth2AccessTokensListOneOf_0ResultsItemsProviderClientId?: GraphQLScalarType;
  QueryOauth2AccessTokensListOneOf_0ResultsItemsProviderClientSecret?: GraphQLScalarType;
  Oauth2AccessTokensRetrieveResponse?: Oauth2AccessTokensRetrieveResponseResolvers<ContextType>;
  Oauth2AccessTokensUsedByListResponse?: Oauth2AccessTokensUsedByListResponseResolvers<ContextType>;
  Oauth2AuthorizationCodesListResponse?: Oauth2AuthorizationCodesListResponseResolvers<ContextType>;
  PaginatedExpiringBaseGrantModelList?: PaginatedExpiringBaseGrantModelListResolvers<ContextType>;
  ExpiringBaseGrantModel?: ExpiringBaseGrantModelResolvers<ContextType>;
  Oauth2AuthorizationCodesRetrieveResponse?: Oauth2AuthorizationCodesRetrieveResponseResolvers<ContextType>;
  Oauth2AuthorizationCodesUsedByListResponse?: Oauth2AuthorizationCodesUsedByListResponseResolvers<ContextType>;
  Oauth2RefreshTokensListResponse?: Oauth2RefreshTokensListResponseResolvers<ContextType>;
  Oauth2RefreshTokensRetrieveResponse?: Oauth2RefreshTokensRetrieveResponseResolvers<ContextType>;
  Oauth2RefreshTokensUsedByListResponse?: Oauth2RefreshTokensUsedByListResponseResolvers<ContextType>;
  OutpostsInstancesListResponse?: OutpostsInstancesListResponseResolvers<ContextType>;
  PaginatedOutpostList?: PaginatedOutpostListResolvers<ContextType>;
  Outpost?: OutpostResolvers<ContextType>;
  ServiceConnection?: ServiceConnectionResolvers<ContextType>;
  OutpostsInstancesRetrieveResponse?: OutpostsInstancesRetrieveResponseResolvers<ContextType>;
  OutpostsInstancesHealthListResponse?: OutpostsInstancesHealthListResponseResolvers<ContextType>;
  OutpostHealth?: OutpostHealthResolvers<ContextType>;
  OutpostsInstancesUsedByListResponse?: OutpostsInstancesUsedByListResponseResolvers<ContextType>;
  OutpostsInstancesDefaultSettingsRetrieveResponse?: OutpostsInstancesDefaultSettingsRetrieveResponseResolvers<ContextType>;
  OutpostDefaultConfig?: OutpostDefaultConfigResolvers<ContextType>;
  OutpostsLdapListResponse?: OutpostsLdapListResponseResolvers<ContextType>;
  PaginatedLdapOutpostConfigList?: PaginatedLdapOutpostConfigListResolvers<ContextType>;
  LdapOutpostConfig?: LdapOutpostConfigResolvers<ContextType>;
  OutpostsLdapRetrieveResponse?: OutpostsLdapRetrieveResponseResolvers<ContextType>;
  OutpostsProxyListResponse?: OutpostsProxyListResponseResolvers<ContextType>;
  PaginatedProxyOutpostConfigList?: PaginatedProxyOutpostConfigListResolvers<ContextType>;
  ProxyOutpostConfig?: ProxyOutpostConfigResolvers<ContextType>;
  QueryOutpostsProxyListOneOf_0ResultsItemsClientId?: GraphQLScalarType;
  QueryOutpostsProxyListOneOf_0ResultsItemsClientSecret?: GraphQLScalarType;
  OpenIdConnectConfiguration?: OpenIdConnectConfigurationResolvers<ContextType>;
  OutpostsProxyRetrieveResponse?: OutpostsProxyRetrieveResponseResolvers<ContextType>;
  OutpostsRadiusListResponse?: OutpostsRadiusListResponseResolvers<ContextType>;
  PaginatedRadiusOutpostConfigList?: PaginatedRadiusOutpostConfigListResolvers<ContextType>;
  RadiusOutpostConfig?: RadiusOutpostConfigResolvers<ContextType>;
  OutpostsRadiusRetrieveResponse?: OutpostsRadiusRetrieveResponseResolvers<ContextType>;
  OutpostsServiceConnectionsAllListResponse?: OutpostsServiceConnectionsAllListResponseResolvers<ContextType>;
  PaginatedServiceConnectionList?: PaginatedServiceConnectionListResolvers<ContextType>;
  OutpostsServiceConnectionsAllRetrieveResponse?: OutpostsServiceConnectionsAllRetrieveResponseResolvers<ContextType>;
  OutpostsServiceConnectionsAllStateRetrieveResponse?: OutpostsServiceConnectionsAllStateRetrieveResponseResolvers<ContextType>;
  ServiceConnectionState?: ServiceConnectionStateResolvers<ContextType>;
  OutpostsServiceConnectionsAllUsedByListResponse?: OutpostsServiceConnectionsAllUsedByListResponseResolvers<ContextType>;
  OutpostsServiceConnectionsAllTypesListResponse?: OutpostsServiceConnectionsAllTypesListResponseResolvers<ContextType>;
  OutpostsServiceConnectionsDockerListResponse?: OutpostsServiceConnectionsDockerListResponseResolvers<ContextType>;
  PaginatedDockerServiceConnectionList?: PaginatedDockerServiceConnectionListResolvers<ContextType>;
  DockerServiceConnection?: DockerServiceConnectionResolvers<ContextType>;
  OutpostsServiceConnectionsDockerRetrieveResponse?: OutpostsServiceConnectionsDockerRetrieveResponseResolvers<ContextType>;
  OutpostsServiceConnectionsDockerUsedByListResponse?: OutpostsServiceConnectionsDockerUsedByListResponseResolvers<ContextType>;
  OutpostsServiceConnectionsKubernetesListResponse?: OutpostsServiceConnectionsKubernetesListResponseResolvers<ContextType>;
  PaginatedKubernetesServiceConnectionList?: PaginatedKubernetesServiceConnectionListResolvers<ContextType>;
  KubernetesServiceConnection?: KubernetesServiceConnectionResolvers<ContextType>;
  OutpostsServiceConnectionsKubernetesRetrieveResponse?: OutpostsServiceConnectionsKubernetesRetrieveResponseResolvers<ContextType>;
  OutpostsServiceConnectionsKubernetesUsedByListResponse?: OutpostsServiceConnectionsKubernetesUsedByListResponseResolvers<ContextType>;
  PoliciesAllListResponse?: PoliciesAllListResponseResolvers<ContextType>;
  PaginatedPolicyList?: PaginatedPolicyListResolvers<ContextType>;
  Policy?: PolicyResolvers<ContextType>;
  PoliciesAllRetrieveResponse?: PoliciesAllRetrieveResponseResolvers<ContextType>;
  PoliciesAllUsedByListResponse?: PoliciesAllUsedByListResponseResolvers<ContextType>;
  PoliciesAllCacheInfoRetrieveResponse?: PoliciesAllCacheInfoRetrieveResponseResolvers<ContextType>;
  PoliciesAllTypesListResponse?: PoliciesAllTypesListResponseResolvers<ContextType>;
  PoliciesBindingsListResponse?: PoliciesBindingsListResponseResolvers<ContextType>;
  PaginatedPolicyBindingList?: PaginatedPolicyBindingListResolvers<ContextType>;
  PolicyBinding?: PolicyBindingResolvers<ContextType>;
  NonNegativeInt?: GraphQLScalarType;
  PoliciesBindingsRetrieveResponse?: PoliciesBindingsRetrieveResponseResolvers<ContextType>;
  PoliciesBindingsUsedByListResponse?: PoliciesBindingsUsedByListResponseResolvers<ContextType>;
  PoliciesDummyListResponse?: PoliciesDummyListResponseResolvers<ContextType>;
  PaginatedDummyPolicyList?: PaginatedDummyPolicyListResolvers<ContextType>;
  DummyPolicy?: DummyPolicyResolvers<ContextType>;
  PoliciesDummyRetrieveResponse?: PoliciesDummyRetrieveResponseResolvers<ContextType>;
  PoliciesDummyUsedByListResponse?: PoliciesDummyUsedByListResponseResolvers<ContextType>;
  PoliciesEventMatcherListResponse?: PoliciesEventMatcherListResponseResolvers<ContextType>;
  PaginatedEventMatcherPolicyList?: PaginatedEventMatcherPolicyListResolvers<ContextType>;
  EventMatcherPolicy?: EventMatcherPolicyResolvers<ContextType>;
  PoliciesEventMatcherRetrieveResponse?: PoliciesEventMatcherRetrieveResponseResolvers<ContextType>;
  PoliciesEventMatcherUsedByListResponse?: PoliciesEventMatcherUsedByListResponseResolvers<ContextType>;
  PoliciesExpressionListResponse?: PoliciesExpressionListResponseResolvers<ContextType>;
  PaginatedExpressionPolicyList?: PaginatedExpressionPolicyListResolvers<ContextType>;
  ExpressionPolicy?: ExpressionPolicyResolvers<ContextType>;
  PoliciesExpressionRetrieveResponse?: PoliciesExpressionRetrieveResponseResolvers<ContextType>;
  PoliciesExpressionUsedByListResponse?: PoliciesExpressionUsedByListResponseResolvers<ContextType>;
  PoliciesPasswordListResponse?: PoliciesPasswordListResponseResolvers<ContextType>;
  PaginatedPasswordPolicyList?: PaginatedPasswordPolicyListResolvers<ContextType>;
  PasswordPolicy?: PasswordPolicyResolvers<ContextType>;
  PoliciesPasswordRetrieveResponse?: PoliciesPasswordRetrieveResponseResolvers<ContextType>;
  PoliciesPasswordUsedByListResponse?: PoliciesPasswordUsedByListResponseResolvers<ContextType>;
  PoliciesPasswordExpiryListResponse?: PoliciesPasswordExpiryListResponseResolvers<ContextType>;
  PaginatedPasswordExpiryPolicyList?: PaginatedPasswordExpiryPolicyListResolvers<ContextType>;
  PasswordExpiryPolicy?: PasswordExpiryPolicyResolvers<ContextType>;
  PoliciesPasswordExpiryRetrieveResponse?: PoliciesPasswordExpiryRetrieveResponseResolvers<ContextType>;
  PoliciesPasswordExpiryUsedByListResponse?: PoliciesPasswordExpiryUsedByListResponseResolvers<ContextType>;
  PoliciesReputationListResponse?: PoliciesReputationListResponseResolvers<ContextType>;
  PaginatedReputationPolicyList?: PaginatedReputationPolicyListResolvers<ContextType>;
  ReputationPolicy?: ReputationPolicyResolvers<ContextType>;
  PoliciesReputationRetrieveResponse?: PoliciesReputationRetrieveResponseResolvers<ContextType>;
  PoliciesReputationUsedByListResponse?: PoliciesReputationUsedByListResponseResolvers<ContextType>;
  PoliciesReputationScoresListResponse?: PoliciesReputationScoresListResponseResolvers<ContextType>;
  PaginatedReputationList?: PaginatedReputationListResolvers<ContextType>;
  Reputation?: ReputationResolvers<ContextType>;
  BigInt?: GraphQLScalarType;
  PoliciesReputationScoresRetrieveResponse?: PoliciesReputationScoresRetrieveResponseResolvers<ContextType>;
  PoliciesReputationScoresUsedByListResponse?: PoliciesReputationScoresUsedByListResponseResolvers<ContextType>;
  PropertymappingsAllListResponse?: PropertymappingsAllListResponseResolvers<ContextType>;
  PaginatedPropertyMappingList?: PaginatedPropertyMappingListResolvers<ContextType>;
  PropertyMapping?: PropertyMappingResolvers<ContextType>;
  PropertymappingsAllRetrieveResponse?: PropertymappingsAllRetrieveResponseResolvers<ContextType>;
  PropertymappingsAllUsedByListResponse?: PropertymappingsAllUsedByListResponseResolvers<ContextType>;
  PropertymappingsAllTypesListResponse?: PropertymappingsAllTypesListResponseResolvers<ContextType>;
  PropertymappingsLdapListResponse?: PropertymappingsLdapListResponseResolvers<ContextType>;
  PaginatedLdapPropertyMappingList?: PaginatedLdapPropertyMappingListResolvers<ContextType>;
  LdapPropertyMapping?: LdapPropertyMappingResolvers<ContextType>;
  PropertymappingsLdapRetrieveResponse?: PropertymappingsLdapRetrieveResponseResolvers<ContextType>;
  PropertymappingsLdapUsedByListResponse?: PropertymappingsLdapUsedByListResponseResolvers<ContextType>;
  PropertymappingsNotificationListResponse?: PropertymappingsNotificationListResponseResolvers<ContextType>;
  PaginatedNotificationWebhookMappingList?: PaginatedNotificationWebhookMappingListResolvers<ContextType>;
  NotificationWebhookMapping?: NotificationWebhookMappingResolvers<ContextType>;
  PropertymappingsNotificationRetrieveResponse?: PropertymappingsNotificationRetrieveResponseResolvers<ContextType>;
  PropertymappingsNotificationUsedByListResponse?: PropertymappingsNotificationUsedByListResponseResolvers<ContextType>;
  PropertymappingsRacListResponse?: PropertymappingsRacListResponseResolvers<ContextType>;
  PaginatedRacPropertyMappingList?: PaginatedRacPropertyMappingListResolvers<ContextType>;
  RacPropertyMapping?: RacPropertyMappingResolvers<ContextType>;
  PropertymappingsRacRetrieveResponse?: PropertymappingsRacRetrieveResponseResolvers<ContextType>;
  PropertymappingsRacUsedByListResponse?: PropertymappingsRacUsedByListResponseResolvers<ContextType>;
  PropertymappingsSamlListResponse?: PropertymappingsSamlListResponseResolvers<ContextType>;
  PaginatedSamlPropertyMappingList?: PaginatedSamlPropertyMappingListResolvers<ContextType>;
  SamlPropertyMapping?: SamlPropertyMappingResolvers<ContextType>;
  PropertymappingsSamlRetrieveResponse?: PropertymappingsSamlRetrieveResponseResolvers<ContextType>;
  PropertymappingsSamlUsedByListResponse?: PropertymappingsSamlUsedByListResponseResolvers<ContextType>;
  PropertymappingsScimListResponse?: PropertymappingsScimListResponseResolvers<ContextType>;
  PaginatedScimMappingList?: PaginatedScimMappingListResolvers<ContextType>;
  ScimMapping?: ScimMappingResolvers<ContextType>;
  PropertymappingsScimRetrieveResponse?: PropertymappingsScimRetrieveResponseResolvers<ContextType>;
  PropertymappingsScimUsedByListResponse?: PropertymappingsScimUsedByListResponseResolvers<ContextType>;
  PropertymappingsScopeListResponse?: PropertymappingsScopeListResponseResolvers<ContextType>;
  PaginatedScopeMappingList?: PaginatedScopeMappingListResolvers<ContextType>;
  ScopeMapping?: ScopeMappingResolvers<ContextType>;
  PropertymappingsScopeRetrieveResponse?: PropertymappingsScopeRetrieveResponseResolvers<ContextType>;
  PropertymappingsScopeUsedByListResponse?: PropertymappingsScopeUsedByListResponseResolvers<ContextType>;
  ProvidersAllListResponse?: ProvidersAllListResponseResolvers<ContextType>;
  PaginatedProviderList?: PaginatedProviderListResolvers<ContextType>;
  ProvidersAllRetrieveResponse?: ProvidersAllRetrieveResponseResolvers<ContextType>;
  ProvidersAllUsedByListResponse?: ProvidersAllUsedByListResponseResolvers<ContextType>;
  ProvidersAllTypesListResponse?: ProvidersAllTypesListResponseResolvers<ContextType>;
  ProvidersLdapListResponse?: ProvidersLdapListResponseResolvers<ContextType>;
  PaginatedLdapProviderList?: PaginatedLdapProviderListResolvers<ContextType>;
  LdapProvider?: LdapProviderResolvers<ContextType>;
  ProvidersLdapRetrieveResponse?: ProvidersLdapRetrieveResponseResolvers<ContextType>;
  ProvidersLdapUsedByListResponse?: ProvidersLdapUsedByListResponseResolvers<ContextType>;
  ProvidersOauth2ListResponse?: ProvidersOauth2ListResponseResolvers<ContextType>;
  PaginatedOAuth2ProviderList?: PaginatedOAuth2ProviderListResolvers<ContextType>;
  ProvidersOauth2RetrieveResponse?: ProvidersOauth2RetrieveResponseResolvers<ContextType>;
  ProvidersOauth2PreviewUserRetrieveResponse?: ProvidersOauth2PreviewUserRetrieveResponseResolvers<ContextType>;
  PropertyMappingPreview?: PropertyMappingPreviewResolvers<ContextType>;
  ProvidersOauth2SetupUrlsRetrieveResponse?: ProvidersOauth2SetupUrlsRetrieveResponseResolvers<ContextType>;
  OAuth2ProviderSetupUrLs?: OAuth2ProviderSetupUrLsResolvers<ContextType>;
  ProvidersOauth2UsedByListResponse?: ProvidersOauth2UsedByListResponseResolvers<ContextType>;
  ProvidersProxyListResponse?: ProvidersProxyListResponseResolvers<ContextType>;
  PaginatedProxyProviderList?: PaginatedProxyProviderListResolvers<ContextType>;
  ProxyProvider?: ProxyProviderResolvers<ContextType>;
  ProvidersProxyRetrieveResponse?: ProvidersProxyRetrieveResponseResolvers<ContextType>;
  ProvidersProxyUsedByListResponse?: ProvidersProxyUsedByListResponseResolvers<ContextType>;
  ProvidersRacListResponse?: ProvidersRacListResponseResolvers<ContextType>;
  PaginatedRacProviderList?: PaginatedRacProviderListResolvers<ContextType>;
  RacProvider?: RacProviderResolvers<ContextType>;
  ProvidersRacRetrieveResponse?: ProvidersRacRetrieveResponseResolvers<ContextType>;
  ProvidersRacUsedByListResponse?: ProvidersRacUsedByListResponseResolvers<ContextType>;
  ProvidersRadiusListResponse?: ProvidersRadiusListResponseResolvers<ContextType>;
  PaginatedRadiusProviderList?: PaginatedRadiusProviderListResolvers<ContextType>;
  RadiusProvider?: RadiusProviderResolvers<ContextType>;
  ProvidersRadiusRetrieveResponse?: ProvidersRadiusRetrieveResponseResolvers<ContextType>;
  ProvidersRadiusUsedByListResponse?: ProvidersRadiusUsedByListResponseResolvers<ContextType>;
  ProvidersSamlListResponse?: ProvidersSamlListResponseResolvers<ContextType>;
  PaginatedSamlProviderList?: PaginatedSamlProviderListResolvers<ContextType>;
  SamlProvider?: SamlProviderResolvers<ContextType>;
  ServiceProviderBinding?: ServiceProviderBindingResolvers<ContextType>;
  ProvidersSamlRetrieveResponse?: ProvidersSamlRetrieveResponseResolvers<ContextType>;
  ProvidersSamlMetadataRetrieveResponse?: ProvidersSamlMetadataRetrieveResponseResolvers<ContextType>;
  SamlMetadata?: SamlMetadataResolvers<ContextType>;
  ProvidersSamlPreviewUserRetrieveResponse?: ProvidersSamlPreviewUserRetrieveResponseResolvers<ContextType>;
  ProvidersSamlUsedByListResponse?: ProvidersSamlUsedByListResponseResolvers<ContextType>;
  ProvidersScimListResponse?: ProvidersScimListResponseResolvers<ContextType>;
  PaginatedScimProviderList?: PaginatedScimProviderListResolvers<ContextType>;
  ScimProvider?: ScimProviderResolvers<ContextType>;
  ProvidersScimRetrieveResponse?: ProvidersScimRetrieveResponseResolvers<ContextType>;
  ProvidersScimSyncStatusRetrieveResponse?: ProvidersScimSyncStatusRetrieveResponseResolvers<ContextType>;
  ScimSyncStatus?: ScimSyncStatusResolvers<ContextType>;
  ProvidersScimUsedByListResponse?: ProvidersScimUsedByListResponseResolvers<ContextType>;
  RacConnectionTokensListResponse?: RacConnectionTokensListResponseResolvers<ContextType>;
  PaginatedConnectionTokenList?: PaginatedConnectionTokenListResolvers<ContextType>;
  ConnectionToken?: ConnectionTokenResolvers<ContextType>;
  Endpoint?: EndpointResolvers<ContextType>;
  RacConnectionTokensRetrieveResponse?: RacConnectionTokensRetrieveResponseResolvers<ContextType>;
  RacConnectionTokensUsedByListResponse?: RacConnectionTokensUsedByListResponseResolvers<ContextType>;
  RacEndpointsListResponse?: RacEndpointsListResponseResolvers<ContextType>;
  PaginatedEndpointList?: PaginatedEndpointListResolvers<ContextType>;
  RacEndpointsRetrieveResponse?: RacEndpointsRetrieveResponseResolvers<ContextType>;
  RacEndpointsUsedByListResponse?: RacEndpointsUsedByListResponseResolvers<ContextType>;
  RbacPermissionsListResponse?: RbacPermissionsListResponseResolvers<ContextType>;
  PaginatedPermissionList?: PaginatedPermissionListResolvers<ContextType>;
  Permission?: PermissionResolvers<ContextType>;
  QueryRbacPermissionsListOneOf_0ResultsItemsName?: GraphQLScalarType;
  QueryRbacPermissionsListOneOf_0ResultsItemsCodename?: GraphQLScalarType;
  RbacPermissionsRetrieveResponse?: RbacPermissionsRetrieveResponseResolvers<ContextType>;
  RbacPermissionsAssignedByRolesListResponse?: RbacPermissionsAssignedByRolesListResponseResolvers<ContextType>;
  PaginatedRoleAssignedObjectPermissionList?: PaginatedRoleAssignedObjectPermissionListResolvers<ContextType>;
  RoleAssignedObjectPermission?: RoleAssignedObjectPermissionResolvers<ContextType>;
  RoleObjectPermission?: RoleObjectPermissionResolvers<ContextType>;
  RbacPermissionsAssignedByUsersListResponse?: RbacPermissionsAssignedByUsersListResponseResolvers<ContextType>;
  PaginatedUserAssignedObjectPermissionList?: PaginatedUserAssignedObjectPermissionListResolvers<ContextType>;
  UserAssignedObjectPermission?: UserAssignedObjectPermissionResolvers<ContextType>;
  QueryRbacPermissionsAssignedByUsersListOneOf_0ResultsItemsUsername?: GraphQLScalarType;
  UserObjectPermission?: UserObjectPermissionResolvers<ContextType>;
  RbacPermissionsRolesListResponse?: RbacPermissionsRolesListResponseResolvers<ContextType>;
  PaginatedExtraRoleObjectPermissionList?: PaginatedExtraRoleObjectPermissionListResolvers<ContextType>;
  ExtraRoleObjectPermission?: ExtraRoleObjectPermissionResolvers<ContextType>;
  RbacPermissionsUsersListResponse?: RbacPermissionsUsersListResponseResolvers<ContextType>;
  PaginatedExtraUserObjectPermissionList?: PaginatedExtraUserObjectPermissionListResolvers<ContextType>;
  ExtraUserObjectPermission?: ExtraUserObjectPermissionResolvers<ContextType>;
  RbacRolesListResponse?: RbacRolesListResponseResolvers<ContextType>;
  PaginatedRoleList?: PaginatedRoleListResolvers<ContextType>;
  RbacRolesRetrieveResponse?: RbacRolesRetrieveResponseResolvers<ContextType>;
  RbacRolesUsedByListResponse?: RbacRolesUsedByListResponseResolvers<ContextType>;
  RootConfigRetrieveResponse?: RootConfigRetrieveResponseResolvers<ContextType>;
  Config?: ConfigResolvers<ContextType>;
  ErrorReportingConfig?: ErrorReportingConfigResolvers<ContextType>;
  SchemaRetrieveResponse?: SchemaRetrieveResponseResolvers<ContextType>;
  JsonContainer?: JsonContainerResolvers<ContextType>;
  SourcesAllListResponse?: SourcesAllListResponseResolvers<ContextType>;
  PaginatedSourceList?: PaginatedSourceListResolvers<ContextType>;
  Source?: SourceResolvers<ContextType>;
  QuerySourcesAllListOneOf_0ResultsItemsSlug?: GraphQLScalarType;
  SourcesAllRetrieveResponse?: SourcesAllRetrieveResponseResolvers<ContextType>;
  SourcesAllUsedByListResponse?: SourcesAllUsedByListResponseResolvers<ContextType>;
  SourcesAllTypesListResponse?: SourcesAllTypesListResponseResolvers<ContextType>;
  SourcesAllUserSettingsListResponse?: SourcesAllUserSettingsListResponseResolvers<ContextType>;
  UserSetting?: UserSettingResolvers<ContextType>;
  SourcesLdapListResponse?: SourcesLdapListResponseResolvers<ContextType>;
  PaginatedLdapSourceList?: PaginatedLdapSourceListResolvers<ContextType>;
  LdapSource?: LdapSourceResolvers<ContextType>;
  QuerySourcesLdapListOneOf_0ResultsItemsSlug?: GraphQLScalarType;
  SourcesLdapRetrieveResponse?: SourcesLdapRetrieveResponseResolvers<ContextType>;
  SourcesLdapDebugRetrieveResponse?: SourcesLdapDebugRetrieveResponseResolvers<ContextType>;
  LdapDebug?: LdapDebugResolvers<ContextType>;
  SourcesLdapSyncStatusRetrieveResponse?: SourcesLdapSyncStatusRetrieveResponseResolvers<ContextType>;
  LdapSyncStatus?: LdapSyncStatusResolvers<ContextType>;
  SourcesLdapUsedByListResponse?: SourcesLdapUsedByListResponseResolvers<ContextType>;
  SourcesOauthListResponse?: SourcesOauthListResponseResolvers<ContextType>;
  PaginatedOAuthSourceList?: PaginatedOAuthSourceListResolvers<ContextType>;
  OAuthSource?: OAuthSourceResolvers<ContextType>;
  QuerySourcesOauthListOneOf_0ResultsItemsSlug?: GraphQLScalarType;
  QuerySourcesOauthListOneOf_0ResultsItemsRequestTokenUrl?: GraphQLScalarType;
  QuerySourcesOauthListOneOf_0ResultsItemsAuthorizationUrl?: GraphQLScalarType;
  QuerySourcesOauthListOneOf_0ResultsItemsAccessTokenUrl?: GraphQLScalarType;
  QuerySourcesOauthListOneOf_0ResultsItemsProfileUrl?: GraphQLScalarType;
  SourceType?: SourceTypeResolvers<ContextType>;
  SourcesOauthRetrieveResponse?: SourcesOauthRetrieveResponseResolvers<ContextType>;
  SourcesOauthUsedByListResponse?: SourcesOauthUsedByListResponseResolvers<ContextType>;
  SourcesOauthSourceTypesListResponse?: SourcesOauthSourceTypesListResponseResolvers<ContextType>;
  SourcesPlexListResponse?: SourcesPlexListResponseResolvers<ContextType>;
  PaginatedPlexSourceList?: PaginatedPlexSourceListResolvers<ContextType>;
  PlexSource?: PlexSourceResolvers<ContextType>;
  QuerySourcesPlexListOneOf_0ResultsItemsSlug?: GraphQLScalarType;
  SourcesPlexRetrieveResponse?: SourcesPlexRetrieveResponseResolvers<ContextType>;
  SourcesPlexUsedByListResponse?: SourcesPlexUsedByListResponseResolvers<ContextType>;
  SourcesSamlListResponse?: SourcesSamlListResponseResolvers<ContextType>;
  PaginatedSamlSourceList?: PaginatedSamlSourceListResolvers<ContextType>;
  SamlSource?: SamlSourceResolvers<ContextType>;
  QuerySourcesSamlListOneOf_0ResultsItemsSlug?: GraphQLScalarType;
  SourcesSamlRetrieveResponse?: SourcesSamlRetrieveResponseResolvers<ContextType>;
  SourcesSamlMetadataRetrieveResponse?: SourcesSamlMetadataRetrieveResponseResolvers<ContextType>;
  SourcesSamlUsedByListResponse?: SourcesSamlUsedByListResponseResolvers<ContextType>;
  SourcesScimListResponse?: SourcesScimListResponseResolvers<ContextType>;
  PaginatedScimSourceList?: PaginatedScimSourceListResolvers<ContextType>;
  ScimSource?: ScimSourceResolvers<ContextType>;
  QuerySourcesScimListOneOf_0ResultsItemsSlug?: GraphQLScalarType;
  SourcesScimRetrieveResponse?: SourcesScimRetrieveResponseResolvers<ContextType>;
  SourcesScimUsedByListResponse?: SourcesScimUsedByListResponseResolvers<ContextType>;
  SourcesScimGroupsListResponse?: SourcesScimGroupsListResponseResolvers<ContextType>;
  PaginatedScimSourceGroupList?: PaginatedScimSourceGroupListResolvers<ContextType>;
  ScimSourceGroup?: ScimSourceGroupResolvers<ContextType>;
  SourcesScimGroupsRetrieveResponse?: SourcesScimGroupsRetrieveResponseResolvers<ContextType>;
  SourcesScimGroupsUsedByListResponse?: SourcesScimGroupsUsedByListResponseResolvers<ContextType>;
  SourcesScimUsersListResponse?: SourcesScimUsersListResponseResolvers<ContextType>;
  PaginatedScimSourceUserList?: PaginatedScimSourceUserListResolvers<ContextType>;
  ScimSourceUser?: ScimSourceUserResolvers<ContextType>;
  SourcesScimUsersRetrieveResponse?: SourcesScimUsersRetrieveResponseResolvers<ContextType>;
  SourcesScimUsersUsedByListResponse?: SourcesScimUsersUsedByListResponseResolvers<ContextType>;
  SourcesUserConnectionsAllListResponse?: SourcesUserConnectionsAllListResponseResolvers<ContextType>;
  PaginatedUserSourceConnectionList?: PaginatedUserSourceConnectionListResolvers<ContextType>;
  UserSourceConnection?: UserSourceConnectionResolvers<ContextType>;
  SourcesUserConnectionsAllRetrieveResponse?: SourcesUserConnectionsAllRetrieveResponseResolvers<ContextType>;
  SourcesUserConnectionsAllUsedByListResponse?: SourcesUserConnectionsAllUsedByListResponseResolvers<ContextType>;
  SourcesUserConnectionsOauthListResponse?: SourcesUserConnectionsOauthListResponseResolvers<ContextType>;
  PaginatedUserOAuthSourceConnectionList?: PaginatedUserOAuthSourceConnectionListResolvers<ContextType>;
  UserOAuthSourceConnection?: UserOAuthSourceConnectionResolvers<ContextType>;
  QuerySourcesUserConnectionsOauthListOneOf_0ResultsItemsIdentifier?: GraphQLScalarType;
  SourcesUserConnectionsOauthRetrieveResponse?: SourcesUserConnectionsOauthRetrieveResponseResolvers<ContextType>;
  SourcesUserConnectionsOauthUsedByListResponse?: SourcesUserConnectionsOauthUsedByListResponseResolvers<ContextType>;
  SourcesUserConnectionsPlexListResponse?: SourcesUserConnectionsPlexListResponseResolvers<ContextType>;
  PaginatedPlexSourceConnectionList?: PaginatedPlexSourceConnectionListResolvers<ContextType>;
  PlexSourceConnection?: PlexSourceConnectionResolvers<ContextType>;
  SourcesUserConnectionsPlexRetrieveResponse?: SourcesUserConnectionsPlexRetrieveResponseResolvers<ContextType>;
  SourcesUserConnectionsPlexUsedByListResponse?: SourcesUserConnectionsPlexUsedByListResponseResolvers<ContextType>;
  SourcesUserConnectionsSamlListResponse?: SourcesUserConnectionsSamlListResponseResolvers<ContextType>;
  PaginatedUserSamlSourceConnectionList?: PaginatedUserSamlSourceConnectionListResolvers<ContextType>;
  UserSamlSourceConnection?: UserSamlSourceConnectionResolvers<ContextType>;
  SourcesUserConnectionsSamlRetrieveResponse?: SourcesUserConnectionsSamlRetrieveResponseResolvers<ContextType>;
  SourcesUserConnectionsSamlUsedByListResponse?: SourcesUserConnectionsSamlUsedByListResponseResolvers<ContextType>;
  StagesAllListResponse?: StagesAllListResponseResolvers<ContextType>;
  PaginatedStageList?: PaginatedStageListResolvers<ContextType>;
  StagesAllRetrieveResponse?: StagesAllRetrieveResponseResolvers<ContextType>;
  StagesAllUsedByListResponse?: StagesAllUsedByListResponseResolvers<ContextType>;
  StagesAllTypesListResponse?: StagesAllTypesListResponseResolvers<ContextType>;
  StagesAllUserSettingsListResponse?: StagesAllUserSettingsListResponseResolvers<ContextType>;
  StagesAuthenticatorDuoListResponse?: StagesAuthenticatorDuoListResponseResolvers<ContextType>;
  PaginatedAuthenticatorDuoStageList?: PaginatedAuthenticatorDuoStageListResolvers<ContextType>;
  AuthenticatorDuoStage?: AuthenticatorDuoStageResolvers<ContextType>;
  StagesAuthenticatorDuoRetrieveResponse?: StagesAuthenticatorDuoRetrieveResponseResolvers<ContextType>;
  StagesAuthenticatorDuoUsedByListResponse?: StagesAuthenticatorDuoUsedByListResponseResolvers<ContextType>;
  StagesAuthenticatorSmsListResponse?: StagesAuthenticatorSmsListResponseResolvers<ContextType>;
  PaginatedAuthenticatorSmsStageList?: PaginatedAuthenticatorSmsStageListResolvers<ContextType>;
  AuthenticatorSmsStage?: AuthenticatorSmsStageResolvers<ContextType>;
  StagesAuthenticatorSmsRetrieveResponse?: StagesAuthenticatorSmsRetrieveResponseResolvers<ContextType>;
  StagesAuthenticatorSmsUsedByListResponse?: StagesAuthenticatorSmsUsedByListResponseResolvers<ContextType>;
  StagesAuthenticatorStaticListResponse?: StagesAuthenticatorStaticListResponseResolvers<ContextType>;
  PaginatedAuthenticatorStaticStageList?: PaginatedAuthenticatorStaticStageListResolvers<ContextType>;
  AuthenticatorStaticStage?: AuthenticatorStaticStageResolvers<ContextType>;
  StagesAuthenticatorStaticRetrieveResponse?: StagesAuthenticatorStaticRetrieveResponseResolvers<ContextType>;
  StagesAuthenticatorStaticUsedByListResponse?: StagesAuthenticatorStaticUsedByListResponseResolvers<ContextType>;
  StagesAuthenticatorTotpListResponse?: StagesAuthenticatorTotpListResponseResolvers<ContextType>;
  PaginatedAuthenticatorTotpStageList?: PaginatedAuthenticatorTotpStageListResolvers<ContextType>;
  AuthenticatorTotpStage?: AuthenticatorTotpStageResolvers<ContextType>;
  StagesAuthenticatorTotpRetrieveResponse?: StagesAuthenticatorTotpRetrieveResponseResolvers<ContextType>;
  StagesAuthenticatorTotpUsedByListResponse?: StagesAuthenticatorTotpUsedByListResponseResolvers<ContextType>;
  StagesAuthenticatorValidateListResponse?: StagesAuthenticatorValidateListResponseResolvers<ContextType>;
  PaginatedAuthenticatorValidateStageList?: PaginatedAuthenticatorValidateStageListResolvers<ContextType>;
  AuthenticatorValidateStage?: AuthenticatorValidateStageResolvers<ContextType>;
  StagesAuthenticatorValidateRetrieveResponse?: StagesAuthenticatorValidateRetrieveResponseResolvers<ContextType>;
  StagesAuthenticatorValidateUsedByListResponse?: StagesAuthenticatorValidateUsedByListResponseResolvers<ContextType>;
  StagesAuthenticatorWebauthnListResponse?: StagesAuthenticatorWebauthnListResponseResolvers<ContextType>;
  PaginatedAuthenticatorWebAuthnStageList?: PaginatedAuthenticatorWebAuthnStageListResolvers<ContextType>;
  AuthenticatorWebAuthnStage?: AuthenticatorWebAuthnStageResolvers<ContextType>;
  StagesAuthenticatorWebauthnRetrieveResponse?: StagesAuthenticatorWebauthnRetrieveResponseResolvers<ContextType>;
  StagesAuthenticatorWebauthnUsedByListResponse?: StagesAuthenticatorWebauthnUsedByListResponseResolvers<ContextType>;
  StagesAuthenticatorWebauthnDeviceTypesListResponse?: StagesAuthenticatorWebauthnDeviceTypesListResponseResolvers<ContextType>;
  PaginatedWebAuthnDeviceTypeList?: PaginatedWebAuthnDeviceTypeListResolvers<ContextType>;
  StagesAuthenticatorWebauthnDeviceTypesRetrieveResponse?: StagesAuthenticatorWebauthnDeviceTypesRetrieveResponseResolvers<ContextType>;
  StagesCaptchaListResponse?: StagesCaptchaListResponseResolvers<ContextType>;
  PaginatedCaptchaStageList?: PaginatedCaptchaStageListResolvers<ContextType>;
  CaptchaStage?: CaptchaStageResolvers<ContextType>;
  StagesCaptchaRetrieveResponse?: StagesCaptchaRetrieveResponseResolvers<ContextType>;
  StagesCaptchaUsedByListResponse?: StagesCaptchaUsedByListResponseResolvers<ContextType>;
  StagesConsentListResponse?: StagesConsentListResponseResolvers<ContextType>;
  PaginatedConsentStageList?: PaginatedConsentStageListResolvers<ContextType>;
  ConsentStage?: ConsentStageResolvers<ContextType>;
  StagesConsentRetrieveResponse?: StagesConsentRetrieveResponseResolvers<ContextType>;
  StagesConsentUsedByListResponse?: StagesConsentUsedByListResponseResolvers<ContextType>;
  StagesDenyListResponse?: StagesDenyListResponseResolvers<ContextType>;
  PaginatedDenyStageList?: PaginatedDenyStageListResolvers<ContextType>;
  DenyStage?: DenyStageResolvers<ContextType>;
  StagesDenyRetrieveResponse?: StagesDenyRetrieveResponseResolvers<ContextType>;
  StagesDenyUsedByListResponse?: StagesDenyUsedByListResponseResolvers<ContextType>;
  StagesDummyListResponse?: StagesDummyListResponseResolvers<ContextType>;
  PaginatedDummyStageList?: PaginatedDummyStageListResolvers<ContextType>;
  DummyStage?: DummyStageResolvers<ContextType>;
  StagesDummyRetrieveResponse?: StagesDummyRetrieveResponseResolvers<ContextType>;
  StagesDummyUsedByListResponse?: StagesDummyUsedByListResponseResolvers<ContextType>;
  StagesEmailListResponse?: StagesEmailListResponseResolvers<ContextType>;
  PaginatedEmailStageList?: PaginatedEmailStageListResolvers<ContextType>;
  EmailStage?: EmailStageResolvers<ContextType>;
  StagesEmailRetrieveResponse?: StagesEmailRetrieveResponseResolvers<ContextType>;
  StagesEmailUsedByListResponse?: StagesEmailUsedByListResponseResolvers<ContextType>;
  StagesEmailTemplatesListResponse?: StagesEmailTemplatesListResponseResolvers<ContextType>;
  StagesIdentificationListResponse?: StagesIdentificationListResponseResolvers<ContextType>;
  PaginatedIdentificationStageList?: PaginatedIdentificationStageListResolvers<ContextType>;
  IdentificationStage?: IdentificationStageResolvers<ContextType>;
  StagesIdentificationRetrieveResponse?: StagesIdentificationRetrieveResponseResolvers<ContextType>;
  StagesIdentificationUsedByListResponse?: StagesIdentificationUsedByListResponseResolvers<ContextType>;
  StagesInvitationInvitationsListResponse?: StagesInvitationInvitationsListResponseResolvers<ContextType>;
  PaginatedInvitationList?: PaginatedInvitationListResolvers<ContextType>;
  Invitation?: InvitationResolvers<ContextType>;
  QueryStagesInvitationInvitationsListOneOf_0ResultsItemsName?: GraphQLScalarType;
  StagesInvitationInvitationsRetrieveResponse?: StagesInvitationInvitationsRetrieveResponseResolvers<ContextType>;
  StagesInvitationInvitationsUsedByListResponse?: StagesInvitationInvitationsUsedByListResponseResolvers<ContextType>;
  StagesInvitationStagesListResponse?: StagesInvitationStagesListResponseResolvers<ContextType>;
  PaginatedInvitationStageList?: PaginatedInvitationStageListResolvers<ContextType>;
  InvitationStage?: InvitationStageResolvers<ContextType>;
  StagesInvitationStagesRetrieveResponse?: StagesInvitationStagesRetrieveResponseResolvers<ContextType>;
  StagesInvitationStagesUsedByListResponse?: StagesInvitationStagesUsedByListResponseResolvers<ContextType>;
  StagesPasswordListResponse?: StagesPasswordListResponseResolvers<ContextType>;
  PaginatedPasswordStageList?: PaginatedPasswordStageListResolvers<ContextType>;
  PasswordStage?: PasswordStageResolvers<ContextType>;
  StagesPasswordRetrieveResponse?: StagesPasswordRetrieveResponseResolvers<ContextType>;
  StagesPasswordUsedByListResponse?: StagesPasswordUsedByListResponseResolvers<ContextType>;
  StagesPromptPromptsListResponse?: StagesPromptPromptsListResponseResolvers<ContextType>;
  PaginatedPromptList?: PaginatedPromptListResolvers<ContextType>;
  Prompt?: PromptResolvers<ContextType>;
  StagesPromptPromptsRetrieveResponse?: StagesPromptPromptsRetrieveResponseResolvers<ContextType>;
  StagesPromptPromptsUsedByListResponse?: StagesPromptPromptsUsedByListResponseResolvers<ContextType>;
  StagesPromptStagesListResponse?: StagesPromptStagesListResponseResolvers<ContextType>;
  PaginatedPromptStageList?: PaginatedPromptStageListResolvers<ContextType>;
  PromptStage?: PromptStageResolvers<ContextType>;
  StagesPromptStagesRetrieveResponse?: StagesPromptStagesRetrieveResponseResolvers<ContextType>;
  StagesPromptStagesUsedByListResponse?: StagesPromptStagesUsedByListResponseResolvers<ContextType>;
  StagesSourceListResponse?: StagesSourceListResponseResolvers<ContextType>;
  PaginatedSourceStageList?: PaginatedSourceStageListResolvers<ContextType>;
  SourceStage?: SourceStageResolvers<ContextType>;
  StagesSourceRetrieveResponse?: StagesSourceRetrieveResponseResolvers<ContextType>;
  StagesSourceUsedByListResponse?: StagesSourceUsedByListResponseResolvers<ContextType>;
  StagesUserDeleteListResponse?: StagesUserDeleteListResponseResolvers<ContextType>;
  PaginatedUserDeleteStageList?: PaginatedUserDeleteStageListResolvers<ContextType>;
  UserDeleteStage?: UserDeleteStageResolvers<ContextType>;
  StagesUserDeleteRetrieveResponse?: StagesUserDeleteRetrieveResponseResolvers<ContextType>;
  StagesUserDeleteUsedByListResponse?: StagesUserDeleteUsedByListResponseResolvers<ContextType>;
  StagesUserLoginListResponse?: StagesUserLoginListResponseResolvers<ContextType>;
  PaginatedUserLoginStageList?: PaginatedUserLoginStageListResolvers<ContextType>;
  UserLoginStage?: UserLoginStageResolvers<ContextType>;
  StagesUserLoginRetrieveResponse?: StagesUserLoginRetrieveResponseResolvers<ContextType>;
  StagesUserLoginUsedByListResponse?: StagesUserLoginUsedByListResponseResolvers<ContextType>;
  StagesUserLogoutListResponse?: StagesUserLogoutListResponseResolvers<ContextType>;
  PaginatedUserLogoutStageList?: PaginatedUserLogoutStageListResolvers<ContextType>;
  UserLogoutStage?: UserLogoutStageResolvers<ContextType>;
  StagesUserLogoutRetrieveResponse?: StagesUserLogoutRetrieveResponseResolvers<ContextType>;
  StagesUserLogoutUsedByListResponse?: StagesUserLogoutUsedByListResponseResolvers<ContextType>;
  StagesUserWriteListResponse?: StagesUserWriteListResponseResolvers<ContextType>;
  PaginatedUserWriteStageList?: PaginatedUserWriteStageListResolvers<ContextType>;
  UserWriteStage?: UserWriteStageResolvers<ContextType>;
  StagesUserWriteRetrieveResponse?: StagesUserWriteRetrieveResponseResolvers<ContextType>;
  StagesUserWriteUsedByListResponse?: StagesUserWriteUsedByListResponseResolvers<ContextType>;
  AdminSettingsUpdateResponse?: AdminSettingsUpdateResponseResolvers<ContextType>;
  NonEmptyString?: GraphQLScalarType;
  AdminSettingsPartialUpdateResponse?: AdminSettingsPartialUpdateResponseResolvers<ContextType>;
  AdminSystemCreateResponse?: AdminSystemCreateResponseResolvers<ContextType>;
  AuthenticatorsAdminDuoCreateResponse?: AuthenticatorsAdminDuoCreateResponseResolvers<ContextType>;
  MutationInputAuthenticatorsAdminDuoCreateInputName?: GraphQLScalarType;
  AuthenticatorsAdminDuoUpdateResponse?: AuthenticatorsAdminDuoUpdateResponseResolvers<ContextType>;
  AuthenticatorsAdminDuoPartialUpdateResponse?: AuthenticatorsAdminDuoPartialUpdateResponseResolvers<ContextType>;
  MutationInputAuthenticatorsAdminDuoPartialUpdateInputName?: GraphQLScalarType;
  AuthenticatorsAdminDuoDestroyResponse?: AuthenticatorsAdminDuoDestroyResponseResolvers<ContextType>;
  AuthenticatorsAdminSmsCreateResponse?: AuthenticatorsAdminSmsCreateResponseResolvers<ContextType>;
  MutationInputAuthenticatorsAdminSmsCreateInputName?: GraphQLScalarType;
  AuthenticatorsAdminSmsUpdateResponse?: AuthenticatorsAdminSmsUpdateResponseResolvers<ContextType>;
  AuthenticatorsAdminSmsPartialUpdateResponse?: AuthenticatorsAdminSmsPartialUpdateResponseResolvers<ContextType>;
  MutationInputAuthenticatorsAdminSmsPartialUpdateInputName?: GraphQLScalarType;
  AuthenticatorsAdminSmsDestroyResponse?: AuthenticatorsAdminSmsDestroyResponseResolvers<ContextType>;
  AuthenticatorsAdminStaticCreateResponse?: AuthenticatorsAdminStaticCreateResponseResolvers<ContextType>;
  MutationInputAuthenticatorsAdminStaticCreateInputName?: GraphQLScalarType;
  AuthenticatorsAdminStaticUpdateResponse?: AuthenticatorsAdminStaticUpdateResponseResolvers<ContextType>;
  AuthenticatorsAdminStaticPartialUpdateResponse?: AuthenticatorsAdminStaticPartialUpdateResponseResolvers<ContextType>;
  MutationInputAuthenticatorsAdminStaticPartialUpdateInputName?: GraphQLScalarType;
  AuthenticatorsAdminStaticDestroyResponse?: AuthenticatorsAdminStaticDestroyResponseResolvers<ContextType>;
  AuthenticatorsAdminTotpCreateResponse?: AuthenticatorsAdminTotpCreateResponseResolvers<ContextType>;
  MutationInputAuthenticatorsAdminTotpCreateInputName?: GraphQLScalarType;
  AuthenticatorsAdminTotpUpdateResponse?: AuthenticatorsAdminTotpUpdateResponseResolvers<ContextType>;
  AuthenticatorsAdminTotpPartialUpdateResponse?: AuthenticatorsAdminTotpPartialUpdateResponseResolvers<ContextType>;
  MutationInputAuthenticatorsAdminTotpPartialUpdateInputName?: GraphQLScalarType;
  AuthenticatorsAdminTotpDestroyResponse?: AuthenticatorsAdminTotpDestroyResponseResolvers<ContextType>;
  AuthenticatorsAdminWebauthnCreateResponse?: AuthenticatorsAdminWebauthnCreateResponseResolvers<ContextType>;
  MutationInputAuthenticatorsAdminWebauthnCreateInputName?: GraphQLScalarType;
  AuthenticatorsAdminWebauthnUpdateResponse?: AuthenticatorsAdminWebauthnUpdateResponseResolvers<ContextType>;
  AuthenticatorsAdminWebauthnPartialUpdateResponse?: AuthenticatorsAdminWebauthnPartialUpdateResponseResolvers<ContextType>;
  MutationInputAuthenticatorsAdminWebauthnPartialUpdateInputName?: GraphQLScalarType;
  AuthenticatorsAdminWebauthnDestroyResponse?: AuthenticatorsAdminWebauthnDestroyResponseResolvers<ContextType>;
  AuthenticatorsDuoUpdateResponse?: AuthenticatorsDuoUpdateResponseResolvers<ContextType>;
  AuthenticatorsDuoPartialUpdateResponse?: AuthenticatorsDuoPartialUpdateResponseResolvers<ContextType>;
  AuthenticatorsDuoDestroyResponse?: AuthenticatorsDuoDestroyResponseResolvers<ContextType>;
  AuthenticatorsSmsUpdateResponse?: AuthenticatorsSmsUpdateResponseResolvers<ContextType>;
  AuthenticatorsSmsPartialUpdateResponse?: AuthenticatorsSmsPartialUpdateResponseResolvers<ContextType>;
  AuthenticatorsSmsDestroyResponse?: AuthenticatorsSmsDestroyResponseResolvers<ContextType>;
  AuthenticatorsStaticUpdateResponse?: AuthenticatorsStaticUpdateResponseResolvers<ContextType>;
  AuthenticatorsStaticPartialUpdateResponse?: AuthenticatorsStaticPartialUpdateResponseResolvers<ContextType>;
  AuthenticatorsStaticDestroyResponse?: AuthenticatorsStaticDestroyResponseResolvers<ContextType>;
  AuthenticatorsTotpUpdateResponse?: AuthenticatorsTotpUpdateResponseResolvers<ContextType>;
  AuthenticatorsTotpPartialUpdateResponse?: AuthenticatorsTotpPartialUpdateResponseResolvers<ContextType>;
  AuthenticatorsTotpDestroyResponse?: AuthenticatorsTotpDestroyResponseResolvers<ContextType>;
  AuthenticatorsWebauthnUpdateResponse?: AuthenticatorsWebauthnUpdateResponseResolvers<ContextType>;
  AuthenticatorsWebauthnPartialUpdateResponse?: AuthenticatorsWebauthnPartialUpdateResponseResolvers<ContextType>;
  AuthenticatorsWebauthnDestroyResponse?: AuthenticatorsWebauthnDestroyResponseResolvers<ContextType>;
  CoreApplicationsCreateResponse?: CoreApplicationsCreateResponseResolvers<ContextType>;
  MutationInputCoreApplicationsCreateInputSlug?: GraphQLScalarType;
  CoreApplicationsUpdateResponse?: CoreApplicationsUpdateResponseResolvers<ContextType>;
  CoreApplicationsPartialUpdateResponse?: CoreApplicationsPartialUpdateResponseResolvers<ContextType>;
  MutationInputCoreApplicationsPartialUpdateInputSlug?: GraphQLScalarType;
  CoreApplicationsDestroyResponse?: CoreApplicationsDestroyResponseResolvers<ContextType>;
  CoreAuthenticatedSessionsDestroyResponse?: CoreAuthenticatedSessionsDestroyResponseResolvers<ContextType>;
  CoreBrandsCreateResponse?: CoreBrandsCreateResponseResolvers<ContextType>;
  CoreBrandsUpdateResponse?: CoreBrandsUpdateResponseResolvers<ContextType>;
  CoreBrandsPartialUpdateResponse?: CoreBrandsPartialUpdateResponseResolvers<ContextType>;
  CoreBrandsDestroyResponse?: CoreBrandsDestroyResponseResolvers<ContextType>;
  CoreGroupsCreateResponse?: CoreGroupsCreateResponseResolvers<ContextType>;
  MutationInputCoreGroupsCreateInputName?: GraphQLScalarType;
  CoreGroupsUpdateResponse?: CoreGroupsUpdateResponseResolvers<ContextType>;
  CoreGroupsPartialUpdateResponse?: CoreGroupsPartialUpdateResponseResolvers<ContextType>;
  MutationInputCoreGroupsPartialUpdateInputName?: GraphQLScalarType;
  CoreGroupsDestroyResponse?: CoreGroupsDestroyResponseResolvers<ContextType>;
  CoreGroupsAddUserCreateResponse?: CoreGroupsAddUserCreateResponseResolvers<ContextType>;
  CoreGroupsRemoveUserCreateResponse?: CoreGroupsRemoveUserCreateResponseResolvers<ContextType>;
  CoreTokensCreateResponse?: CoreTokensCreateResponseResolvers<ContextType>;
  MutationInputCoreTokensCreateInputIdentifier?: GraphQLScalarType;
  CoreTokensUpdateResponse?: CoreTokensUpdateResponseResolvers<ContextType>;
  CoreTokensPartialUpdateResponse?: CoreTokensPartialUpdateResponseResolvers<ContextType>;
  MutationInputCoreTokensPartialUpdateInputIdentifier?: GraphQLScalarType;
  CoreTokensDestroyResponse?: CoreTokensDestroyResponseResolvers<ContextType>;
  CoreTokensSetKeyCreateResponse?: CoreTokensSetKeyCreateResponseResolvers<ContextType>;
  CoreTransactionalApplicationsUpdateResponse?: CoreTransactionalApplicationsUpdateResponseResolvers<ContextType>;
  TransactionApplicationResponse?: TransactionApplicationResponseResolvers<ContextType>;
  MutationInputCoreTransactionalApplicationsUpdateInputProviderOneOf_1ClientId?: GraphQLScalarType;
  MutationInputCoreTransactionalApplicationsUpdateInputProviderOneOf_1ClientSecret?: GraphQLScalarType;
  CoreUserConsentDestroyResponse?: CoreUserConsentDestroyResponseResolvers<ContextType>;
  CoreUsersCreateResponse?: CoreUsersCreateResponseResolvers<ContextType>;
  MutationInputCoreUsersCreateInputUsername?: GraphQLScalarType;
  CoreUsersUpdateResponse?: CoreUsersUpdateResponseResolvers<ContextType>;
  CoreUsersPartialUpdateResponse?: CoreUsersPartialUpdateResponseResolvers<ContextType>;
  MutationInputCoreUsersPartialUpdateInputUsername?: GraphQLScalarType;
  CoreUsersDestroyResponse?: CoreUsersDestroyResponseResolvers<ContextType>;
  CoreUsersImpersonateCreateResponse?: CoreUsersImpersonateCreateResponseResolvers<ContextType>;
  CoreUsersRecoveryCreateResponse?: CoreUsersRecoveryCreateResponseResolvers<ContextType>;
  CoreUsersRecoveryEmailCreateResponse?: CoreUsersRecoveryEmailCreateResponseResolvers<ContextType>;
  CoreUsersSetPasswordCreateResponse?: CoreUsersSetPasswordCreateResponseResolvers<ContextType>;
  CoreUsersServiceAccountCreateResponse?: CoreUsersServiceAccountCreateResponseResolvers<ContextType>;
  UserServiceAccountResponse?: UserServiceAccountResponseResolvers<ContextType>;
  CryptoCertificatekeypairsCreateResponse?: CryptoCertificatekeypairsCreateResponseResolvers<ContextType>;
  CryptoCertificatekeypairsUpdateResponse?: CryptoCertificatekeypairsUpdateResponseResolvers<ContextType>;
  CryptoCertificatekeypairsPartialUpdateResponse?: CryptoCertificatekeypairsPartialUpdateResponseResolvers<ContextType>;
  CryptoCertificatekeypairsDestroyResponse?: CryptoCertificatekeypairsDestroyResponseResolvers<ContextType>;
  CryptoCertificatekeypairsGenerateCreateResponse?: CryptoCertificatekeypairsGenerateCreateResponseResolvers<ContextType>;
  EnterpriseLicenseCreateResponse?: EnterpriseLicenseCreateResponseResolvers<ContextType>;
  EnterpriseLicenseUpdateResponse?: EnterpriseLicenseUpdateResponseResolvers<ContextType>;
  EnterpriseLicensePartialUpdateResponse?: EnterpriseLicensePartialUpdateResponseResolvers<ContextType>;
  EnterpriseLicenseDestroyResponse?: EnterpriseLicenseDestroyResponseResolvers<ContextType>;
  EventsEventsCreateResponse?: EventsEventsCreateResponseResolvers<ContextType>;
  EventsEventsUpdateResponse?: EventsEventsUpdateResponseResolvers<ContextType>;
  EventsEventsPartialUpdateResponse?: EventsEventsPartialUpdateResponseResolvers<ContextType>;
  EventsEventsDestroyResponse?: EventsEventsDestroyResponseResolvers<ContextType>;
  EventsNotificationsUpdateResponse?: EventsNotificationsUpdateResponseResolvers<ContextType>;
  EventsNotificationsPartialUpdateResponse?: EventsNotificationsPartialUpdateResponseResolvers<ContextType>;
  EventsNotificationsDestroyResponse?: EventsNotificationsDestroyResponseResolvers<ContextType>;
  EventsNotificationsMarkAllSeenCreateResponse?: EventsNotificationsMarkAllSeenCreateResponseResolvers<ContextType>;
  EventsRulesCreateResponse?: EventsRulesCreateResponseResolvers<ContextType>;
  EventsRulesUpdateResponse?: EventsRulesUpdateResponseResolvers<ContextType>;
  EventsRulesPartialUpdateResponse?: EventsRulesPartialUpdateResponseResolvers<ContextType>;
  EventsRulesDestroyResponse?: EventsRulesDestroyResponseResolvers<ContextType>;
  EventsSystemTasksRunCreateResponse?: EventsSystemTasksRunCreateResponseResolvers<ContextType>;
  EventsTransportsCreateResponse?: EventsTransportsCreateResponseResolvers<ContextType>;
  EventsTransportsUpdateResponse?: EventsTransportsUpdateResponseResolvers<ContextType>;
  EventsTransportsPartialUpdateResponse?: EventsTransportsPartialUpdateResponseResolvers<ContextType>;
  EventsTransportsDestroyResponse?: EventsTransportsDestroyResponseResolvers<ContextType>;
  EventsTransportsTestCreateResponse?: EventsTransportsTestCreateResponseResolvers<ContextType>;
  NotificationTransportTest?: NotificationTransportTestResolvers<ContextType>;
  FlowsBindingsCreateResponse?: FlowsBindingsCreateResponseResolvers<ContextType>;
  FlowsBindingsUpdateResponse?: FlowsBindingsUpdateResponseResolvers<ContextType>;
  FlowsBindingsPartialUpdateResponse?: FlowsBindingsPartialUpdateResponseResolvers<ContextType>;
  FlowsBindingsDestroyResponse?: FlowsBindingsDestroyResponseResolvers<ContextType>;
  FlowsExecutorSolveResponse?: FlowsExecutorSolveResponseResolvers<ContextType>;
  FlowsInstancesCreateResponse?: FlowsInstancesCreateResponseResolvers<ContextType>;
  MutationInputFlowsInstancesCreateInputSlug?: GraphQLScalarType;
  FlowsInstancesUpdateResponse?: FlowsInstancesUpdateResponseResolvers<ContextType>;
  FlowsInstancesPartialUpdateResponse?: FlowsInstancesPartialUpdateResponseResolvers<ContextType>;
  MutationInputFlowsInstancesPartialUpdateInputSlug?: GraphQLScalarType;
  FlowsInstancesDestroyResponse?: FlowsInstancesDestroyResponseResolvers<ContextType>;
  FlowsInstancesCacheClearCreateResponse?: FlowsInstancesCacheClearCreateResponseResolvers<ContextType>;
  FlowsInstancesImportCreateResponse?: FlowsInstancesImportCreateResponseResolvers<ContextType>;
  FlowImportResult?: FlowImportResultResolvers<ContextType>;
  ManagedBlueprintsCreateResponse?: ManagedBlueprintsCreateResponseResolvers<ContextType>;
  ManagedBlueprintsUpdateResponse?: ManagedBlueprintsUpdateResponseResolvers<ContextType>;
  ManagedBlueprintsPartialUpdateResponse?: ManagedBlueprintsPartialUpdateResponseResolvers<ContextType>;
  ManagedBlueprintsDestroyResponse?: ManagedBlueprintsDestroyResponseResolvers<ContextType>;
  ManagedBlueprintsApplyCreateResponse?: ManagedBlueprintsApplyCreateResponseResolvers<ContextType>;
  Oauth2AccessTokensDestroyResponse?: Oauth2AccessTokensDestroyResponseResolvers<ContextType>;
  Oauth2AuthorizationCodesDestroyResponse?: Oauth2AuthorizationCodesDestroyResponseResolvers<ContextType>;
  Oauth2RefreshTokensDestroyResponse?: Oauth2RefreshTokensDestroyResponseResolvers<ContextType>;
  OutpostsInstancesCreateResponse?: OutpostsInstancesCreateResponseResolvers<ContextType>;
  OutpostsInstancesUpdateResponse?: OutpostsInstancesUpdateResponseResolvers<ContextType>;
  OutpostsInstancesPartialUpdateResponse?: OutpostsInstancesPartialUpdateResponseResolvers<ContextType>;
  OutpostsInstancesDestroyResponse?: OutpostsInstancesDestroyResponseResolvers<ContextType>;
  OutpostsServiceConnectionsAllDestroyResponse?: OutpostsServiceConnectionsAllDestroyResponseResolvers<ContextType>;
  OutpostsServiceConnectionsDockerCreateResponse?: OutpostsServiceConnectionsDockerCreateResponseResolvers<ContextType>;
  OutpostsServiceConnectionsDockerUpdateResponse?: OutpostsServiceConnectionsDockerUpdateResponseResolvers<ContextType>;
  OutpostsServiceConnectionsDockerPartialUpdateResponse?: OutpostsServiceConnectionsDockerPartialUpdateResponseResolvers<ContextType>;
  OutpostsServiceConnectionsDockerDestroyResponse?: OutpostsServiceConnectionsDockerDestroyResponseResolvers<ContextType>;
  OutpostsServiceConnectionsKubernetesCreateResponse?: OutpostsServiceConnectionsKubernetesCreateResponseResolvers<ContextType>;
  OutpostsServiceConnectionsKubernetesUpdateResponse?: OutpostsServiceConnectionsKubernetesUpdateResponseResolvers<ContextType>;
  OutpostsServiceConnectionsKubernetesPartialUpdateResponse?: OutpostsServiceConnectionsKubernetesPartialUpdateResponseResolvers<ContextType>;
  OutpostsServiceConnectionsKubernetesDestroyResponse?: OutpostsServiceConnectionsKubernetesDestroyResponseResolvers<ContextType>;
  PoliciesAllDestroyResponse?: PoliciesAllDestroyResponseResolvers<ContextType>;
  PoliciesAllTestCreateResponse?: PoliciesAllTestCreateResponseResolvers<ContextType>;
  PoliciesAllCacheClearCreateResponse?: PoliciesAllCacheClearCreateResponseResolvers<ContextType>;
  PoliciesBindingsCreateResponse?: PoliciesBindingsCreateResponseResolvers<ContextType>;
  PoliciesBindingsUpdateResponse?: PoliciesBindingsUpdateResponseResolvers<ContextType>;
  PoliciesBindingsPartialUpdateResponse?: PoliciesBindingsPartialUpdateResponseResolvers<ContextType>;
  PoliciesBindingsDestroyResponse?: PoliciesBindingsDestroyResponseResolvers<ContextType>;
  PoliciesDummyCreateResponse?: PoliciesDummyCreateResponseResolvers<ContextType>;
  PoliciesDummyUpdateResponse?: PoliciesDummyUpdateResponseResolvers<ContextType>;
  PoliciesDummyPartialUpdateResponse?: PoliciesDummyPartialUpdateResponseResolvers<ContextType>;
  PoliciesDummyDestroyResponse?: PoliciesDummyDestroyResponseResolvers<ContextType>;
  PoliciesEventMatcherCreateResponse?: PoliciesEventMatcherCreateResponseResolvers<ContextType>;
  PoliciesEventMatcherUpdateResponse?: PoliciesEventMatcherUpdateResponseResolvers<ContextType>;
  PoliciesEventMatcherPartialUpdateResponse?: PoliciesEventMatcherPartialUpdateResponseResolvers<ContextType>;
  PoliciesEventMatcherDestroyResponse?: PoliciesEventMatcherDestroyResponseResolvers<ContextType>;
  PoliciesExpressionCreateResponse?: PoliciesExpressionCreateResponseResolvers<ContextType>;
  PoliciesExpressionUpdateResponse?: PoliciesExpressionUpdateResponseResolvers<ContextType>;
  PoliciesExpressionPartialUpdateResponse?: PoliciesExpressionPartialUpdateResponseResolvers<ContextType>;
  PoliciesExpressionDestroyResponse?: PoliciesExpressionDestroyResponseResolvers<ContextType>;
  PoliciesPasswordCreateResponse?: PoliciesPasswordCreateResponseResolvers<ContextType>;
  PoliciesPasswordUpdateResponse?: PoliciesPasswordUpdateResponseResolvers<ContextType>;
  PoliciesPasswordPartialUpdateResponse?: PoliciesPasswordPartialUpdateResponseResolvers<ContextType>;
  PoliciesPasswordDestroyResponse?: PoliciesPasswordDestroyResponseResolvers<ContextType>;
  PoliciesPasswordExpiryCreateResponse?: PoliciesPasswordExpiryCreateResponseResolvers<ContextType>;
  PoliciesPasswordExpiryUpdateResponse?: PoliciesPasswordExpiryUpdateResponseResolvers<ContextType>;
  PoliciesPasswordExpiryPartialUpdateResponse?: PoliciesPasswordExpiryPartialUpdateResponseResolvers<ContextType>;
  PoliciesPasswordExpiryDestroyResponse?: PoliciesPasswordExpiryDestroyResponseResolvers<ContextType>;
  PoliciesReputationCreateResponse?: PoliciesReputationCreateResponseResolvers<ContextType>;
  PoliciesReputationUpdateResponse?: PoliciesReputationUpdateResponseResolvers<ContextType>;
  PoliciesReputationPartialUpdateResponse?: PoliciesReputationPartialUpdateResponseResolvers<ContextType>;
  PoliciesReputationDestroyResponse?: PoliciesReputationDestroyResponseResolvers<ContextType>;
  PoliciesReputationScoresDestroyResponse?: PoliciesReputationScoresDestroyResponseResolvers<ContextType>;
  PropertymappingsAllDestroyResponse?: PropertymappingsAllDestroyResponseResolvers<ContextType>;
  PropertymappingsAllTestCreateResponse?: PropertymappingsAllTestCreateResponseResolvers<ContextType>;
  PropertyMappingTestResult?: PropertyMappingTestResultResolvers<ContextType>;
  PropertymappingsLdapCreateResponse?: PropertymappingsLdapCreateResponseResolvers<ContextType>;
  PropertymappingsLdapUpdateResponse?: PropertymappingsLdapUpdateResponseResolvers<ContextType>;
  PropertymappingsLdapPartialUpdateResponse?: PropertymappingsLdapPartialUpdateResponseResolvers<ContextType>;
  PropertymappingsLdapDestroyResponse?: PropertymappingsLdapDestroyResponseResolvers<ContextType>;
  PropertymappingsNotificationCreateResponse?: PropertymappingsNotificationCreateResponseResolvers<ContextType>;
  PropertymappingsNotificationUpdateResponse?: PropertymappingsNotificationUpdateResponseResolvers<ContextType>;
  PropertymappingsNotificationPartialUpdateResponse?: PropertymappingsNotificationPartialUpdateResponseResolvers<ContextType>;
  PropertymappingsNotificationDestroyResponse?: PropertymappingsNotificationDestroyResponseResolvers<ContextType>;
  PropertymappingsRacCreateResponse?: PropertymappingsRacCreateResponseResolvers<ContextType>;
  PropertymappingsRacUpdateResponse?: PropertymappingsRacUpdateResponseResolvers<ContextType>;
  PropertymappingsRacPartialUpdateResponse?: PropertymappingsRacPartialUpdateResponseResolvers<ContextType>;
  PropertymappingsRacDestroyResponse?: PropertymappingsRacDestroyResponseResolvers<ContextType>;
  PropertymappingsSamlCreateResponse?: PropertymappingsSamlCreateResponseResolvers<ContextType>;
  PropertymappingsSamlUpdateResponse?: PropertymappingsSamlUpdateResponseResolvers<ContextType>;
  PropertymappingsSamlPartialUpdateResponse?: PropertymappingsSamlPartialUpdateResponseResolvers<ContextType>;
  PropertymappingsSamlDestroyResponse?: PropertymappingsSamlDestroyResponseResolvers<ContextType>;
  PropertymappingsScimCreateResponse?: PropertymappingsScimCreateResponseResolvers<ContextType>;
  PropertymappingsScimUpdateResponse?: PropertymappingsScimUpdateResponseResolvers<ContextType>;
  PropertymappingsScimPartialUpdateResponse?: PropertymappingsScimPartialUpdateResponseResolvers<ContextType>;
  PropertymappingsScimDestroyResponse?: PropertymappingsScimDestroyResponseResolvers<ContextType>;
  PropertymappingsScopeCreateResponse?: PropertymappingsScopeCreateResponseResolvers<ContextType>;
  PropertymappingsScopeUpdateResponse?: PropertymappingsScopeUpdateResponseResolvers<ContextType>;
  PropertymappingsScopePartialUpdateResponse?: PropertymappingsScopePartialUpdateResponseResolvers<ContextType>;
  PropertymappingsScopeDestroyResponse?: PropertymappingsScopeDestroyResponseResolvers<ContextType>;
  ProvidersAllDestroyResponse?: ProvidersAllDestroyResponseResolvers<ContextType>;
  ProvidersLdapCreateResponse?: ProvidersLdapCreateResponseResolvers<ContextType>;
  ProvidersLdapUpdateResponse?: ProvidersLdapUpdateResponseResolvers<ContextType>;
  ProvidersLdapPartialUpdateResponse?: ProvidersLdapPartialUpdateResponseResolvers<ContextType>;
  ProvidersLdapDestroyResponse?: ProvidersLdapDestroyResponseResolvers<ContextType>;
  ProvidersOauth2CreateResponse?: ProvidersOauth2CreateResponseResolvers<ContextType>;
  ProvidersOauth2UpdateResponse?: ProvidersOauth2UpdateResponseResolvers<ContextType>;
  ProvidersOauth2PartialUpdateResponse?: ProvidersOauth2PartialUpdateResponseResolvers<ContextType>;
  MutationInputProvidersOauth2PartialUpdateInputClientId?: GraphQLScalarType;
  MutationInputProvidersOauth2PartialUpdateInputClientSecret?: GraphQLScalarType;
  ProvidersOauth2DestroyResponse?: ProvidersOauth2DestroyResponseResolvers<ContextType>;
  ProvidersProxyCreateResponse?: ProvidersProxyCreateResponseResolvers<ContextType>;
  ProvidersProxyUpdateResponse?: ProvidersProxyUpdateResponseResolvers<ContextType>;
  ProvidersProxyPartialUpdateResponse?: ProvidersProxyPartialUpdateResponseResolvers<ContextType>;
  ProvidersProxyDestroyResponse?: ProvidersProxyDestroyResponseResolvers<ContextType>;
  ProvidersRacCreateResponse?: ProvidersRacCreateResponseResolvers<ContextType>;
  ProvidersRacUpdateResponse?: ProvidersRacUpdateResponseResolvers<ContextType>;
  ProvidersRacPartialUpdateResponse?: ProvidersRacPartialUpdateResponseResolvers<ContextType>;
  ProvidersRacDestroyResponse?: ProvidersRacDestroyResponseResolvers<ContextType>;
  ProvidersRadiusCreateResponse?: ProvidersRadiusCreateResponseResolvers<ContextType>;
  ProvidersRadiusUpdateResponse?: ProvidersRadiusUpdateResponseResolvers<ContextType>;
  ProvidersRadiusPartialUpdateResponse?: ProvidersRadiusPartialUpdateResponseResolvers<ContextType>;
  ProvidersRadiusDestroyResponse?: ProvidersRadiusDestroyResponseResolvers<ContextType>;
  ProvidersSamlCreateResponse?: ProvidersSamlCreateResponseResolvers<ContextType>;
  ProvidersSamlUpdateResponse?: ProvidersSamlUpdateResponseResolvers<ContextType>;
  ProvidersSamlPartialUpdateResponse?: ProvidersSamlPartialUpdateResponseResolvers<ContextType>;
  ProvidersSamlDestroyResponse?: ProvidersSamlDestroyResponseResolvers<ContextType>;
  ProvidersSamlImportMetadataCreateResponse?: ProvidersSamlImportMetadataCreateResponseResolvers<ContextType>;
  ProvidersScimCreateResponse?: ProvidersScimCreateResponseResolvers<ContextType>;
  ProvidersScimUpdateResponse?: ProvidersScimUpdateResponseResolvers<ContextType>;
  ProvidersScimPartialUpdateResponse?: ProvidersScimPartialUpdateResponseResolvers<ContextType>;
  ProvidersScimDestroyResponse?: ProvidersScimDestroyResponseResolvers<ContextType>;
  RacConnectionTokensUpdateResponse?: RacConnectionTokensUpdateResponseResolvers<ContextType>;
  RacConnectionTokensPartialUpdateResponse?: RacConnectionTokensPartialUpdateResponseResolvers<ContextType>;
  RacConnectionTokensDestroyResponse?: RacConnectionTokensDestroyResponseResolvers<ContextType>;
  RacEndpointsCreateResponse?: RacEndpointsCreateResponseResolvers<ContextType>;
  RacEndpointsUpdateResponse?: RacEndpointsUpdateResponseResolvers<ContextType>;
  RacEndpointsPartialUpdateResponse?: RacEndpointsPartialUpdateResponseResolvers<ContextType>;
  RacEndpointsDestroyResponse?: RacEndpointsDestroyResponseResolvers<ContextType>;
  RbacPermissionsAssignedByRolesAssignCreateResponse?: RbacPermissionsAssignedByRolesAssignCreateResponseResolvers<ContextType>;
  RbacPermissionsAssignedByRolesUnassignPartialUpdateResponse?: RbacPermissionsAssignedByRolesUnassignPartialUpdateResponseResolvers<ContextType>;
  RbacPermissionsAssignedByUsersAssignCreateResponse?: RbacPermissionsAssignedByUsersAssignCreateResponseResolvers<ContextType>;
  RbacPermissionsAssignedByUsersUnassignPartialUpdateResponse?: RbacPermissionsAssignedByUsersUnassignPartialUpdateResponseResolvers<ContextType>;
  RbacRolesCreateResponse?: RbacRolesCreateResponseResolvers<ContextType>;
  MutationInputRbacRolesCreateInputName?: GraphQLScalarType;
  RbacRolesUpdateResponse?: RbacRolesUpdateResponseResolvers<ContextType>;
  RbacRolesPartialUpdateResponse?: RbacRolesPartialUpdateResponseResolvers<ContextType>;
  MutationInputRbacRolesPartialUpdateInputName?: GraphQLScalarType;
  RbacRolesDestroyResponse?: RbacRolesDestroyResponseResolvers<ContextType>;
  SourcesAllDestroyResponse?: SourcesAllDestroyResponseResolvers<ContextType>;
  SourcesLdapCreateResponse?: SourcesLdapCreateResponseResolvers<ContextType>;
  MutationInputSourcesLdapCreateInputSlug?: GraphQLScalarType;
  SourcesLdapUpdateResponse?: SourcesLdapUpdateResponseResolvers<ContextType>;
  SourcesLdapPartialUpdateResponse?: SourcesLdapPartialUpdateResponseResolvers<ContextType>;
  MutationInputSourcesLdapPartialUpdateInputSlug?: GraphQLScalarType;
  SourcesLdapDestroyResponse?: SourcesLdapDestroyResponseResolvers<ContextType>;
  SourcesOauthCreateResponse?: SourcesOauthCreateResponseResolvers<ContextType>;
  MutationInputSourcesOauthCreateInputSlug?: GraphQLScalarType;
  MutationInputSourcesOauthCreateInputRequestTokenUrl?: GraphQLScalarType;
  MutationInputSourcesOauthCreateInputAuthorizationUrl?: GraphQLScalarType;
  MutationInputSourcesOauthCreateInputAccessTokenUrl?: GraphQLScalarType;
  MutationInputSourcesOauthCreateInputProfileUrl?: GraphQLScalarType;
  SourcesOauthUpdateResponse?: SourcesOauthUpdateResponseResolvers<ContextType>;
  SourcesOauthPartialUpdateResponse?: SourcesOauthPartialUpdateResponseResolvers<ContextType>;
  MutationInputSourcesOauthPartialUpdateInputSlug?: GraphQLScalarType;
  MutationInputSourcesOauthPartialUpdateInputRequestTokenUrl?: GraphQLScalarType;
  MutationInputSourcesOauthPartialUpdateInputAuthorizationUrl?: GraphQLScalarType;
  MutationInputSourcesOauthPartialUpdateInputAccessTokenUrl?: GraphQLScalarType;
  MutationInputSourcesOauthPartialUpdateInputProfileUrl?: GraphQLScalarType;
  SourcesOauthDestroyResponse?: SourcesOauthDestroyResponseResolvers<ContextType>;
  SourcesPlexCreateResponse?: SourcesPlexCreateResponseResolvers<ContextType>;
  MutationInputSourcesPlexCreateInputSlug?: GraphQLScalarType;
  SourcesPlexUpdateResponse?: SourcesPlexUpdateResponseResolvers<ContextType>;
  SourcesPlexPartialUpdateResponse?: SourcesPlexPartialUpdateResponseResolvers<ContextType>;
  MutationInputSourcesPlexPartialUpdateInputSlug?: GraphQLScalarType;
  SourcesPlexDestroyResponse?: SourcesPlexDestroyResponseResolvers<ContextType>;
  SourcesSamlCreateResponse?: SourcesSamlCreateResponseResolvers<ContextType>;
  MutationInputSourcesSamlCreateInputSlug?: GraphQLScalarType;
  SourcesSamlUpdateResponse?: SourcesSamlUpdateResponseResolvers<ContextType>;
  SourcesSamlPartialUpdateResponse?: SourcesSamlPartialUpdateResponseResolvers<ContextType>;
  MutationInputSourcesSamlPartialUpdateInputSlug?: GraphQLScalarType;
  SourcesSamlDestroyResponse?: SourcesSamlDestroyResponseResolvers<ContextType>;
  SourcesScimCreateResponse?: SourcesScimCreateResponseResolvers<ContextType>;
  MutationInputSourcesScimCreateInputSlug?: GraphQLScalarType;
  SourcesScimUpdateResponse?: SourcesScimUpdateResponseResolvers<ContextType>;
  SourcesScimPartialUpdateResponse?: SourcesScimPartialUpdateResponseResolvers<ContextType>;
  MutationInputSourcesScimPartialUpdateInputSlug?: GraphQLScalarType;
  SourcesScimDestroyResponse?: SourcesScimDestroyResponseResolvers<ContextType>;
  SourcesScimGroupsCreateResponse?: SourcesScimGroupsCreateResponseResolvers<ContextType>;
  SourcesScimGroupsUpdateResponse?: SourcesScimGroupsUpdateResponseResolvers<ContextType>;
  SourcesScimGroupsPartialUpdateResponse?: SourcesScimGroupsPartialUpdateResponseResolvers<ContextType>;
  SourcesScimGroupsDestroyResponse?: SourcesScimGroupsDestroyResponseResolvers<ContextType>;
  SourcesScimUsersCreateResponse?: SourcesScimUsersCreateResponseResolvers<ContextType>;
  SourcesScimUsersUpdateResponse?: SourcesScimUsersUpdateResponseResolvers<ContextType>;
  SourcesScimUsersPartialUpdateResponse?: SourcesScimUsersPartialUpdateResponseResolvers<ContextType>;
  SourcesScimUsersDestroyResponse?: SourcesScimUsersDestroyResponseResolvers<ContextType>;
  SourcesUserConnectionsAllUpdateResponse?: SourcesUserConnectionsAllUpdateResponseResolvers<ContextType>;
  SourcesUserConnectionsAllPartialUpdateResponse?: SourcesUserConnectionsAllPartialUpdateResponseResolvers<ContextType>;
  SourcesUserConnectionsAllDestroyResponse?: SourcesUserConnectionsAllDestroyResponseResolvers<ContextType>;
  SourcesUserConnectionsOauthCreateResponse?: SourcesUserConnectionsOauthCreateResponseResolvers<ContextType>;
  MutationInputSourcesUserConnectionsOauthCreateInputIdentifier?: GraphQLScalarType;
  SourcesUserConnectionsOauthUpdateResponse?: SourcesUserConnectionsOauthUpdateResponseResolvers<ContextType>;
  SourcesUserConnectionsOauthPartialUpdateResponse?: SourcesUserConnectionsOauthPartialUpdateResponseResolvers<ContextType>;
  MutationInputSourcesUserConnectionsOauthPartialUpdateInputIdentifier?: GraphQLScalarType;
  SourcesUserConnectionsOauthDestroyResponse?: SourcesUserConnectionsOauthDestroyResponseResolvers<ContextType>;
  SourcesUserConnectionsPlexCreateResponse?: SourcesUserConnectionsPlexCreateResponseResolvers<ContextType>;
  SourcesUserConnectionsPlexUpdateResponse?: SourcesUserConnectionsPlexUpdateResponseResolvers<ContextType>;
  SourcesUserConnectionsPlexPartialUpdateResponse?: SourcesUserConnectionsPlexPartialUpdateResponseResolvers<ContextType>;
  SourcesUserConnectionsPlexDestroyResponse?: SourcesUserConnectionsPlexDestroyResponseResolvers<ContextType>;
  SourcesUserConnectionsSamlCreateResponse?: SourcesUserConnectionsSamlCreateResponseResolvers<ContextType>;
  SourcesUserConnectionsSamlUpdateResponse?: SourcesUserConnectionsSamlUpdateResponseResolvers<ContextType>;
  SourcesUserConnectionsSamlPartialUpdateResponse?: SourcesUserConnectionsSamlPartialUpdateResponseResolvers<ContextType>;
  SourcesUserConnectionsSamlDestroyResponse?: SourcesUserConnectionsSamlDestroyResponseResolvers<ContextType>;
  StagesAllDestroyResponse?: StagesAllDestroyResponseResolvers<ContextType>;
  StagesAuthenticatorDuoCreateResponse?: StagesAuthenticatorDuoCreateResponseResolvers<ContextType>;
  MutationInputStagesAuthenticatorDuoCreateInputFlowSetItemsSlug?: GraphQLScalarType;
  StagesAuthenticatorDuoUpdateResponse?: StagesAuthenticatorDuoUpdateResponseResolvers<ContextType>;
  StagesAuthenticatorDuoPartialUpdateResponse?: StagesAuthenticatorDuoPartialUpdateResponseResolvers<ContextType>;
  StagesAuthenticatorDuoDestroyResponse?: StagesAuthenticatorDuoDestroyResponseResolvers<ContextType>;
  StagesAuthenticatorDuoEnrollmentStatusCreateResponse?: StagesAuthenticatorDuoEnrollmentStatusCreateResponseResolvers<ContextType>;
  DuoDeviceEnrollmentStatus?: DuoDeviceEnrollmentStatusResolvers<ContextType>;
  StagesAuthenticatorDuoImportDeviceManualCreateResponse?: StagesAuthenticatorDuoImportDeviceManualCreateResponseResolvers<ContextType>;
  StagesAuthenticatorDuoImportDevicesAutomaticCreateResponse?: StagesAuthenticatorDuoImportDevicesAutomaticCreateResponseResolvers<ContextType>;
  AuthenticatorDuoStageDeviceImportResponse?: AuthenticatorDuoStageDeviceImportResponseResolvers<ContextType>;
  StagesAuthenticatorSmsCreateResponse?: StagesAuthenticatorSmsCreateResponseResolvers<ContextType>;
  StagesAuthenticatorSmsUpdateResponse?: StagesAuthenticatorSmsUpdateResponseResolvers<ContextType>;
  StagesAuthenticatorSmsPartialUpdateResponse?: StagesAuthenticatorSmsPartialUpdateResponseResolvers<ContextType>;
  StagesAuthenticatorSmsDestroyResponse?: StagesAuthenticatorSmsDestroyResponseResolvers<ContextType>;
  StagesAuthenticatorStaticCreateResponse?: StagesAuthenticatorStaticCreateResponseResolvers<ContextType>;
  StagesAuthenticatorStaticUpdateResponse?: StagesAuthenticatorStaticUpdateResponseResolvers<ContextType>;
  StagesAuthenticatorStaticPartialUpdateResponse?: StagesAuthenticatorStaticPartialUpdateResponseResolvers<ContextType>;
  StagesAuthenticatorStaticDestroyResponse?: StagesAuthenticatorStaticDestroyResponseResolvers<ContextType>;
  StagesAuthenticatorTotpCreateResponse?: StagesAuthenticatorTotpCreateResponseResolvers<ContextType>;
  StagesAuthenticatorTotpUpdateResponse?: StagesAuthenticatorTotpUpdateResponseResolvers<ContextType>;
  StagesAuthenticatorTotpPartialUpdateResponse?: StagesAuthenticatorTotpPartialUpdateResponseResolvers<ContextType>;
  StagesAuthenticatorTotpDestroyResponse?: StagesAuthenticatorTotpDestroyResponseResolvers<ContextType>;
  StagesAuthenticatorValidateCreateResponse?: StagesAuthenticatorValidateCreateResponseResolvers<ContextType>;
  StagesAuthenticatorValidateUpdateResponse?: StagesAuthenticatorValidateUpdateResponseResolvers<ContextType>;
  StagesAuthenticatorValidatePartialUpdateResponse?: StagesAuthenticatorValidatePartialUpdateResponseResolvers<ContextType>;
  StagesAuthenticatorValidateDestroyResponse?: StagesAuthenticatorValidateDestroyResponseResolvers<ContextType>;
  StagesAuthenticatorWebauthnCreateResponse?: StagesAuthenticatorWebauthnCreateResponseResolvers<ContextType>;
  StagesAuthenticatorWebauthnUpdateResponse?: StagesAuthenticatorWebauthnUpdateResponseResolvers<ContextType>;
  StagesAuthenticatorWebauthnPartialUpdateResponse?: StagesAuthenticatorWebauthnPartialUpdateResponseResolvers<ContextType>;
  StagesAuthenticatorWebauthnDestroyResponse?: StagesAuthenticatorWebauthnDestroyResponseResolvers<ContextType>;
  StagesCaptchaCreateResponse?: StagesCaptchaCreateResponseResolvers<ContextType>;
  StagesCaptchaUpdateResponse?: StagesCaptchaUpdateResponseResolvers<ContextType>;
  StagesCaptchaPartialUpdateResponse?: StagesCaptchaPartialUpdateResponseResolvers<ContextType>;
  StagesCaptchaDestroyResponse?: StagesCaptchaDestroyResponseResolvers<ContextType>;
  StagesConsentCreateResponse?: StagesConsentCreateResponseResolvers<ContextType>;
  StagesConsentUpdateResponse?: StagesConsentUpdateResponseResolvers<ContextType>;
  StagesConsentPartialUpdateResponse?: StagesConsentPartialUpdateResponseResolvers<ContextType>;
  StagesConsentDestroyResponse?: StagesConsentDestroyResponseResolvers<ContextType>;
  StagesDenyCreateResponse?: StagesDenyCreateResponseResolvers<ContextType>;
  StagesDenyUpdateResponse?: StagesDenyUpdateResponseResolvers<ContextType>;
  StagesDenyPartialUpdateResponse?: StagesDenyPartialUpdateResponseResolvers<ContextType>;
  StagesDenyDestroyResponse?: StagesDenyDestroyResponseResolvers<ContextType>;
  StagesDummyCreateResponse?: StagesDummyCreateResponseResolvers<ContextType>;
  StagesDummyUpdateResponse?: StagesDummyUpdateResponseResolvers<ContextType>;
  StagesDummyPartialUpdateResponse?: StagesDummyPartialUpdateResponseResolvers<ContextType>;
  StagesDummyDestroyResponse?: StagesDummyDestroyResponseResolvers<ContextType>;
  StagesEmailCreateResponse?: StagesEmailCreateResponseResolvers<ContextType>;
  StagesEmailUpdateResponse?: StagesEmailUpdateResponseResolvers<ContextType>;
  StagesEmailPartialUpdateResponse?: StagesEmailPartialUpdateResponseResolvers<ContextType>;
  StagesEmailDestroyResponse?: StagesEmailDestroyResponseResolvers<ContextType>;
  StagesIdentificationCreateResponse?: StagesIdentificationCreateResponseResolvers<ContextType>;
  StagesIdentificationUpdateResponse?: StagesIdentificationUpdateResponseResolvers<ContextType>;
  StagesIdentificationPartialUpdateResponse?: StagesIdentificationPartialUpdateResponseResolvers<ContextType>;
  StagesIdentificationDestroyResponse?: StagesIdentificationDestroyResponseResolvers<ContextType>;
  StagesInvitationInvitationsCreateResponse?: StagesInvitationInvitationsCreateResponseResolvers<ContextType>;
  MutationInputStagesInvitationInvitationsCreateInputName?: GraphQLScalarType;
  StagesInvitationInvitationsUpdateResponse?: StagesInvitationInvitationsUpdateResponseResolvers<ContextType>;
  StagesInvitationInvitationsPartialUpdateResponse?: StagesInvitationInvitationsPartialUpdateResponseResolvers<ContextType>;
  MutationInputStagesInvitationInvitationsPartialUpdateInputName?: GraphQLScalarType;
  StagesInvitationInvitationsDestroyResponse?: StagesInvitationInvitationsDestroyResponseResolvers<ContextType>;
  StagesInvitationStagesCreateResponse?: StagesInvitationStagesCreateResponseResolvers<ContextType>;
  StagesInvitationStagesUpdateResponse?: StagesInvitationStagesUpdateResponseResolvers<ContextType>;
  StagesInvitationStagesPartialUpdateResponse?: StagesInvitationStagesPartialUpdateResponseResolvers<ContextType>;
  StagesInvitationStagesDestroyResponse?: StagesInvitationStagesDestroyResponseResolvers<ContextType>;
  StagesPasswordCreateResponse?: StagesPasswordCreateResponseResolvers<ContextType>;
  StagesPasswordUpdateResponse?: StagesPasswordUpdateResponseResolvers<ContextType>;
  StagesPasswordPartialUpdateResponse?: StagesPasswordPartialUpdateResponseResolvers<ContextType>;
  StagesPasswordDestroyResponse?: StagesPasswordDestroyResponseResolvers<ContextType>;
  StagesPromptPromptsCreateResponse?: StagesPromptPromptsCreateResponseResolvers<ContextType>;
  StagesPromptPromptsUpdateResponse?: StagesPromptPromptsUpdateResponseResolvers<ContextType>;
  StagesPromptPromptsPartialUpdateResponse?: StagesPromptPromptsPartialUpdateResponseResolvers<ContextType>;
  StagesPromptPromptsDestroyResponse?: StagesPromptPromptsDestroyResponseResolvers<ContextType>;
  StagesPromptPromptsPreviewCreateResponse?: StagesPromptPromptsPreviewCreateResponseResolvers<ContextType>;
  StagesPromptStagesCreateResponse?: StagesPromptStagesCreateResponseResolvers<ContextType>;
  StagesPromptStagesUpdateResponse?: StagesPromptStagesUpdateResponseResolvers<ContextType>;
  StagesPromptStagesPartialUpdateResponse?: StagesPromptStagesPartialUpdateResponseResolvers<ContextType>;
  StagesPromptStagesDestroyResponse?: StagesPromptStagesDestroyResponseResolvers<ContextType>;
  StagesSourceCreateResponse?: StagesSourceCreateResponseResolvers<ContextType>;
  StagesSourceUpdateResponse?: StagesSourceUpdateResponseResolvers<ContextType>;
  StagesSourcePartialUpdateResponse?: StagesSourcePartialUpdateResponseResolvers<ContextType>;
  StagesSourceDestroyResponse?: StagesSourceDestroyResponseResolvers<ContextType>;
  StagesUserDeleteCreateResponse?: StagesUserDeleteCreateResponseResolvers<ContextType>;
  StagesUserDeleteUpdateResponse?: StagesUserDeleteUpdateResponseResolvers<ContextType>;
  StagesUserDeletePartialUpdateResponse?: StagesUserDeletePartialUpdateResponseResolvers<ContextType>;
  StagesUserDeleteDestroyResponse?: StagesUserDeleteDestroyResponseResolvers<ContextType>;
  StagesUserLoginCreateResponse?: StagesUserLoginCreateResponseResolvers<ContextType>;
  StagesUserLoginUpdateResponse?: StagesUserLoginUpdateResponseResolvers<ContextType>;
  StagesUserLoginPartialUpdateResponse?: StagesUserLoginPartialUpdateResponseResolvers<ContextType>;
  StagesUserLoginDestroyResponse?: StagesUserLoginDestroyResponseResolvers<ContextType>;
  StagesUserLogoutCreateResponse?: StagesUserLogoutCreateResponseResolvers<ContextType>;
  StagesUserLogoutUpdateResponse?: StagesUserLogoutUpdateResponseResolvers<ContextType>;
  StagesUserLogoutPartialUpdateResponse?: StagesUserLogoutPartialUpdateResponseResolvers<ContextType>;
  StagesUserLogoutDestroyResponse?: StagesUserLogoutDestroyResponseResolvers<ContextType>;
  StagesUserWriteCreateResponse?: StagesUserWriteCreateResponseResolvers<ContextType>;
  StagesUserWriteUpdateResponse?: StagesUserWriteUpdateResponseResolvers<ContextType>;
  StagesUserWritePartialUpdateResponse?: StagesUserWritePartialUpdateResponseResolvers<ContextType>;
  StagesUserWriteDestroyResponse?: StagesUserWriteDestroyResponseResolvers<ContextType>;
  ObjMap?: GraphQLScalarType;
  ResolveToSourceArgs?: GraphQLScalarType;
}>;

export type DirectiveResolvers<ContextType = MeshContext> = ResolversObject<{
  resolveRoot?: resolveRootDirectiveResolver<any, any, ContextType>;
  statusCodeTypeName?: statusCodeTypeNameDirectiveResolver<any, any, ContextType>;
  length?: lengthDirectiveResolver<any, any, ContextType>;
  enum?: enumDirectiveResolver<any, any, ContextType>;
  regexp?: regexpDirectiveResolver<any, any, ContextType>;
  typescript?: typescriptDirectiveResolver<any, any, ContextType>;
  discriminator?: discriminatorDirectiveResolver<any, any, ContextType>;
  httpOperation?: httpOperationDirectiveResolver<any, any, ContextType>;
  transport?: transportDirectiveResolver<any, any, ContextType>;
  resolveTo?: resolveToDirectiveResolver<any, any, ContextType>;
}>;

export type MeshContext = ChurrosTypes.Context & AuthentikTypes.Context & BaseMeshContext;


import { fileURLToPath } from '@graphql-mesh/utils';
const baseDir = pathModule.join(pathModule.dirname(fileURLToPath(import.meta.url)), '..');

const importFn: ImportFn = <T>(moduleId: string) => {
  const relativeModuleId = (pathModule.isAbsolute(moduleId) ? pathModule.relative(baseDir, moduleId) : moduleId).split('\\').join('/').replace(baseDir + '/', '');
  switch(relativeModuleId) {
    default:
      return Promise.reject(new Error(`Cannot find module '${relativeModuleId}'.`));
  }
};

const rootStore = new MeshStore('.mesh', new FsStoreStorageAdapter({
  cwd: baseDir,
  importFn,
  fileType: "ts",
}), {
  readonly: true,
  validate: false
});

export function getMeshOptions() {
  console.warn('WARNING: These artifacts are built for development mode. Please run "mesh build" to build production artifacts');
  return findAndParseConfig({
    dir: baseDir,
    artifactsDir: ".mesh",
    configName: "mesh",
    additionalPackagePrefixes: [],
    initialLoggerPrefix: "🕸️  Mesh",
  });
}

export function createBuiltMeshHTTPHandler<TServerContext = {}>(): MeshHTTPHandler<TServerContext> {
  return createMeshHTTPHandler<TServerContext>({
    baseDir,
    getBuiltMesh: getBuiltMesh,
    rawServeConfig: {"browser":false},
  })
}

let meshInstance$: Promise<MeshInstance> | undefined;

export const pollingInterval = null;

export function getBuiltMesh(): Promise<MeshInstance> {
  if (meshInstance$ == null) {
    if (pollingInterval) {
      setInterval(() => {
        getMeshOptions()
        .then(meshOptions => getMesh(meshOptions))
        .then(newMesh =>
          meshInstance$.then(oldMesh => {
            oldMesh.destroy()
            meshInstance$ = Promise.resolve(newMesh)
          })
        ).catch(err => {
          console.error("Mesh polling failed so the existing version will be used:", err);
        });
      }, pollingInterval)
    }
    meshInstance$ = getMeshOptions().then(meshOptions => getMesh(meshOptions)).then(mesh => {
      const id = mesh.pubsub.subscribe('destroy', () => {
        meshInstance$ = undefined;
        mesh.pubsub.unsubscribe(id);
      });
      return mesh;
    });
  }
  return meshInstance$;
}

export const execute: ExecuteMeshFn = (...args) => getBuiltMesh().then(({ execute }) => execute(...args));

export const subscribe: SubscribeMeshFn = (...args) => getBuiltMesh().then(({ subscribe }) => subscribe(...args));