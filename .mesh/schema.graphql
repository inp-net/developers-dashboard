schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

directive @resolveRoot(subgraph: String) on FIELD_DEFINITION

directive @statusCodeTypeName(subgraph: String, typeName: String, statusCode: ID) repeatable on UNION

directive @length(subgraph: String, min: Int, max: Int) on SCALAR

directive @enum(subgraph: String, value: String) on ENUM_VALUE

directive @regexp(subgraph: String, pattern: String) on SCALAR

directive @typescript(subgraph: String, type: String) on SCALAR | ENUM

directive @discriminator(subgraph: String, field: String, mapping: ObjMap) on INTERFACE | UNION

directive @httpOperation(subgraph: String, path: String, operationSpecificHeaders: [[String]], httpMethod: HttpMethod, isBinary: Boolean, requestBaseBody: ObjMap, queryParamArgMap: ObjMap, queryStringOptionsByParam: ObjMap, jsonApiFields: Boolean, queryStringOptions: ObjMap) on FIELD_DEFINITION

directive @transport(subgraph: String, kind: String, location: String, headers: [[String]], queryStringOptions: ObjMap, queryParams: [[String]]) repeatable on SCHEMA

directive @resolveTo(requiredSelectionSet: String, sourceName: String!, sourceTypeName: String!, sourceFieldName: String!, sourceSelectionSet: String, sourceArgs: ResolveToSourceArgs, keyField: String, keysArg: String, pubsubTopic: String, filterBy: String, additionalArgs: ResolveToSourceArgs, result: String, resultType: String) on FIELD_DEFINITION

type Query {
  group(uid: String!): ChurrosGroup!
  """- **Rate limit:** 6000/minute"""
  me: ChurrosUser!
  user(id: ID, uid: String): ChurrosUser!
  """Custom list method that checks Policy based access instead of guardian"""
  applications(
    forUser: Int
    group: String
    metaDescription: String
    metaLaunchUrl: String
    metaPublisher: String
    name: String
    """Which field to use when ordering the results."""
    ordering: String
    """A page number within the paginated result set."""
    page: Int
    """Number of results to return per page."""
    pageSize: Int
    """A search term."""
    search: String
    slug: String
    superuserFullList: Boolean
  ): CoreApplicationsListResponse @httpOperation(subgraph: "Authentik", path: "/core/applications/", operationSpecificHeaders: [["accept", "application/json"]], httpMethod: GET, queryParamArgMap: "{\"for_user\":\"for_user\",\"group\":\"group\",\"meta_description\":\"meta_description\",\"meta_launch_url\":\"meta_launch_url\",\"meta_publisher\":\"meta_publisher\",\"name\":\"name\",\"ordering\":\"ordering\",\"page\":\"page\",\"page_size\":\"page_size\",\"search\":\"search\",\"slug\":\"slug\",\"superuser_full_list\":\"superuser_full_list\"}")
  """Application Viewset"""
  application(
    """Internal application name, used in URLs."""
    slug: String!
  ): CoreApplicationsRetrieveResponse @httpOperation(subgraph: "Authentik", path: "/core/applications/{args.slug}/", operationSpecificHeaders: [["accept", "application/json"]], httpMethod: GET)
  """Check access to a single application by slug"""
  coreApplicationsCheckAccessRetrieve(
    """Internal application name, used in URLs."""
    slug: String!
    forUser: Int
  ): CoreApplicationsCheckAccessRetrieveResponse @httpOperation(subgraph: "Authentik", path: "/core/applications/{args.slug}/check_access/", operationSpecificHeaders: [["accept", "application/json"]], httpMethod: GET, queryParamArgMap: "{\"for_user\":\"for_user\"}")
  """Metrics for application logins"""
  applicationMetrics(
    """Internal application name, used in URLs."""
    slug: String!
  ): [CoreApplicationsMetricsListResponse] @httpOperation(subgraph: "Authentik", path: "/core/applications/{args.slug}/metrics/", operationSpecificHeaders: [["accept", "application/json"]], httpMethod: GET)
  """Get a list of all objects that use this object"""
  coreApplicationsUsedByList(
    """Internal application name, used in URLs."""
    slug: String!
  ): [CoreApplicationsUsedByListResponse] @httpOperation(subgraph: "Authentik", path: "/core/applications/{args.slug}/used_by/", operationSpecificHeaders: [["accept", "application/json"]], httpMethod: GET)
  """FlowStageBinding Viewset"""
  flowsBindingsList(
    evaluateOnPlan: Boolean
    fsbUuid: UUID
    invalidResponseAction: QueryInputFlowsBindingsListInvalidResponseAction
    order: Int
    """Which field to use when ordering the results."""
    ordering: String
    """A page number within the paginated result set."""
    page: Int
    """Number of results to return per page."""
    pageSize: Int
    pbmUuid: UUID
    policies: [UUID]
    policyEngineMode: QueryInputFlowsBindingsListPolicyEngineMode
    reEvaluatePolicies: Boolean
    """A search term."""
    search: String
    stage: UUID
    target: UUID
  ): FlowsBindingsListResponse @httpOperation(subgraph: "Authentik", path: "/flows/bindings/", operationSpecificHeaders: [["accept", "application/json"]], httpMethod: GET, queryParamArgMap: "{\"evaluate_on_plan\":\"evaluate_on_plan\",\"fsb_uuid\":\"fsb_uuid\",\"invalid_response_action\":\"invalid_response_action\",\"order\":\"order\",\"ordering\":\"ordering\",\"page\":\"page\",\"page_size\":\"page_size\",\"pbm_uuid\":\"pbm_uuid\",\"policies\":\"policies\",\"policy_engine_mode\":\"policy_engine_mode\",\"re_evaluate_policies\":\"re_evaluate_policies\",\"search\":\"search\",\"stage\":\"stage\",\"target\":\"target\"}", queryStringOptionsByParam: "{\"policies\":{\"arrayFormat\":\"repeat\",\"destructObject\":true}}")
  """FlowStageBinding Viewset"""
  flowsBindingsRetrieve(
    """A UUID string identifying this Flow Stage Binding."""
    fsbUuid: UUID!
  ): FlowsBindingsRetrieveResponse @httpOperation(subgraph: "Authentik", path: "/flows/bindings/{args.fsb_uuid}/", operationSpecificHeaders: [["accept", "application/json"]], httpMethod: GET)
  """Get a list of all objects that use this object"""
  flowsBindingsUsedByList(
    """A UUID string identifying this Flow Stage Binding."""
    fsbUuid: UUID!
  ): [FlowsBindingsUsedByListResponse] @httpOperation(subgraph: "Authentik", path: "/flows/bindings/{args.fsb_uuid}/used_by/", operationSpecificHeaders: [["accept", "application/json"]], httpMethod: GET)
  """Get the next pending challenge from the currently active flow."""
  flowsExecutorGet(
    flowSlug: String!
    """Querystring as received"""
    query: String!
  ): FlowsExecutorGetResponse @httpOperation(subgraph: "Authentik", path: "/flows/executor/{args.flow_slug}/", operationSpecificHeaders: [["accept", "application/json"]], httpMethod: GET, queryParamArgMap: "{\"query\":\"query\"}")
  """Get current flow state and record it"""
  flowsInspectorGet(flowSlug: String!): FlowsInspectorGetResponse @httpOperation(subgraph: "Authentik", path: "/flows/inspector/{args.flow_slug}/", operationSpecificHeaders: [["accept", "application/json"]], httpMethod: GET)
  """Flow Viewset"""
  flowsInstancesList(
    deniedAction: QueryInputFlowsInstancesListDeniedAction
    designation: QueryInputFlowsInstancesListDesignation
    flowUuid: UUID
    name: String
    """Which field to use when ordering the results."""
    ordering: String
    """A page number within the paginated result set."""
    page: Int
    """Number of results to return per page."""
    pageSize: Int
    """A search term."""
    search: String
    slug: String
  ): FlowsInstancesListResponse @httpOperation(subgraph: "Authentik", path: "/flows/instances/", operationSpecificHeaders: [["accept", "application/json"]], httpMethod: GET, queryParamArgMap: "{\"denied_action\":\"denied_action\",\"designation\":\"designation\",\"flow_uuid\":\"flow_uuid\",\"name\":\"name\",\"ordering\":\"ordering\",\"page\":\"page\",\"page_size\":\"page_size\",\"search\":\"search\",\"slug\":\"slug\"}")
  """Flow Viewset"""
  flowsInstancesRetrieve(
    """Visible in the URL."""
    slug: String!
  ): FlowsInstancesRetrieveResponse @httpOperation(subgraph: "Authentik", path: "/flows/instances/{args.slug}/", operationSpecificHeaders: [["accept", "application/json"]], httpMethod: GET)
  """
  Return diagram for flow with slug `slug`, in the format used by flowchart.js
  """
  flowsInstancesDiagramRetrieve(
    """Visible in the URL."""
    slug: String!
  ): FlowsInstancesDiagramRetrieveResponse @httpOperation(subgraph: "Authentik", path: "/flows/instances/{args.slug}/diagram/", operationSpecificHeaders: [["accept", "application/json"]], httpMethod: GET)
  """Execute flow for current user"""
  flowsInstancesExecuteRetrieve(
    """Visible in the URL."""
    slug: String!
  ): FlowsInstancesExecuteRetrieveResponse @httpOperation(subgraph: "Authentik", path: "/flows/instances/{args.slug}/execute/", operationSpecificHeaders: [["accept", "application/json"]], httpMethod: GET)
  """Export flow to .yaml file"""
  flowsInstancesExportRetrieve(
    """Visible in the URL."""
    slug: String!
  ): FlowsInstancesExportRetrieveResponse @httpOperation(subgraph: "Authentik", path: "/flows/instances/{args.slug}/export/", operationSpecificHeaders: [["accept", "application/json"]], httpMethod: GET)
  """Get a list of all objects that use this object"""
  flowsInstancesUsedByList(
    """Visible in the URL."""
    slug: String!
  ): [FlowsInstancesUsedByListResponse] @httpOperation(subgraph: "Authentik", path: "/flows/instances/{args.slug}/used_by/", operationSpecificHeaders: [["accept", "application/json"]], httpMethod: GET)
  """Info about cached flows"""
  flowsInstancesCacheInfoRetrieve: FlowsInstancesCacheInfoRetrieveResponse @httpOperation(subgraph: "Authentik", path: "/flows/instances/cache_info/", operationSpecificHeaders: [["accept", "application/json"]], httpMethod: GET)
  """Provider Viewset"""
  providers(
    applicationIsnull: Boolean
    backchannelOnly: Boolean
    """Which field to use when ordering the results."""
    ordering: String
    """A page number within the paginated result set."""
    page: Int
    """Number of results to return per page."""
    pageSize: Int
    """A search term."""
    search: String
  ): ProvidersAllListResponse @httpOperation(subgraph: "Authentik", path: "/providers/all/", operationSpecificHeaders: [["accept", "application/json"]], httpMethod: GET, queryParamArgMap: "{\"application__isnull\":\"application__isnull\",\"backchannel_only\":\"backchannel_only\",\"ordering\":\"ordering\",\"page\":\"page\",\"page_size\":\"page_size\",\"search\":\"search\"}")
  """Provider Viewset"""
  provider(
    """A unique integer value identifying this provider."""
    id: Int!
  ): ProvidersAllRetrieveResponse @httpOperation(subgraph: "Authentik", path: "/providers/all/{args.id}/", operationSpecificHeaders: [["accept", "application/json"]], httpMethod: GET)
  """Get a list of all objects that use this object"""
  providersAllUsedByList(
    """A unique integer value identifying this provider."""
    id: Int!
  ): [ProvidersAllUsedByListResponse] @httpOperation(subgraph: "Authentik", path: "/providers/all/{args.id}/used_by/", operationSpecificHeaders: [["accept", "application/json"]], httpMethod: GET)
  """Get all creatable provider types"""
  providersAllTypesList: [ProvidersAllTypesListResponse] @httpOperation(subgraph: "Authentik", path: "/providers/all/types/", operationSpecificHeaders: [["accept", "application/json"]], httpMethod: GET)
}

"""
Permet de faire des requêtes de données temps-réel, via des _websockets_.
L'endpoint pour le temps réel est `wss://churros.inpt.fr/graphql`. 

Pour un client JavaScript, il y a par exemple [GraphQL-WebSocket](https://the-guild.dev/graphql/ws/get-started#use-the-client)

- **Rate limit par défault:** 600 / 10 minutes (par utilisateur·ice et par query)
"""
type Subscription {
  announcementsNow: [ChurrosAnnouncement!]!
  article(id: ChurrosLocalID!): ChurrosArticle!
  event(group: ChurrosUID, id: ChurrosLocalID, slug: String): ChurrosEvent!
  """
  Récupère un formulaire. On peut utiliser une subscription pour avoir la mise à jour en temps réel des réponses au formulaire.
  """
  form(
    """Identifiant local (sans le préfixe `form:`) du formulaire"""
    localId: String!
  ): ChurrosForm
  """Gets the homepage articles, customized if the user is logged in."""
  homepage(after: String, before: String, first: Int, last: Int): ChurrosQueryHomepageConnection!
  kioskReload: Boolean!
  registration(id: ID!): ChurrosSubscriptionRegistrationResult!
  thirdPartyApp(
    """The third party app's client_id. The 'app:' id prefix is optional."""
    id: ID!
  ): ChurrosThirdPartyApp!
}

"""
Announcement is a way to get a message accross the entire site, such as for maintenance announcements.
"""
type ChurrosAnnouncement implements ChurrosNode {
  body: String!
  bodyHtml: String!
  by: ChurrosUser
  createdAt: DateTime!
  endsAt: DateTime!
  id: ID!
  """L'identifiant local de la ressource (sans préfixe)"""
  localID: ChurrosLocalID!
  startsAt: DateTime!
  title: String!
  updatedAt: DateTime!
  userId: ID
  warning: Boolean!
}

"""
Une réponse à un formulaire. Les réponses peuvent être de plusieurs types différents (en fonction de la question).
"""
interface ChurrosAnswer {
  answerString: String!
  """Réservation associée à la réponse"""
  booking: ChurrosRegistration
  checkboxIsMarked: Boolean
  """Date de création de la réponse"""
  createdAt: DateTime!
  """Utilisateur ayant répondu à la question"""
  createdBy: ChurrosUser
  """Formulaire auquel appartient la question"""
  form: ChurrosForm!
  """Préfixe de l'identifiant: `answer:`"""
  id: ID!
  question: ChurrosQuestion!
  """Section du formulaire auquel appartient la question"""
  section: ChurrosFormSection!
  """Date de dernière mise à jour de la réponse"""
  updatedAt: DateTime!
}

"""Réponse de type `Date` (voir [`QuestionKind`](#QuestionKind))"""
type ChurrosAnswerDate implements ChurrosAnswer {
  answerString: String!
  """Réservation associée à la réponse"""
  booking: ChurrosRegistration
  checkboxIsMarked: Boolean
  """Date de création de la réponse"""
  createdAt: DateTime!
  """Utilisateur ayant répondu à la question"""
  createdBy: ChurrosUser
  """Formulaire auquel appartient la question"""
  form: ChurrosForm!
  """Préfixe de l'identifiant: `answer:`"""
  id: ID!
  """Question à laquelle la réponse est associée"""
  question: ChurrosQuestionScalar!
  """Réponse donnée, brute (sous forme de texte)"""
  rawValue: String
  """Section du formulaire auquel appartient la question"""
  section: ChurrosFormSection!
  """Date de dernière mise à jour de la réponse"""
  updatedAt: DateTime!
  """Réponse donnée"""
  value: DateTime
}

"""Réponse de type `FileUpload` (voir [`QuestionKind`](#QuestionKind))"""
type ChurrosAnswerFileUpload implements ChurrosAnswer {
  answerString: String!
  """Réservation associée à la réponse"""
  booking: ChurrosRegistration
  checkboxIsMarked: Boolean
  """Date de création de la réponse"""
  createdAt: DateTime!
  """Utilisateur ayant répondu à la question"""
  createdBy: ChurrosUser
  """Formulaire auquel appartient la question"""
  form: ChurrosForm!
  """Préfixe de l'identifiant: `answer:`"""
  id: ID!
  """Question à laquelle la réponse est associée"""
  question: ChurrosQuestionFileUpload!
  """Section du formulaire auquel appartient la question"""
  section: ChurrosFormSection!
  """Date de dernière mise à jour de la réponse"""
  updatedAt: DateTime!
  """Réponse donnée"""
  value: String
}

input ChurrosAnswerInput {
  """
  
  Réponse à la question. Pour les questions à une seule réponse, ne mettre qu'un seul élément.
      
  - Pour les questions de type `Date`, utiliser le format `YYYY-mm-dd`
  - Pour les questions de type `Time`, utiliser le format `HH:MM:ss`
  - Pour les questions de type `Scale`, utiliser simplement le nombre répondu par l'utilisateur·ice
  - Pour les questions de type `FileUpload`, utiliser la mutation [`answerFileQuestion`](#mutation/answerFileQuestion)
        
  """
  answer: [String!]!
  """ID de la question à laquelle répondre"""
  question: ID!
}

"""Réponse de type `LongText` (voir [`QuestionKind`](#QuestionKind))"""
type ChurrosAnswerLongText implements ChurrosAnswer {
  answerString: String!
  """Réservation associée à la réponse"""
  booking: ChurrosRegistration
  checkboxIsMarked: Boolean
  """Date de création de la réponse"""
  createdAt: DateTime!
  """Utilisateur ayant répondu à la question"""
  createdBy: ChurrosUser
  """Formulaire auquel appartient la question"""
  form: ChurrosForm!
  """Préfixe de l'identifiant: `answer:`"""
  id: ID!
  """Question à laquelle la réponse est associée"""
  question: ChurrosQuestionScalar!
  """Section du formulaire auquel appartient la question"""
  section: ChurrosFormSection!
  """Date de dernière mise à jour de la réponse"""
  updatedAt: DateTime!
  """Réponse donnée"""
  value: String
}

"""Réponse de type `Number` (voir [`QuestionKind`](#QuestionKind))"""
type ChurrosAnswerNumber implements ChurrosAnswer {
  answerString: String!
  """Réservation associée à la réponse"""
  booking: ChurrosRegistration
  checkboxIsMarked: Boolean
  """Date de création de la réponse"""
  createdAt: DateTime!
  """Utilisateur ayant répondu à la question"""
  createdBy: ChurrosUser
  """Formulaire auquel appartient la question"""
  form: ChurrosForm!
  """Préfixe de l'identifiant: `answer:`"""
  id: ID!
  """Question à laquelle la réponse est associée"""
  question: ChurrosQuestionScalar!
  """Section du formulaire auquel appartient la question"""
  section: ChurrosFormSection!
  """Date de dernière mise à jour de la réponse"""
  updatedAt: DateTime!
  """Réponse donnée"""
  value: Float
}

"""Réponse de type `Scale` (voir [`QuestionKind`](#QuestionKind))"""
type ChurrosAnswerScale implements ChurrosAnswer {
  answerString: String!
  """Réservation associée à la réponse"""
  booking: ChurrosRegistration
  checkboxIsMarked: Boolean
  """Date de création de la réponse"""
  createdAt: DateTime!
  """Utilisateur ayant répondu à la question"""
  createdBy: ChurrosUser
  """Formulaire auquel appartient la question"""
  form: ChurrosForm!
  """Préfixe de l'identifiant: `answer:`"""
  id: ID!
  """Réponse donnée, entre 0 et 1"""
  normalizedValue: Float
  """Question à laquelle la réponse est associée"""
  question: ChurrosQuestionScale!
  """Section du formulaire auquel appartient la question"""
  section: ChurrosFormSection!
  """Date de dernière mise à jour de la réponse"""
  updatedAt: DateTime!
  """Réponse donnée"""
  value: Int
}

type ChurrosAnswerSearchResult {
  answer: ChurrosAnswer!
  id: ID!
  rank: Float
  similarity: Float!
}

"""
Réponse de type `SelectMultiple` (voir [`QuestionKind`](#QuestionKind))
"""
type ChurrosAnswerSelectMultiple implements ChurrosAnswer {
  answerString: String!
  """Réservation associée à la réponse"""
  booking: ChurrosRegistration
  checkboxIsMarked: Boolean
  """Date de création de la réponse"""
  createdAt: DateTime!
  """Utilisateur ayant répondu à la question"""
  createdBy: ChurrosUser
  """Formulaire auquel appartient la question"""
  form: ChurrosForm!
  """Préfixe de l'identifiant: `answer:`"""
  id: ID!
  """Question à laquelle la réponse est associée"""
  question: ChurrosQuestionSelectMultiple!
  """Section du formulaire auquel appartient la question"""
  section: ChurrosFormSection!
  """Date de dernière mise à jour de la réponse"""
  updatedAt: DateTime!
  """Réponse donnée"""
  value: [String!]
}

"""Réponse de type `SelectOne` (voir [`QuestionKind`](#QuestionKind))"""
type ChurrosAnswerSelectOne implements ChurrosAnswer {
  answerString: String!
  """Réservation associée à la réponse"""
  booking: ChurrosRegistration
  checkboxIsMarked: Boolean
  """Date de création de la réponse"""
  createdAt: DateTime!
  """Utilisateur ayant répondu à la question"""
  createdBy: ChurrosUser
  """Formulaire auquel appartient la question"""
  form: ChurrosForm!
  """Préfixe de l'identifiant: `answer:`"""
  id: ID!
  """Question à laquelle la réponse est associée"""
  question: ChurrosQuestionSelectOne!
  """Section du formulaire auquel appartient la question"""
  section: ChurrosFormSection!
  """Date de dernière mise à jour de la réponse"""
  updatedAt: DateTime!
  """Réponse donnée"""
  value: String
}

"""Réponse de type `Text` (voir [`QuestionKind`](#QuestionKind))"""
type ChurrosAnswerText implements ChurrosAnswer {
  answerString: String!
  """Réservation associée à la réponse"""
  booking: ChurrosRegistration
  checkboxIsMarked: Boolean
  """Date de création de la réponse"""
  createdAt: DateTime!
  """Utilisateur ayant répondu à la question"""
  createdBy: ChurrosUser
  """Formulaire auquel appartient la question"""
  form: ChurrosForm!
  """Préfixe de l'identifiant: `answer:`"""
  id: ID!
  """Question à laquelle la réponse est associée"""
  question: ChurrosQuestionScalar!
  """Section du formulaire auquel appartient la question"""
  section: ChurrosFormSection!
  """Date de dernière mise à jour de la réponse"""
  updatedAt: DateTime!
  """Réponse donnée"""
  value: String
}

"""Réponse de type `Time` (voir [`QuestionKind`](#QuestionKind))"""
type ChurrosAnswerTime implements ChurrosAnswer {
  answer: ChurrosAnswer!
  answerString: String!
  """Réservation associée à la réponse"""
  booking: ChurrosRegistration
  checkboxIsMarked: Boolean
  """Date de création de la réponse"""
  createdAt: DateTime!
  """Utilisateur ayant répondu à la question"""
  createdBy: ChurrosUser
  """Formulaire auquel appartient la question"""
  form: ChurrosForm!
  """Préfixe de l'identifiant: `answer:`"""
  id: ID!
  """Question à laquelle la réponse est associée"""
  question: ChurrosQuestionScalar!
  """Réponse donnée, brute (sous forme de texte)"""
  rawValue: String
  """Section du formulaire auquel appartient la question"""
  section: ChurrosFormSection!
  """Date de dernière mise à jour de la réponse"""
  updatedAt: DateTime!
  """Réponse donnée"""
  value: DateTime
}

"""Formats d'export des réponses"""
enum ChurrosAnswersExportFormats {
  """
  Format CSV (séparateur de colonnes: virgule, séparateur de lignes: saut de ligne)
  """
  CSV
  """
  Format TSV (séparateur de colonnes: tabulation, séparateur de lignes: saut de ligne)
  """
  TSV
}

"""
Représente toutes les réponses d'un·e utilisateur·ice à un formulaire. Pratique pour grouper les réponses afin de les afficher dans un tableau
"""
type ChurrosAnswersOfUser {
  answers: [ChurrosAnswer!]!
  """Correspond à la date de dernière réponse parmis les réponses"""
  date: DateTime!
  user: ChurrosUser!
}

"""
Des données temporelles pour construire des graphiques d'atteintes de rate limiting. La résolution temporelle est d'une minute.
"""
type ChurrosApiRateLimitHits {
  """Le nombre d'erreurs de rate-limiting à cette date"""
  count: Int!
  """La date à laquelle les requêtes ont été faites"""
  date: DateTime!
  """Le nom de la query ou mutation ou subscription"""
  queryName: String!
  """Le type de requête effectuée"""
  queryType: String!
  timestamp: Int!
  user: ChurrosUser
}

"""
Des données temporelles pour construire des graphiques d'utilisation de l'API au cours du temps. La résolution temporelle est d'une minute.
"""
type ChurrosApiUsage {
  """Le nombre de requêtes faites à cette date"""
  count: Int!
  """La date à laquelle les requêtes ont été faites"""
  date: DateTime!
  """Le nom de la query ou mutation ou subscription"""
  queryName: String!
  """Le type de requête effectuée"""
  queryType: ChurrosApiUsageQueryType!
  timestamp: Int!
  user: ChurrosUser
}

"""Type de requête effectuée sur l'API"""
enum ChurrosApiUsageQueryType {
  """Modification de données, ou autre action diverses"""
  Mutation
  """Récupération de données"""
  Query
  """
  Abonnement à des données pour être informé en temps réel des changements
  """
  Subscription
}

"""An article is a post in a group"""
type ChurrosArticle implements ChurrosCommentable & ChurrosNode & ChurrosPictured & ChurrosReactable {
  author: ChurrosUser
  authorId: ID
  body: String!
  bodyHtml: String!
  bodyPreview: String!
  """
  Vrai si l'utilisateur·ice connecté·e peut éditer le post (en considérant qu'iel ne va pas changer l'auteur·ice ou le groupe du post)
  """
  canBeEdited: Boolean!
  comments(after: String, before: String, first: Int, last: Int): ChurrosCommentsConnection!
  createdAt: DateTime!
  event: ChurrosEvent
  eventId: ID
  group: ChurrosGroup!
  groupId: ID!
  id: ID!
  links: [ChurrosLink!]!
  """L'identifiant local de la ressource (sans préfixe)"""
  localID: ChurrosLocalID!
  myReactions: ChurrosBooleanMap!
  notifiedAt: DateTime
  pictureFile: String!
  """Le nom du fichier de l'image, en thème sombre"""
  pictureFileDark: String!
  """L'URL publique de l'image"""
  pictureURL(
    """Utiliser l'image en thème sombre"""
    dark: Boolean! = false
  ): String!
  published: Boolean!
  publishedAt: DateTime!
  reacted(emoji: String!): Boolean!
  reactionCounts: ChurrosCounts!
  reactions(emoji: String!): Int!
  """Un nom lisible sans espaces, adaptés pour des URLs."""
  slug: String!
  title: String!
  uid: String! @deprecated(reason: "Use `slug` instead. This field was never universally unique.")
  visibility: ChurrosVisibility!
}

type ChurrosArticleSearchResultType {
  article: ChurrosArticle!
  highlightedTitle: String!
  id: ID!
  rank: Float
  similarity: Float!
}

type ChurrosAwaitingValidationError {
  message: String!
}

"""A bar week is a week during which some groups takeover the bar staff"""
type ChurrosBarWeek implements ChurrosNode {
  description: String!
  descriptionHtml: String!
  endsAt: DateTime!
  groups: [ChurrosGroup!]!
  id: ID!
  """L'identifiant local de la ressource (sans préfixe)"""
  localID: ChurrosLocalID!
  """Un nom lisible sans espaces, adaptés pour des URLs."""
  slug: String!
  startsAt: DateTime!
  uid: String! @deprecated(reason: "Use `slug` instead. This field was never universally unique.")
}

scalar ChurrosBooleanMap

type ChurrosBuildInfo {
  """Le hash du commit utilisé pour build l'API"""
  commit: String!
  """La version actuelle de l'API (et de l'application)"""
  version: String!
}

"""A release in the changelog"""
type ChurrosChangelogRelease {
  """The changes of the release, grouped by category"""
  changes: ChurrosReleaseChangesMaps!
  """The date of the release"""
  date: DateTime
  """A short description of the release"""
  description: String!
  """A short description of the release, in HTML. Safe from XSS."""
  descriptionHtml: String!
  """The version of the release"""
  version: String!
}

type ChurrosComment implements ChurrosNode & ChurrosReactable {
  author: ChurrosUser
  authorId: ID
  body: String!
  bodyHtml: String!
  createdAt: DateTime!
  document: ChurrosDocument
  documentId: ID
  id: ID!
  inReplyTo: ChurrosComment
  inReplyToId: ID
  """L'identifiant local de la ressource (sans préfixe)"""
  localID: ChurrosLocalID!
  reacted(emoji: String!): Boolean!
  reactions(emoji: String!): Int!
  replies: [ChurrosComment!]!
  updatedAt: DateTime!
}

"""Une resource pouvant être commentée par les utilisateur·ice·s"""
interface ChurrosCommentable {
  comments(after: String, before: String, first: Int, last: Int): ChurrosCommentsConnection!
  """L’identifiant de la resource commentée"""
  id: ID!
}

type ChurrosCommentsConnection {
  edges: [ChurrosCommentsEdge!]!
  nodes: [ChurrosComment!]!
  pageInfo: ChurrosPageInfo!
}

type ChurrosCommentsEdge {
  cursor: String!
  node: ChurrosComment!
}

union ChurrosCompleteSignupResult = ChurrosUser | ChurrosUserCandidate

type ChurrosContributionOption {
  descriptionHtml: String!
  id: ID!
  name: String!
  offeredIn: ChurrosSchool!
  paysFor: [ChurrosStudentAssociation!]!
  price: Float!
}

scalar ChurrosCounts

"""A credential is a way to authenticate a user"""
type ChurrosCredential {
  active: Boolean!
  createdAt: DateTime!
  expiresAt: DateTime
  id: ID!
  name: String!
  token: String!
  type: ChurrosCredentialType!
  user: ChurrosUser!
  userAgent: String!
}

enum ChurrosCredentialType {
  Google
  Password
  Token
}

type ChurrosDatabaseHealthCheck {
  prisma: Boolean!
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

type ChurrosDocument implements ChurrosCommentable & ChurrosNode & ChurrosReactable {
  comments(after: String, before: String, first: Int, last: Int): ChurrosCommentsConnection!
  createdAt: DateTime!
  description: String!
  descriptionHtml: String!
  id: ID!
  """L'identifiant local de la ressource (sans préfixe)"""
  localID: ChurrosLocalID!
  """
  Liste de chemins vers les fichiers représentant le sujet (ou la fiche de révision)
  """
  paperPaths: [String!]!
  reacted(emoji: String!): Boolean!
  reactions(emoji: String!): Int!
  schoolYear: Int!
  """Un nom lisible sans espaces, adaptés pour des URLs."""
  slug: String!
  """Liste de chemins vers les fichiers représentant la correction."""
  solutionPaths: [String!]!
  subject: ChurrosSubject
  subjectId: ID
  title: String!
  type: ChurrosDocumentType!
  uid: String! @deprecated(reason: "Use `slug` instead. This field was never universally unique.")
  updatedAt: DateTime!
  uploader: ChurrosUser
  uploaderId: ID
}

type ChurrosDocumentSearchResult {
  document: ChurrosDocument!
  id: ID!
  rank: Int
  similarity: Float!
}

enum ChurrosDocumentType {
  CourseNotes
  CourseSlides
  Exam
  Exercises
  GradedExercises
  Miscellaneous
  Practical
  PracticalExam
  Summary
}

"""A email validation request"""
type ChurrosEmailChange {
  createdAt: DateTime!
  email: String!
  id: ID!
  pending: Boolean!
  updatedAt: DateTime!
  user: ChurrosUser!
  userId: ID!
}

"""
The most basic error object, based on the base JavaScript Error object.
"""
type ChurrosError implements ChurrosErrorInterface {
  message: String!
}

"""Basic interface for all error types to implement."""
interface ChurrosErrorInterface {
  message: String!
}

type ChurrosEvenSearchResult {
  event: ChurrosEvent!
  highlightedTitle: String!
  id: ID!
  rank: Float
  similarity: Float!
}

"""An event is a date, time and place, as well as an optional ticket"""
type ChurrosEvent implements ChurrosNode & ChurrosPictured & ChurrosReactable {
  articles: [ChurrosArticle!]!
  author: ChurrosUser
  authorId: ID
  bannedUsers: [ChurrosUser!]!
  beneficiary: ChurrosLydiaAccount
  bookings(after: String, before: String, first: Int, last: Int): ChurrosEventBookingsConnection!
  bookingsCounts: ChurrosRegistrationsCounts!
  """
  Renvoie un texte au format CSV contenant un export des réservations de l'évènement.
  """
  bookingsCsv: ChurrosEventBookingsCsvResult!
  """L'utilisateur·ice connecté·e peut modifier cet évènement"""
  canEdit: Boolean!
  """
  L'utilisateur·ice connecté·e peut ajouter, enlever ou modifier les droits des managers de cet évènement
  """
  canEditManagers: Boolean!
  """
  L'utilisateur·ice connecté·e peut scanner les réservations de cet évènement
  """
  canScanBookings: Boolean!
  """
  L'utilisateur·ice connecté·e peut voir les réservations de cet évènement
  """
  canSeeBookings: Boolean!
  """L'utilsateur·ice connecté·e peut voir les logs de cet évènement"""
  canSeeLogs: Boolean!
  capacity: Int!
  coOrganizers: [ChurrosGroup!]!
  contactMail: String!
  description: String!
  descriptionHtml: String!
  descriptionPreview: String!
  endsAt: DateTime!
  """Formulaires associés à l'événement"""
  forms: [ChurrosForm!]!
  frequency: ChurrosEventFrequency!
  group: ChurrosGroup!
  groupId: ID!
  id: ID!
  """Vrai si l'évènement doit apparaître dans le mode kiosque"""
  includeInKiosk: Boolean!
  links: [ChurrosLink!]!
  """L'identifiant local de la ressource (sans préfixe)"""
  localID: ChurrosLocalID!
  location: String!
  """
  Logs concernant cet évènement. Ne contient pas les logs concernant les réservations.
  """
  logs(after: String, before: String, first: Int, last: Int): ChurrosEventLogsConnection!
  lydiaAccountId: ID
  managers: [ChurrosEventManager!]!
  """Réservations faites par et/ou pour l'utilisateur.ice connecté.e"""
  myBookings: ChurrosEventMyBookingsResult!
  myReactions: ChurrosBooleanMap!
  mySoonestShotgunOpensAt: DateTime
  pictureFile: String!
  """Le nom du fichier de l'image, en thème sombre"""
  pictureFileDark: String!
  """L'URL publique de l'image"""
  pictureURL(
    """Utiliser l'image en thème sombre"""
    dark: Boolean! = false
  ): String!
  placesLeft: Int
  profitsBreakdown: ChurrosProfitsBreakdown!
  reacted(emoji: String!): Boolean!
  reactionCounts: ChurrosCounts!
  reactions(emoji: String!): Int!
  recurringUntil: DateTime
  searchBookings(q: String!): [ChurrosRegistrationSearchResult!]!
  """Vrai si le nombre de places restantes doit être affiché"""
  showPlacesLeft: Boolean!
  """Un nom lisible sans espaces, adaptés pour des URLs."""
  slug: String!
  startsAt: DateTime!
  ticket(slug: String!): ChurrosTicket
  ticketGroups: [ChurrosTicketGroup!]!
  tickets: [ChurrosTicket!]!
  title: String!
  uid: String! @deprecated(reason: "Use `slug` instead. This field was never universally unique.")
  visibility: ChurrosVisibility!
}

type ChurrosEventBookingsConnection {
  edges: [ChurrosEventBookingsConnectionEdge!]!
  nodes: [ChurrosRegistration!]!
  pageInfo: ChurrosPageInfo!
}

type ChurrosEventBookingsConnectionEdge {
  cursor: String!
  node: ChurrosRegistration!
}

union ChurrosEventBookingsCsvResult = ChurrosError | ChurrosEventBookingsCsvSuccess

type ChurrosEventBookingsCsvSuccess {
  data: String!
}

enum ChurrosEventFrequency {
  Biweekly
  Monthly
  Once
  Weekly
}

type ChurrosEventLogsConnection {
  edges: [ChurrosEventLogsConnectionEdge!]!
  nodes: [ChurrosLogEntry!]!
  pageInfo: ChurrosPageInfo!
}

type ChurrosEventLogsConnectionEdge {
  cursor: String!
  node: ChurrosLogEntry!
}

"""
An event manager is a user that can scan tickets, and may be able to manage the event
"""
type ChurrosEventManager {
  canEdit: Boolean!
  canEditPermissions: Boolean!
  canVerifyRegistrations: Boolean!
  event: ChurrosEvent!
  power: ChurrosEventManagerPowerLevel!
  user: ChurrosUser!
}

enum ChurrosEventManagerPowerLevel {
  Edit
  EditPermissions
  ReadOnly
  ScanTickets
}

union ChurrosEventMyBookingsResult = ChurrosError | ChurrosEventMyBookingsSuccess

type ChurrosEventMyBookingsSuccess {
  data: [ChurrosRegistration!]!
}

type ChurrosEventsByDay {
  date: DateTime!
  """Évènements qui ont lieu (commencent) à ce jour"""
  happening: [ChurrosEvent!]!
  """Évènements qui ont leur premier shotgun à ce jour"""
  shotgunning: [ChurrosEvent!]!
}

type ChurrosFamilyTree {
  nesting: String!
  users: [ChurrosUser!]!
}

scalar ChurrosFile

"""Un formulaire"""
type ChurrosForm implements ChurrosNode {
  """Nombre de réponses au formulaire"""
  answerCount: Int!
  """Réponses au formulaire"""
  answers(after: String, before: String, first: Int, last: Int): ChurrosFormAnswersConnection!
  """
  Réponses au formulaire, groupées par utilisateur·ice. Ne contient pas de réponses dont l'utilisateur·ice est inconnu·e.
  """
  answersByUser(
    after: String
    before: String
    first: Int
    last: Int
    """Recherche par utilisateur·ice"""
    q: String
  ): ChurrosFormAnswersByUserConnection!
  """Export des réponses au formulaires dans un format"""
  answersExport(
    """Format à utiliser"""
    format: ChurrosAnswersExportFormats! = CSV
  ): String!
  """Indique si l'utilisateur peut répondre au formulaire."""
  canAnswer: Boolean!
  """Indique si l'utilisateur peut éditer le formulaire."""
  canEdit: Boolean!
  """Indique si l'utilisateur·ice peut modifier ses réponses au formulaire."""
  canModifyAnswers: Boolean!
  """
  Indique si l'utilisateur peut voir les statistiques des réponses au formulaire.
  """
  canSeeAnswerStats: Boolean!
  """Indique si l'utilisateur peut voir les réponses au formulaire."""
  canSeeAnswers: Boolean!
  """
  Indique si l'utilisateur peut cocher ou décocher les cases à cocher à côté des réponses au formulaire.
  """
  canSetCheckboxes: Boolean!
  checkboxesAreEnabled: Boolean!
  """Date de fermeture du formulaire."""
  closesAt: DateTime
  """Date de création du formulaire"""
  createdAt: DateTime!
  """Utilisateur ayant créé le formulaire"""
  createdBy: ChurrosUser
  """Description en Markdown du formulaire."""
  description: String
  """Description en HTML du formulaire."""
  descriptionHtml: String!
  """Événement associé au formulaire"""
  event: ChurrosEvent
  """Groupe auquel le formulaire est associé"""
  group: ChurrosGroup
  """Vrai si le formulaire comporte des sections"""
  hasSections: Boolean!
  """Préfixe de l'identifiant: `form:`"""
  id: ID!
  """
  L'URL du Google Sheet des réponses lié à ce formulaire. Voir `createLinkedGoogleSheet` pour créer un Google Sheet lié au formulaire.
  """
  linkedGoogleSheetUrl: String
  """L'identifiant local de la ressource (sans préfixe)"""
  localID: ChurrosLocalID!
  """Identifiant local du formulaire"""
  localId: String!
  """Réponses de l'utilisateur·ice connecté·e à ce formulaire"""
  myAnswers: [ChurrosAnswer!]!
  """Date d'ouverture du formulaire."""
  opensAt: DateTime
  """
  Questions du formulaire. Liste de toutes les questions, peut importe la section dans laquelle elles se trouvent.
  """
  questions(after: String, before: String, first: Int, last: Int): ChurrosFormQuestionsConnection!
  searchAnswers(
    """La recherche"""
    q: String!
    similarityCutoff: Float
  ): [ChurrosAnswerSearchResult!]!
  """Une section du formulaire."""
  section(
    """Identifiant (local ou global) de la section"""
    id: String
  ): ChurrosFormSection!
  """
  Sections du formulaire. Un formulaire contient toujours au moins une section (sauf s'il n'y a aucune question). Uniquement accessible par celleux qui peuvent modifier le formulaire. Utiliser `nextSection` pour afficher une section dans le but d'y répondre.
  """
  sections: [ChurrosFormSection!]!
  title: String!
  """Date de dernière mise à jour du formulaire"""
  updatedAt: DateTime!
  """Visibilité du formulaire"""
  visibility: ChurrosVisibility!
}

type ChurrosFormAnswersByUserConnection {
  edges: [ChurrosFormAnswersByUserConnectionEdge!]!
  nodes: [ChurrosAnswersOfUser!]!
  pageInfo: ChurrosPageInfo!
}

type ChurrosFormAnswersByUserConnectionEdge {
  cursor: String!
  node: ChurrosAnswersOfUser!
}

type ChurrosFormAnswersConnection {
  edges: [ChurrosFormAnswersConnectionEdge!]!
  nodes: [ChurrosAnswer!]!
  pageInfo: ChurrosPageInfo!
}

type ChurrosFormAnswersConnectionEdge {
  cursor: String!
  node: ChurrosAnswer!
}

type ChurrosFormQuestionsConnection {
  edges: [ChurrosFormQuestionsConnectionEdge!]!
  nodes: [ChurrosQuestion!]!
  pageInfo: ChurrosPageInfo!
}

type ChurrosFormQuestionsConnectionEdge {
  cursor: String!
  node: ChurrosQuestion!
}

type ChurrosFormSearchResult {
  form: ChurrosForm!
  highlightedDescription: String!
  id: ID!
  rank: Float
  similarity: Float!
}

"""
Une section d'un formulaire. Les sections sont utiles pour séparer les questions en plusieurs parties, dont certaines peuvent être affichées selon des réponses à des questions précédentes
"""
type ChurrosFormSection {
  """Réponses à cette section"""
  answers(after: String, before: String, first: Int, last: Int): ChurrosFormSectionAnswersConnection!
  """Description en Markdown de la section"""
  description: String!
  """Description en HTML de la section"""
  descriptionHtml: String!
  """Formulaire auquel appartient la section"""
  form: ChurrosForm!
  id: ID!
  """Identifiant local de la section du formulaire"""
  localId: String!
  """
  Section suivante dans le formulaire, si il y en a une. (Sinon, c'est que c'est la dernière section). Dépend du fait que des sections soit cachées à l'utilisateur (voir `restrictedToGroups`), ou que une répond à une question provoque le passaage à une autre section (voir `goToSection`) 
  """
  nextSection: ChurrosFormSection
  """Ordre de la section dans le formulaire"""
  order: Int!
  """Questions dans section"""
  questions: [ChurrosQuestion!]!
  """
  Si non vide, seul·e·s les membres des groupes spécifiés peuvent accéder à cette section. 
  """
  restrictedToGroups: [ChurrosGroup!]!
  """Titre de la section"""
  title: String!
}

type ChurrosFormSectionAnswersConnection {
  edges: [ChurrosFormSectionAnswersConnectionEdge!]!
  nodes: [ChurrosAnswer!]!
  pageInfo: ChurrosPageInfo!
}

type ChurrosFormSectionAnswersConnectionEdge {
  cursor: String!
  node: ChurrosAnswer!
}

"""
Requests to become someone's godchild. Gets deleted once the request has been accepted (or denied). godchild is the requester, godparent is the requested.
"""
type ChurrosGodparentRequest {
  createdAt: DateTime!
  godchild: ChurrosUser!
  godparent: ChurrosUser!
  id: ID!
  updatedAt: DateTime!
}

"""A group is a collection of users"""
type ChurrosGroup implements ChurrosNode & ChurrosPictured {
  address: String!
  """All the ancestors of this group, from the current group to the root."""
  ancestors: [ChurrosGroup!]!
  articles: [ChurrosArticle!]!
  boardMembers: [ChurrosGroupMember!]!
  """
  Vrai si l'utilisateur·ice connecté·e peut modifier les informations du groupe
  """
  canEditDetails: Boolean!
  """
  L'utilisateur·ice connecté·e peut éditer (créer ou modifier) les pages du groupe
  """
  canEditPages: Boolean!
  """L'utilisateur·ice connecté·e peut lister les pages du groupe"""
  canListPages: Boolean!
  children: [ChurrosGroup!]!
  coOrganizedEvents: [ChurrosEvent!]!
  color: String!
  description: String!
  email: String!
  events(after: String, before: String, first: Int, last: Int): ChurrosGroupEventsConnection!
  familyChildren: [ChurrosGroup!]!
  """
  Helper field to get a whole tree without processing all groups\nTo be set to the group's id itself for root groups.
  """
  familyId: ID
  """Formulaires associés au groupe"""
  forms: [ChurrosForm!]!
  groupId: ID!
  id: ID!
  ldapUid: String!
  links: [ChurrosLink!]!
  """L'identifiant local de la ressource (sans préfixe)"""
  localID: ChurrosLocalID!
  longDescription: String!
  longDescriptionHtml: String!
  """Comptes Lydia du groupe"""
  lydiaAccounts: [ChurrosLydiaAccount!]!
  mailingList: String!
  members: [ChurrosGroupMember!]!
  name: String!
  ownEvents: [ChurrosEvent!]!
  """La page associée au groupe"""
  page(
    """
    Le chemin de la page. Ce n'est pas le chemin complet, mais celui qui est local au groupe. Voir `Page` pour plus d'informations.
    """
    path: String!
  ): ChurrosPage
  """Les pages associées au groupe"""
  pages(after: String, before: String, first: Int, last: Int): ChurrosPagesConnection!
  """Parent group, from which this group inherits its permissions"""
  parent: ChurrosGroup
  parentId: ID
  pictureFile: String!
  pictureFileDark: String!
  """L'URL publique de l'image"""
  pictureURL(
    """Utiliser l'image en thème sombre"""
    dark: Boolean! = false
  ): String!
  president: ChurrosGroupMember
  """Related clubs"""
  related: [ChurrosGroup!]!
  roomIsOpen: Boolean!
  """Family root, only created for performance reasons"""
  root: ChurrosGroup
  secretaries: [ChurrosGroupMember!]!
  selfJoinable: Boolean!
  services: [ChurrosService!]!
  """Article de la boutique du groupe"""
  shopItem(id: ChurrosLocalID!): ChurrosShopItem
  shopItems(after: String, before: String, first: Int, last: Int): ChurrosGroupShopItemsConnection!
  shopOrders: [ChurrosShopPayment!]!
  studentAssociation: ChurrosStudentAssociation
  treasurers: [ChurrosGroupMember!]!
  type: ChurrosGroupType!
  uid: String!
  vicePresidents: [ChurrosGroupMember!]!
  website: String!
}

type ChurrosGroupEventsConnection {
  edges: [ChurrosGroupEventsConnectionEdge!]!
  nodes: [ChurrosEvent!]!
  pageInfo: ChurrosPageInfo!
}

type ChurrosGroupEventsConnectionEdge {
  cursor: String!
  node: ChurrosEvent!
}

"""The intermediate model between users and groups"""
type ChurrosGroupMember {
  canEditArticles: Boolean!
  canEditMembers: Boolean!
  canScanEvents: Boolean!
  createdAt: DateTime!
  group: ChurrosGroup!
  groupId: ID!
  isDeveloper: Boolean!
  member: ChurrosUser!
  memberId: ID!
  president: Boolean!
  secretary: Boolean!
  title: String!
  treasurer: Boolean!
  vicePresident: Boolean!
}

type ChurrosGroupSearchResult {
  group: ChurrosGroup!
  highlightedDescription: String!
  id: ID!
  rank: Float
  similarity: Float!
}

type ChurrosGroupShopItemsConnection {
  edges: [ChurrosGroupShopItemsConnectionEdge!]!
  nodes: [ChurrosShopItem!]!
  pageInfo: ChurrosPageInfo!
}

type ChurrosGroupShopItemsConnectionEdge {
  cursor: String!
  node: ChurrosShopItem!
}

enum ChurrosGroupType {
  Association
  Club
  Group
  Integration
  List
  StudentAssociationSection
}

"""Results of a health self-check"""
type ChurrosHealthCheck {
  database: ChurrosDatabaseHealthCheck!
  ldap: ChurrosLdapHealthCheck!
  mail: ChurrosMailHealthCheck!
  redis: ChurrosRedisHealthCheck!
}

"""A Gitlab issue"""
type ChurrosIssue {
  body: String!
  bodyHtml: String!
  comments: [ChurrosIssueComment!]!
  deployedIn: String!
  """Expressed from 0 to 1"""
  difficulty: Float
  duplicatedFrom: Int
  """Expressed from 0 to 1"""
  importance: Float
  number: Int!
  state: ChurrosIssueState!
  """The date at which the issue was submitted"""
  submittedAt: DateTime!
  title: String!
  url: String!
}

"""A Gitlab issue comment"""
type ChurrosIssueComment {
  """The date at which the comment was added"""
  addedAt: DateTime!
  authorAvatarUrl: String!
  authorGitlabUrl: String!
  authorName: String!
  body: String!
  bodyHtml: String!
}

enum ChurrosIssueState {
  Closed
  Deployed
  Open
}

type ChurrosLdapHealthCheck {
  """Whether the LDAP internal client is ready"""
  internal: Boolean!
  """Whether the LDAP school client is ready"""
  school: Boolean!
}

"""A single external link"""
type ChurrosLink implements ChurrosNode {
  computedValue: String!
  createdAt: DateTime!
  id: ID!
  """L'identifiant local de la ressource (sans préfixe)"""
  localID: ChurrosLocalID!
  name: String!
  value: String!
}

input ChurrosLinkInput {
  name: String!
  value: String!
}

"""
Un identifiant, dont le préfixe (par exemple, `a:` dans `a:627dgfd87ccc`) est optionnel.
"""
scalar ChurrosLocalID

"""A log entry is a log of an action that happened on the website"""
type ChurrosLogEntry implements ChurrosNode {
  action: String!
  area: String!
  happenedAt: DateTime!
  id: ID!
  """L'identifiant local de la ressource (sans préfixe)"""
  localID: ChurrosLocalID!
  message: String!
  target: String
  user: ChurrosUser
}

enum ChurrosLogoSourceType {
  ExternalLink
  GroupLogo
  Icon
  InternalLink
}

"""A Lydia account"""
type ChurrosLydiaAccount {
  events: [ChurrosEvent!]!
  group: ChurrosGroup
  groupId: ID
  id: ID!
  name: String!
  studentAssociation: ChurrosStudentAssociation
  studentAssociationId: ID
}

type ChurrosMailHealthCheck {
  """Whether the SMTP client is ready"""
  smtp: Boolean!
}

"""A school syllabus"""
type ChurrosMajor {
  id: ID!
  ldapSchool: ChurrosSchool
  minors: [ChurrosMinor!]!
  name: String!
  schools: [ChurrosSchool!]!
  shortName: String!
  subjects(forApprentices: Boolean, yearTier: Int): [ChurrosSubject!]!
  uid: String!
}

input ChurrosManagerOfEventInput {
  canEdit: Boolean!
  canEditPermissions: Boolean!
  canVerifyRegistrations: Boolean!
  userUid: String!
}

type ChurrosMinor implements ChurrosNode {
  id: ID!
  """L'identifiant local de la ressource (sans préfixe)"""
  localID: ChurrosLocalID!
  majors: [ChurrosMajor!]!
  name: String!
  shortName: String!
  """Un nom lisible sans espaces, adaptés pour des URLs."""
  slug: String!
  subjects: [ChurrosSubject!]!
  uid: String! @deprecated(reason: "Use `slug` instead. This field was never universally unique.")
  users: [ChurrosUser!]!
  yearTier: Int!
}

union ChurrosMutationAcceptRegistrationResult = ChurrosError | ChurrosMutationAcceptRegistrationSuccess

type ChurrosMutationAcceptRegistrationSuccess {
  data: ChurrosUser!
}

union ChurrosMutationAddFileToPageResult = ChurrosError | ChurrosMutationAddFileToPageSuccess | ChurrosZodError

type ChurrosMutationAddFileToPageSuccess {
  data: ChurrosPage!
}

union ChurrosMutationAddGroupMemberResult = ChurrosError | ChurrosMutationAddGroupMemberSuccess

type ChurrosMutationAddGroupMemberSuccess {
  data: ChurrosGroupMember!
}

union ChurrosMutationAnswerFormSectionResult = ChurrosError | ChurrosMutationAnswerFormSectionSuccess

type ChurrosMutationAnswerFormSectionSuccess {
  data: [ChurrosAnswer!]!
}

union ChurrosMutationAuthorizeResult = ChurrosError | ChurrosMutationAuthorizeSuccess | ChurrosOAuth2Error

type ChurrosMutationAuthorizeSuccess {
  data: String!
}

union ChurrosMutationCancelRegistrationResult = ChurrosError | ChurrosMutationCancelRegistrationSuccess

type ChurrosMutationCancelRegistrationSuccess {
  data: Boolean!
}

union ChurrosMutationCompleteRegistrationResult = ChurrosError | ChurrosMutationCompleteRegistrationSuccess | ChurrosZodError

type ChurrosMutationCompleteRegistrationSuccess {
  data: ChurrosCompleteSignupResult!
}

union ChurrosMutationContributeResult = ChurrosError | ChurrosMutationContributeSuccess

type ChurrosMutationContributeSuccess {
  data: Boolean!
}

union ChurrosMutationCreatePasswordResetResult = ChurrosError | ChurrosMutationCreatePasswordResetSuccess

type ChurrosMutationCreatePasswordResetSuccess {
  data: Boolean!
}

union ChurrosMutationDeletePageResult = ChurrosError | ChurrosMutationDeletePageSuccess | ChurrosZodError

type ChurrosMutationDeletePageSuccess {
  data: ChurrosPage!
}

union ChurrosMutationDeleteShopItemResult = ChurrosError | ChurrosMutationDeleteShopItemSuccess

type ChurrosMutationDeleteShopItemSuccess {
  data: Boolean!
}

union ChurrosMutationFinishPaypalRegistrationPaymentResult = ChurrosError | ChurrosMutationFinishPaypalRegistrationPaymentSuccess

type ChurrosMutationFinishPaypalRegistrationPaymentSuccess {
  data: Boolean!
}

union ChurrosMutationLoginResult = ChurrosAwaitingValidationError | ChurrosError | ChurrosMutationLoginSuccess

type ChurrosMutationLoginSuccess {
  data: ChurrosCredential!
}

union ChurrosMutationMailFormAnswersResult = ChurrosError | ChurrosMutationMailFormAnswersSuccess

type ChurrosMutationMailFormAnswersSuccess {
  data: String!
}

union ChurrosMutationOpposeRegistrationResult = ChurrosError | ChurrosMutationOpposeRegistrationSuccess

type ChurrosMutationOpposeRegistrationSuccess {
  data: Boolean!
}

union ChurrosMutationPaidRegistrationResult = ChurrosError | ChurrosMutationPaidRegistrationSuccess

type ChurrosMutationPaidRegistrationSuccess {
  data: String!
}

union ChurrosMutationPaidShopPaymentResult = ChurrosError | ChurrosMutationPaidShopPaymentSuccess

type ChurrosMutationPaidShopPaymentSuccess {
  data: ChurrosShopPayment!
}

union ChurrosMutationRegisterGoogleCredentialResult = ChurrosError | ChurrosMutationRegisterGoogleCredentialSuccess

type ChurrosMutationRegisterGoogleCredentialSuccess {
  data: Boolean!
}

union ChurrosMutationRemoveFileFromPageResult = ChurrosError | ChurrosMutationRemoveFileFromPageSuccess | ChurrosZodError

type ChurrosMutationRemoveFileFromPageSuccess {
  data: ChurrosPage!
}

union ChurrosMutationRequestEmailChangeResult = ChurrosError | ChurrosMutationRequestEmailChangeSuccess

type ChurrosMutationRequestEmailChangeSuccess {
  data: Boolean!
}

union ChurrosMutationResetPasswordResult = ChurrosError | ChurrosMutationResetPasswordSuccess

type ChurrosMutationResetPasswordSuccess {
  data: Boolean!
}

union ChurrosMutationStartRegistrationResult = ChurrosError | ChurrosMutationStartRegistrationSuccess | ChurrosZodError

type ChurrosMutationStartRegistrationSuccess {
  data: Boolean!
}

union ChurrosMutationUpdateUserCandidateResult = ChurrosError | ChurrosMutationUpdateUserCandidateSuccess | ChurrosZodError

type ChurrosMutationUpdateUserCandidateSuccess {
  data: Boolean!
}

union ChurrosMutationUpdateUserResult = ChurrosError | ChurrosMutationUpdateUserSuccess

type ChurrosMutationUpdateUserSuccess {
  data: ChurrosUser!
}

union ChurrosMutationUpsertAnnouncementResult = ChurrosError | ChurrosMutationUpsertAnnouncementSuccess | ChurrosZodError

type ChurrosMutationUpsertAnnouncementSuccess {
  data: ChurrosAnnouncement!
}

union ChurrosMutationUpsertArticleResult = ChurrosError | ChurrosMutationUpsertArticleSuccess | ChurrosZodError

type ChurrosMutationUpsertArticleSuccess {
  data: ChurrosArticle!
}

union ChurrosMutationUpsertBarWeekResult = ChurrosError | ChurrosMutationUpsertBarWeekSuccess

type ChurrosMutationUpsertBarWeekSuccess {
  data: ChurrosBarWeek!
}

union ChurrosMutationUpsertDocumentResult = ChurrosError | ChurrosMutationUpsertDocumentSuccess

type ChurrosMutationUpsertDocumentSuccess {
  data: ChurrosDocument!
}

union ChurrosMutationUpsertEventResult = ChurrosError | ChurrosMutationUpsertEventSuccess

type ChurrosMutationUpsertEventSuccess {
  data: ChurrosEvent!
}

input ChurrosMutationUpsertFormInput {
  closesAt: DateTime
  description: String! = ""
  """Identifiant de l'événement à associer au formulaire"""
  eventId: ID
  """UID du groupe auquel le formulaire est associé."""
  group: String
  """
  Identifiant du formulaire à mettre à jour. Si non fourni, un nouveau formulaire sera créé.
  """
  id: ID
  opensAt: DateTime
  title: String!
  visibility: ChurrosVisibility! = Unlisted
}

input ChurrosMutationUpsertFormSectionInput {
  description: String! = ""
  """
  Identifiant du formulaire auquel associer la section. Il n'es pas possible de changer le formulaire auquel une section est associée, si id est fourni, ce paramètre est ignoré. L'ID peut être local
  """
  formId: String!
  """
  Identifiant de la section à mettre à jour. Si non fourni, une nouvelle section sera créée.
  """
  id: ID
  """
  Position de la section dans le formulaire. Si non spécifié, la section est ajoutée à la fin du formulaire
  """
  order: Int
  title: String!
}

union ChurrosMutationUpsertGodparentRequestResult = ChurrosError | ChurrosMutationUpsertGodparentRequestSuccess

type ChurrosMutationUpsertGodparentRequestSuccess {
  data: ChurrosGodparentRequest!
}

union ChurrosMutationUpsertGroupResult = ChurrosError | ChurrosMutationUpsertGroupSuccess | ChurrosZodError

type ChurrosMutationUpsertGroupSuccess {
  data: ChurrosGroup!
}

union ChurrosMutationUpsertPageResult = ChurrosError | ChurrosMutationUpsertPageSuccess | ChurrosZodError

type ChurrosMutationUpsertPageSuccess {
  data: ChurrosPage!
}

input ChurrosMutationUpsertQuestionInput {
  """
  Indique si la question doit avoir une option "Autre"
  """
  allowOptionOther: Boolean! = false
  """Types de fichiers autorisés pour les questions de type `FileUpload`"""
  allowedFiletypes: [String!]
  """Indique si les réponses à la question sont anonymes"""
  anonymous: Boolean!
  """
  Valeur par défaut de la question. Voir `AnswerInput.answer` pour le format.
  """
  default: [String!]! = []
  description: String! = ""
  """
  Identifiant du formulaire auquel associer la question. Il n'es pas possible de changer le formulaire auquel une question est associée, si id est fourni, ce paramètre est ignoré.
  """
  formId: ID
  """
  Identifiant de la question à mettre à jour. Si non fourni, une nouvelle question sera créée.
  """
  id: ID
  """Indique si la question est obligatoire"""
  mandatory: Boolean!
  options: [ChurrosQuestionOptionInput!]
  """
  Position de la question dans la section. Si non spécifié, rajoute la question à la fin de la section.
  """
  order: Int
  scale: ChurrosQuestionScaleInput
  """
  Identifiant de la section de formulaire à laquelle associer la question. Si non fourni, la question est rajoutée à une section à titre vide, qui est créée au besoin. Pratique pour les formulaires plus simples sans section.
  """
  sectionId: ID
  title: String!
  type: ChurrosQuestionKind!
}

union ChurrosMutationUpsertRegistrationResult = ChurrosError | ChurrosMutationUpsertRegistrationSuccess

type ChurrosMutationUpsertRegistrationSuccess {
  data: ChurrosRegistration!
}

union ChurrosMutationUpsertServiceResult = ChurrosError | ChurrosMutationUpsertServiceSuccess

type ChurrosMutationUpsertServiceSuccess {
  data: ChurrosService!
}

union ChurrosMutationUpsertShopItemResult = ChurrosError | ChurrosMutationUpsertShopItemSuccess

type ChurrosMutationUpsertShopItemSuccess {
  data: ChurrosShopItem!
}

union ChurrosMutationUpsertShopPaymentResult = ChurrosError | ChurrosMutationUpsertShopPaymentSuccess

type ChurrosMutationUpsertShopPaymentSuccess {
  data: ChurrosShopPayment!
}

union ChurrosMutationUsePasswordResetResult = ChurrosError | ChurrosMutationUsePasswordResetSuccess

type ChurrosMutationUsePasswordResetSuccess {
  data: Boolean!
}

union ChurrosMutationValidateEmailResult = ChurrosError | ChurrosMutationValidateEmailSuccess

type ChurrosMutationValidateEmailSuccess {
  data: Boolean!
}

union ChurrosMutationVerifyBookingResult = ChurrosError | ChurrosMutationVerifyBookingSuccess

type ChurrosMutationVerifyBookingSuccess {
  data: ChurrosRegistrationVerificationResult!
}

interface ChurrosNode {
  id: ID!
  """L'identifiant local de la ressource (sans préfixe)"""
  localID: ChurrosLocalID!
}

"""An error raised when a resource does not exist."""
type ChurrosNotFoundError implements ChurrosErrorInterface {
  message: String!
}

"""A notification is a push notification that was sent to a user"""
type ChurrosNotification implements ChurrosNode {
  actions: [ChurrosLink!]!
  body: String!
  channel: ChurrosNotificationChannel!
  createdAt: DateTime!
  goto: String!
  group: ChurrosGroup
  groupId: ID
  id: ID!
  imageFile: String!
  """L'identifiant local de la ressource (sans préfixe)"""
  localID: ChurrosLocalID!
  subscription: ChurrosNotificationSubscription!
  subscriptionId: ID!
  timestamp: DateTime
  title: String!
  updatedAt: DateTime!
  vibrate: [Int!]!
}

enum ChurrosNotificationChannel {
  Articles
  Comments
  GodparentRequests
  GroupBoard
  Other
  Permissions
  Shotguns
}

"""
A NotificationSubscription stores a user's subscription to push notifications on a user agent
"""
type ChurrosNotificationSubscription {
  createdAt: DateTime!
  endpoint: String!
  expiresAt: DateTime
  id: ID!
  name: String!
  owner: ChurrosUser!
  ownerId: ID!
  updatedAt: DateTime!
}

input ChurrosNotificationSubscriptionKeysInput {
  auth: String!
  p256dh: String!
}

type ChurrosOAuth2Error {
  code: ChurrosOAuth2ErrorCode!
  message: String!
}

"""OAuth2 error codes, see RFC 6749 § 4.1.2.1"""
enum ChurrosOAuth2ErrorCode {
  access_denied
  invalid_request
  invalid_scope
  server_error
  temporarily_unavailable
  unauthorized_client
  unsupported_response_type
}

"""
Une page écrite par un·e utilisateur·rice, servant par exemple à présenter les partenariats d'une AE sur une page dédiée.
"""
type ChurrosPage {
  """Contenu de la page. Supporte la syntaxe Markdown."""
  body: String!
  """Contenu de la page, converti en HTML. Protégé contre les attaques XSS."""
  bodyHtml: String!
  """L'utilisateur·ice connecté·e peut modifier ou supprimer cette page"""
  canBeEdited: Boolean!
  createdAt: DateTime!
  """
  Chemin vers les fichiers inclus sur la page, par exmple des images. Voir filesURLs pour obtenir les URLs de ces fichiers.
  """
  files: [String!]!
  """URLs vers les fichiers inclus sur la page."""
  filesURLs: [String!]!
  """
  Groupe auquel appartient la page. Peut être null si la page n'appartient à aucun groupe.
  """
  group: ChurrosGroup
  id: ID!
  """
  Dernier·ère utilisateur·rice ayant modifié la page. Peut être null si la page n'a jamais été modifiée, ou que l'utilisateur·ice en question a été supprimé·e.
  """
  lastAuthor: ChurrosUser
  """
  Chemin vers la page. Doit être unique _par AE ou groupe_. L'URL finale sera donc préfixée d'une certaine manière pour éviter les collisions.
  """
  path: String!
  """
  Association étudiante à laquelle appartient la page. Peut être null si la page n'appartient à aucune association.
  """
  studentAssociation: ChurrosStudentAssociation
  """Titre de la page."""
  title: String!
  updatedAt: DateTime!
}

type ChurrosPageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type ChurrosPagesConnection {
  edges: [ChurrosPagesEdge!]!
  nodes: [ChurrosPage!]!
  pageInfo: ChurrosPageInfo!
}

type ChurrosPagesEdge {
  cursor: String!
  node: ChurrosPage!
}

enum ChurrosPaymentMethod {
  Card
  Cash
  Check
  Lydia
  Other
  PayPal
  Transfer
}

type ChurrosPicture {
  id: ID!
  path: String!
  position: Int!
}

"""Une ressource qui possède une image associée"""
interface ChurrosPictured {
  """Le nom du fichier de l'image"""
  pictureFile: String!
  """Le nom du fichier de l'image, en thème sombre"""
  pictureFileDark: String!
  """L'URL publique de l'image"""
  pictureURL(
    """Utiliser l'image en thème sombre"""
    dark: Boolean! = false
  ): String!
}

type ChurrosProfitsBreakdown {
  byPaymentMethod: ChurrosProfitsBreakdownByPaymentMethod!
  byTicket: [ChurrosProfitsBreakdownByTicket!]!
  total: Float!
}

type ChurrosProfitsBreakdownByPaymentMethod {
  Card: Float!
  Cash: Float!
  Check: Float!
  Lydia: Float!
  Other: Float!
  PayPal: Float!
  Transfer: Float!
}

type ChurrosProfitsBreakdownByTicket {
  amount: Float!
  id: ID!
}

enum ChurrosPromotionType {
  SIMPPS
}

type ChurrosQRCode {
  path: String!
  viewbox: String!
}

type ChurrosQueryAllFormsConnection {
  edges: [ChurrosQueryAllFormsConnectionEdge!]!
  nodes: [ChurrosForm!]!
  pageInfo: ChurrosPageInfo!
}

type ChurrosQueryAllFormsConnectionEdge {
  cursor: String!
  node: ChurrosForm!
}

type ChurrosQueryAllUsersConnection {
  edges: [ChurrosQueryAllUsersConnectionEdge!]!
  nodes: [ChurrosUser!]!
  pageInfo: ChurrosPageInfo!
}

type ChurrosQueryAllUsersConnectionEdge {
  cursor: String!
  node: ChurrosUser!
}

type ChurrosQueryAnnouncementsConnection {
  edges: [ChurrosQueryAnnouncementsConnectionEdge!]!
  nodes: [ChurrosAnnouncement!]!
  pageInfo: ChurrosPageInfo!
}

type ChurrosQueryAnnouncementsConnectionEdge {
  cursor: String!
  node: ChurrosAnnouncement!
}

union ChurrosQueryCodeContributorsResult = ChurrosError | ChurrosQueryCodeContributorsSuccess

type ChurrosQueryCodeContributorsSuccess {
  data: [ChurrosUser!]!
}

union ChurrosQueryCombinedChangelogResult = ChurrosError | ChurrosQueryCombinedChangelogSuccess

type ChurrosQueryCombinedChangelogSuccess {
  data: [ChurrosChangelogRelease!]!
}

type ChurrosQueryDocumentsConnection {
  edges: [ChurrosQueryDocumentsConnectionEdge!]!
  nodes: [ChurrosDocument!]!
  pageInfo: ChurrosPageInfo!
}

type ChurrosQueryDocumentsConnectionEdge {
  cursor: String!
  node: ChurrosDocument!
}

type ChurrosQueryEventsByDayConnection {
  edges: [ChurrosQueryEventsByDayConnectionEdge!]!
  nodes: [ChurrosEventsByDay!]!
  pageInfo: ChurrosPageInfo!
}

type ChurrosQueryEventsByDayConnectionEdge {
  cursor: String!
  node: ChurrosEventsByDay!
}

type ChurrosQueryEventsConnection {
  edges: [ChurrosQueryEventsConnectionEdge!]!
  nodes: [ChurrosEvent!]!
  pageInfo: ChurrosPageInfo!
}

type ChurrosQueryEventsConnectionEdge {
  cursor: String!
  node: ChurrosEvent!
}

type ChurrosQueryFormsConnection {
  edges: [ChurrosQueryFormsConnectionEdge!]!
  nodes: [ChurrosForm!]!
  pageInfo: ChurrosPageInfo!
}

type ChurrosQueryFormsConnectionEdge {
  cursor: String!
  node: ChurrosForm!
}

union ChurrosQueryGroupMembersCsvResult = ChurrosError | ChurrosQueryGroupMembersCsvSuccess

type ChurrosQueryGroupMembersCsvSuccess {
  data: String!
}

type ChurrosQueryHomepageConnection {
  edges: [ChurrosQueryHomepageConnectionEdge!]!
  nodes: [ChurrosArticle!]!
  pageInfo: ChurrosPageInfo!
}

type ChurrosQueryHomepageConnectionEdge {
  cursor: String!
  node: ChurrosArticle!
}

type ChurrosQueryLogsConnection {
  edges: [ChurrosQueryLogsConnectionEdge!]!
  nodes: [ChurrosLogEntry!]!
  pageInfo: ChurrosPageInfo!
}

type ChurrosQueryLogsConnectionEdge {
  cursor: String!
  node: ChurrosLogEntry!
}

type ChurrosQueryMinorsConnection {
  edges: [ChurrosQueryMinorsConnectionEdge!]!
  nodes: [ChurrosMinor!]!
  pageInfo: ChurrosPageInfo!
}

type ChurrosQueryMinorsConnectionEdge {
  cursor: String!
  node: ChurrosMinor!
}

type ChurrosQueryNotificationsConnection {
  edges: [ChurrosQueryNotificationsConnectionEdge!]!
  nodes: [ChurrosNotification!]!
  pageInfo: ChurrosPageInfo!
}

type ChurrosQueryNotificationsConnectionEdge {
  cursor: String!
  node: ChurrosNotification!
}

type ChurrosQueryPagesConnection {
  edges: [ChurrosQueryPagesConnectionEdge!]!
  nodes: [ChurrosPage!]!
  pageInfo: ChurrosPageInfo!
}

type ChurrosQueryPagesConnectionEdge {
  cursor: String!
  node: ChurrosPage!
}

type ChurrosQueryQuickSignupsConnection {
  edges: [ChurrosQueryQuickSignupsConnectionEdge!]!
  nodes: [ChurrosQuickSignup!]!
  pageInfo: ChurrosPageInfo!
}

type ChurrosQueryQuickSignupsConnectionEdge {
  cursor: String!
  node: ChurrosQuickSignup!
}

type ChurrosQueryReactionsConnection {
  edges: [ChurrosQueryReactionsConnectionEdge!]!
  nodes: [ChurrosReaction!]!
  pageInfo: ChurrosPageInfo!
}

type ChurrosQueryReactionsConnectionEdge {
  cursor: String!
  node: ChurrosReaction!
}

union ChurrosQueryRegistrationResult = ChurrosError | ChurrosQueryRegistrationSuccess

type ChurrosQueryRegistrationSuccess {
  data: ChurrosRegistration!
}

type ChurrosQueryRegistrationsOfUserConnection {
  edges: [ChurrosQueryRegistrationsOfUserConnectionEdge!]!
  nodes: [ChurrosRegistration!]!
  pageInfo: ChurrosPageInfo!
}

type ChurrosQueryRegistrationsOfUserConnectionEdge {
  cursor: String!
  node: ChurrosRegistration!
}

union ChurrosQueryUpcomingChangelogResult = ChurrosError | ChurrosQueryUpcomingChangelogSuccess

type ChurrosQueryUpcomingChangelogSuccess {
  data: ChurrosChangelogRelease!
}

type ChurrosQueryUserCandidatesConnection {
  edges: [ChurrosQueryUserCandidatesConnectionEdge!]!
  nodes: [ChurrosUserCandidate!]!
  pageInfo: ChurrosPageInfo!
}

type ChurrosQueryUserCandidatesConnectionEdge {
  cursor: String!
  node: ChurrosUserCandidate!
}

"""Une question dans un formulaire"""
interface ChurrosQuestion {
  """
  Indique si la réponse à la question est anonyme. Si oui, les personnes pouvant voir les réponses ne pouront jamais savoir la réponse d'une personne à la question
  """
  anonymous: Boolean!
  answers(
    after: String
    before: String
    """Récupérer uniquement les réponses d'un utilisateur, par son uid."""
    by: String
    first: Int
    last: Int
  ): ChurrosQuestionAnswersConnection!
  """
  La réponse par défaut à cette question. Même si le résultat est bien de type Answer, le champ `id` est vide
  """
  defaultAnswer: ChurrosAnswer
  """Description en Markdown de la question"""
  description: String!
  """Description en HTML de la question"""
  descriptionHtml: String!
  """Préfixe d'identifiant: question:"""
  id: ID!
  """Indique si la question est obligatoire"""
  mandatory: Boolean!
  """La réponse de l'utilisateur·ice connecté·e à cette question"""
  myAnswer: ChurrosAnswer
  """Ordre de la question dans la section"""
  order: Int!
  """Section du formulaire dans laquelle est la question"""
  section: ChurrosFormSection!
  """Titre de la question"""
  title: String!
  """Nombre total de réponses à cette question"""
  totalAnswers: Int!
  """Type de la question"""
  type: ChurrosQuestionKind!
}

type ChurrosQuestionAnswersConnection {
  edges: [ChurrosQuestionAnswersConnectionEdge!]!
  nodes: [ChurrosAnswer!]!
  pageInfo: ChurrosPageInfo!
}

type ChurrosQuestionAnswersConnectionEdge {
  cursor: String!
  node: ChurrosAnswer!
}

"""Question de type `FileUpload`"""
type ChurrosQuestionFileUpload implements ChurrosQuestion {
  """
  Types de fichiers autorisés pour les questions de type `File`. Null si la question n'est pas de type `File`.
  """
  allowedFileTypes: [String!]
  """
  Indique si la réponse à la question est anonyme. Si oui, les personnes pouvant voir les réponses ne pouront jamais savoir la réponse d'une personne à la question
  """
  anonymous: Boolean!
  answers(
    after: String
    before: String
    """Récupérer uniquement les réponses d'un utilisateur, par son uid."""
    by: String
    first: Int
    last: Int
  ): ChurrosQuestionAnswersConnection!
  """
  La réponse par défaut à cette question. Même si le résultat est bien de type Answer, le champ `id` est vide
  """
  defaultAnswer: ChurrosAnswer
  """Description en Markdown de la question"""
  description: String!
  """Description en HTML de la question"""
  descriptionHtml: String!
  """Préfixe d'identifiant: question:"""
  id: ID!
  """Indique si la question est obligatoire"""
  mandatory: Boolean!
  """La réponse de l'utilisateur·ice connecté·e à cette question"""
  myAnswer: ChurrosAnswer
  """Ordre de la question dans la section"""
  order: Int!
  """Section du formulaire dans laquelle est la question"""
  section: ChurrosFormSection!
  """Titre de la question"""
  title: String!
  """Nombre total de réponses à cette question"""
  totalAnswers: Int!
  """Type de la question"""
  type: ChurrosQuestionKind!
}

"""Le type de question"""
enum ChurrosQuestionKind {
  """La réponse est une date, sans heure associée."""
  Date
  """La réponse est un fichier mis en ligne par l'utilisateur·ice."""
  FileUpload
  """La réponse est un texte long."""
  LongText
  """La réponse est un nombre, potentiellement à virgule."""
  Number
  """La réponse est un nombre entier entre deux bornes"""
  Scale
  """La réponse est une ou plusieurs options parmi une liste."""
  SelectMultiple
  """La réponse est une des options parmi une liste."""
  SelectOne
  """La réponse est un texte court."""
  Text
  """
  La réponse est un temps  (heures, minute et seconde), sans date associée.
  """
  Time
}

"""Choix pour les questions de type `SelectOne` ou `SelectMultiple`"""
input ChurrosQuestionOptionInput {
  """ID de la question vers laquelle sauter si ce choix est sélectionné"""
  jump: ID
  """Choix"""
  value: String!
}

"""Question de type `Text`, `Number`, `Date`, `Time` ou `LongText`"""
type ChurrosQuestionScalar implements ChurrosQuestion {
  """
  Indique si la réponse à la question est anonyme. Si oui, les personnes pouvant voir les réponses ne pouront jamais savoir la réponse d'une personne à la question
  """
  anonymous: Boolean!
  answers(
    after: String
    before: String
    """Récupérer uniquement les réponses d'un utilisateur, par son uid."""
    by: String
    first: Int
    last: Int
  ): ChurrosQuestionAnswersConnection!
  """
  La réponse par défaut à cette question. Même si le résultat est bien de type Answer, le champ `id` est vide
  """
  defaultAnswer: ChurrosAnswer
  """Description en Markdown de la question"""
  description: String!
  """Description en HTML de la question"""
  descriptionHtml: String!
  """Préfixe d'identifiant: question:"""
  id: ID!
  """Indique si la question est obligatoire"""
  mandatory: Boolean!
  """La réponse de l'utilisateur·ice connecté·e à cette question"""
  myAnswer: ChurrosAnswer
  """Ordre de la question dans la section"""
  order: Int!
  """Section du formulaire dans laquelle est la question"""
  section: ChurrosFormSection!
  """Titre de la question"""
  title: String!
  """Nombre total de réponses à cette question"""
  totalAnswers: Int!
  """Type de la question"""
  type: ChurrosQuestionKind!
}

"""Question de type `Scale`"""
type ChurrosQuestionScale implements ChurrosQuestion {
  """
  Indique si la réponse à la question est anonyme. Si oui, les personnes pouvant voir les réponses ne pouront jamais savoir la réponse d'une personne à la question
  """
  anonymous: Boolean!
  """
  Compte le nombre total de réponses pour chaque option. Retourne un `StringToIntMapping` où les clés sont les options et les valeurs sont le nombre de réponses pour l'option.
  """
  answerCounts: [ChurrosStringToIntMapping!]!
  answers(
    after: String
    before: String
    """Récupérer uniquement les réponses d'un utilisateur, par son uid."""
    by: String
    first: Int
    last: Int
  ): ChurrosQuestionAnswersConnection!
  """
  La réponse par défaut à cette question. Même si le résultat est bien de type Answer, le champ `id` est vide
  """
  defaultAnswer: ChurrosAnswer
  """Description en Markdown de la question"""
  description: String!
  """Description en HTML de la question"""
  descriptionHtml: String!
  """Préfixe d'identifiant: question:"""
  id: ID!
  """Liste des labels pour les valeurs possibles"""
  labels: [String!]!
  """Indique si la question est obligatoire"""
  mandatory: Boolean!
  """Valeur maximale"""
  maximum: Int!
  """Label de la valeur maximale"""
  maximumLabel: String!
  """Valeur minimale"""
  minimum: Int!
  """Label de la valeur minimale"""
  minimumLabel: String!
  """La réponse de l'utilisateur·ice connecté·e à cette question"""
  myAnswer: ChurrosAnswer
  """Liste des valeurs possibles"""
  options: [Int!]!
  """Ordre de la question dans la section"""
  order: Int!
  """Section du formulaire dans laquelle est la question"""
  section: ChurrosFormSection!
  """Titre de la question"""
  title: String!
  """Nombre total de réponses à cette question"""
  totalAnswers: Int!
  """Type de la question"""
  type: ChurrosQuestionKind!
}

"""Options supplémentaires pour les questions de type `Scale`"""
input ChurrosQuestionScaleInput {
  """Valeur maximale"""
  maximum: Int!
  """Label de la valeur maximale"""
  maximumLabel: String
  """Valeur minimale"""
  minimum: Int!
  """Label de la valeur minimale"""
  minimumLabel: String
}

"""Question de type `SelectMultiple`"""
type ChurrosQuestionSelectMultiple implements ChurrosQuestion {
  """
  Indique si la question de type `SelectOne` ou `SelectMultiple` permet une option "Autre", que l'utilisateur·ice peut remplir sans contrainte.
  """
  allowOptionsOther: Boolean!
  """
  Indique si la réponse à la question est anonyme. Si oui, les personnes pouvant voir les réponses ne pouront jamais savoir la réponse d'une personne à la question
  """
  anonymous: Boolean!
  """
  Compte le nombre total de réponses pour chaque option. Retourne un `StringToIntMapping` où les clés sont les options et les valeurs sont le nombre de réponses pour l'option.
  """
  answerCounts: [ChurrosStringToIntMapping!]!
  answers(
    after: String
    before: String
    """Récupérer uniquement les réponses d'un utilisateur, par son uid."""
    by: String
    first: Int
    last: Int
  ): ChurrosQuestionAnswersConnection!
  """
  La réponse par défaut à cette question. Même si le résultat est bien de type Answer, le champ `id` est vide
  """
  defaultAnswer: ChurrosAnswer
  """Description en Markdown de la question"""
  description: String!
  """Description en HTML de la question"""
  descriptionHtml: String!
  """Préfixe d'identifiant: question:"""
  id: ID!
  """Indique si la question est obligatoire"""
  mandatory: Boolean!
  """La réponse de l'utilisateur·ice connecté·e à cette question"""
  myAnswer: ChurrosAnswer
  """
  Uniquement pertinent pour les questions de type `SelectOne` ou `SelectMultiple`
  """
  options: [String!]!
  """Ordre de la question dans la section"""
  order: Int!
  """Section du formulaire dans laquelle est la question"""
  section: ChurrosFormSection!
  """Titre de la question"""
  title: String!
  """Nombre total de réponses à cette question"""
  totalAnswers: Int!
  """Type de la question"""
  type: ChurrosQuestionKind!
}

"""Question de type `SelectOne`"""
type ChurrosQuestionSelectOne implements ChurrosQuestion {
  """
  Indique si la question de type `SelectOne` ou `SelectMultiple` permet une option "Autre", que l'utilisateur·ice peut remplir sans contrainte.
  """
  allowOptionsOther: Boolean!
  """
  Indique si la réponse à la question est anonyme. Si oui, les personnes pouvant voir les réponses ne pouront jamais savoir la réponse d'une personne à la question
  """
  anonymous: Boolean!
  """
  Compte le nombre total de réponses pour chaque option. Retourne un `StringToIntMapping` où les clés sont les options et les valeurs sont le nombre de réponses pour l'option.
  """
  answerCounts: [ChurrosStringToIntMapping!]!
  answers(
    after: String
    before: String
    """Récupérer uniquement les réponses d'un utilisateur, par son uid."""
    by: String
    first: Int
    last: Int
  ): ChurrosQuestionAnswersConnection!
  """
  La réponse par défaut à cette question. Même si le résultat est bien de type Answer, le champ `id` est vide
  """
  defaultAnswer: ChurrosAnswer
  """Description en Markdown de la question"""
  description: String!
  """Description en HTML de la question"""
  descriptionHtml: String!
  """
  Dans le même ordre que `options`, contient le groupe si l'option porte exactement le nom du groupe, ou null si aucun groupe ne correspond. Pratique pour les questions où l'on demande à choisir entre plusieurs groupes (comme les votes de listes par ex.)
  """
  groups: [ChurrosGroup]!
  """Préfixe d'identifiant: question:"""
  id: ID!
  """
  Correspondances entre les réponses à cette question et les sections du formulaire à sauter vers. Dans le même ordre que `options`. Quand un élément est null, la section suivante n'est pas modifiée
  """
  jumps: [ChurrosFormSection]!
  """Indique si la question est obligatoire"""
  mandatory: Boolean!
  """La réponse de l'utilisateur·ice connecté·e à cette question"""
  myAnswer: ChurrosAnswer
  """
  Uniquement pertinent pour les questions de type `SelectOne` ou `SelectMultiple`
  """
  options: [String!]!
  """Ordre de la question dans la section"""
  order: Int!
  """Section du formulaire dans laquelle est la question"""
  section: ChurrosFormSection!
  """Titre de la question"""
  title: String!
  """Nombre total de réponses à cette question"""
  totalAnswers: Int!
  """Type de la question"""
  type: ChurrosQuestionKind!
}

"""
Lien d'inscription rapide, qui permet de créer un compte étudiant sans adresse mail étudiante et sans validation manuelle
"""
type ChurrosQuickSignup implements ChurrosNode {
  code: String!
  createdAt: DateTime!
  """Vrai si le lien est expiré"""
  expired: Boolean!
  id: ID!
  """L'identifiant local de la ressource (sans préfixe)"""
  localID: ChurrosLocalID!
  school: ChurrosSchool!
  schoolId: ID!
  updatedAt: DateTime!
  validUntil: DateTime!
}

"""
Une resource pouvant recevoir des réactions (likes, etc) par les utilisateur·ice·s
"""
interface ChurrosReactable {
  """L’identifiant de la resource"""
  id: ID!
  """Vrai si l’utilisateur·ice connecté·e a réagi avec cet emoji"""
  reacted(emoji: String!): Boolean!
  """Nombre total de réactions avec cet emoji"""
  reactions(emoji: String!): Int!
}

type ChurrosReaction implements ChurrosNode {
  author: ChurrosUser
  authorId: ID
  comment: ChurrosComment
  commentId: ID
  createdAt: DateTime!
  document: ChurrosDocument
  documentId: ID
  emoji: String!
  id: ID!
  """L'identifiant local de la ressource (sans préfixe)"""
  localID: ChurrosLocalID!
  updatedAt: DateTime!
}

type ChurrosRedisHealthCheck {
  """Whether the Redis publisher client is ready"""
  publish: Boolean!
  """Whether the Redis subscriber client is ready"""
  subscribe: Boolean!
}

"""A reservation is a user's registration for a ticket"""
type ChurrosRegistration implements ChurrosNode {
  author: ChurrosUser
  authorEmail: String!
  authorId: ID
  authorIsBeneficiary: Boolean!
  beneficiary: String!
  beneficiaryUser: ChurrosUser
  cancelled: Boolean!
  cancelledAt: DateTime
  cancelledBy: ChurrosUser
  code: String!
  createdAt: DateTime!
  id: ID!
  """L'identifiant local de la ressource (sans préfixe)"""
  localID: ChurrosLocalID!
  opposed: Boolean!
  opposedAt: DateTime
  opposedBy: ChurrosUser
  paid: Boolean!
  paymentMethod: ChurrosPaymentMethod
  ticket: ChurrosTicket!
  ticketId: ID!
  updatedAt: DateTime!
  verified: Boolean!
  verifiedAt: DateTime
  verifiedBy: ChurrosUser
}

type ChurrosRegistrationSearchResult {
  highlightedBeneficiary: String!
  id: ID!
  rank: Float
  registration: ChurrosRegistration!
  similarity: Float!
}

type ChurrosRegistrationVerificationResult {
  registration: ChurrosRegistration
  state: ChurrosRegistrationVerificationState!
}

enum ChurrosRegistrationVerificationState {
  AlreadyVerified
  NotFound
  NotPaid
  Ok
  Opposed
  OtherEvent
}

type ChurrosRegistrationsCounts {
  cancelled: Float!
  paid: Float!
  total: Float!
  unpaidLydia: Float!
  verified: Float!
}

"""A change in the changelog"""
type ChurrosReleaseChange {
  """The authors of the change"""
  authors: [String!]!
  html: String!
  """Issues linked to the change"""
  issues: [Int!]!
  """Merge requests linked to the change"""
  mergeRequests: [Int!]!
  """People who created the issues (gave the idea, reported the bug, etc.)"""
  reporters: [String!]!
  """The text of the change"""
  text: String!
}

"""Changes in the changelog, grouped by category"""
type ChurrosReleaseChangesMaps {
  """New features"""
  added: [ChurrosReleaseChange!]!
  """What was fixed"""
  fixed: [ChurrosReleaseChange!]!
  """What was improved"""
  improved: [ChurrosReleaseChange!]!
  """Miscalleanous changes"""
  other: [ChurrosReleaseChange!]!
  """Security changes"""
  security: [ChurrosReleaseChange!]!
  """Technical changes"""
  technical: [ChurrosReleaseChange!]!
}

type ChurrosSchool implements ChurrosPictured {
  address: String!
  aliasMailDomains: [String!]!
  color: String!
  description: String!
  id: ID!
  majors: [ChurrosMajor!]!
  name: String!
  pictureFile: String!
  """Le nom du fichier de l'image, en thème sombre"""
  pictureFileDark: String!
  """L'URL publique de l'image"""
  pictureURL(
    """Utiliser l'image en thème sombre"""
    dark: Boolean! = false
  ): String!
  services: [ChurrosService!]!
  slug: String!
  studentAssociations: [ChurrosStudentAssociation!]!
  studentMailDomain: String!
  uid: String!
}

type ChurrosSchoolGroup {
  majors: [ChurrosMajor!]!
  names: [String!]!
}

input ChurrosSchoolInput {
  color: String!
  id: ID
  name: String!
}

"""A service"""
type ChurrosService implements ChurrosNode {
  description: String!
  group: ChurrosGroup
  id: ID!
  importance: Int!
  """L'identifiant local de la ressource (sans préfixe)"""
  localID: ChurrosLocalID!
  logo: String!
  logoSourceType: ChurrosLogoSourceType!
  name: String!
  school: ChurrosSchool
  studentAssociation: ChurrosStudentAssociation
  url: String!
}

type ChurrosShopItem implements ChurrosNode {
  createdAt: DateTime!
  description: String!
  descriptionHtml: String!
  endsAt: DateTime
  group: ChurrosGroup!
  id: ID!
  itemOptions: [ChurrosShopItemOption!]!
  """L'identifiant local de la ressource (sans préfixe)"""
  localID: ChurrosLocalID!
  lydiaAccount: ChurrosLydiaAccount
  max: Int!
  name: String!
  paymentMethods: [ChurrosPaymentMethod!]!
  pictures: [ChurrosPicture!]!
  price: Float!
  shopPayments: [ChurrosShopPayment!]!
  """Un nom lisible sans espaces, adaptés pour des URLs."""
  slug: String!
  startsAt: DateTime
  stock: Int!
  stockLeft: Int!
  uid: String! @deprecated(reason: "Use `slug` instead. This field was never universally unique.")
  updatedAt: DateTime!
  visibility: ChurrosVisibility!
}

type ChurrosShopItemAnswer {
  id: ID!
  options: [String!]!
  shopPayment: ChurrosShopPayment!
  shopPaymentId: String!
}

type ChurrosShopItemOption {
  id: ID!
  name: String!
  options: [String!]!
  otherToggle: Boolean!
  required: Boolean!
  shopItem: ChurrosShopItem!
}

input ChurrosShopItemOptionInput {
  id: String!
  name: String!
  options: [String!]!
  otherToggle: Boolean!
  required: Boolean!
}

type ChurrosShopPayment {
  createdAt: DateTime!
  id: ID!
  paid: Boolean!
  paymentMethod: ChurrosPaymentMethod!
  quantity: Int!
  shopItem: ChurrosShopItem!
  shopItemAnswer: ChurrosShopItemAnswer
  totalPrice: Float!
  updatedAt: DateTime!
  user: ChurrosUser!
}

enum ChurrosSortDirection {
  Ascending
  Descending
}

"""Associe une clé à une valeur de type nombre entier"""
type ChurrosStringToIntMapping {
  """Clé de la paire"""
  key: String!
  """Valeur de la paire"""
  value: Int!
}

"""There is one student association per school"""
type ChurrosStudentAssociation implements ChurrosPictured {
  """
  Si l'utilsateur·ice courant·e peut créer des groupes rattachés à cette AE
  """
  canCreateGroups(
    """
    Quel type de groupe l'on souhaiterait créer. Si non spécifié, renvoie vrai si l'on peut créer au moins un type de groupe
    """
    type: ChurrosGroupType
  ): Boolean!
  """
  L'utilisateur·ice connecté·e peut éditer (créer ou modifier) les pages de l'AE
  """
  canEditPages: Boolean!
  """L'utilisateur·ice connecté·e peut lister les pages de l'AE"""
  canListPages: Boolean!
  contributionOptions: [ChurrosContributionOption!]!
  createdAt: DateTime!
  description: String!
  groups(after: String, before: String, first: Int, last: Int, types: [ChurrosGroupType!]): ChurrosStudentAssociationGroupsConnection!
  """Nombre de groupes reliés à cette AE"""
  groupsCount: Int!
  id: ID!
  links: [ChurrosLink!]!
  name: String!
  """La page associée à l'AE"""
  page(
    """
    Le chemin de la page. Ce n'est pas le chemin complet, mais celui qui est local à l'AE. Voir `Page` pour plus d'informations.
    """
    path: String!
  ): ChurrosPage
  """Les pages associées à l'AE"""
  pages(after: String, before: String, first: Int, last: Int): ChurrosPagesConnection!
  pictureFile: String!
  """Le nom du fichier de l'image, en thème sombre"""
  pictureFileDark: String!
  """L'URL publique de l'image"""
  pictureURL(
    """Utiliser l'image en thème sombre"""
    dark: Boolean! = false
  ): String!
  school: ChurrosSchool!
  schoolId: ID!
  uid: String
  updatedAt: DateTime!
}

type ChurrosStudentAssociationGroupsConnection {
  edges: [ChurrosStudentAssociationGroupsConnectionEdge!]!
  nodes: [ChurrosGroup!]!
  pageInfo: ChurrosPageInfo!
}

type ChurrosStudentAssociationGroupsConnectionEdge {
  cursor: String!
  node: ChurrosGroup!
}

type ChurrosSubject {
  apogeeCode: String
  documents(after: String, before: String, first: Int, last: Int): ChurrosSubjectDocumentsConnection!
  documentsCount: Int!
  emoji: String!
  forApprentices: Boolean!
  id: ID!
  links: [ChurrosLink!]!
  majors: [ChurrosMajor!]!
  minors: [ChurrosMinor!]!
  name: String!
  nextExamAt: DateTime
  semester: Int
  shortName: String!
  """Un nom lisible sans espaces, adaptés pour des URLs."""
  slug: String!
  uid: String! @deprecated(reason: "Use `slug` instead. This field was never universally unique.")
  unit: ChurrosTeachingUnit
  unitId: ID
  yearTier: Int
}

type ChurrosSubjectDocumentsConnection {
  edges: [ChurrosSubjectDocumentsConnectionEdge!]!
  nodes: [ChurrosDocument!]!
  pageInfo: ChurrosPageInfo!
}

type ChurrosSubjectDocumentsConnectionEdge {
  cursor: String!
  node: ChurrosDocument!
}

union ChurrosSubscriptionRegistrationResult = ChurrosError | ChurrosSubscriptionRegistrationSuccess

type ChurrosSubscriptionRegistrationSuccess {
  data: ChurrosRegistration!
}

type ChurrosTeachingUnit {
  apogeeCode: String
  id: ID!
  name: String!
  shortName: String!
  subjects: [ChurrosSubject!]!
}

"""A third-party OAuth2 client"""
type ChurrosThirdPartyApp {
  active: Boolean!
  allowedRedirectUris: [String!]!
  apiUsage(after: String, before: String, first: Int, last: Int): ChurrosThirdPartyAppApiUsageConnection!
  clientId: String!
  createdAt: DateTime!
  description: String!
  faviconUrl: String!
  id: ID!
  """
  Logs de connexion de l'application tierce, utile pour débugger des problèmes. Mise à jour en temps réel disponible via une subscription sur la query `thirdPartyApp`.
  """
  logs(after: String, before: String, first: Int, last: Int): ChurrosThirdPartyAppLogsConnection!
  name: String!
  owner: ChurrosGroup!
  rateLimitHits(after: String, before: String, first: Int, last: Int): ChurrosThirdPartyAppRateLimitHitsConnection!
  secretLength: Int!
  updatedAt: DateTime
  users(after: String, before: String, first: Int, last: Int): ChurrosThirdPartyAppUsersConnection!
  usersCount: Int!
  website: String!
}

type ChurrosThirdPartyAppApiUsageConnection {
  edges: [ChurrosThirdPartyAppApiUsageConnectionEdge!]!
  nodes: [ChurrosApiUsage!]!
  pageInfo: ChurrosPageInfo!
}

type ChurrosThirdPartyAppApiUsageConnectionEdge {
  cursor: String!
  node: ChurrosApiUsage!
}

type ChurrosThirdPartyAppLogsConnection {
  edges: [ChurrosThirdPartyAppLogsConnectionEdge!]!
  nodes: [ChurrosLogEntry!]!
  pageInfo: ChurrosPageInfo!
}

type ChurrosThirdPartyAppLogsConnectionEdge {
  cursor: String!
  node: ChurrosLogEntry!
}

type ChurrosThirdPartyAppRateLimitHitsConnection {
  edges: [ChurrosThirdPartyAppRateLimitHitsConnectionEdge!]!
  nodes: [ChurrosApiRateLimitHits!]!
  pageInfo: ChurrosPageInfo!
}

type ChurrosThirdPartyAppRateLimitHitsConnectionEdge {
  cursor: String!
  node: ChurrosApiRateLimitHits!
}

type ChurrosThirdPartyAppRegistrationResponse {
  client_id: String!
  client_secret: String!
}

type ChurrosThirdPartyAppUsersConnection {
  edges: [ChurrosThirdPartyAppUsersConnectionEdge!]!
  nodes: [ChurrosUser!]!
  pageInfo: ChurrosPageInfo!
  totalCount: Int!
}

type ChurrosThirdPartyAppUsersConnectionEdge {
  cursor: String!
  node: ChurrosUser!
}

"""
A ticket is a way to register for an event. May include a price and conditions.
"""
type ChurrosTicket implements ChurrosNode {
  allowedPaymentMethods: [ChurrosPaymentMethod!]!
  autojoinGroups: [ChurrosGroup!]!
  basePrice: Float!
  capacity: Int!
  closesAt: DateTime
  description: String!
  descriptionHtml: String!
  event: ChurrosEvent!
  eventId: ID!
  """Full name, including the ticket group's name if any"""
  fullName: String!
  godsonLimit: Int!
  group: ChurrosTicketGroup
  id: ID!
  links: [ChurrosLink!]!
  """L'identifiant local de la ressource (sans préfixe)"""
  localID: ChurrosLocalID!
  name: String!
  onlyManagersCanProvide: Boolean!
  openToAlumni: Boolean
  openToApprentices: Boolean
  openToContributors: Boolean
  openToExternal: Boolean
  openToGroups: [ChurrosGroup!]!
  openToMajors: [ChurrosMajor!]!
  openToPromotions: [Int!]!
  openToSchools: [ChurrosSchool!]!
  opensAt: DateTime
  """
  Nombre de places restantes. Null si l'information n'est pas disponible. N'est jamais null quand il n'y a plus de places disponibles (0)
  """
  placesLeft: Int
  price: Float!
  registrations: [ChurrosRegistration!]!
  remainingGodsons: Int!
  """Un nom lisible sans espaces, adaptés pour des URLs."""
  slug: String!
  ticketGroupId: ID
  uid: String! @deprecated(reason: "Use `slug` instead. This field was never universally unique.")
}

"""
A ticket group allows for conditions on multiple tickets, such as an upper limit on the sum of registrations in the sub-tickets
"""
type ChurrosTicketGroup implements ChurrosNode {
  capacity: Int!
  event: ChurrosEvent!
  eventId: ID!
  id: ID!
  """L'identifiant local de la ressource (sans préfixe)"""
  localID: ChurrosLocalID!
  name: String!
  tickets: [ChurrosTicket!]!
}

input ChurrosTicketGroupInput {
  capacity: Int!
  id: ID
  name: String!
}

input ChurrosTicketInput {
  allowedPaymentMethods: [ChurrosPaymentMethod!]!
  autojoinGroups: [String!]!
  capacity: Int!
  closesAt: DateTime
  description: String!
  godsonLimit: Int!
  groupName: String
  id: ID
  links: [ChurrosLinkInput!]!
  name: String!
  onlyManagersCanProvide: Boolean!
  openToAlumni: Boolean
  openToApprentices: Boolean
  openToContributors: Boolean
  openToExternal: Boolean
  openToGroups: [String!]!
  openToMajors: [String!]!
  openToPromotions: [Int!]!
  openToSchools: [String!]!
  opensAt: DateTime
  price: Float!
}

"""A field whose value matches /^[\w-]{3,255}$/."""
scalar ChurrosUID

input ChurrosUpsertGroupInput {
  address: String!
  color: String
  description: String!
  email: String
  links: [ChurrosLinkInput!]!
  longDescription: String!
  mailingList: String
  name: String!
  parent: ChurrosUID
  related: [String!]!
  school: ChurrosUID
  selfJoinable: Boolean!
  studentAssociation: ChurrosUID
  type: ChurrosGroupType!
  """
  Ne sert qu'à la création du groupe. Il est impossible de modifier un uid existant
  """
  uid: ChurrosUID
  website: String!
}

"""Users are the people who use the app"""
type ChurrosUser implements ChurrosNode & ChurrosPictured {
  address: String!
  admin: Boolean!
  """
  Vrai si cette personne est administratrice de l'association étudiante donnée
  """
  adminOf(
    """UID de l'association étudiante"""
    studentAssociation: String!
  ): Boolean!
  allowedApps: [ChurrosThirdPartyApp!]! @deprecated(reason: "Use `authorizedApps` instead")
  """Formulaires complètement répondus par l'utilisateur"""
  answeredForms(after: String, before: String, first: Int, last: Int): ChurrosUserAnsweredFormsConnection!
  apprentice: Boolean!
  articles(after: String, before: String, first: Int, last: Int): ChurrosUserArticlesConnection!
  """Applications tierces autorisées à accéder à ce compte utilisateur"""
  authorizedApps: [ChurrosThirdPartyApp!]!
  birthday: DateTime
  """Les affiliations de l'utilisateur à des groupes dont iel est au bureau"""
  boardMemberships: [ChurrosGroupMember!]!
  booking(beneficiary: String, event: ID!): ChurrosRegistration!
  bookings(after: String, before: String, first: Int, forUserOnly: Boolean, last: Int): ChurrosUserBookingsConnection!
  """
  Vrai si cet utilisateur est un bot (i.e. ne représente pas une personne physique)
  """
  bot: Boolean!
  canAccessDocuments: Boolean!
  canBeEdited: Boolean!
  """Groupes sur lesquels l'utilisateur·ice peut créer des posts"""
  canCreatePostsOn: [ChurrosGroup!]!
  """Vrai si cette personne peut éditer le groupe donné"""
  canEditGroup(
    """UID du groupe"""
    uid: String!
  ): Boolean!
  """Vrai si cette personne peut éditer des groupes"""
  canEditGroups: Boolean!
  cededImageRightsToTVn7: Boolean!
  contributesTo: [ChurrosStudentAssociation!]!
  contributesWith: [ChurrosContributionOption!]!
  createdAt: DateTime!
  credentials: [ChurrosCredential!]!
  description: String!
  descriptionHtml: String!
  email: String!
  emailChangeRequests: [ChurrosEmailChange!]!
  enabledNotificationChannels: [ChurrosNotificationChannel!]!
  external: Boolean!
  familyTree: ChurrosFamilyTree!
  firstName: String!
  fullName: String!
  godchildren: [ChurrosUser!]!
  godparent: ChurrosUser
  graduationYear: Int!
  groups: [ChurrosGroupMember!]!
  id: ID!
  incomingGodparentRequests: [ChurrosGodparentRequest!]!
  lastName: String!
  latestVersionSeenInChangelog: String!
  links: [ChurrosLink!]!
  """L'identifiant local de la ressource (sans préfixe)"""
  localID: ChurrosLocalID!
  major: ChurrosMajor
  majorId: ID
  managedEvents: [ChurrosEventManager!]!
  minor: ChurrosMinor
  nickname: String!
  otherEmails: [String!]!
  outgoingGodparentRequests: [ChurrosGodparentRequest!]!
  """Formulaires partiellement répondus par l'utilisateur"""
  partiallyAnsweredForms(after: String, before: String, first: Int, last: Int): ChurrosUserPartiallyAnsweredFormsConnection!
  pendingContributions: [ChurrosContributionOption!]!
  phone: String!
  pictureFile: String!
  """Le nom du fichier de l'image, en thème sombre"""
  pictureFileDark: String!
  """L'URL publique de l'image"""
  pictureURL(
    """Utiliser l'image en thème sombre"""
    dark: Boolean! = false
  ): String!
  schoolUid: String
  """
  Vrai si cette personne est administratrice d'au moins une association étudiante
  """
  studentAssociationAdmin: Boolean!
  uid: String!
  yearTier: Int!
}

type ChurrosUserAnsweredFormsConnection {
  edges: [ChurrosUserAnsweredFormsConnectionEdge!]!
  nodes: [ChurrosForm!]!
  pageInfo: ChurrosPageInfo!
}

type ChurrosUserAnsweredFormsConnectionEdge {
  cursor: String!
  node: ChurrosForm!
}

type ChurrosUserArticlesConnection {
  edges: [ChurrosUserArticlesConnectionEdge!]!
  nodes: [ChurrosArticle!]!
  pageInfo: ChurrosPageInfo!
}

type ChurrosUserArticlesConnectionEdge {
  cursor: String!
  node: ChurrosArticle!
}

type ChurrosUserBookingsConnection {
  edges: [ChurrosUserBookingsConnectionEdge!]!
  nodes: [ChurrosRegistration!]!
  pageInfo: ChurrosPageInfo!
}

type ChurrosUserBookingsConnectionEdge {
  cursor: String!
  node: ChurrosRegistration!
}

"""UserCandidates are users in the registration process"""
type ChurrosUserCandidate implements ChurrosNode {
  address: String!
  apprentice: Boolean!
  birthday: DateTime
  cededImageRightsToTVn7: Boolean!
  createdAt: DateTime
  email: String!
  """Vrai si l'email est une adresse email d'étudiant."""
  emailIsSchoolEmail: Boolean!
  emailValidated: Boolean!
  firstName: String!
  fullName: String!
  graduationYear: Int!
  id: ID!
  lastName: String!
  """L'identifiant local de la ressource (sans préfixe)"""
  localID: ChurrosLocalID!
  major: ChurrosMajor
  majorId: ID
  """
  Vrai si l'utilisateur aura besoin d'une validation manuelle à la fin de l'inscription. Null si la notion n'a pas encore de sens. Si la filière n'a pas encore été renseignée, retourne vrai seulement si l'inscription devra être validée manuellement si une filière (peut importe laquelle) est choisie. Voir `needsManualValidationForMajor` pour être plus précis
  """
  needsManualValidation: Boolean
  """
  Vrai si l'utilisateur aura besoin d'une validation manuelle à la fin de l'inscription si iel choisi cette filière. Null si la notion n'a pas encore de sens.
  """
  needsManualValidationForMajor(
    """L'UID de la filière"""
    major: String!
  ): Boolean
  phone: String!
  schoolEmail: String
  schoolServer: String
  schoolUid: String
  suggestedUid: String!
  uid: String!
  """Vrai si l'utilisateur a été créé via un lien d'inscription rapide."""
  usingQuickSignup: Boolean!
}

type ChurrosUserPartiallyAnsweredFormsConnection {
  edges: [ChurrosUserPartiallyAnsweredFormsConnectionEdge!]!
  nodes: [ChurrosForm!]!
  pageInfo: ChurrosPageInfo!
}

type ChurrosUserPartiallyAnsweredFormsConnectionEdge {
  cursor: String!
  node: ChurrosForm!
}

type ChurrosUserSearchResult {
  highlightedDescription: String!
  id: ID!
  rank: Float
  similarity: Float!
  user: ChurrosUser!
}

enum ChurrosVisibility {
  GroupRestricted
  Private
  Public
  SchoolRestricted
  Unlisted
}

"""A validation error, as a list of field errors."""
type ChurrosZodError implements ChurrosErrorInterface {
  fieldErrors: [ChurrosZodFieldError!]!
  message: String!
}

"""A validation issue for a field."""
type ChurrosZodFieldError {
  message: String!
  path: [String!]!
}

type Mutation {
  """Application Viewset"""
  coreApplicationsCreate(input: ApplicationRequestInput): CoreApplicationsCreateResponse @httpOperation(subgraph: "Authentik", path: "/core/applications/", operationSpecificHeaders: [["Content-Type", "application/json"], ["accept", "application/json"]], httpMethod: POST)
  """Application Viewset"""
  coreApplicationsUpdate(
    """Internal application name, used in URLs."""
    slug: String!
    input: ApplicationRequestInput
  ): CoreApplicationsUpdateResponse @httpOperation(subgraph: "Authentik", path: "/core/applications/{args.slug}/", operationSpecificHeaders: [["Content-Type", "application/json"], ["accept", "application/json"]], httpMethod: PUT)
  """Application Viewset"""
  coreApplicationsPartialUpdate(
    """Internal application name, used in URLs."""
    slug: String!
    input: PatchedApplicationRequestInput
  ): CoreApplicationsPartialUpdateResponse @httpOperation(subgraph: "Authentik", path: "/core/applications/{args.slug}/", operationSpecificHeaders: [["Content-Type", "application/json"], ["accept", "application/json"]], httpMethod: PATCH)
  """Application Viewset"""
  coreApplicationsDestroy(
    """Internal application name, used in URLs."""
    slug: String!
  ): CoreApplicationsDestroyResponse @httpOperation(subgraph: "Authentik", path: "/core/applications/{args.slug}/", operationSpecificHeaders: [["accept", "application/json"]], httpMethod: DELETE)
  """Set application icon"""
  coreApplicationsSetIconCreate(
    """Internal application name, used in URLs."""
    slug: String!
    input: FileUploadRequestInput
  ): GenericError @httpOperation(subgraph: "Authentik", path: "/core/applications/{args.slug}/set_icon/", operationSpecificHeaders: [["Content-Type", "multipart/form-data"], ["accept", "application/json"]], httpMethod: POST)
  """Set application icon (as URL)"""
  coreApplicationsSetIconUrlCreate(
    """Internal application name, used in URLs."""
    slug: String!
    input: FilePathRequestInput
  ): GenericError @httpOperation(subgraph: "Authentik", path: "/core/applications/{args.slug}/set_icon_url/", operationSpecificHeaders: [["Content-Type", "application/json"], ["accept", "application/json"]], httpMethod: POST)
  """FlowStageBinding Viewset"""
  flowsBindingsCreate(input: FlowStageBindingRequestInput): FlowsBindingsCreateResponse @httpOperation(subgraph: "Authentik", path: "/flows/bindings/", operationSpecificHeaders: [["Content-Type", "application/json"], ["accept", "application/json"]], httpMethod: POST)
  """FlowStageBinding Viewset"""
  flowsBindingsUpdate(
    """A UUID string identifying this Flow Stage Binding."""
    fsbUuid: UUID!
    input: FlowStageBindingRequestInput
  ): FlowsBindingsUpdateResponse @httpOperation(subgraph: "Authentik", path: "/flows/bindings/{args.fsb_uuid}/", operationSpecificHeaders: [["Content-Type", "application/json"], ["accept", "application/json"]], httpMethod: PUT)
  """FlowStageBinding Viewset"""
  flowsBindingsPartialUpdate(
    """A UUID string identifying this Flow Stage Binding."""
    fsbUuid: UUID!
    input: PatchedFlowStageBindingRequestInput
  ): FlowsBindingsPartialUpdateResponse @httpOperation(subgraph: "Authentik", path: "/flows/bindings/{args.fsb_uuid}/", operationSpecificHeaders: [["Content-Type", "application/json"], ["accept", "application/json"]], httpMethod: PATCH)
  """FlowStageBinding Viewset"""
  flowsBindingsDestroy(
    """A UUID string identifying this Flow Stage Binding."""
    fsbUuid: UUID!
  ): FlowsBindingsDestroyResponse @httpOperation(subgraph: "Authentik", path: "/flows/bindings/{args.fsb_uuid}/", operationSpecificHeaders: [["accept", "application/json"]], httpMethod: DELETE)
  """
  Solve the previously retrieved challenge and advanced to the next stage.
  """
  flowsExecutorSolve(
    flowSlug: String!
    """Querystring as received"""
    query: String!
    input: FlowChallengeResponseRequestInput
  ): FlowsExecutorSolveResponse @httpOperation(subgraph: "Authentik", path: "/flows/executor/{args.flow_slug}/", operationSpecificHeaders: [["Content-Type", "application/json"], ["accept", "application/json"]], httpMethod: POST, queryParamArgMap: "{\"query\":\"query\"}")
  """Flow Viewset"""
  flowsInstancesCreate(input: FlowRequestInput): FlowsInstancesCreateResponse @httpOperation(subgraph: "Authentik", path: "/flows/instances/", operationSpecificHeaders: [["Content-Type", "application/json"], ["accept", "application/json"]], httpMethod: POST)
  """Flow Viewset"""
  flowsInstancesUpdate(
    """Visible in the URL."""
    slug: String!
    input: FlowRequestInput
  ): FlowsInstancesUpdateResponse @httpOperation(subgraph: "Authentik", path: "/flows/instances/{args.slug}/", operationSpecificHeaders: [["Content-Type", "application/json"], ["accept", "application/json"]], httpMethod: PUT)
  """Flow Viewset"""
  flowsInstancesPartialUpdate(
    """Visible in the URL."""
    slug: String!
    input: PatchedFlowRequestInput
  ): FlowsInstancesPartialUpdateResponse @httpOperation(subgraph: "Authentik", path: "/flows/instances/{args.slug}/", operationSpecificHeaders: [["Content-Type", "application/json"], ["accept", "application/json"]], httpMethod: PATCH)
  """Flow Viewset"""
  flowsInstancesDestroy(
    """Visible in the URL."""
    slug: String!
  ): FlowsInstancesDestroyResponse @httpOperation(subgraph: "Authentik", path: "/flows/instances/{args.slug}/", operationSpecificHeaders: [["accept", "application/json"]], httpMethod: DELETE)
  """Set Flow background"""
  flowsInstancesSetBackgroundCreate(
    """Visible in the URL."""
    slug: String!
    input: FileUploadRequestInput
  ): GenericError @httpOperation(subgraph: "Authentik", path: "/flows/instances/{args.slug}/set_background/", operationSpecificHeaders: [["Content-Type", "multipart/form-data"], ["accept", "application/json"]], httpMethod: POST)
  """Set Flow background (as URL)"""
  flowsInstancesSetBackgroundUrlCreate(
    """Visible in the URL."""
    slug: String!
    input: FilePathRequestInput
  ): GenericError @httpOperation(subgraph: "Authentik", path: "/flows/instances/{args.slug}/set_background_url/", operationSpecificHeaders: [["Content-Type", "application/json"], ["accept", "application/json"]], httpMethod: POST)
  """Clear flow cache"""
  flowsInstancesCacheClearCreate: FlowsInstancesCacheClearCreateResponse @httpOperation(subgraph: "Authentik", path: "/flows/instances/cache_clear/", operationSpecificHeaders: [["accept", "application/json"]], httpMethod: POST)
  """Import flow from .yaml file"""
  flowsInstancesImportCreate(input: FileUploadRequestInput): FlowsInstancesImportCreateResponse @httpOperation(subgraph: "Authentik", path: "/flows/instances/import/", operationSpecificHeaders: [["Content-Type", "multipart/form-data"], ["accept", "application/json"]], httpMethod: POST)
  """Provider Viewset"""
  providersAllDestroy(
    """A unique integer value identifying this provider."""
    id: Int!
  ): ProvidersAllDestroyResponse @httpOperation(subgraph: "Authentik", path: "/providers/all/{args.id}/", operationSpecificHeaders: [["accept", "application/json"]], httpMethod: DELETE)
}

union AdminAppsListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "App") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = App | ValidationError | GenericError

"""Serialize Application info"""
type App {
  name: String!
  label: String!
}

"""Validation Error"""
type ValidationError {
  nonFieldErrors: [String]
  code: String
  additionalProperties: JSON @resolveRoot(subgraph: "Authentik")
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

"""Generic API Error"""
type GenericError {
  detail: String!
  code: String
}

union AdminMetricsRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "LoginMetrics") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = LoginMetrics | ValidationError | GenericError

"""Login Metrics per 1h"""
type LoginMetrics {
  logins: [Coordinate]!
  loginsFailed: [Coordinate]!
  authorizations: [Coordinate]!
}

"""Coordinates for diagrams"""
type Coordinate {
  xCord: Int!
  yCord: Int!
}

union AdminModelsListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "App") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = App | ValidationError | GenericError

union AdminSettingsRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Settings") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Settings | ValidationError | GenericError

"""Settings Serializer"""
type Settings {
  """Configure how authentik should show avatars for users."""
  avatars: String
  """Enable the ability for users to change their name."""
  defaultUserChangeName: Boolean
  """Enable the ability for users to change their email address."""
  defaultUserChangeEmail: Boolean
  """Enable the ability for users to change their username."""
  defaultUserChangeUsername: Boolean
  """
  Events will be deleted after this duration.(Format: weeks=3;days=2;hours=3,seconds=2).
  """
  eventRetention: String
  """The option configures the footer links on the flow executor pages."""
  footerLinks: JSON
  """
  When enabled, all the events caused by a user will be deleted upon the user's deletion.
  """
  gdprCompliance: Boolean
  """Globally enable/disable impersonation."""
  impersonation: Boolean
  """Default token duration"""
  defaultTokenDuration: String
  """Default token length"""
  defaultTokenLength: PositiveInt
}

"""Integers that will have a value greater than 0."""
scalar PositiveInt

union AdminSystemRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "SystemInfo") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = SystemInfo | ValidationError | GenericError

"""Get system information."""
type SystemInfo {
  """Get HTTP Request headers"""
  httpHeaders: JSON!
  """Get HTTP host"""
  httpHost: String!
  """Get HTTP Secure flag"""
  httpIsSecure: Boolean!
  runtime: QueryAdminSystemRetrieveOneOf_0Runtime!
  """Currently active brand"""
  brand: String!
  """Current server time"""
  serverTime: DateTime!
  """Whether the embedded outpost is disabled"""
  embeddedOutpostDisabled: Boolean!
  """Get the FQDN configured on the embedded outpost"""
  embeddedOutpostHost: String!
}

"""Get versions"""
type QueryAdminSystemRetrieveOneOf_0Runtime {
  pythonVersion: String!
  gunicornVersion: String!
  environment: String!
  architecture: String!
  platform: String!
  uname: String!
}

union AdminVersionRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Version") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Version | ValidationError | GenericError

"""Get running and latest version."""
type Version {
  """Get current version"""
  versionCurrent: String!
  """Get latest version from cache"""
  versionLatest: String!
  """Check if latest version is valid"""
  versionLatestValid: Boolean!
  """Get build hash, if version is not latest or released"""
  buildHash: String!
  """Check if we're running the latest version"""
  outdated: Boolean!
}

union AdminWorkersRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Workers") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Workers | ValidationError | GenericError

type Workers {
  count: Int!
}

union AuthenticatorsAdminAllListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Device") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Device | ValidationError | GenericError

"""Serializer for Duo authenticator devices"""
type Device {
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  pk: Int!
  name: String!
  """Get type of device"""
  type: String!
  confirmed: Boolean!
}

union AuthenticatorsAdminDuoListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedDuoDeviceList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedDuoDeviceList | ValidationError | GenericError

type PaginatedDuoDeviceList {
  pagination: Pagination!
  results: [DuoDevice]!
}

type Pagination {
  next: Float!
  previous: Float!
  count: Float!
  current: Float!
  totalPages: Float!
  startIndex: Float!
  endIndex: Float!
}

"""Serializer for Duo authenticator devices"""
type DuoDevice {
  pk: Int!
  """The human-readable name of this device."""
  name: QueryAuthenticatorsAdminDuoListOneOf_0ResultsItemsName!
}

"""The human-readable name of this device."""
scalar QueryAuthenticatorsAdminDuoListOneOf_0ResultsItemsName @length(subgraph: "Authentik", max: 64)

union AuthenticatorsAdminDuoRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "DuoDevice") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = DuoDevice | ValidationError | GenericError

union AuthenticatorsAdminSmsListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedSMSDeviceList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedSmsDeviceList | ValidationError | GenericError

type PaginatedSmsDeviceList {
  pagination: Pagination!
  results: [SmsDevice]!
}

"""Serializer for sms authenticator devices"""
type SmsDevice {
  """The human-readable name of this device."""
  name: QueryAuthenticatorsAdminSmsListOneOf_0ResultsItemsName!
  pk: Int!
  phoneNumber: String!
}

"""The human-readable name of this device."""
scalar QueryAuthenticatorsAdminSmsListOneOf_0ResultsItemsName @length(subgraph: "Authentik", max: 64)

union AuthenticatorsAdminSmsRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "SMSDevice") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = SmsDevice | ValidationError | GenericError

union AuthenticatorsAdminStaticListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedStaticDeviceList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedStaticDeviceList | ValidationError | GenericError

type PaginatedStaticDeviceList {
  pagination: Pagination!
  results: [StaticDevice]!
}

"""Serializer for static authenticator devices"""
type StaticDevice {
  """The human-readable name of this device."""
  name: QueryAuthenticatorsAdminStaticListOneOf_0ResultsItemsName!
  tokenSet: [StaticDeviceToken]!
  pk: Int!
}

"""The human-readable name of this device."""
scalar QueryAuthenticatorsAdminStaticListOneOf_0ResultsItemsName @length(subgraph: "Authentik", max: 64)

"""Serializer for static device's tokens"""
type StaticDeviceToken {
  token: QueryAuthenticatorsAdminStaticListOneOf_0ResultsItemsTokenSetItemsToken!
}

scalar QueryAuthenticatorsAdminStaticListOneOf_0ResultsItemsTokenSetItemsToken @length(subgraph: "Authentik", max: 16)

union AuthenticatorsAdminStaticRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "StaticDevice") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = StaticDevice | ValidationError | GenericError

union AuthenticatorsAdminTotpListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedTOTPDeviceList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedTotpDeviceList | ValidationError | GenericError

type PaginatedTotpDeviceList {
  pagination: Pagination!
  results: [TotpDevice]!
}

"""Serializer for totp authenticator devices"""
type TotpDevice {
  """The human-readable name of this device."""
  name: QueryAuthenticatorsAdminTotpListOneOf_0ResultsItemsName!
  pk: Int!
}

"""The human-readable name of this device."""
scalar QueryAuthenticatorsAdminTotpListOneOf_0ResultsItemsName @length(subgraph: "Authentik", max: 64)

union AuthenticatorsAdminTotpRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "TOTPDevice") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = TotpDevice | ValidationError | GenericError

union AuthenticatorsAdminWebauthnListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedWebAuthnDeviceList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedWebAuthnDeviceList | ValidationError | GenericError

type PaginatedWebAuthnDeviceList {
  pagination: Pagination!
  results: [WebAuthnDevice]!
}

"""Serializer for WebAuthn authenticator devices"""
type WebAuthnDevice {
  pk: Int!
  name: QueryAuthenticatorsAdminWebauthnListOneOf_0ResultsItemsName!
  createdOn: DateTime!
  deviceType: WebAuthnDeviceType!
  aaguid: String!
}

scalar QueryAuthenticatorsAdminWebauthnListOneOf_0ResultsItemsName @length(subgraph: "Authentik", max: 200)

"""WebAuthnDeviceType Serializer"""
type WebAuthnDeviceType {
  aaguid: UUID!
  description: String!
}

"""
A field whose value is a generic Universally Unique Identifier: https://en.wikipedia.org/wiki/Universally_unique_identifier.
"""
scalar UUID

union AuthenticatorsAdminWebauthnRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "WebAuthnDevice") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = WebAuthnDevice | ValidationError | GenericError

union AuthenticatorsAllListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Device") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Device | ValidationError | GenericError

union AuthenticatorsDuoListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedDuoDeviceList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedDuoDeviceList | ValidationError | GenericError

union AuthenticatorsDuoRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "DuoDevice") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = DuoDevice | ValidationError | GenericError

union AuthenticatorsDuoUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

"""A list of all objects referencing the queried object"""
type UsedBy {
  app: String!
  modelName: String!
  pk: String!
  name: String!
  action: UsedByActionEnum!
}

enum UsedByActionEnum {
  CASCADE
  CASCADE_MANY
  SET_NULL
  SET_DEFAULT
}

union AuthenticatorsSmsListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedSMSDeviceList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedSmsDeviceList | ValidationError | GenericError

union AuthenticatorsSmsRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "SMSDevice") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = SmsDevice | ValidationError | GenericError

union AuthenticatorsSmsUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union AuthenticatorsStaticListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedStaticDeviceList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedStaticDeviceList | ValidationError | GenericError

union AuthenticatorsStaticRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "StaticDevice") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = StaticDevice | ValidationError | GenericError

union AuthenticatorsStaticUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union AuthenticatorsTotpListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedTOTPDeviceList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedTotpDeviceList | ValidationError | GenericError

union AuthenticatorsTotpRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "TOTPDevice") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = TotpDevice | ValidationError | GenericError

union AuthenticatorsTotpUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union AuthenticatorsWebauthnListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedWebAuthnDeviceList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedWebAuthnDeviceList | ValidationError | GenericError

union AuthenticatorsWebauthnRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "WebAuthnDevice") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = WebAuthnDevice | ValidationError | GenericError

union AuthenticatorsWebauthnUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union CoreApplicationsListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedApplicationList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedApplicationList | ValidationError | GenericError

type PaginatedApplicationList {
  pagination: Pagination!
  results: [Application]!
}

"""Application Serializer"""
type Application {
  pk: UUID!
  """Application's display Name."""
  name: String!
  slug: QueryCoreApplicationsListOneOf_0ResultsItemsSlug!
  provider: Int
  providerObj: Provider!
  backchannelProviders: [Int]
  backchannelProvidersObj: [Provider]!
  """Allow formatting of launch URL"""
  launchUrl: String
  """Open launch URL in a new browser tab or window."""
  openInNewTab: Boolean
  metaLaunchUrl: URL
  """
  Get the URL to the App Icon image. If the name is /static or starts with http
  it is returned as-is
  """
  metaIcon: String
  metaDescription: String
  metaPublisher: String
  policyEngineMode: PolicyEngineMode
  groupSlug: String
  churrosGroup: ChurrosGroup! @resolveTo(sourceName: "Churros", sourceTypeName: "Query", sourceFieldName: "group", requiredSelectionSet: "{ groupSlug }", sourceArgs: {uid: "{root.groupSlug}"})
  metrics: [CoreApplicationsMetricsListResponse] @resolveTo(sourceName: "Authentik", sourceTypeName: "Query", sourceFieldName: "applicationMetrics", requiredSelectionSet: "{ slug }", sourceArgs: {slug: "{root.slug}"})
}

scalar QueryCoreApplicationsListOneOf_0ResultsItemsSlug @regexp(subgraph: "Authentik", pattern: "^[-a-zA-Z0-9_]+$") @typescript(subgraph: "Authentik", type: "string")

"""Provider Serializer"""
type Provider {
  pk: Int!
  name: String!
  """
  Flow used for authentication when the associated application is accessed by an un-authenticated user.
  """
  authenticationFlow: UUID
  """Flow used when authorizing this provider."""
  authorizationFlow: UUID!
  propertyMappings: [UUID]
  """Get object component so that we know how to edit the object"""
  component: String!
  """Internal application name, used in URLs."""
  assignedApplicationSlug: String!
  """Application's display Name."""
  assignedApplicationName: String!
  """Internal application name, used in URLs."""
  assignedBackchannelApplicationSlug: String!
  """Application's display Name."""
  assignedBackchannelApplicationName: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  additionalProperties: JSON @resolveRoot(subgraph: "Authentik")
  application: CoreApplicationsRetrieveResponse @resolveTo(sourceName: "Authentik", sourceTypeName: "Query", sourceFieldName: "application", requiredSelectionSet: "{ assignedApplicationSlug }", sourceArgs: {slug: "{root.assignedApplicationSlug}"})
}

"""
A field whose value conforms to the standard URL format as specified in RFC3986: https://www.ietf.org/rfc/rfc3986.txt.
"""
scalar URL

enum PolicyEngineMode {
  ALL
  ANY
}

union CoreApplicationsRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Application") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Application | ValidationError | GenericError

union CoreApplicationsCheckAccessRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PolicyTestResult") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PolicyTestResult | ValidationError | GenericError

"""result of a policy test"""
type PolicyTestResult {
  passing: Boolean!
  messages: [String]!
  logMessages: [LogEvent]!
}

"""Single log message with all context logged."""
type LogEvent {
  timestamp: DateTime!
  logLevel: LogLevelEnum!
  logger: String!
  event: String!
  attributes: JSON!
}

enum LogLevelEnum {
  CRITICAL
  EXCEPTION
  ERROR
  WARN
  WARNING
  INFO
  DEBUG
  NOTSET
}

union CoreApplicationsMetricsListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Coordinate") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Coordinate | ValidationError | GenericError

union CoreApplicationsUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union CoreAuthenticatedSessionsListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedAuthenticatedSessionList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedAuthenticatedSessionList | ValidationError | GenericError

type PaginatedAuthenticatedSessionList {
  pagination: Pagination!
  results: [AuthenticatedSession]!
}

"""AuthenticatedSession Serializer"""
type AuthenticatedSession {
  uuid: UUID
  """Check if session is currently active session"""
  current: Boolean!
  userAgent: QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgent!
  geoIp: QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsGeoIp
  asn: QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsAsn
  user: Int!
  lastIp: String!
  lastUserAgent: String
  lastUsed: DateTime!
  expires: DateTime
}

"""Get parsed user agent"""
type QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgent {
  device: QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentDevice!
  os: QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentOs!
  userAgent: QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentUserAgent!
  string: String!
}

"""User agent device"""
type QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentDevice {
  brand: String!
  family: String!
  model: String!
}

"""User agent os"""
type QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentOs {
  family: String!
  major: String!
  minor: String!
  patch: String!
  patchMinor: String!
}

"""User agent browser"""
type QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsUserAgentUserAgent {
  family: String!
  major: String!
  minor: String!
  patch: String!
}

"""Get GeoIP Data"""
type QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsGeoIp {
  continent: String!
  country: String!
  lat: Float!
  long: Float!
  city: String!
}

"""Get ASN Data"""
type QueryCoreAuthenticatedSessionsListOneOf_0ResultsItemsAsn {
  asn: Int!
  asOrg: String
  network: String
}

union CoreAuthenticatedSessionsRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "AuthenticatedSession") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = AuthenticatedSession | ValidationError | GenericError

union CoreAuthenticatedSessionsUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union CoreBrandsListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedBrandList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedBrandList | ValidationError | GenericError

type PaginatedBrandList {
  pagination: Pagination!
  results: [Brand]!
}

"""Brand Serializer"""
type Brand {
  brandUuid: UUID!
  """
  Domain that activates this brand. Can be a superset, i.e. `a.b` for `aa.b` and `ba.b`
  """
  domain: String!
  default: Boolean
  brandingTitle: String
  brandingLogo: String
  brandingFavicon: String
  flowAuthentication: UUID
  flowInvalidation: UUID
  flowRecovery: UUID
  flowUnenrollment: UUID
  flowUserSettings: UUID
  flowDeviceCode: UUID
  """Web Certificate used by the authentik Core webserver."""
  webCertificate: UUID
  attributes: JSON
}

union CoreBrandsRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Brand") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Brand | ValidationError | GenericError

union CoreBrandsUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union CoreBrandsCurrentRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "CurrentBrand") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = CurrentBrand | ValidationError | GenericError

"""Partial brand information for styling"""
type CurrentBrand {
  matchedDomain: String!
  brandingTitle: String!
  brandingLogo: String!
  brandingFavicon: String!
  uiFooterLinks: [FooterLink]!
  uiTheme: UiThemeEnum!
  flowAuthentication: String
  flowInvalidation: String
  flowRecovery: String
  flowUnenrollment: String
  flowUserSettings: String
  flowDeviceCode: String
  defaultLocale: String!
}

"""Links returned in Config API"""
type FooterLink {
  href: String!
  name: String!
}

enum UiThemeEnum {
  AUTOMATIC
  LIGHT
  DARK
}

union CoreGroupsListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedGroupList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedGroupList | ValidationError | GenericError

type PaginatedGroupList {
  pagination: Pagination!
  results: [Group]!
}

"""Group Serializer"""
type Group {
  pk: UUID!
  numPk: Int!
  name: QueryCoreGroupsListOneOf_0ResultsItemsName!
  """Users added to this group will be superusers."""
  isSuperuser: Boolean
  parent: UUID
  parentName: String
  users: [Int]
  usersObj: [GroupMember]
  attributes: JSON
  roles: [UUID]
  rolesObj: [Role]!
  additionalProperties: JSON @resolveRoot(subgraph: "Authentik")
}

scalar QueryCoreGroupsListOneOf_0ResultsItemsName @length(subgraph: "Authentik", max: 80)

"""Stripped down user serializer to show relevant users for groups"""
type GroupMember {
  pk: Int!
  username: QueryCoreGroupsListOneOf_0ResultsItemsUsersObjItemsUsername!
  """User's display name."""
  name: String!
  """
  Designates whether this user should be treated as active. Unselect this instead of deleting accounts.
  """
  isActive: Boolean
  lastLogin: DateTime
  email: EmailAddress
  attributes: JSON
  uid: String!
  additionalProperties: JSON @resolveRoot(subgraph: "Authentik")
}

scalar QueryCoreGroupsListOneOf_0ResultsItemsUsersObjItemsUsername @regexp(subgraph: "Authentik", pattern: "^[\\w.@+-]+$") @typescript(subgraph: "Authentik", type: "string")

"""
A field whose value conforms to the standard internet email address format as specified in HTML Spec: https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address.
"""
scalar EmailAddress @specifiedBy(url: "https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address")

"""Role serializer"""
type Role {
  pk: UUID!
  name: QueryCoreGroupsListOneOf_0ResultsItemsRolesObjItemsName!
}

scalar QueryCoreGroupsListOneOf_0ResultsItemsRolesObjItemsName @length(subgraph: "Authentik", max: 150)

union CoreGroupsRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Group") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Group | ValidationError | GenericError

union CoreGroupsUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union CoreTokensListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedTokenList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedTokenList | ValidationError | GenericError

type PaginatedTokenList {
  pagination: Pagination!
  results: [Token]!
}

"""Token Serializer"""
type Token {
  pk: UUID!
  """
  Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.
  """
  managed: String
  identifier: QueryCoreTokensListOneOf_0ResultsItemsIdentifier!
  intent: IntentEnum
  user: Int
  userObj: User!
  description: String
  expires: DateTime
  expiring: Boolean
  additionalProperties: JSON @resolveRoot(subgraph: "Authentik")
}

scalar QueryCoreTokensListOneOf_0ResultsItemsIdentifier @regexp(subgraph: "Authentik", pattern: "^[-a-zA-Z0-9_]+$") @typescript(subgraph: "Authentik", type: "string")

enum IntentEnum {
  VERIFICATION
  API
  RECOVERY
  APP_PASSWORD
}

"""User Serializer"""
type User {
  pk: Int!
  username: QueryCoreTokensListOneOf_0ResultsItemsUserObjUsername!
  """User's display name."""
  name: String!
  """
  Designates whether this user should be treated as active. Unselect this instead of deleting accounts.
  """
  isActive: Boolean
  lastLogin: DateTime
  isSuperuser: Boolean!
  groups: [UUID]
  groupsObj: [UserGroup]
  email: EmailAddress
  """User's avatar, either a http/https URL or a data URI"""
  avatar: String!
  attributes: JSON
  uid: String!
  path: String
  type: UserTypeEnum
  uuid: UUID!
  additionalProperties: JSON @resolveRoot(subgraph: "Authentik")
}

scalar QueryCoreTokensListOneOf_0ResultsItemsUserObjUsername @length(subgraph: "Authentik", max: 150)

"""Simplified Group Serializer for user's groups"""
type UserGroup {
  pk: UUID!
  """Get a numerical, int32 ID for the group"""
  numPk: Int!
  name: QueryCoreTokensListOneOf_0ResultsItemsUserObjGroupsObjItemsName!
  """Users added to this group will be superusers."""
  isSuperuser: Boolean
  parent: UUID
  parentName: String
  attributes: JSON
  additionalProperties: JSON @resolveRoot(subgraph: "Authentik")
}

scalar QueryCoreTokensListOneOf_0ResultsItemsUserObjGroupsObjItemsName @length(subgraph: "Authentik", max: 80)

enum UserTypeEnum {
  INTERNAL
  EXTERNAL
  SERVICE_ACCOUNT
  INTERNAL_SERVICE_ACCOUNT
}

enum QueryInputCoreTokensListIntent {
  API
  APP_PASSWORD
  RECOVERY
  VERIFICATION
}

union CoreTokensRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Token") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Token | ValidationError | GenericError

union CoreTokensUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union CoreTokensViewKeyRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "TokenView") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = TokenView | ValidationError | GenericError

"""Show token's current key"""
type TokenView {
  key: String!
}

union CoreUserConsentListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedUserConsentList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedUserConsentList | ValidationError | GenericError

type PaginatedUserConsentList {
  pagination: Pagination!
  results: [UserConsent]!
}

"""UserConsent Serializer"""
type UserConsent {
  pk: Int!
  expires: DateTime
  expiring: Boolean
  user: User!
  application: Application!
  permissions: String
}

union CoreUserConsentRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UserConsent") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UserConsent | ValidationError | GenericError

union CoreUserConsentUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union CoreUsersListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedUserList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedUserList | ValidationError | GenericError

type PaginatedUserList {
  pagination: Pagination!
  results: [User]!
}

enum QueryInputCoreUsersListTypeItems {
  EXTERNAL
  INTERNAL
  INTERNAL_SERVICE_ACCOUNT
  SERVICE_ACCOUNT
}

union CoreUsersRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "User") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = User | ValidationError | GenericError

union CoreUsersMetricsRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UserMetrics") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UserMetrics | ValidationError | GenericError

"""User Metrics"""
type UserMetrics {
  logins: [Coordinate]!
  loginsFailed: [Coordinate]!
  authorizations: [Coordinate]!
}

union CoreUsersUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union CoreUsersImpersonateEndRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

type VoidContainer {
  void: Void @resolveRoot(subgraph: "Authentik")
}

"""Represents empty values"""
scalar Void

union CoreUsersMeRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "SessionUser") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = SessionUser | ValidationError | GenericError

"""
Response for the /user/me endpoint, returns the currently active user (as `user` property)
and, if this user is being impersonated, the original user in the `original` property.
"""
type SessionUser {
  user: UserSelf!
  original: UserSelf
}

"""User Serializer for information a user can retrieve about themselves"""
type UserSelf {
  pk: Int!
  username: QueryCoreUsersMeRetrieveOneOf_0UserUsername!
  """User's display name."""
  name: String!
  """
  Designates whether this user should be treated as active. Unselect this instead of deleting accounts.
  """
  isActive: Boolean!
  isSuperuser: Boolean!
  groups: [UserSelfGroups]!
  email: EmailAddress
  """User's avatar, either a http/https URL or a data URI"""
  avatar: String!
  uid: String!
  """Get user settings with brand and group settings applied"""
  settings: JSON!
  type: UserTypeEnum
  """Get all system permissions assigned to the user"""
  systemPermissions: [String]!
}

scalar QueryCoreUsersMeRetrieveOneOf_0UserUsername @regexp(subgraph: "Authentik", pattern: "^[\\w.@+-]+$") @typescript(subgraph: "Authentik", type: "string")

type UserSelfGroups {
  name: String!
  pk: String!
}

union CoreUsersPathsRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UserPath") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UserPath | ValidationError | GenericError

type UserPath {
  paths: [String]!
}

union CryptoCertificatekeypairsListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedCertificateKeyPairList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedCertificateKeyPairList | ValidationError | GenericError

type PaginatedCertificateKeyPairList {
  pagination: Pagination!
  results: [CertificateKeyPair]!
}

"""CertificateKeyPair Serializer"""
type CertificateKeyPair {
  pk: UUID!
  name: String!
  """Get certificate Hash (SHA256)"""
  fingerprintSha256: String
  """Get certificate Hash (SHA1)"""
  fingerprintSha1: String
  """Get certificate expiry"""
  certExpiry: DateTime
  """Get certificate subject as full rfc4514"""
  certSubject: String
  """Show if this keypair has a private key configured or not"""
  privateKeyAvailable: Boolean!
  """Get the private key's type, if set"""
  privateKeyType: String
  """Get URL to download certificate"""
  certificateDownloadUrl: String!
  """Get URL to download private key"""
  privateKeyDownloadUrl: String!
  """
  Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.
  """
  managed: String
}

union CryptoCertificatekeypairsRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "CertificateKeyPair") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = CertificateKeyPair | ValidationError | GenericError

union CryptoCertificatekeypairsUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union CryptoCertificatekeypairsViewCertificateRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "CertificateData") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = CertificateData | ValidationError | GenericError

"""Get CertificateKeyPair's data"""
type CertificateData {
  data: String!
}

union CryptoCertificatekeypairsViewPrivateKeyRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "CertificateData") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = CertificateData | ValidationError | GenericError

union EnterpriseLicenseListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedLicenseList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedLicenseList | ValidationError | GenericError

type PaginatedLicenseList {
  pagination: Pagination!
  results: [License]!
}

"""License Serializer"""
type License {
  licenseUuid: UUID!
  name: String!
  key: String!
  expiry: DateTime!
  internalUsers: Int!
  externalUsers: Int!
}

union EnterpriseLicenseRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "License") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = License | ValidationError | GenericError

union EnterpriseLicenseUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union EnterpriseLicenseForecastRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "LicenseForecast") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = LicenseForecast | ValidationError | GenericError

"""Serializer for license forecast"""
type LicenseForecast {
  internalUsers: Int!
  externalUsers: Int!
  forecastedInternalUsers: Int!
  forecastedExternalUsers: Int!
}

union EnterpriseLicenseGetInstallIdRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "InstallID") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = InstallId | ValidationError | GenericError

type InstallId {
  installId: String!
}

union EnterpriseLicenseSummaryRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "LicenseSummary") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = LicenseSummary | ValidationError | GenericError

"""Serializer for license status"""
type LicenseSummary {
  internalUsers: Int!
  externalUsers: Int!
  valid: Boolean!
  showAdminWarning: Boolean!
  showUserWarning: Boolean!
  readOnly: Boolean!
  latestValid: DateTime!
  hasLicense: Boolean!
}

union EventsEventsListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedEventList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedEventList | ValidationError | GenericError

type PaginatedEventList {
  pagination: Pagination!
  results: [Event]!
}

"""Event Serializer"""
type Event {
  pk: UUID!
  user: JSON
  action: EventActions!
  app: String!
  context: JSON
  clientIp: String
  created: DateTime!
  expires: DateTime
  brand: JSON
}

enum EventActions {
  LOGIN
  LOGIN_FAILED
  LOGOUT
  USER_WRITE
  SUSPICIOUS_REQUEST
  PASSWORD_SET
  SECRET_VIEW
  SECRET_ROTATE
  INVITATION_USED
  AUTHORIZE_APPLICATION
  SOURCE_LINKED
  IMPERSONATION_STARTED
  IMPERSONATION_ENDED
  FLOW_EXECUTION
  POLICY_EXECUTION
  POLICY_EXCEPTION
  PROPERTY_MAPPING_EXCEPTION
  SYSTEM_TASK_EXECUTION
  SYSTEM_TASK_EXCEPTION
  SYSTEM_EXCEPTION
  CONFIGURATION_ERROR
  MODEL_CREATED
  MODEL_UPDATED
  MODEL_DELETED
  EMAIL_SENT
  UPDATE_AVAILABLE
  CUSTOM_
}

union EventsEventsRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Event") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Event | ValidationError | GenericError

union EventsEventsActionsListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "TypeCreate") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = TypeCreate | ValidationError | GenericError

"""Types of an object that can be created"""
type TypeCreate {
  name: String!
  description: String!
  component: String!
  modelName: String!
  requiresEnterprise: Boolean
}

union EventsEventsPerMonthListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Coordinate") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Coordinate | ValidationError | GenericError

union EventsEventsTopPerUserListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "EventTopPerUser") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = EventTopPerUser | ValidationError | GenericError

"""Response object of Event's top_per_user"""
type EventTopPerUser {
  application: JSON!
  countedEvents: Int!
  uniqueUsers: Int!
}

union EventsEventsVolumeListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Coordinate") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Coordinate | ValidationError | GenericError

union EventsNotificationsListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedNotificationList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedNotificationList | ValidationError | GenericError

type PaginatedNotificationList {
  pagination: Pagination!
  results: [Notification]!
}

"""Notification Serializer"""
type Notification {
  pk: UUID!
  severity: SeverityEnum!
  body: String!
  created: DateTime!
  event: Event
  seen: Boolean
}

enum SeverityEnum {
  NOTICE
  WARNING
  ALERT
}

enum QueryInputEventsNotificationsListSeverity {
  ALERT
  NOTICE
  WARNING
}

union EventsNotificationsRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Notification") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Notification | ValidationError | GenericError

union EventsNotificationsUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union EventsRulesListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedNotificationRuleList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedNotificationRuleList | ValidationError | GenericError

type PaginatedNotificationRuleList {
  pagination: Pagination!
  results: [NotificationRule]!
}

"""NotificationRule Serializer"""
type NotificationRule {
  pk: UUID!
  name: String!
  """
  Select which transports should be used to notify the user. If none are selected, the notification will only be shown in the authentik UI.
  """
  transports: [UUID]
  severity: SeverityEnum
  """
  Define which group of users this notification should be sent and shown to. If left empty, Notification won't ben sent.
  """
  group: UUID
  groupObj: Group!
}

"""Controls which severity level the created notifications will have."""
enum QueryInputEventsRulesListSeverity {
  ALERT
  NOTICE
  WARNING
}

union EventsRulesRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "NotificationRule") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = NotificationRule | ValidationError | GenericError

union EventsRulesUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union EventsSystemTasksListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedSystemTaskList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedSystemTaskList | ValidationError | GenericError

type PaginatedSystemTaskList {
  pagination: Pagination!
  results: [SystemTask]!
}

"""Serialize TaskInfo and TaskResult"""
type SystemTask {
  uuid: UUID!
  name: String!
  """Get full name with UID"""
  fullName: String!
  uid: String
  description: String!
  startTimestamp: DateTime!
  finishTimestamp: DateTime!
  duration: Float!
  status: SystemTaskStatusEnum!
  messages: [LogEvent]!
}

enum SystemTaskStatusEnum {
  UNKNOWN
  SUCCESSFUL
  WARNING
  ERROR
}

enum QueryInputEventsSystemTasksListStatus {
  ERROR
  SUCCESSFUL
  UNKNOWN
  WARNING
}

union EventsSystemTasksRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "SystemTask") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = SystemTask | ValidationError | GenericError

union EventsTransportsListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedNotificationTransportList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedNotificationTransportList | ValidationError | GenericError

type PaginatedNotificationTransportList {
  pagination: Pagination!
  results: [NotificationTransport]!
}

"""NotificationTransport Serializer"""
type NotificationTransport {
  pk: UUID!
  name: String!
  mode: NotificationTransportModeEnum
  """Return selected mode with a UI Label"""
  modeVerbose: String!
  webhookUrl: URL
  webhookMapping: UUID
  """
  Only send notification once, for example when sending a webhook into a chat channel.
  """
  sendOnce: Boolean
}

enum NotificationTransportModeEnum {
  LOCAL
  WEBHOOK
  WEBHOOK_SLACK
  EMAIL
}

enum QueryInputEventsTransportsListMode {
  EMAIL
  LOCAL
  WEBHOOK
  WEBHOOK_SLACK
}

union EventsTransportsRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "NotificationTransport") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = NotificationTransport | ValidationError | GenericError

union EventsTransportsUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union FlowsBindingsListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedFlowStageBindingList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedFlowStageBindingList | ValidationError | GenericError

type PaginatedFlowStageBindingList {
  pagination: Pagination!
  results: [FlowStageBinding]!
}

"""FlowStageBinding Serializer"""
type FlowStageBinding {
  pk: UUID!
  policybindingmodelPtrId: UUID!
  target: UUID!
  stage: UUID!
  stageObj: Stage!
  """Evaluate policies during the Flow planning process."""
  evaluateOnPlan: Boolean
  """Evaluate policies when the Stage is present to the user."""
  reEvaluatePolicies: Boolean
  order: Int!
  policyEngineMode: PolicyEngineMode
  invalidResponseAction: InvalidResponseActionEnum
  additionalProperties: JSON @resolveRoot(subgraph: "Authentik")
}

"""Stage Serializer"""
type Stage {
  pk: UUID!
  name: String!
  """Get object type so that we know how to edit the object"""
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  flowSet: [FlowSet]
  additionalProperties: JSON @resolveRoot(subgraph: "Authentik")
}

"""Stripped down flow serializer"""
type FlowSet {
  pk: UUID!
  policybindingmodelPtrId: UUID!
  name: String!
  slug: QueryFlowsBindingsListOneOf_0ResultsItemsStageObjFlowSetItemsSlug!
  """Shown as the Title in Flow pages."""
  title: String!
  designation: FlowDesignationEnum!
  """
  Get the URL to the background image. If the name is /static or starts with http
  it is returned as-is
  """
  background: String!
  policyEngineMode: PolicyEngineMode
  """
  Enable compatibility mode, increases compatibility with password managers on mobile devices.
  """
  compatibilityMode: Boolean
  """Get export URL for flow"""
  exportUrl: String!
  layout: FlowLayoutEnum
  deniedAction: DeniedActionEnum
}

scalar QueryFlowsBindingsListOneOf_0ResultsItemsStageObjFlowSetItemsSlug @regexp(subgraph: "Authentik", pattern: "^[-a-zA-Z0-9_]+$") @typescript(subgraph: "Authentik", type: "string")

enum FlowDesignationEnum {
  AUTHENTICATION
  AUTHORIZATION
  INVALIDATION
  ENROLLMENT
  UNENROLLMENT
  RECOVERY
  STAGE_CONFIGURATION
}

enum FlowLayoutEnum {
  STACKED
  CONTENT_LEFT
  CONTENT_RIGHT
  SIDEBAR_LEFT
  SIDEBAR_RIGHT
}

enum DeniedActionEnum {
  MESSAGE_CONTINUE
  MESSAGE
  CONTINUE
}

enum InvalidResponseActionEnum {
  RETRY
  RESTART
  RESTART_WITH_CONTEXT
}

"""
Configure how the flow executor should handle an invalid response to a challenge. RETRY returns the error message and a similar challenge to the executor. RESTART restarts the flow from the beginning, and RESTART_WITH_CONTEXT restarts the flow while keeping the current context.
"""
enum QueryInputFlowsBindingsListInvalidResponseAction {
  RESTART
  RESTART_WITH_CONTEXT
  RETRY
}

enum QueryInputFlowsBindingsListPolicyEngineMode {
  ALL
  ANY
}

union FlowsBindingsRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "FlowStageBinding") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = FlowStageBinding | ValidationError | GenericError

union FlowsBindingsUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union FlowsExecutorGetResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = AccessDeniedChallenge | AppleLoginChallenge | AuthenticatorDuoChallenge | AuthenticatorSmsChallenge | AuthenticatorStaticChallenge | AuthenticatorTotpChallenge | AuthenticatorValidationChallenge | AuthenticatorWebAuthnChallenge | AutosubmitChallenge | CaptchaChallenge | ConsentChallenge | EmailChallenge | FlowErrorChallenge | IdentificationChallenge | OAuthDeviceCodeChallenge | OAuthDeviceCodeFinishChallenge | PasswordChallenge | PlexAuthenticationChallenge | PromptChallenge | RedirectChallenge | ShellChallenge | UserLoginChallenge | ValidationError | GenericError

"""Challenge when a flow's active stage calls `stage_invalid()`."""
type AccessDeniedChallenge {
  type: ChallengeChoices!
  flowInfo: ContextualFlowInfo
  component: String
  responseErrors: JSON
  pendingUser: String!
  pendingUserAvatar: String!
  errorMessage: String
}

enum ChallengeChoices {
  NATIVE
  SHELL
  REDIRECT
}

"""Contextual flow information for a challenge"""
type ContextualFlowInfo {
  title: String
  background: String
  cancelUrl: String!
  layout: ContextualFlowInfoLayoutEnum!
}

enum ContextualFlowInfoLayoutEnum {
  STACKED
  CONTENT_LEFT
  CONTENT_RIGHT
  SIDEBAR_LEFT
  SIDEBAR_RIGHT
}

"""
Special challenge for apple-native authentication flow, which happens on the client.
"""
type AppleLoginChallenge {
  type: ChallengeChoices!
  flowInfo: ContextualFlowInfo
  component: String
  responseErrors: JSON
  clientId: String!
  scope: String!
  redirectUri: String!
  state: String!
}

"""Duo Challenge"""
type AuthenticatorDuoChallenge {
  type: ChallengeChoices!
  flowInfo: ContextualFlowInfo
  component: String
  responseErrors: JSON
  pendingUser: String!
  pendingUserAvatar: String!
  activationBarcode: String!
  activationCode: String!
  stageUuid: String!
}

"""SMS Setup challenge"""
type AuthenticatorSmsChallenge {
  type: ChallengeChoices!
  flowInfo: ContextualFlowInfo
  component: String
  responseErrors: JSON
  pendingUser: String!
  pendingUserAvatar: String!
  phoneNumberRequired: Boolean
}

"""Static authenticator challenge"""
type AuthenticatorStaticChallenge {
  type: ChallengeChoices!
  flowInfo: ContextualFlowInfo
  component: String
  responseErrors: JSON
  pendingUser: String!
  pendingUserAvatar: String!
  codes: [String]!
}

"""TOTP Setup challenge"""
type AuthenticatorTotpChallenge {
  type: ChallengeChoices!
  flowInfo: ContextualFlowInfo
  component: String
  responseErrors: JSON
  pendingUser: String!
  pendingUserAvatar: String!
  configUrl: String!
}

"""Authenticator challenge"""
type AuthenticatorValidationChallenge {
  type: ChallengeChoices!
  flowInfo: ContextualFlowInfo
  component: String
  responseErrors: JSON
  pendingUser: String!
  pendingUserAvatar: String!
  deviceChallenges: [DeviceChallenge]!
  configurationStages: [SelectableStage]!
}

"""Single device challenge"""
type DeviceChallenge {
  deviceClass: String!
  deviceUid: String!
  challenge: JSON!
}

"""Serializer for stages which can be selected by users"""
type SelectableStage {
  pk: UUID!
  name: String!
  verboseName: String!
  metaModelName: String!
}

"""WebAuthn Challenge"""
type AuthenticatorWebAuthnChallenge {
  type: ChallengeChoices!
  flowInfo: ContextualFlowInfo
  component: String
  responseErrors: JSON
  pendingUser: String!
  pendingUserAvatar: String!
  registration: JSON!
}

"""Autosubmit challenge used to send and navigate a POST request"""
type AutosubmitChallenge {
  type: ChallengeChoices!
  flowInfo: ContextualFlowInfo
  component: String
  responseErrors: JSON
  url: String!
  attrs: JSON!
  title: String
}

"""Site public key"""
type CaptchaChallenge {
  type: ChallengeChoices!
  flowInfo: ContextualFlowInfo
  component: String
  responseErrors: JSON
  pendingUser: String!
  pendingUserAvatar: String!
  siteKey: String!
  jsUrl: String!
}

"""Challenge info for consent screens"""
type ConsentChallenge {
  type: ChallengeChoices!
  flowInfo: ContextualFlowInfo
  component: String
  responseErrors: JSON
  pendingUser: String!
  pendingUserAvatar: String!
  headerText: String
  permissions: [ConsentPermission]!
  additionalPermissions: [ConsentPermission]!
  token: String!
}

"""Permission used for consent"""
type ConsentPermission {
  name: String!
  id: String!
}

"""Email challenge"""
type EmailChallenge {
  type: ChallengeChoices!
  flowInfo: ContextualFlowInfo
  component: String
  responseErrors: JSON
}

"""
Challenge class when an unhandled error occurs during a stage. Normal users
are shown an error message, superusers are shown a full stacktrace.
"""
type FlowErrorChallenge {
  type: String
  flowInfo: ContextualFlowInfo
  component: String
  responseErrors: JSON
  requestId: String!
  error: String
  traceback: String
}

"""Identification challenges with all UI elements"""
type IdentificationChallenge {
  type: ChallengeChoices!
  flowInfo: ContextualFlowInfo
  component: String
  responseErrors: JSON
  userFields: [String]
  passwordFields: Boolean!
  applicationPre: String
  flowDesignation: FlowDesignationEnum!
  enrollUrl: String
  recoveryUrl: String
  passwordlessUrl: String
  primaryAction: String!
  sources: [LoginSource]
  showSourceLabels: Boolean!
}

"""Serializer for Login buttons of sources"""
type LoginSource {
  name: String!
  iconUrl: String
  challenge: LoginChallengeTypes!
}

union LoginChallengeTypes @discriminator(subgraph: "Authentik", field: "component", mapping: "{\"xak-flow-redirect\":\"RedirectChallenge\",\"ak-source-plex\":\"PlexAuthenticationChallenge\",\"ak-source-oauth-apple\":\"AppleLoginChallenge\"}") = RedirectChallenge | PlexAuthenticationChallenge | AppleLoginChallenge

"""Challenge type to redirect the client"""
type RedirectChallenge {
  type: ChallengeChoices!
  flowInfo: ContextualFlowInfo
  component: String
  responseErrors: JSON
  to: String!
}

"""Challenge shown to the user in identification stage"""
type PlexAuthenticationChallenge {
  type: ChallengeChoices!
  flowInfo: ContextualFlowInfo
  component: String
  responseErrors: JSON
  clientId: String!
  slug: String!
}

"""OAuth Device code challenge"""
type OAuthDeviceCodeChallenge {
  type: ChallengeChoices!
  flowInfo: ContextualFlowInfo
  component: String
  responseErrors: JSON
}

"""Final challenge after user enters their code"""
type OAuthDeviceCodeFinishChallenge {
  type: ChallengeChoices!
  flowInfo: ContextualFlowInfo
  component: String
  responseErrors: JSON
}

"""Password challenge UI fields"""
type PasswordChallenge {
  type: ChallengeChoices!
  flowInfo: ContextualFlowInfo
  component: String
  responseErrors: JSON
  pendingUser: String!
  pendingUserAvatar: String!
  recoveryUrl: String
}

"""Initial challenge being sent, define fields"""
type PromptChallenge {
  type: ChallengeChoices!
  flowInfo: ContextualFlowInfo
  component: String
  responseErrors: JSON
  fields: [StagePrompt]!
}

"""Serializer for a single Prompt field"""
type StagePrompt {
  fieldKey: String!
  label: String!
  type: PromptTypeEnum!
  required: Boolean!
  placeholder: String!
  initialValue: String!
  order: Int!
  subText: String!
  choices: [String]
}

enum PromptTypeEnum {
  TEXT
  TEXT_AREA
  TEXT_READ_ONLY
  TEXT_AREA_READ_ONLY
  USERNAME
  EMAIL
  PASSWORD
  NUMBER
  CHECKBOX
  RADIO_BUTTON_GROUP @enum(subgraph: "Authentik", value: "\"radio-button-group\"")
  DROPDOWN
  DATE
  DATE_TIME @enum(subgraph: "Authentik", value: "\"date-time\"")
  FILE
  SEPARATOR
  HIDDEN
  STATIC
  AK_LOCALE @enum(subgraph: "Authentik", value: "\"ak-locale\"")
}

"""challenge type to render HTML as-is"""
type ShellChallenge {
  type: ChallengeChoices!
  flowInfo: ContextualFlowInfo
  component: String
  responseErrors: JSON
  body: String!
}

"""Empty challenge"""
type UserLoginChallenge {
  type: ChallengeChoices!
  flowInfo: ContextualFlowInfo
  component: String
  responseErrors: JSON
  pendingUser: String!
  pendingUserAvatar: String!
}

union FlowsInspectorGetResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "FlowInspection") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = FlowInspection | GenericError

"""Serializer for inspect endpoint"""
type FlowInspection {
  plans: [FlowInspectorPlan]!
  currentPlan: FlowInspectorPlan
  isCompleted: Boolean!
}

"""Serializer for an active FlowPlan"""
type FlowInspectorPlan {
  currentStage: FlowStageBinding!
  nextPlannedStage: FlowStageBinding!
  """Get the plan's context, sanitized"""
  planContext: JSON!
  """Get a unique session ID"""
  sessionId: String!
}

union FlowsInstancesListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedFlowList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedFlowList | ValidationError | GenericError

type PaginatedFlowList {
  pagination: Pagination!
  results: [Flow]!
}

"""Flow Serializer"""
type Flow {
  pk: UUID!
  policybindingmodelPtrId: UUID!
  name: String!
  slug: QueryFlowsInstancesListOneOf_0ResultsItemsSlug!
  """Shown as the Title in Flow pages."""
  title: String!
  designation: FlowDesignationEnum!
  """
  Get the URL to the background image. If the name is /static or starts with http
  it is returned as-is
  """
  background: String!
  stages: [UUID]!
  policies: [UUID]!
  """Get count of cached flows"""
  cacheCount: Int!
  policyEngineMode: PolicyEngineMode
  """
  Enable compatibility mode, increases compatibility with password managers on mobile devices.
  """
  compatibilityMode: Boolean
  """Get export URL for flow"""
  exportUrl: String!
  layout: FlowLayoutEnum
  deniedAction: DeniedActionEnum
  authentication: AuthenticationEnum
  additionalProperties: JSON @resolveRoot(subgraph: "Authentik")
}

scalar QueryFlowsInstancesListOneOf_0ResultsItemsSlug @regexp(subgraph: "Authentik", pattern: "^[-a-zA-Z0-9_]+$") @typescript(subgraph: "Authentik", type: "string")

enum AuthenticationEnum {
  NONE
  REQUIRE_AUTHENTICATED
  REQUIRE_UNAUTHENTICATED
  REQUIRE_SUPERUSER
  REQUIRE_OUTPOST
}

"""Configure what should happen when a flow denies access to a user."""
enum QueryInputFlowsInstancesListDeniedAction {
  CONTINUE
  MESSAGE
  MESSAGE_CONTINUE
}

"""
Decides what this Flow is used for. For example, the Authentication flow is redirect to when an un-authenticated user visits authentik.
"""
enum QueryInputFlowsInstancesListDesignation {
  AUTHENTICATION
  AUTHORIZATION
  ENROLLMENT
  INVALIDATION
  RECOVERY
  STAGE_CONFIGURATION
  UNENROLLMENT
}

union FlowsInstancesRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Flow") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Flow | ValidationError | GenericError

union FlowsInstancesDiagramRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "FlowDiagram") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = FlowDiagram | ValidationError | GenericError

"""response of the flow's diagram action"""
type FlowDiagram {
  diagram: String!
}

union FlowsInstancesExecuteRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Link") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Link | GenericError

"""Returns a single link"""
type Link {
  link: String!
}

union FlowsInstancesExportRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "File_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = FileContainer | ValidationError | GenericError

type FileContainer {
  file: File @resolveRoot(subgraph: "Authentik")
}

"""The `File` scalar type represents a file upload."""
scalar File

union FlowsInstancesUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union FlowsInstancesCacheInfoRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Cache") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Cache | ValidationError | GenericError

"""Generic cache stats for an object"""
type Cache {
  count: Int!
}

union ManagedBlueprintsListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedBlueprintInstanceList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedBlueprintInstanceList | ValidationError | GenericError

type PaginatedBlueprintInstanceList {
  pagination: Pagination!
  results: [BlueprintInstance]!
}

"""Info about a single blueprint instance file"""
type BlueprintInstance {
  pk: UUID!
  name: String!
  path: String
  context: JSON
  lastApplied: DateTime!
  lastAppliedHash: String!
  status: BlueprintInstanceStatusEnum!
  enabled: Boolean
  managedModels: [String]!
  metadata: JSON!
  content: String
}

enum BlueprintInstanceStatusEnum {
  SUCCESSFUL
  WARNING
  ERROR
  ORPHANED
  UNKNOWN
}

union ManagedBlueprintsRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "BlueprintInstance") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = BlueprintInstance | ValidationError | GenericError

union ManagedBlueprintsUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union ManagedBlueprintsAvailableListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "BlueprintFile") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = BlueprintFile | ValidationError | GenericError

type BlueprintFile {
  path: String!
  lastM: DateTime!
  hash: String!
  meta: Metadata!
}

"""Serializer for blueprint metadata"""
type Metadata {
  name: String!
  labels: JSON!
  additionalProperties: JSON @resolveRoot(subgraph: "Authentik")
}

union Oauth2AccessTokensListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedTokenModelList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedTokenModelList | ValidationError | GenericError

type PaginatedTokenModelList {
  pagination: Pagination!
  results: [TokenModel]!
}

"""Serializer for BaseGrantModel and RefreshToken"""
type TokenModel {
  pk: Int!
  provider: OAuth2Provider!
  user: User!
  """Check if token is expired yet."""
  isExpired: Boolean!
  expires: DateTime
  scope: [String]!
  """Get the token's id_token as JSON String"""
  idToken: String!
  revoked: Boolean
}

"""OAuth2Provider Serializer"""
type OAuth2Provider {
  pk: Int!
  name: String!
  """
  Flow used for authentication when the associated application is accessed by an un-authenticated user.
  """
  authenticationFlow: UUID
  """Flow used when authorizing this provider."""
  authorizationFlow: UUID!
  propertyMappings: [UUID]
  """Get object component so that we know how to edit the object"""
  component: String!
  """Internal application name, used in URLs."""
  assignedApplicationSlug: String!
  """Application's display Name."""
  assignedApplicationName: String!
  """Internal application name, used in URLs."""
  assignedBackchannelApplicationSlug: String!
  """Application's display Name."""
  assignedBackchannelApplicationName: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  clientType: ClientTypeEnum
  clientId: QueryOauth2AccessTokensListOneOf_0ResultsItemsProviderClientId
  clientSecret: QueryOauth2AccessTokensListOneOf_0ResultsItemsProviderClientSecret
  """
  Access codes not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).
  """
  accessCodeValidity: String
  """
  Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).
  """
  accessTokenValidity: String
  """
  Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).
  """
  refreshTokenValidity: String
  """
  Include User claims from scopes in the id_token, for applications that don't access the userinfo endpoint.
  """
  includeClaimsInIdToken: Boolean
  """
  Key used to sign the tokens. Only required when JWT Algorithm is set to RS256.
  """
  signingKey: UUID
  """Enter each URI on a new line."""
  redirectUris: String
  subMode: SubModeEnum
  issuerMode: IssuerModeEnum
  jwksSources: [UUID]
}

enum ClientTypeEnum {
  CONFIDENTIAL
  PUBLIC
}

scalar QueryOauth2AccessTokensListOneOf_0ResultsItemsProviderClientId @length(subgraph: "Authentik", max: 255)

scalar QueryOauth2AccessTokensListOneOf_0ResultsItemsProviderClientSecret @length(subgraph: "Authentik", max: 255)

enum SubModeEnum {
  HASHED_USER_ID
  USER_ID
  USER_UUID
  USER_USERNAME
  USER_EMAIL
  USER_UPN
}

enum IssuerModeEnum {
  GLOBAL
  PER_PROVIDER
}

union Oauth2AccessTokensRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "TokenModel") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = TokenModel | ValidationError | GenericError

union Oauth2AccessTokensUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union Oauth2AuthorizationCodesListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedExpiringBaseGrantModelList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedExpiringBaseGrantModelList | ValidationError | GenericError

type PaginatedExpiringBaseGrantModelList {
  pagination: Pagination!
  results: [ExpiringBaseGrantModel]!
}

"""Serializer for BaseGrantModel and ExpiringBaseGrant"""
type ExpiringBaseGrantModel {
  pk: Int!
  provider: OAuth2Provider!
  user: User!
  """Check if token is expired yet."""
  isExpired: Boolean!
  expires: DateTime
  scope: [String]!
}

union Oauth2AuthorizationCodesRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "ExpiringBaseGrantModel") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ExpiringBaseGrantModel | ValidationError | GenericError

union Oauth2AuthorizationCodesUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union Oauth2RefreshTokensListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedTokenModelList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedTokenModelList | ValidationError | GenericError

union Oauth2RefreshTokensRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "TokenModel") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = TokenModel | ValidationError | GenericError

union Oauth2RefreshTokensUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union OutpostsInstancesListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedOutpostList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedOutpostList | ValidationError | GenericError

type PaginatedOutpostList {
  pagination: Pagination!
  results: [Outpost]!
}

"""Outpost Serializer"""
type Outpost {
  pk: UUID!
  name: String!
  type: OutpostTypeEnum!
  providers: [Int]!
  providersObj: [Provider]!
  """
  Select Service-Connection authentik should use to manage this outpost. Leave empty if authentik should not handle the deployment.
  """
  serviceConnection: UUID
  serviceConnectionObj: ServiceConnection!
  """Get Token identifier"""
  tokenIdentifier: String!
  config: JSON!
  """
  Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.
  """
  managed: String
}

enum OutpostTypeEnum {
  PROXY
  LDAP
  RADIUS
  RAC
}

"""ServiceConnection Serializer"""
type ServiceConnection {
  pk: UUID!
  name: String!
  """
  If enabled, use the local connection. Required Docker socket/Kubernetes Integration
  """
  local: Boolean
  """Return component used to edit this object"""
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  additionalProperties: JSON @resolveRoot(subgraph: "Authentik")
}

union OutpostsInstancesRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Outpost") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Outpost | ValidationError | GenericError

union OutpostsInstancesHealthListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "OutpostHealth") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = OutpostHealth | ValidationError | GenericError

"""Outpost health status"""
type OutpostHealth {
  uid: String!
  lastSeen: DateTime!
  version: String!
  versionShould: String!
  versionOutdated: Boolean!
  buildHash: String!
  buildHashShould: String!
  hostname: String!
}

union OutpostsInstancesUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union OutpostsInstancesDefaultSettingsRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "OutpostDefaultConfig") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = OutpostDefaultConfig | ValidationError | GenericError

"""Global default outpost config"""
type OutpostDefaultConfig {
  config: JSON!
}

union OutpostsLdapListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedLDAPOutpostConfigList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedLdapOutpostConfigList | ValidationError | GenericError

type PaginatedLdapOutpostConfigList {
  pagination: Pagination!
  results: [LdapOutpostConfig]!
}

"""LDAPProvider Serializer"""
type LdapOutpostConfig {
  pk: Int!
  name: String!
  """DN under which objects are accessible."""
  baseDn: String
  bindFlowSlug: String!
  """Prioritise backchannel slug over direct application slug"""
  applicationSlug: String!
  """
  Users in this group can do search queries. If not set, every user can execute search queries.
  """
  searchGroup: UUID
  certificate: UUID
  tlsServerName: String
  """
  The start for uidNumbers, this number is added to the user.pk to make sure that the numbers aren't too low for POSIX users. Default is 2000 to ensure that we don't collide with local users uidNumber
  """
  uidStartNumber: Int
  """
  The start for gidNumbers, this number is added to a number generated from the group.pk to make sure that the numbers aren't too low for POSIX groups. Default is 4000 to ensure that we don't collide with local groups or users primary groups gidNumber
  """
  gidStartNumber: Int
  searchMode: LdapapiAccessMode
  bindMode: LdapapiAccessMode
  """
  When enabled, code-based multi-factor authentication can be used by appending a semicolon and the TOTP code to the password. This should only be enabled if all users that will bind to this provider have a TOTP device configured, as otherwise a password may incorrectly be rejected if it contains a semicolon.
  """
  mfaSupport: Boolean
}

enum LdapapiAccessMode {
  DIRECT
  CACHED
}

union OutpostsLdapRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "LDAPOutpostConfig") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = LdapOutpostConfig | ValidationError | GenericError

union OutpostsProxyListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedProxyOutpostConfigList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedProxyOutpostConfigList | ValidationError | GenericError

type PaginatedProxyOutpostConfigList {
  pagination: Pagination!
  results: [ProxyOutpostConfig]!
}

"""Proxy provider serializer for outposts"""
type ProxyOutpostConfig {
  pk: Int!
  name: String!
  internalHost: URL
  externalHost: URL!
  """Validate SSL Certificates of upstream servers"""
  internalHostSslValidation: Boolean
  clientId: QueryOutpostsProxyListOneOf_0ResultsItemsClientId
  clientSecret: QueryOutpostsProxyListOneOf_0ResultsItemsClientSecret
  oidcConfiguration: OpenIdConnectConfiguration!
  cookieSecret: String
  certificate: UUID
  """
  Regular expressions for which authentication is not required. Each new line is interpreted as a new Regular Expression.
  """
  skipPathRegex: String
  """
  Set a custom HTTP-Basic Authentication header based on values from authentik.
  """
  basicAuthEnabled: Boolean
  """
  User/Group Attribute used for the password part of the HTTP-Basic Header.
  """
  basicAuthPasswordAttribute: String
  """
  User/Group Attribute used for the user part of the HTTP-Basic Header. If not set, the user's Email address is used.
  """
  basicAuthUserAttribute: String
  mode: ProxyMode
  cookieDomain: String
  """Get token validity as second count"""
  accessTokenValidity: Float
  """
  When enabled, this provider will intercept the authorization header and authenticate requests based on its value.
  """
  interceptHeaderAuth: Boolean
  """
  Get all the scope names the outpost should request,
  including custom-defined ones
  """
  scopesToRequest: [String]!
  """Internal application name, used in URLs."""
  assignedApplicationSlug: String!
  """Application's display Name."""
  assignedApplicationName: String!
}

scalar QueryOutpostsProxyListOneOf_0ResultsItemsClientId @length(subgraph: "Authentik", max: 255)

scalar QueryOutpostsProxyListOneOf_0ResultsItemsClientSecret @length(subgraph: "Authentik", max: 255)

"""rest_framework Serializer for OIDC Configuration"""
type OpenIdConnectConfiguration {
  issuer: String!
  authorizationEndpoint: String!
  tokenEndpoint: String!
  userinfoEndpoint: String!
  endSessionEndpoint: String!
  introspectionEndpoint: String!
  jwksUri: String!
  responseTypesSupported: [String]!
  idTokenSigningAlgValuesSupported: [String]!
  subjectTypesSupported: [String]!
  tokenEndpointAuthMethodsSupported: [String]!
  additionalProperties: JSON @resolveRoot(subgraph: "Authentik")
}

enum ProxyMode {
  PROXY
  FORWARD_SINGLE
  FORWARD_DOMAIN
}

union OutpostsProxyRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "ProxyOutpostConfig") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ProxyOutpostConfig | ValidationError | GenericError

union OutpostsRadiusListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedRadiusOutpostConfigList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedRadiusOutpostConfigList | ValidationError | GenericError

type PaginatedRadiusOutpostConfigList {
  pagination: Pagination!
  results: [RadiusOutpostConfig]!
}

"""RadiusProvider Serializer"""
type RadiusOutpostConfig {
  pk: Int!
  name: String!
  applicationSlug: String!
  authFlowSlug: String!
  """
  List of CIDRs (comma-separated) that clients can connect from. A more specific CIDR will match before a looser one. Clients connecting from a non-specified CIDR will be dropped.
  """
  clientNetworks: String
  """Shared secret between clients and server to hash packets."""
  sharedSecret: String
  """
  When enabled, code-based multi-factor authentication can be used by appending a semicolon and the TOTP code to the password. This should only be enabled if all users that will bind to this provider have a TOTP device configured, as otherwise a password may incorrectly be rejected if it contains a semicolon.
  """
  mfaSupport: Boolean
}

union OutpostsRadiusRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "RadiusOutpostConfig") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = RadiusOutpostConfig | ValidationError | GenericError

union OutpostsServiceConnectionsAllListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedServiceConnectionList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedServiceConnectionList | ValidationError | GenericError

type PaginatedServiceConnectionList {
  pagination: Pagination!
  results: [ServiceConnection]!
}

union OutpostsServiceConnectionsAllRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "ServiceConnection") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ServiceConnection | ValidationError | GenericError

union OutpostsServiceConnectionsAllStateRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "ServiceConnectionState") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ServiceConnectionState | ValidationError | GenericError

"""Serializer for Service connection state"""
type ServiceConnectionState {
  healthy: Boolean!
  version: String!
}

union OutpostsServiceConnectionsAllUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union OutpostsServiceConnectionsAllTypesListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "TypeCreate") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = TypeCreate | ValidationError | GenericError

union OutpostsServiceConnectionsDockerListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedDockerServiceConnectionList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedDockerServiceConnectionList | ValidationError | GenericError

type PaginatedDockerServiceConnectionList {
  pagination: Pagination!
  results: [DockerServiceConnection]!
}

"""DockerServiceConnection Serializer"""
type DockerServiceConnection {
  pk: UUID!
  name: String!
  """
  If enabled, use the local connection. Required Docker socket/Kubernetes Integration
  """
  local: Boolean
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  """
  Can be in the format of 'unix://<path>' when connecting to a local docker daemon, or 'https://<hostname>:2376' when connecting to a remote system.
  """
  url: String!
  """
  CA which the endpoint's Certificate is verified against. Can be left empty for no validation.
  """
  tlsVerification: UUID
  """
  Certificate/Key used for authentication. Can be left empty for no authentication.
  """
  tlsAuthentication: UUID
}

union OutpostsServiceConnectionsDockerRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "DockerServiceConnection") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = DockerServiceConnection | ValidationError | GenericError

union OutpostsServiceConnectionsDockerUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union OutpostsServiceConnectionsKubernetesListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedKubernetesServiceConnectionList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedKubernetesServiceConnectionList | ValidationError | GenericError

type PaginatedKubernetesServiceConnectionList {
  pagination: Pagination!
  results: [KubernetesServiceConnection]!
}

"""KubernetesServiceConnection Serializer"""
type KubernetesServiceConnection {
  pk: UUID!
  name: String!
  """
  If enabled, use the local connection. Required Docker socket/Kubernetes Integration
  """
  local: Boolean
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  """
  Paste your kubeconfig here. authentik will automatically use the currently selected context.
  """
  kubeconfig: JSON
  """Verify SSL Certificates of the Kubernetes API endpoint"""
  verifySsl: Boolean
}

union OutpostsServiceConnectionsKubernetesRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "KubernetesServiceConnection") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = KubernetesServiceConnection | ValidationError | GenericError

union OutpostsServiceConnectionsKubernetesUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union PoliciesAllListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedPolicyList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedPolicyList | ValidationError | GenericError

type PaginatedPolicyList {
  pagination: Pagination!
  results: [Policy]!
}

"""Policy Serializer"""
type Policy {
  pk: UUID!
  name: String!
  """
  When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.
  """
  executionLogging: Boolean
  """Get object component so that we know how to edit the object"""
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  """Return objects policy is bound to"""
  boundTo: Int!
  additionalProperties: JSON @resolveRoot(subgraph: "Authentik")
}

union PoliciesAllRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Policy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Policy | ValidationError | GenericError

union PoliciesAllUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union PoliciesAllCacheInfoRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Cache") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Cache | ValidationError | GenericError

union PoliciesAllTypesListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "TypeCreate") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = TypeCreate | ValidationError | GenericError

union PoliciesBindingsListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedPolicyBindingList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedPolicyBindingList | ValidationError | GenericError

type PaginatedPolicyBindingList {
  pagination: Pagination!
  results: [PolicyBinding]!
}

"""PolicyBinding Serializer"""
type PolicyBinding {
  pk: UUID!
  policy: UUID
  group: UUID
  user: Int
  policyObj: Policy!
  groupObj: Group!
  userObj: User!
  target: UUID!
  """Negates the outcome of the policy. Messages are unaffected."""
  negate: Boolean
  enabled: Boolean
  order: Int!
  """Timeout after which Policy execution is terminated."""
  timeout: NonNegativeInt
  """Result if the Policy execution fails."""
  failureResult: Boolean
}

"""Integers that will have a value of 0 or more."""
scalar NonNegativeInt

union PoliciesBindingsRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PolicyBinding") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PolicyBinding | ValidationError | GenericError

union PoliciesBindingsUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union PoliciesDummyListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedDummyPolicyList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedDummyPolicyList | ValidationError | GenericError

type PaginatedDummyPolicyList {
  pagination: Pagination!
  results: [DummyPolicy]!
}

"""Dummy Policy Serializer"""
type DummyPolicy {
  pk: UUID!
  name: String!
  """
  When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.
  """
  executionLogging: Boolean
  """Get object component so that we know how to edit the object"""
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  """Return objects policy is bound to"""
  boundTo: Int!
  result: Boolean
  waitMin: Int
  waitMax: Int
}

union PoliciesDummyRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "DummyPolicy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = DummyPolicy | ValidationError | GenericError

union PoliciesDummyUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union PoliciesEventMatcherListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedEventMatcherPolicyList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedEventMatcherPolicyList | ValidationError | GenericError

type PaginatedEventMatcherPolicyList {
  pagination: Pagination!
  results: [EventMatcherPolicy]!
}

"""Event Matcher Policy Serializer"""
type EventMatcherPolicy {
  pk: UUID!
  name: String!
  """
  When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.
  """
  executionLogging: Boolean
  """Get object component so that we know how to edit the object"""
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  """Return objects policy is bound to"""
  boundTo: Int!
  action: EventActions
  """
  Matches Event's Client IP (strict matching, for network matching use an Expression Policy)
  """
  clientIp: String
  app: AppEnum
  model: ModelEnum
}

enum AppEnum {
  AUTHENTIK_TENANTS @enum(subgraph: "Authentik", value: "\"authentik.tenants\"")
  AUTHENTIK_ADMIN @enum(subgraph: "Authentik", value: "\"authentik.admin\"")
  AUTHENTIK_API @enum(subgraph: "Authentik", value: "\"authentik.api\"")
  AUTHENTIK_CRYPTO @enum(subgraph: "Authentik", value: "\"authentik.crypto\"")
  AUTHENTIK_FLOWS @enum(subgraph: "Authentik", value: "\"authentik.flows\"")
  AUTHENTIK_OUTPOSTS @enum(subgraph: "Authentik", value: "\"authentik.outposts\"")
  AUTHENTIK_POLICIES_DUMMY @enum(subgraph: "Authentik", value: "\"authentik.policies.dummy\"")
  AUTHENTIK_POLICIES_EVENT_MATCHER @enum(subgraph: "Authentik", value: "\"authentik.policies.event_matcher\"")
  AUTHENTIK_POLICIES_EXPIRY @enum(subgraph: "Authentik", value: "\"authentik.policies.expiry\"")
  AUTHENTIK_POLICIES_EXPRESSION @enum(subgraph: "Authentik", value: "\"authentik.policies.expression\"")
  AUTHENTIK_POLICIES_PASSWORD @enum(subgraph: "Authentik", value: "\"authentik.policies.password\"")
  AUTHENTIK_POLICIES_REPUTATION @enum(subgraph: "Authentik", value: "\"authentik.policies.reputation\"")
  AUTHENTIK_POLICIES @enum(subgraph: "Authentik", value: "\"authentik.policies\"")
  AUTHENTIK_PROVIDERS_LDAP @enum(subgraph: "Authentik", value: "\"authentik.providers.ldap\"")
  AUTHENTIK_PROVIDERS_OAUTH2 @enum(subgraph: "Authentik", value: "\"authentik.providers.oauth2\"")
  AUTHENTIK_PROVIDERS_PROXY @enum(subgraph: "Authentik", value: "\"authentik.providers.proxy\"")
  AUTHENTIK_PROVIDERS_RADIUS @enum(subgraph: "Authentik", value: "\"authentik.providers.radius\"")
  AUTHENTIK_PROVIDERS_SAML @enum(subgraph: "Authentik", value: "\"authentik.providers.saml\"")
  AUTHENTIK_PROVIDERS_SCIM @enum(subgraph: "Authentik", value: "\"authentik.providers.scim\"")
  AUTHENTIK_RBAC @enum(subgraph: "Authentik", value: "\"authentik.rbac\"")
  AUTHENTIK_RECOVERY @enum(subgraph: "Authentik", value: "\"authentik.recovery\"")
  AUTHENTIK_SOURCES_LDAP @enum(subgraph: "Authentik", value: "\"authentik.sources.ldap\"")
  AUTHENTIK_SOURCES_OAUTH @enum(subgraph: "Authentik", value: "\"authentik.sources.oauth\"")
  AUTHENTIK_SOURCES_PLEX @enum(subgraph: "Authentik", value: "\"authentik.sources.plex\"")
  AUTHENTIK_SOURCES_SAML @enum(subgraph: "Authentik", value: "\"authentik.sources.saml\"")
  AUTHENTIK_SOURCES_SCIM @enum(subgraph: "Authentik", value: "\"authentik.sources.scim\"")
  AUTHENTIK_STAGES_AUTHENTICATOR @enum(subgraph: "Authentik", value: "\"authentik.stages.authenticator\"")
  AUTHENTIK_STAGES_AUTHENTICATOR_DUO @enum(subgraph: "Authentik", value: "\"authentik.stages.authenticator_duo\"")
  AUTHENTIK_STAGES_AUTHENTICATOR_SMS @enum(subgraph: "Authentik", value: "\"authentik.stages.authenticator_sms\"")
  AUTHENTIK_STAGES_AUTHENTICATOR_STATIC @enum(subgraph: "Authentik", value: "\"authentik.stages.authenticator_static\"")
  AUTHENTIK_STAGES_AUTHENTICATOR_TOTP @enum(subgraph: "Authentik", value: "\"authentik.stages.authenticator_totp\"")
  AUTHENTIK_STAGES_AUTHENTICATOR_VALIDATE @enum(subgraph: "Authentik", value: "\"authentik.stages.authenticator_validate\"")
  AUTHENTIK_STAGES_AUTHENTICATOR_WEBAUTHN @enum(subgraph: "Authentik", value: "\"authentik.stages.authenticator_webauthn\"")
  AUTHENTIK_STAGES_CAPTCHA @enum(subgraph: "Authentik", value: "\"authentik.stages.captcha\"")
  AUTHENTIK_STAGES_CONSENT @enum(subgraph: "Authentik", value: "\"authentik.stages.consent\"")
  AUTHENTIK_STAGES_DENY @enum(subgraph: "Authentik", value: "\"authentik.stages.deny\"")
  AUTHENTIK_STAGES_DUMMY @enum(subgraph: "Authentik", value: "\"authentik.stages.dummy\"")
  AUTHENTIK_STAGES_EMAIL @enum(subgraph: "Authentik", value: "\"authentik.stages.email\"")
  AUTHENTIK_STAGES_IDENTIFICATION @enum(subgraph: "Authentik", value: "\"authentik.stages.identification\"")
  AUTHENTIK_STAGES_INVITATION @enum(subgraph: "Authentik", value: "\"authentik.stages.invitation\"")
  AUTHENTIK_STAGES_PASSWORD @enum(subgraph: "Authentik", value: "\"authentik.stages.password\"")
  AUTHENTIK_STAGES_PROMPT @enum(subgraph: "Authentik", value: "\"authentik.stages.prompt\"")
  AUTHENTIK_STAGES_USER_DELETE @enum(subgraph: "Authentik", value: "\"authentik.stages.user_delete\"")
  AUTHENTIK_STAGES_USER_LOGIN @enum(subgraph: "Authentik", value: "\"authentik.stages.user_login\"")
  AUTHENTIK_STAGES_USER_LOGOUT @enum(subgraph: "Authentik", value: "\"authentik.stages.user_logout\"")
  AUTHENTIK_STAGES_USER_WRITE @enum(subgraph: "Authentik", value: "\"authentik.stages.user_write\"")
  AUTHENTIK_BRANDS @enum(subgraph: "Authentik", value: "\"authentik.brands\"")
  AUTHENTIK_BLUEPRINTS @enum(subgraph: "Authentik", value: "\"authentik.blueprints\"")
  AUTHENTIK_CORE @enum(subgraph: "Authentik", value: "\"authentik.core\"")
  AUTHENTIK_ENTERPRISE @enum(subgraph: "Authentik", value: "\"authentik.enterprise\"")
  AUTHENTIK_ENTERPRISE_AUDIT @enum(subgraph: "Authentik", value: "\"authentik.enterprise.audit\"")
  AUTHENTIK_ENTERPRISE_PROVIDERS_RAC @enum(subgraph: "Authentik", value: "\"authentik.enterprise.providers.rac\"")
  AUTHENTIK_ENTERPRISE_STAGES_SOURCE @enum(subgraph: "Authentik", value: "\"authentik.enterprise.stages.source\"")
  AUTHENTIK_EVENTS @enum(subgraph: "Authentik", value: "\"authentik.events\"")
}

enum ModelEnum {
  AUTHENTIK_TENANTS_DOMAIN @enum(subgraph: "Authentik", value: "\"authentik_tenants.domain\"")
  AUTHENTIK_CRYPTO_CERTIFICATEKEYPAIR @enum(subgraph: "Authentik", value: "\"authentik_crypto.certificatekeypair\"")
  AUTHENTIK_FLOWS_FLOW @enum(subgraph: "Authentik", value: "\"authentik_flows.flow\"")
  AUTHENTIK_FLOWS_FLOWSTAGEBINDING @enum(subgraph: "Authentik", value: "\"authentik_flows.flowstagebinding\"")
  AUTHENTIK_OUTPOSTS_DOCKERSERVICECONNECTION @enum(subgraph: "Authentik", value: "\"authentik_outposts.dockerserviceconnection\"")
  AUTHENTIK_OUTPOSTS_KUBERNETESSERVICECONNECTION @enum(subgraph: "Authentik", value: "\"authentik_outposts.kubernetesserviceconnection\"")
  AUTHENTIK_OUTPOSTS_OUTPOST @enum(subgraph: "Authentik", value: "\"authentik_outposts.outpost\"")
  AUTHENTIK_POLICIES_DUMMY_DUMMYPOLICY @enum(subgraph: "Authentik", value: "\"authentik_policies_dummy.dummypolicy\"")
  AUTHENTIK_POLICIES_EVENT_MATCHER_EVENTMATCHERPOLICY @enum(subgraph: "Authentik", value: "\"authentik_policies_event_matcher.eventmatcherpolicy\"")
  AUTHENTIK_POLICIES_EXPIRY_PASSWORDEXPIRYPOLICY @enum(subgraph: "Authentik", value: "\"authentik_policies_expiry.passwordexpirypolicy\"")
  AUTHENTIK_POLICIES_EXPRESSION_EXPRESSIONPOLICY @enum(subgraph: "Authentik", value: "\"authentik_policies_expression.expressionpolicy\"")
  AUTHENTIK_POLICIES_PASSWORD_PASSWORDPOLICY @enum(subgraph: "Authentik", value: "\"authentik_policies_password.passwordpolicy\"")
  AUTHENTIK_POLICIES_REPUTATION_REPUTATIONPOLICY @enum(subgraph: "Authentik", value: "\"authentik_policies_reputation.reputationpolicy\"")
  AUTHENTIK_POLICIES_POLICYBINDING @enum(subgraph: "Authentik", value: "\"authentik_policies.policybinding\"")
  AUTHENTIK_PROVIDERS_LDAP_LDAPPROVIDER @enum(subgraph: "Authentik", value: "\"authentik_providers_ldap.ldapprovider\"")
  AUTHENTIK_PROVIDERS_OAUTH2_SCOPEMAPPING @enum(subgraph: "Authentik", value: "\"authentik_providers_oauth2.scopemapping\"")
  AUTHENTIK_PROVIDERS_OAUTH2_OAUTH2PROVIDER @enum(subgraph: "Authentik", value: "\"authentik_providers_oauth2.oauth2provider\"")
  AUTHENTIK_PROVIDERS_PROXY_PROXYPROVIDER @enum(subgraph: "Authentik", value: "\"authentik_providers_proxy.proxyprovider\"")
  AUTHENTIK_PROVIDERS_RADIUS_RADIUSPROVIDER @enum(subgraph: "Authentik", value: "\"authentik_providers_radius.radiusprovider\"")
  AUTHENTIK_PROVIDERS_SAML_SAMLPROVIDER @enum(subgraph: "Authentik", value: "\"authentik_providers_saml.samlprovider\"")
  AUTHENTIK_PROVIDERS_SAML_SAMLPROPERTYMAPPING @enum(subgraph: "Authentik", value: "\"authentik_providers_saml.samlpropertymapping\"")
  AUTHENTIK_PROVIDERS_SCIM_SCIMPROVIDER @enum(subgraph: "Authentik", value: "\"authentik_providers_scim.scimprovider\"")
  AUTHENTIK_PROVIDERS_SCIM_SCIMMAPPING @enum(subgraph: "Authentik", value: "\"authentik_providers_scim.scimmapping\"")
  AUTHENTIK_RBAC_ROLE @enum(subgraph: "Authentik", value: "\"authentik_rbac.role\"")
  AUTHENTIK_SOURCES_LDAP_LDAPSOURCE @enum(subgraph: "Authentik", value: "\"authentik_sources_ldap.ldapsource\"")
  AUTHENTIK_SOURCES_LDAP_LDAPPROPERTYMAPPING @enum(subgraph: "Authentik", value: "\"authentik_sources_ldap.ldappropertymapping\"")
  AUTHENTIK_SOURCES_OAUTH_OAUTHSOURCE @enum(subgraph: "Authentik", value: "\"authentik_sources_oauth.oauthsource\"")
  AUTHENTIK_SOURCES_OAUTH_USEROAUTHSOURCECONNECTION @enum(subgraph: "Authentik", value: "\"authentik_sources_oauth.useroauthsourceconnection\"")
  AUTHENTIK_SOURCES_PLEX_PLEXSOURCE @enum(subgraph: "Authentik", value: "\"authentik_sources_plex.plexsource\"")
  AUTHENTIK_SOURCES_PLEX_PLEXSOURCECONNECTION @enum(subgraph: "Authentik", value: "\"authentik_sources_plex.plexsourceconnection\"")
  AUTHENTIK_SOURCES_SAML_SAMLSOURCE @enum(subgraph: "Authentik", value: "\"authentik_sources_saml.samlsource\"")
  AUTHENTIK_SOURCES_SAML_USERSAMLSOURCECONNECTION @enum(subgraph: "Authentik", value: "\"authentik_sources_saml.usersamlsourceconnection\"")
  AUTHENTIK_SOURCES_SCIM_SCIMSOURCE @enum(subgraph: "Authentik", value: "\"authentik_sources_scim.scimsource\"")
  AUTHENTIK_STAGES_AUTHENTICATOR_DUO_AUTHENTICATORDUOSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_authenticator_duo.authenticatorduostage\"")
  AUTHENTIK_STAGES_AUTHENTICATOR_DUO_DUODEVICE @enum(subgraph: "Authentik", value: "\"authentik_stages_authenticator_duo.duodevice\"")
  AUTHENTIK_STAGES_AUTHENTICATOR_SMS_AUTHENTICATORSMSSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_authenticator_sms.authenticatorsmsstage\"")
  AUTHENTIK_STAGES_AUTHENTICATOR_SMS_SMSDEVICE @enum(subgraph: "Authentik", value: "\"authentik_stages_authenticator_sms.smsdevice\"")
  AUTHENTIK_STAGES_AUTHENTICATOR_STATIC_AUTHENTICATORSTATICSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_authenticator_static.authenticatorstaticstage\"")
  AUTHENTIK_STAGES_AUTHENTICATOR_STATIC_STATICDEVICE @enum(subgraph: "Authentik", value: "\"authentik_stages_authenticator_static.staticdevice\"")
  AUTHENTIK_STAGES_AUTHENTICATOR_TOTP_AUTHENTICATORTOTPSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_authenticator_totp.authenticatortotpstage\"")
  AUTHENTIK_STAGES_AUTHENTICATOR_TOTP_TOTPDEVICE @enum(subgraph: "Authentik", value: "\"authentik_stages_authenticator_totp.totpdevice\"")
  AUTHENTIK_STAGES_AUTHENTICATOR_VALIDATE_AUTHENTICATORVALIDATESTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_authenticator_validate.authenticatorvalidatestage\"")
  AUTHENTIK_STAGES_AUTHENTICATOR_WEBAUTHN_AUTHENTICATORWEBAUTHNSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_authenticator_webauthn.authenticatorwebauthnstage\"")
  AUTHENTIK_STAGES_AUTHENTICATOR_WEBAUTHN_WEBAUTHNDEVICE @enum(subgraph: "Authentik", value: "\"authentik_stages_authenticator_webauthn.webauthndevice\"")
  AUTHENTIK_STAGES_CAPTCHA_CAPTCHASTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_captcha.captchastage\"")
  AUTHENTIK_STAGES_CONSENT_CONSENTSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_consent.consentstage\"")
  AUTHENTIK_STAGES_CONSENT_USERCONSENT @enum(subgraph: "Authentik", value: "\"authentik_stages_consent.userconsent\"")
  AUTHENTIK_STAGES_DENY_DENYSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_deny.denystage\"")
  AUTHENTIK_STAGES_DUMMY_DUMMYSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_dummy.dummystage\"")
  AUTHENTIK_STAGES_EMAIL_EMAILSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_email.emailstage\"")
  AUTHENTIK_STAGES_IDENTIFICATION_IDENTIFICATIONSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_identification.identificationstage\"")
  AUTHENTIK_STAGES_INVITATION_INVITATIONSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_invitation.invitationstage\"")
  AUTHENTIK_STAGES_INVITATION_INVITATION @enum(subgraph: "Authentik", value: "\"authentik_stages_invitation.invitation\"")
  AUTHENTIK_STAGES_PASSWORD_PASSWORDSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_password.passwordstage\"")
  AUTHENTIK_STAGES_PROMPT_PROMPT @enum(subgraph: "Authentik", value: "\"authentik_stages_prompt.prompt\"")
  AUTHENTIK_STAGES_PROMPT_PROMPTSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_prompt.promptstage\"")
  AUTHENTIK_STAGES_USER_DELETE_USERDELETESTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_user_delete.userdeletestage\"")
  AUTHENTIK_STAGES_USER_LOGIN_USERLOGINSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_user_login.userloginstage\"")
  AUTHENTIK_STAGES_USER_LOGOUT_USERLOGOUTSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_user_logout.userlogoutstage\"")
  AUTHENTIK_STAGES_USER_WRITE_USERWRITESTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_user_write.userwritestage\"")
  AUTHENTIK_BRANDS_BRAND @enum(subgraph: "Authentik", value: "\"authentik_brands.brand\"")
  AUTHENTIK_BLUEPRINTS_BLUEPRINTINSTANCE @enum(subgraph: "Authentik", value: "\"authentik_blueprints.blueprintinstance\"")
  AUTHENTIK_CORE_GROUP @enum(subgraph: "Authentik", value: "\"authentik_core.group\"")
  AUTHENTIK_CORE_USER @enum(subgraph: "Authentik", value: "\"authentik_core.user\"")
  AUTHENTIK_CORE_APPLICATION @enum(subgraph: "Authentik", value: "\"authentik_core.application\"")
  AUTHENTIK_CORE_TOKEN @enum(subgraph: "Authentik", value: "\"authentik_core.token\"")
  AUTHENTIK_ENTERPRISE_LICENSE @enum(subgraph: "Authentik", value: "\"authentik_enterprise.license\"")
  AUTHENTIK_PROVIDERS_RAC_RACPROVIDER @enum(subgraph: "Authentik", value: "\"authentik_providers_rac.racprovider\"")
  AUTHENTIK_PROVIDERS_RAC_ENDPOINT @enum(subgraph: "Authentik", value: "\"authentik_providers_rac.endpoint\"")
  AUTHENTIK_PROVIDERS_RAC_RACPROPERTYMAPPING @enum(subgraph: "Authentik", value: "\"authentik_providers_rac.racpropertymapping\"")
  AUTHENTIK_STAGES_SOURCE_SOURCESTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_source.sourcestage\"")
  AUTHENTIK_EVENTS_EVENT @enum(subgraph: "Authentik", value: "\"authentik_events.event\"")
  AUTHENTIK_EVENTS_NOTIFICATIONTRANSPORT @enum(subgraph: "Authentik", value: "\"authentik_events.notificationtransport\"")
  AUTHENTIK_EVENTS_NOTIFICATION @enum(subgraph: "Authentik", value: "\"authentik_events.notification\"")
  AUTHENTIK_EVENTS_NOTIFICATIONRULE @enum(subgraph: "Authentik", value: "\"authentik_events.notificationrule\"")
  AUTHENTIK_EVENTS_NOTIFICATIONWEBHOOKMAPPING @enum(subgraph: "Authentik", value: "\"authentik_events.notificationwebhookmapping\"")
}

"""
Match created events with this action type. When left empty, all action types will be matched.
"""
enum QueryInputPoliciesEventMatcherListAction {
  AUTHORIZE_APPLICATION
  CONFIGURATION_ERROR
  CUSTOM_
  EMAIL_SENT
  FLOW_EXECUTION
  IMPERSONATION_ENDED
  IMPERSONATION_STARTED
  INVITATION_USED
  LOGIN
  LOGIN_FAILED
  LOGOUT
  MODEL_CREATED
  MODEL_DELETED
  MODEL_UPDATED
  PASSWORD_SET
  POLICY_EXCEPTION
  POLICY_EXECUTION
  PROPERTY_MAPPING_EXCEPTION
  SECRET_ROTATE
  SECRET_VIEW
  SOURCE_LINKED
  SUSPICIOUS_REQUEST
  SYSTEM_EXCEPTION
  SYSTEM_TASK_EXCEPTION
  SYSTEM_TASK_EXECUTION
  UPDATE_AVAILABLE
  USER_WRITE
}

union PoliciesEventMatcherRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "EventMatcherPolicy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = EventMatcherPolicy | ValidationError | GenericError

union PoliciesEventMatcherUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union PoliciesExpressionListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedExpressionPolicyList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedExpressionPolicyList | ValidationError | GenericError

type PaginatedExpressionPolicyList {
  pagination: Pagination!
  results: [ExpressionPolicy]!
}

"""Group Membership Policy Serializer"""
type ExpressionPolicy {
  pk: UUID!
  name: String!
  """
  When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.
  """
  executionLogging: Boolean
  """Get object component so that we know how to edit the object"""
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  """Return objects policy is bound to"""
  boundTo: Int!
  expression: String!
}

union PoliciesExpressionRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "ExpressionPolicy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ExpressionPolicy | ValidationError | GenericError

union PoliciesExpressionUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union PoliciesPasswordListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedPasswordPolicyList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedPasswordPolicyList | ValidationError | GenericError

type PaginatedPasswordPolicyList {
  pagination: Pagination!
  results: [PasswordPolicy]!
}

"""Password Policy Serializer"""
type PasswordPolicy {
  pk: UUID!
  name: String!
  """
  When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.
  """
  executionLogging: Boolean
  """Get object component so that we know how to edit the object"""
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  """Return objects policy is bound to"""
  boundTo: Int!
  """Field key to check, field keys defined in Prompt stages are available."""
  passwordField: String
  amountDigits: NonNegativeInt
  amountUppercase: NonNegativeInt
  amountLowercase: NonNegativeInt
  amountSymbols: NonNegativeInt
  lengthMin: NonNegativeInt
  symbolCharset: String
  errorMessage: String
  checkStaticRules: Boolean
  checkHaveIBeenPwned: Boolean
  checkZxcvbn: Boolean
  """How many times the password hash is allowed to be on haveibeenpwned"""
  hibpAllowedCount: NonNegativeInt
  """
  If the zxcvbn score is equal or less than this value, the policy will fail.
  """
  zxcvbnScoreThreshold: NonNegativeInt
}

union PoliciesPasswordRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PasswordPolicy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PasswordPolicy | ValidationError | GenericError

union PoliciesPasswordUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union PoliciesPasswordExpiryListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedPasswordExpiryPolicyList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedPasswordExpiryPolicyList | ValidationError | GenericError

type PaginatedPasswordExpiryPolicyList {
  pagination: Pagination!
  results: [PasswordExpiryPolicy]!
}

"""Password Expiry Policy Serializer"""
type PasswordExpiryPolicy {
  pk: UUID!
  name: String!
  """
  When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.
  """
  executionLogging: Boolean
  """Get object component so that we know how to edit the object"""
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  """Return objects policy is bound to"""
  boundTo: Int!
  days: Int!
  denyOnly: Boolean
}

union PoliciesPasswordExpiryRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PasswordExpiryPolicy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PasswordExpiryPolicy | ValidationError | GenericError

union PoliciesPasswordExpiryUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union PoliciesReputationListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedReputationPolicyList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedReputationPolicyList | ValidationError | GenericError

type PaginatedReputationPolicyList {
  pagination: Pagination!
  results: [ReputationPolicy]!
}

"""Reputation Policy Serializer"""
type ReputationPolicy {
  pk: UUID!
  name: String!
  """
  When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.
  """
  executionLogging: Boolean
  """Get object component so that we know how to edit the object"""
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  """Return objects policy is bound to"""
  boundTo: Int!
  checkIp: Boolean
  checkUsername: Boolean
  threshold: Int
}

union PoliciesReputationRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "ReputationPolicy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ReputationPolicy | ValidationError | GenericError

union PoliciesReputationUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union PoliciesReputationScoresListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedReputationList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedReputationList | ValidationError | GenericError

type PaginatedReputationList {
  pagination: Pagination!
  results: [Reputation]!
}

"""Reputation Serializer"""
type Reputation {
  pk: UUID
  identifier: String!
  ip: String!
  ipGeoData: JSON
  ipAsnData: JSON
  score: BigInt
  updated: DateTime!
}

"""
The `BigInt` scalar type represents non-fractional signed whole numeric values.
"""
scalar BigInt

union PoliciesReputationScoresRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Reputation") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Reputation | ValidationError | GenericError

union PoliciesReputationScoresUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union PropertymappingsAllListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedPropertyMappingList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedPropertyMappingList | ValidationError | GenericError

type PaginatedPropertyMappingList {
  pagination: Pagination!
  results: [PropertyMapping]!
}

"""PropertyMapping Serializer"""
type PropertyMapping {
  pk: UUID!
  """
  Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.
  """
  managed: String
  name: String!
  expression: String!
  """Get object's component so that we know how to edit the object"""
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
}

union PropertymappingsAllRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PropertyMapping") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PropertyMapping | ValidationError | GenericError

union PropertymappingsAllUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union PropertymappingsAllTypesListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "TypeCreate") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = TypeCreate | ValidationError | GenericError

union PropertymappingsLdapListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedLDAPPropertyMappingList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedLdapPropertyMappingList | ValidationError | GenericError

type PaginatedLdapPropertyMappingList {
  pagination: Pagination!
  results: [LdapPropertyMapping]!
}

"""LDAP PropertyMapping Serializer"""
type LdapPropertyMapping {
  pk: UUID!
  """
  Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.
  """
  managed: String
  name: String!
  expression: String!
  """Get object's component so that we know how to edit the object"""
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  objectField: String!
}

union PropertymappingsLdapRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "LDAPPropertyMapping") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = LdapPropertyMapping | ValidationError | GenericError

union PropertymappingsLdapUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union PropertymappingsNotificationListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedNotificationWebhookMappingList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedNotificationWebhookMappingList | ValidationError | GenericError

type PaginatedNotificationWebhookMappingList {
  pagination: Pagination!
  results: [NotificationWebhookMapping]!
}

"""NotificationWebhookMapping Serializer"""
type NotificationWebhookMapping {
  pk: UUID!
  name: String!
  expression: String!
}

union PropertymappingsNotificationRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "NotificationWebhookMapping") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = NotificationWebhookMapping | ValidationError | GenericError

union PropertymappingsNotificationUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union PropertymappingsRacListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedRACPropertyMappingList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedRacPropertyMappingList | ValidationError | GenericError

type PaginatedRacPropertyMappingList {
  pagination: Pagination!
  results: [RacPropertyMapping]!
}

"""RACPropertyMapping Serializer"""
type RacPropertyMapping {
  pk: UUID!
  """
  Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.
  """
  managed: String
  name: String!
  expression: String
  """Get object's component so that we know how to edit the object"""
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  staticSettings: JSON!
}

union PropertymappingsRacRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "RACPropertyMapping") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = RacPropertyMapping | ValidationError | GenericError

union PropertymappingsRacUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union PropertymappingsSamlListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedSAMLPropertyMappingList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedSamlPropertyMappingList | ValidationError | GenericError

type PaginatedSamlPropertyMappingList {
  pagination: Pagination!
  results: [SamlPropertyMapping]!
}

"""SAMLPropertyMapping Serializer"""
type SamlPropertyMapping {
  pk: UUID!
  """
  Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.
  """
  managed: String
  name: String!
  expression: String!
  """Get object's component so that we know how to edit the object"""
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  samlName: String!
  friendlyName: String
}

union PropertymappingsSamlRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "SAMLPropertyMapping") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = SamlPropertyMapping | ValidationError | GenericError

union PropertymappingsSamlUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union PropertymappingsScimListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedSCIMMappingList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedScimMappingList | ValidationError | GenericError

type PaginatedScimMappingList {
  pagination: Pagination!
  results: [ScimMapping]!
}

"""SCIMMapping Serializer"""
type ScimMapping {
  pk: UUID!
  """
  Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.
  """
  managed: String
  name: String!
  expression: String!
  """Get object's component so that we know how to edit the object"""
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
}

union PropertymappingsScimRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "SCIMMapping") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ScimMapping | ValidationError | GenericError

union PropertymappingsScimUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union PropertymappingsScopeListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedScopeMappingList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedScopeMappingList | ValidationError | GenericError

type PaginatedScopeMappingList {
  pagination: Pagination!
  results: [ScopeMapping]!
}

"""ScopeMapping Serializer"""
type ScopeMapping {
  pk: UUID!
  """
  Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.
  """
  managed: String
  name: String!
  expression: String!
  """Get object's component so that we know how to edit the object"""
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  """Scope name requested by the client"""
  scopeName: String!
  """
  Description shown to the user when consenting. If left empty, the user won't be informed.
  """
  description: String
}

union PropertymappingsScopeRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "ScopeMapping") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ScopeMapping | ValidationError | GenericError

union PropertymappingsScopeUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union ProvidersAllListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedProviderList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedProviderList | ValidationError | GenericError

type PaginatedProviderList {
  pagination: Pagination!
  results: [Provider]!
}

union ProvidersAllRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Provider") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Provider | ValidationError | GenericError

union ProvidersAllUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union ProvidersAllTypesListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "TypeCreate") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = TypeCreate | ValidationError | GenericError

union ProvidersLdapListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedLDAPProviderList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedLdapProviderList | ValidationError | GenericError

type PaginatedLdapProviderList {
  pagination: Pagination!
  results: [LdapProvider]!
}

"""LDAPProvider Serializer"""
type LdapProvider {
  pk: Int!
  name: String!
  """
  Flow used for authentication when the associated application is accessed by an un-authenticated user.
  """
  authenticationFlow: UUID
  """Flow used when authorizing this provider."""
  authorizationFlow: UUID!
  propertyMappings: [UUID]
  """Get object component so that we know how to edit the object"""
  component: String!
  """Internal application name, used in URLs."""
  assignedApplicationSlug: String!
  """Application's display Name."""
  assignedApplicationName: String!
  """Internal application name, used in URLs."""
  assignedBackchannelApplicationSlug: String!
  """Application's display Name."""
  assignedBackchannelApplicationName: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  """DN under which objects are accessible."""
  baseDn: String
  """
  Users in this group can do search queries. If not set, every user can execute search queries.
  """
  searchGroup: UUID
  certificate: UUID
  tlsServerName: String
  """
  The start for uidNumbers, this number is added to the user.pk to make sure that the numbers aren't too low for POSIX users. Default is 2000 to ensure that we don't collide with local users uidNumber
  """
  uidStartNumber: Int
  """
  The start for gidNumbers, this number is added to a number generated from the group.pk to make sure that the numbers aren't too low for POSIX groups. Default is 4000 to ensure that we don't collide with local groups or users primary groups gidNumber
  """
  gidStartNumber: Int
  outpostSet: [String]!
  searchMode: LdapapiAccessMode
  bindMode: LdapapiAccessMode
  """
  When enabled, code-based multi-factor authentication can be used by appending a semicolon and the TOTP code to the password. This should only be enabled if all users that will bind to this provider have a TOTP device configured, as otherwise a password may incorrectly be rejected if it contains a semicolon.
  """
  mfaSupport: Boolean
}

union ProvidersLdapRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "LDAPProvider") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = LdapProvider | ValidationError | GenericError

union ProvidersLdapUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union ProvidersOauth2ListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedOAuth2ProviderList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedOAuth2ProviderList | ValidationError | GenericError

type PaginatedOAuth2ProviderList {
  pagination: Pagination!
  results: [OAuth2Provider]!
}

"""
Confidential clients are capable of maintaining the confidentiality of their credentials. Public clients are incapable
"""
enum QueryInputProvidersOauth2ListClientType {
  CONFIDENTIAL
  PUBLIC
}

"""Configure how the issuer field of the ID Token should be filled."""
enum QueryInputProvidersOauth2ListIssuerMode {
  GLOBAL
  PER_PROVIDER
}

"""
Configure what data should be used as unique User Identifier. For most cases, the default should be fine.
"""
enum QueryInputProvidersOauth2ListSubMode {
  HASHED_USER_ID
  USER_EMAIL
  USER_ID
  USER_UPN
  USER_USERNAME
  USER_UUID
}

union ProvidersOauth2RetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "OAuth2Provider") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = OAuth2Provider | ValidationError | GenericError

union ProvidersOauth2PreviewUserRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PropertyMappingPreview") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PropertyMappingPreview | GenericError

"""
Preview how the current user is mapped via the property mappings selected in a provider
"""
type PropertyMappingPreview {
  preview: JSON!
}

union ProvidersOauth2SetupUrlsRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "OAuth2ProviderSetupURLs") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = OAuth2ProviderSetupUrLs | ValidationError | GenericError

"""OAuth2 Provider Metadata serializer"""
type OAuth2ProviderSetupUrLs {
  issuer: String!
  authorize: String!
  token: String!
  userInfo: String!
  providerInfo: String!
  logout: String!
  jwks: String!
}

union ProvidersOauth2UsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union ProvidersProxyListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedProxyProviderList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedProxyProviderList | ValidationError | GenericError

type PaginatedProxyProviderList {
  pagination: Pagination!
  results: [ProxyProvider]!
}

"""ProxyProvider Serializer"""
type ProxyProvider {
  pk: Int!
  name: String!
  """
  Flow used for authentication when the associated application is accessed by an un-authenticated user.
  """
  authenticationFlow: UUID
  """Flow used when authorizing this provider."""
  authorizationFlow: UUID!
  propertyMappings: [UUID]
  """Get object component so that we know how to edit the object"""
  component: String!
  """Internal application name, used in URLs."""
  assignedApplicationSlug: String!
  """Application's display Name."""
  assignedApplicationName: String!
  """Internal application name, used in URLs."""
  assignedBackchannelApplicationSlug: String!
  """Application's display Name."""
  assignedBackchannelApplicationName: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  clientId: String!
  internalHost: URL
  externalHost: URL!
  """Validate SSL Certificates of upstream servers"""
  internalHostSslValidation: Boolean
  certificate: UUID
  """
  Regular expressions for which authentication is not required. Each new line is interpreted as a new Regular Expression.
  """
  skipPathRegex: String
  """
  Set a custom HTTP-Basic Authentication header based on values from authentik.
  """
  basicAuthEnabled: Boolean
  """
  User/Group Attribute used for the password part of the HTTP-Basic Header.
  """
  basicAuthPasswordAttribute: String
  """
  User/Group Attribute used for the user part of the HTTP-Basic Header. If not set, the user's Email address is used.
  """
  basicAuthUserAttribute: String
  mode: ProxyMode
  """
  When enabled, this provider will intercept the authorization header and authenticate requests based on its value.
  """
  interceptHeaderAuth: Boolean
  redirectUris: String!
  cookieDomain: String
  jwksSources: [UUID]
  """
  Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).
  """
  accessTokenValidity: String
  """
  Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).
  """
  refreshTokenValidity: String
  outpostSet: [String]!
}

union ProvidersProxyRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "ProxyProvider") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ProxyProvider | ValidationError | GenericError

union ProvidersProxyUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union ProvidersRacListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedRACProviderList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedRacProviderList | ValidationError | GenericError

type PaginatedRacProviderList {
  pagination: Pagination!
  results: [RacProvider]!
}

"""RACProvider Serializer"""
type RacProvider {
  pk: Int!
  name: String!
  """
  Flow used for authentication when the associated application is accessed by an un-authenticated user.
  """
  authenticationFlow: UUID
  """Flow used when authorizing this provider."""
  authorizationFlow: UUID!
  propertyMappings: [UUID]
  """Get object component so that we know how to edit the object"""
  component: String!
  """Internal application name, used in URLs."""
  assignedApplicationSlug: String!
  """Application's display Name."""
  assignedApplicationName: String!
  """Internal application name, used in URLs."""
  assignedBackchannelApplicationSlug: String!
  """Application's display Name."""
  assignedBackchannelApplicationName: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  settings: JSON
  outpostSet: [String]!
  """
  Determines how long a session lasts. Default of 0 means that the sessions lasts until the browser is closed. (Format: hours=-1;minutes=-2;seconds=-3)
  """
  connectionExpiry: String
  """When set to true, connection tokens will be deleted upon disconnect."""
  deleteTokenOnDisconnect: Boolean
  additionalProperties: JSON @resolveRoot(subgraph: "Authentik")
}

union ProvidersRacRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "RACProvider") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = RacProvider | ValidationError | GenericError

union ProvidersRacUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union ProvidersRadiusListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedRadiusProviderList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedRadiusProviderList | ValidationError | GenericError

type PaginatedRadiusProviderList {
  pagination: Pagination!
  results: [RadiusProvider]!
}

"""RadiusProvider Serializer"""
type RadiusProvider {
  pk: Int!
  name: String!
  """
  Flow used for authentication when the associated application is accessed by an un-authenticated user.
  """
  authenticationFlow: UUID
  """Flow used when authorizing this provider."""
  authorizationFlow: UUID!
  propertyMappings: [UUID]
  """Get object component so that we know how to edit the object"""
  component: String!
  """Internal application name, used in URLs."""
  assignedApplicationSlug: String!
  """Application's display Name."""
  assignedApplicationName: String!
  """Internal application name, used in URLs."""
  assignedBackchannelApplicationSlug: String!
  """Application's display Name."""
  assignedBackchannelApplicationName: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  """
  List of CIDRs (comma-separated) that clients can connect from. A more specific CIDR will match before a looser one. Clients connecting from a non-specified CIDR will be dropped.
  """
  clientNetworks: String
  """Shared secret between clients and server to hash packets."""
  sharedSecret: String
  outpostSet: [String]!
  """
  When enabled, code-based multi-factor authentication can be used by appending a semicolon and the TOTP code to the password. This should only be enabled if all users that will bind to this provider have a TOTP device configured, as otherwise a password may incorrectly be rejected if it contains a semicolon.
  """
  mfaSupport: Boolean
}

union ProvidersRadiusRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "RadiusProvider") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = RadiusProvider | ValidationError | GenericError

union ProvidersRadiusUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union ProvidersSamlListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedSAMLProviderList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedSamlProviderList | ValidationError | GenericError

type PaginatedSamlProviderList {
  pagination: Pagination!
  results: [SamlProvider]!
}

"""SAMLProvider Serializer"""
type SamlProvider {
  pk: Int!
  name: String!
  """
  Flow used for authentication when the associated application is accessed by an un-authenticated user.
  """
  authenticationFlow: UUID
  """Flow used when authorizing this provider."""
  authorizationFlow: UUID!
  propertyMappings: [UUID]
  """Get object component so that we know how to edit the object"""
  component: String!
  """Internal application name, used in URLs."""
  assignedApplicationSlug: String!
  """Application's display Name."""
  assignedApplicationName: String!
  """Internal application name, used in URLs."""
  assignedBackchannelApplicationSlug: String!
  """Application's display Name."""
  assignedBackchannelApplicationName: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  acsUrl: URL!
  """
  Value of the audience restriction field of the assertion. When left empty, no audience restriction will be added.
  """
  audience: String
  """Also known as EntityID"""
  issuer: String
  """
  Assertion valid not before current time + this value (Format: hours=-1;minutes=-2;seconds=-3).
  """
  assertionValidNotBefore: String
  """
  Assertion not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).
  """
  assertionValidNotOnOrAfter: String
  """
  Session not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).
  """
  sessionValidNotOnOrAfter: String
  """
  Configure how the NameID value will be created. When left empty, the NameIDPolicy of the incoming request will be considered
  """
  nameIdMapping: UUID
  digestAlgorithm: DigestAlgorithmEnum
  signatureAlgorithm: SignatureAlgorithmEnum
  """Keypair used to sign outgoing Responses going to the Service Provider."""
  signingKp: UUID
  """
  When selected, incoming assertion's Signatures will be validated against this certificate. To allow unsigned Requests, leave on default.
  """
  verificationKp: UUID
  """
  This determines how authentik sends the response back to the Service Provider.
  """
  spBinding: ServiceProviderBinding
  """Default relay_state value for IDP-initiated logins"""
  defaultRelayState: String
  """Get metadata download URL"""
  urlDownloadMetadata: String!
  """Get SSO Post URL"""
  urlSsoPost: String!
  """Get SSO Redirect URL"""
  urlSsoRedirect: String!
  """Get SSO IDP-Initiated URL"""
  urlSsoInit: String!
  """Get SLO POST URL"""
  urlSloPost: String!
  """Get SLO redirect URL"""
  urlSloRedirect: String!
}

enum DigestAlgorithmEnum {
  HTTP___WWW_W3_ORG_2000_09_XMLDSIG_POUND_SHA1 @enum(subgraph: "Authentik", value: "\"http://www.w3.org/2000/09/xmldsig#sha1\"")
  HTTP___WWW_W3_ORG_2001_04_XMLENC_POUND_SHA256 @enum(subgraph: "Authentik", value: "\"http://www.w3.org/2001/04/xmlenc#sha256\"")
  HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_SHA384 @enum(subgraph: "Authentik", value: "\"http://www.w3.org/2001/04/xmldsig-more#sha384\"")
  HTTP___WWW_W3_ORG_2001_04_XMLENC_POUND_SHA512 @enum(subgraph: "Authentik", value: "\"http://www.w3.org/2001/04/xmlenc#sha512\"")
}

enum SignatureAlgorithmEnum {
  HTTP___WWW_W3_ORG_2000_09_XMLDSIG_POUND_RSA_SHA1 @enum(subgraph: "Authentik", value: "\"http://www.w3.org/2000/09/xmldsig#rsa-sha1\"")
  HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_RSA_SHA256 @enum(subgraph: "Authentik", value: "\"http://www.w3.org/2001/04/xmldsig-more#rsa-sha256\"")
  HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_RSA_SHA384 @enum(subgraph: "Authentik", value: "\"http://www.w3.org/2001/04/xmldsig-more#rsa-sha384\"")
  HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_RSA_SHA512 @enum(subgraph: "Authentik", value: "\"http://www.w3.org/2001/04/xmldsig-more#rsa-sha512\"")
  HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_ECDSA_SHA1 @enum(subgraph: "Authentik", value: "\"http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha1\"")
  HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_ECDSA_SHA256 @enum(subgraph: "Authentik", value: "\"http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha256\"")
  HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_ECDSA_SHA384 @enum(subgraph: "Authentik", value: "\"http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha384\"")
  HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_ECDSA_SHA512 @enum(subgraph: "Authentik", value: "\"http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha512\"")
  HTTP___WWW_W3_ORG_2000_09_XMLDSIG_POUND_DSA_SHA1 @enum(subgraph: "Authentik", value: "\"http://www.w3.org/2000/09/xmldsig#dsa-sha1\"")
}

"""
This determines how authentik sends the response back to the Service Provider.
"""
type ServiceProviderBinding {
  spBindingEnum: SpBindingEnum @resolveRoot(subgraph: "Authentik")
}

enum SpBindingEnum {
  REDIRECT
  POST
}

enum QueryInputProvidersSamlListDigestAlgorithm {
  HTTP___WWW_W3_ORG_2000_09_XMLDSIG_POUND_SHA1 @enum(subgraph: "Authentik", value: "\"http://www.w3.org/2000/09/xmldsig#sha1\"")
  HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_SHA384 @enum(subgraph: "Authentik", value: "\"http://www.w3.org/2001/04/xmldsig-more#sha384\"")
  HTTP___WWW_W3_ORG_2001_04_XMLENC_POUND_SHA256 @enum(subgraph: "Authentik", value: "\"http://www.w3.org/2001/04/xmlenc#sha256\"")
  HTTP___WWW_W3_ORG_2001_04_XMLENC_POUND_SHA512 @enum(subgraph: "Authentik", value: "\"http://www.w3.org/2001/04/xmlenc#sha512\"")
}

enum QueryInputProvidersSamlListSignatureAlgorithm {
  HTTP___WWW_W3_ORG_2000_09_XMLDSIG_POUND_DSA_SHA1 @enum(subgraph: "Authentik", value: "\"http://www.w3.org/2000/09/xmldsig#dsa-sha1\"")
  HTTP___WWW_W3_ORG_2000_09_XMLDSIG_POUND_RSA_SHA1 @enum(subgraph: "Authentik", value: "\"http://www.w3.org/2000/09/xmldsig#rsa-sha1\"")
  HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_ECDSA_SHA1 @enum(subgraph: "Authentik", value: "\"http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha1\"")
  HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_ECDSA_SHA256 @enum(subgraph: "Authentik", value: "\"http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha256\"")
  HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_ECDSA_SHA384 @enum(subgraph: "Authentik", value: "\"http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha384\"")
  HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_ECDSA_SHA512 @enum(subgraph: "Authentik", value: "\"http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha512\"")
  HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_RSA_SHA256 @enum(subgraph: "Authentik", value: "\"http://www.w3.org/2001/04/xmldsig-more#rsa-sha256\"")
  HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_RSA_SHA384 @enum(subgraph: "Authentik", value: "\"http://www.w3.org/2001/04/xmldsig-more#rsa-sha384\"")
  HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_RSA_SHA512 @enum(subgraph: "Authentik", value: "\"http://www.w3.org/2001/04/xmldsig-more#rsa-sha512\"")
}

"""
This determines how authentik sends the response back to the Service Provider.
"""
enum QueryInputProvidersSamlListSpBinding {
  POST
  REDIRECT
}

union ProvidersSamlRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "SAMLProvider") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = SamlProvider | ValidationError | GenericError

union ProvidersSamlMetadataRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "SAMLMetadata") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = SamlMetadata | ValidationError | GenericError

"""SAML Provider Metadata serializer"""
type SamlMetadata {
  metadata: String!
  downloadUrl: String!
}

"""Optionally force the metadata to only include one binding."""
enum QueryInputProvidersSamlMetadataRetrieveForceBinding {
  URN_OASIS_NAMES_TC_SAML_2_0_BINDINGS_HTTP_POST @enum(subgraph: "Authentik", value: "\"urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST\"")
  URN_OASIS_NAMES_TC_SAML_2_0_BINDINGS_HTTP_REDIRECT @enum(subgraph: "Authentik", value: "\"urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect\"")
}

union ProvidersSamlPreviewUserRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PropertyMappingPreview") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PropertyMappingPreview | GenericError

union ProvidersSamlUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union ProvidersScimListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedSCIMProviderList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedScimProviderList | ValidationError | GenericError

type PaginatedScimProviderList {
  pagination: Pagination!
  results: [ScimProvider]!
}

"""SCIMProvider Serializer"""
type ScimProvider {
  pk: Int!
  name: String!
  propertyMappings: [UUID]
  """Property mappings used for group creation/updating."""
  propertyMappingsGroup: [UUID]
  """Get object component so that we know how to edit the object"""
  component: String!
  """Internal application name, used in URLs."""
  assignedBackchannelApplicationSlug: String!
  """Application's display Name."""
  assignedBackchannelApplicationName: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  """Base URL to SCIM requests, usually ends in /v2"""
  url: String!
  """Authentication token"""
  token: String!
  excludeUsersServiceAccount: Boolean
  filterGroup: UUID
}

union ProvidersScimRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "SCIMProvider") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ScimProvider | ValidationError | GenericError

union ProvidersScimSyncStatusRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "SCIMSyncStatus") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ScimSyncStatus | ValidationError | GenericError

"""SCIM Provider sync status"""
type ScimSyncStatus {
  isRunning: Boolean!
  tasks: [SystemTask]!
}

union ProvidersScimUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union RacConnectionTokensListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedConnectionTokenList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedConnectionTokenList | ValidationError | GenericError

type PaginatedConnectionTokenList {
  pagination: Pagination!
  results: [ConnectionToken]!
}

"""ConnectionToken Serializer"""
type ConnectionToken {
  pk: UUID
  provider: Int!
  providerObj: RacProvider!
  endpoint: UUID!
  endpointObj: Endpoint!
  user: GroupMember!
}

"""Endpoint Serializer"""
type Endpoint {
  pk: UUID!
  name: String!
  provider: Int!
  providerObj: RacProvider!
  protocol: ProtocolEnum!
  host: String!
  settings: JSON
  propertyMappings: [UUID]
  authMode: AuthModeEnum!
  """
  Build actual launch URL (the provider itself does not have one, just
  individual endpoints)
  """
  launchUrl: String
  maximumConnections: Int
  additionalProperties: JSON @resolveRoot(subgraph: "Authentik")
}

enum ProtocolEnum {
  RDP
  VNC
  SSH
}

enum AuthModeEnum {
  STATIC
  PROMPT
}

union RacConnectionTokensRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "ConnectionToken") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ConnectionToken | ValidationError | GenericError

union RacConnectionTokensUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union RacEndpointsListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedEndpointList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedEndpointList | GenericError

type PaginatedEndpointList {
  pagination: Pagination!
  results: [Endpoint]!
}

union RacEndpointsRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Endpoint") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Endpoint | ValidationError | GenericError

union RacEndpointsUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union RbacPermissionsListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedPermissionList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedPermissionList | ValidationError | GenericError

type PaginatedPermissionList {
  pagination: Pagination!
  results: [Permission]!
}

"""Global permission"""
type Permission {
  id: Int!
  name: QueryRbacPermissionsListOneOf_0ResultsItemsName!
  codename: QueryRbacPermissionsListOneOf_0ResultsItemsCodename!
  model: String!
  appLabel: String!
  """Human-readable app label"""
  appLabelVerbose: String!
  """Human-readable model name"""
  modelVerbose: String!
}

scalar QueryRbacPermissionsListOneOf_0ResultsItemsName @length(subgraph: "Authentik", max: 255)

scalar QueryRbacPermissionsListOneOf_0ResultsItemsCodename @length(subgraph: "Authentik", max: 100)

union RbacPermissionsRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Permission") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Permission | ValidationError | GenericError

union RbacPermissionsAssignedByRolesListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedRoleAssignedObjectPermissionList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedRoleAssignedObjectPermissionList | ValidationError | GenericError

type PaginatedRoleAssignedObjectPermissionList {
  pagination: Pagination!
  results: [RoleAssignedObjectPermission]!
}

"""Roles assigned object permission serializer"""
type RoleAssignedObjectPermission {
  rolePk: String!
  name: String!
  permissions: [RoleObjectPermission]!
}

"""Role-bound object level permission"""
type RoleObjectPermission {
  id: Int!
  codename: String!
  model: String!
  appLabel: String!
  objectPk: String!
  name: String!
}

enum QueryInputRbacPermissionsAssignedByRolesListModel {
  AUTHENTIK_BLUEPRINTS_BLUEPRINTINSTANCE @enum(subgraph: "Authentik", value: "\"authentik_blueprints.blueprintinstance\"")
  AUTHENTIK_BRANDS_BRAND @enum(subgraph: "Authentik", value: "\"authentik_brands.brand\"")
  AUTHENTIK_CORE_APPLICATION @enum(subgraph: "Authentik", value: "\"authentik_core.application\"")
  AUTHENTIK_CORE_GROUP @enum(subgraph: "Authentik", value: "\"authentik_core.group\"")
  AUTHENTIK_CORE_TOKEN @enum(subgraph: "Authentik", value: "\"authentik_core.token\"")
  AUTHENTIK_CORE_USER @enum(subgraph: "Authentik", value: "\"authentik_core.user\"")
  AUTHENTIK_CRYPTO_CERTIFICATEKEYPAIR @enum(subgraph: "Authentik", value: "\"authentik_crypto.certificatekeypair\"")
  AUTHENTIK_ENTERPRISE_LICENSE @enum(subgraph: "Authentik", value: "\"authentik_enterprise.license\"")
  AUTHENTIK_EVENTS_EVENT @enum(subgraph: "Authentik", value: "\"authentik_events.event\"")
  AUTHENTIK_EVENTS_NOTIFICATION @enum(subgraph: "Authentik", value: "\"authentik_events.notification\"")
  AUTHENTIK_EVENTS_NOTIFICATIONRULE @enum(subgraph: "Authentik", value: "\"authentik_events.notificationrule\"")
  AUTHENTIK_EVENTS_NOTIFICATIONTRANSPORT @enum(subgraph: "Authentik", value: "\"authentik_events.notificationtransport\"")
  AUTHENTIK_EVENTS_NOTIFICATIONWEBHOOKMAPPING @enum(subgraph: "Authentik", value: "\"authentik_events.notificationwebhookmapping\"")
  AUTHENTIK_FLOWS_FLOW @enum(subgraph: "Authentik", value: "\"authentik_flows.flow\"")
  AUTHENTIK_FLOWS_FLOWSTAGEBINDING @enum(subgraph: "Authentik", value: "\"authentik_flows.flowstagebinding\"")
  AUTHENTIK_OUTPOSTS_DOCKERSERVICECONNECTION @enum(subgraph: "Authentik", value: "\"authentik_outposts.dockerserviceconnection\"")
  AUTHENTIK_OUTPOSTS_KUBERNETESSERVICECONNECTION @enum(subgraph: "Authentik", value: "\"authentik_outposts.kubernetesserviceconnection\"")
  AUTHENTIK_OUTPOSTS_OUTPOST @enum(subgraph: "Authentik", value: "\"authentik_outposts.outpost\"")
  AUTHENTIK_POLICIES_POLICYBINDING @enum(subgraph: "Authentik", value: "\"authentik_policies.policybinding\"")
  AUTHENTIK_POLICIES_DUMMY_DUMMYPOLICY @enum(subgraph: "Authentik", value: "\"authentik_policies_dummy.dummypolicy\"")
  AUTHENTIK_POLICIES_EVENT_MATCHER_EVENTMATCHERPOLICY @enum(subgraph: "Authentik", value: "\"authentik_policies_event_matcher.eventmatcherpolicy\"")
  AUTHENTIK_POLICIES_EXPIRY_PASSWORDEXPIRYPOLICY @enum(subgraph: "Authentik", value: "\"authentik_policies_expiry.passwordexpirypolicy\"")
  AUTHENTIK_POLICIES_EXPRESSION_EXPRESSIONPOLICY @enum(subgraph: "Authentik", value: "\"authentik_policies_expression.expressionpolicy\"")
  AUTHENTIK_POLICIES_PASSWORD_PASSWORDPOLICY @enum(subgraph: "Authentik", value: "\"authentik_policies_password.passwordpolicy\"")
  AUTHENTIK_POLICIES_REPUTATION_REPUTATIONPOLICY @enum(subgraph: "Authentik", value: "\"authentik_policies_reputation.reputationpolicy\"")
  AUTHENTIK_PROVIDERS_LDAP_LDAPPROVIDER @enum(subgraph: "Authentik", value: "\"authentik_providers_ldap.ldapprovider\"")
  AUTHENTIK_PROVIDERS_OAUTH2_OAUTH2PROVIDER @enum(subgraph: "Authentik", value: "\"authentik_providers_oauth2.oauth2provider\"")
  AUTHENTIK_PROVIDERS_OAUTH2_SCOPEMAPPING @enum(subgraph: "Authentik", value: "\"authentik_providers_oauth2.scopemapping\"")
  AUTHENTIK_PROVIDERS_PROXY_PROXYPROVIDER @enum(subgraph: "Authentik", value: "\"authentik_providers_proxy.proxyprovider\"")
  AUTHENTIK_PROVIDERS_RAC_ENDPOINT @enum(subgraph: "Authentik", value: "\"authentik_providers_rac.endpoint\"")
  AUTHENTIK_PROVIDERS_RAC_RACPROPERTYMAPPING @enum(subgraph: "Authentik", value: "\"authentik_providers_rac.racpropertymapping\"")
  AUTHENTIK_PROVIDERS_RAC_RACPROVIDER @enum(subgraph: "Authentik", value: "\"authentik_providers_rac.racprovider\"")
  AUTHENTIK_PROVIDERS_RADIUS_RADIUSPROVIDER @enum(subgraph: "Authentik", value: "\"authentik_providers_radius.radiusprovider\"")
  AUTHENTIK_PROVIDERS_SAML_SAMLPROPERTYMAPPING @enum(subgraph: "Authentik", value: "\"authentik_providers_saml.samlpropertymapping\"")
  AUTHENTIK_PROVIDERS_SAML_SAMLPROVIDER @enum(subgraph: "Authentik", value: "\"authentik_providers_saml.samlprovider\"")
  AUTHENTIK_PROVIDERS_SCIM_SCIMMAPPING @enum(subgraph: "Authentik", value: "\"authentik_providers_scim.scimmapping\"")
  AUTHENTIK_PROVIDERS_SCIM_SCIMPROVIDER @enum(subgraph: "Authentik", value: "\"authentik_providers_scim.scimprovider\"")
  AUTHENTIK_RBAC_ROLE @enum(subgraph: "Authentik", value: "\"authentik_rbac.role\"")
  AUTHENTIK_SOURCES_LDAP_LDAPPROPERTYMAPPING @enum(subgraph: "Authentik", value: "\"authentik_sources_ldap.ldappropertymapping\"")
  AUTHENTIK_SOURCES_LDAP_LDAPSOURCE @enum(subgraph: "Authentik", value: "\"authentik_sources_ldap.ldapsource\"")
  AUTHENTIK_SOURCES_OAUTH_OAUTHSOURCE @enum(subgraph: "Authentik", value: "\"authentik_sources_oauth.oauthsource\"")
  AUTHENTIK_SOURCES_OAUTH_USEROAUTHSOURCECONNECTION @enum(subgraph: "Authentik", value: "\"authentik_sources_oauth.useroauthsourceconnection\"")
  AUTHENTIK_SOURCES_PLEX_PLEXSOURCE @enum(subgraph: "Authentik", value: "\"authentik_sources_plex.plexsource\"")
  AUTHENTIK_SOURCES_PLEX_PLEXSOURCECONNECTION @enum(subgraph: "Authentik", value: "\"authentik_sources_plex.plexsourceconnection\"")
  AUTHENTIK_SOURCES_SAML_SAMLSOURCE @enum(subgraph: "Authentik", value: "\"authentik_sources_saml.samlsource\"")
  AUTHENTIK_SOURCES_SAML_USERSAMLSOURCECONNECTION @enum(subgraph: "Authentik", value: "\"authentik_sources_saml.usersamlsourceconnection\"")
  AUTHENTIK_SOURCES_SCIM_SCIMSOURCE @enum(subgraph: "Authentik", value: "\"authentik_sources_scim.scimsource\"")
  AUTHENTIK_STAGES_AUTHENTICATOR_DUO_AUTHENTICATORDUOSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_authenticator_duo.authenticatorduostage\"")
  AUTHENTIK_STAGES_AUTHENTICATOR_DUO_DUODEVICE @enum(subgraph: "Authentik", value: "\"authentik_stages_authenticator_duo.duodevice\"")
  AUTHENTIK_STAGES_AUTHENTICATOR_SMS_AUTHENTICATORSMSSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_authenticator_sms.authenticatorsmsstage\"")
  AUTHENTIK_STAGES_AUTHENTICATOR_SMS_SMSDEVICE @enum(subgraph: "Authentik", value: "\"authentik_stages_authenticator_sms.smsdevice\"")
  AUTHENTIK_STAGES_AUTHENTICATOR_STATIC_AUTHENTICATORSTATICSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_authenticator_static.authenticatorstaticstage\"")
  AUTHENTIK_STAGES_AUTHENTICATOR_STATIC_STATICDEVICE @enum(subgraph: "Authentik", value: "\"authentik_stages_authenticator_static.staticdevice\"")
  AUTHENTIK_STAGES_AUTHENTICATOR_TOTP_AUTHENTICATORTOTPSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_authenticator_totp.authenticatortotpstage\"")
  AUTHENTIK_STAGES_AUTHENTICATOR_TOTP_TOTPDEVICE @enum(subgraph: "Authentik", value: "\"authentik_stages_authenticator_totp.totpdevice\"")
  AUTHENTIK_STAGES_AUTHENTICATOR_VALIDATE_AUTHENTICATORVALIDATESTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_authenticator_validate.authenticatorvalidatestage\"")
  AUTHENTIK_STAGES_AUTHENTICATOR_WEBAUTHN_AUTHENTICATORWEBAUTHNSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_authenticator_webauthn.authenticatorwebauthnstage\"")
  AUTHENTIK_STAGES_AUTHENTICATOR_WEBAUTHN_WEBAUTHNDEVICE @enum(subgraph: "Authentik", value: "\"authentik_stages_authenticator_webauthn.webauthndevice\"")
  AUTHENTIK_STAGES_CAPTCHA_CAPTCHASTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_captcha.captchastage\"")
  AUTHENTIK_STAGES_CONSENT_CONSENTSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_consent.consentstage\"")
  AUTHENTIK_STAGES_CONSENT_USERCONSENT @enum(subgraph: "Authentik", value: "\"authentik_stages_consent.userconsent\"")
  AUTHENTIK_STAGES_DENY_DENYSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_deny.denystage\"")
  AUTHENTIK_STAGES_DUMMY_DUMMYSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_dummy.dummystage\"")
  AUTHENTIK_STAGES_EMAIL_EMAILSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_email.emailstage\"")
  AUTHENTIK_STAGES_IDENTIFICATION_IDENTIFICATIONSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_identification.identificationstage\"")
  AUTHENTIK_STAGES_INVITATION_INVITATION @enum(subgraph: "Authentik", value: "\"authentik_stages_invitation.invitation\"")
  AUTHENTIK_STAGES_INVITATION_INVITATIONSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_invitation.invitationstage\"")
  AUTHENTIK_STAGES_PASSWORD_PASSWORDSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_password.passwordstage\"")
  AUTHENTIK_STAGES_PROMPT_PROMPT @enum(subgraph: "Authentik", value: "\"authentik_stages_prompt.prompt\"")
  AUTHENTIK_STAGES_PROMPT_PROMPTSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_prompt.promptstage\"")
  AUTHENTIK_STAGES_SOURCE_SOURCESTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_source.sourcestage\"")
  AUTHENTIK_STAGES_USER_DELETE_USERDELETESTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_user_delete.userdeletestage\"")
  AUTHENTIK_STAGES_USER_LOGIN_USERLOGINSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_user_login.userloginstage\"")
  AUTHENTIK_STAGES_USER_LOGOUT_USERLOGOUTSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_user_logout.userlogoutstage\"")
  AUTHENTIK_STAGES_USER_WRITE_USERWRITESTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_user_write.userwritestage\"")
  AUTHENTIK_TENANTS_DOMAIN @enum(subgraph: "Authentik", value: "\"authentik_tenants.domain\"")
}

union RbacPermissionsAssignedByUsersListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedUserAssignedObjectPermissionList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedUserAssignedObjectPermissionList | ValidationError | GenericError

type PaginatedUserAssignedObjectPermissionList {
  pagination: Pagination!
  results: [UserAssignedObjectPermission]!
}

"""Users assigned object permission serializer"""
type UserAssignedObjectPermission {
  pk: Int!
  username: QueryRbacPermissionsAssignedByUsersListOneOf_0ResultsItemsUsername!
  """User's display name."""
  name: String!
  """
  Designates whether this user should be treated as active. Unselect this instead of deleting accounts.
  """
  isActive: Boolean
  lastLogin: DateTime
  email: EmailAddress
  attributes: JSON
  uid: String!
  permissions: [UserObjectPermission]!
  isSuperuser: Boolean!
}

scalar QueryRbacPermissionsAssignedByUsersListOneOf_0ResultsItemsUsername @regexp(subgraph: "Authentik", pattern: "^[\\w.@+-]+$") @typescript(subgraph: "Authentik", type: "string")

"""User-bound object level permission"""
type UserObjectPermission {
  id: Int!
  codename: String!
  model: String!
  appLabel: String!
  objectPk: String!
  name: String!
}

enum QueryInputRbacPermissionsAssignedByUsersListModel {
  AUTHENTIK_BLUEPRINTS_BLUEPRINTINSTANCE @enum(subgraph: "Authentik", value: "\"authentik_blueprints.blueprintinstance\"")
  AUTHENTIK_BRANDS_BRAND @enum(subgraph: "Authentik", value: "\"authentik_brands.brand\"")
  AUTHENTIK_CORE_APPLICATION @enum(subgraph: "Authentik", value: "\"authentik_core.application\"")
  AUTHENTIK_CORE_GROUP @enum(subgraph: "Authentik", value: "\"authentik_core.group\"")
  AUTHENTIK_CORE_TOKEN @enum(subgraph: "Authentik", value: "\"authentik_core.token\"")
  AUTHENTIK_CORE_USER @enum(subgraph: "Authentik", value: "\"authentik_core.user\"")
  AUTHENTIK_CRYPTO_CERTIFICATEKEYPAIR @enum(subgraph: "Authentik", value: "\"authentik_crypto.certificatekeypair\"")
  AUTHENTIK_ENTERPRISE_LICENSE @enum(subgraph: "Authentik", value: "\"authentik_enterprise.license\"")
  AUTHENTIK_EVENTS_EVENT @enum(subgraph: "Authentik", value: "\"authentik_events.event\"")
  AUTHENTIK_EVENTS_NOTIFICATION @enum(subgraph: "Authentik", value: "\"authentik_events.notification\"")
  AUTHENTIK_EVENTS_NOTIFICATIONRULE @enum(subgraph: "Authentik", value: "\"authentik_events.notificationrule\"")
  AUTHENTIK_EVENTS_NOTIFICATIONTRANSPORT @enum(subgraph: "Authentik", value: "\"authentik_events.notificationtransport\"")
  AUTHENTIK_EVENTS_NOTIFICATIONWEBHOOKMAPPING @enum(subgraph: "Authentik", value: "\"authentik_events.notificationwebhookmapping\"")
  AUTHENTIK_FLOWS_FLOW @enum(subgraph: "Authentik", value: "\"authentik_flows.flow\"")
  AUTHENTIK_FLOWS_FLOWSTAGEBINDING @enum(subgraph: "Authentik", value: "\"authentik_flows.flowstagebinding\"")
  AUTHENTIK_OUTPOSTS_DOCKERSERVICECONNECTION @enum(subgraph: "Authentik", value: "\"authentik_outposts.dockerserviceconnection\"")
  AUTHENTIK_OUTPOSTS_KUBERNETESSERVICECONNECTION @enum(subgraph: "Authentik", value: "\"authentik_outposts.kubernetesserviceconnection\"")
  AUTHENTIK_OUTPOSTS_OUTPOST @enum(subgraph: "Authentik", value: "\"authentik_outposts.outpost\"")
  AUTHENTIK_POLICIES_POLICYBINDING @enum(subgraph: "Authentik", value: "\"authentik_policies.policybinding\"")
  AUTHENTIK_POLICIES_DUMMY_DUMMYPOLICY @enum(subgraph: "Authentik", value: "\"authentik_policies_dummy.dummypolicy\"")
  AUTHENTIK_POLICIES_EVENT_MATCHER_EVENTMATCHERPOLICY @enum(subgraph: "Authentik", value: "\"authentik_policies_event_matcher.eventmatcherpolicy\"")
  AUTHENTIK_POLICIES_EXPIRY_PASSWORDEXPIRYPOLICY @enum(subgraph: "Authentik", value: "\"authentik_policies_expiry.passwordexpirypolicy\"")
  AUTHENTIK_POLICIES_EXPRESSION_EXPRESSIONPOLICY @enum(subgraph: "Authentik", value: "\"authentik_policies_expression.expressionpolicy\"")
  AUTHENTIK_POLICIES_PASSWORD_PASSWORDPOLICY @enum(subgraph: "Authentik", value: "\"authentik_policies_password.passwordpolicy\"")
  AUTHENTIK_POLICIES_REPUTATION_REPUTATIONPOLICY @enum(subgraph: "Authentik", value: "\"authentik_policies_reputation.reputationpolicy\"")
  AUTHENTIK_PROVIDERS_LDAP_LDAPPROVIDER @enum(subgraph: "Authentik", value: "\"authentik_providers_ldap.ldapprovider\"")
  AUTHENTIK_PROVIDERS_OAUTH2_OAUTH2PROVIDER @enum(subgraph: "Authentik", value: "\"authentik_providers_oauth2.oauth2provider\"")
  AUTHENTIK_PROVIDERS_OAUTH2_SCOPEMAPPING @enum(subgraph: "Authentik", value: "\"authentik_providers_oauth2.scopemapping\"")
  AUTHENTIK_PROVIDERS_PROXY_PROXYPROVIDER @enum(subgraph: "Authentik", value: "\"authentik_providers_proxy.proxyprovider\"")
  AUTHENTIK_PROVIDERS_RAC_ENDPOINT @enum(subgraph: "Authentik", value: "\"authentik_providers_rac.endpoint\"")
  AUTHENTIK_PROVIDERS_RAC_RACPROPERTYMAPPING @enum(subgraph: "Authentik", value: "\"authentik_providers_rac.racpropertymapping\"")
  AUTHENTIK_PROVIDERS_RAC_RACPROVIDER @enum(subgraph: "Authentik", value: "\"authentik_providers_rac.racprovider\"")
  AUTHENTIK_PROVIDERS_RADIUS_RADIUSPROVIDER @enum(subgraph: "Authentik", value: "\"authentik_providers_radius.radiusprovider\"")
  AUTHENTIK_PROVIDERS_SAML_SAMLPROPERTYMAPPING @enum(subgraph: "Authentik", value: "\"authentik_providers_saml.samlpropertymapping\"")
  AUTHENTIK_PROVIDERS_SAML_SAMLPROVIDER @enum(subgraph: "Authentik", value: "\"authentik_providers_saml.samlprovider\"")
  AUTHENTIK_PROVIDERS_SCIM_SCIMMAPPING @enum(subgraph: "Authentik", value: "\"authentik_providers_scim.scimmapping\"")
  AUTHENTIK_PROVIDERS_SCIM_SCIMPROVIDER @enum(subgraph: "Authentik", value: "\"authentik_providers_scim.scimprovider\"")
  AUTHENTIK_RBAC_ROLE @enum(subgraph: "Authentik", value: "\"authentik_rbac.role\"")
  AUTHENTIK_SOURCES_LDAP_LDAPPROPERTYMAPPING @enum(subgraph: "Authentik", value: "\"authentik_sources_ldap.ldappropertymapping\"")
  AUTHENTIK_SOURCES_LDAP_LDAPSOURCE @enum(subgraph: "Authentik", value: "\"authentik_sources_ldap.ldapsource\"")
  AUTHENTIK_SOURCES_OAUTH_OAUTHSOURCE @enum(subgraph: "Authentik", value: "\"authentik_sources_oauth.oauthsource\"")
  AUTHENTIK_SOURCES_OAUTH_USEROAUTHSOURCECONNECTION @enum(subgraph: "Authentik", value: "\"authentik_sources_oauth.useroauthsourceconnection\"")
  AUTHENTIK_SOURCES_PLEX_PLEXSOURCE @enum(subgraph: "Authentik", value: "\"authentik_sources_plex.plexsource\"")
  AUTHENTIK_SOURCES_PLEX_PLEXSOURCECONNECTION @enum(subgraph: "Authentik", value: "\"authentik_sources_plex.plexsourceconnection\"")
  AUTHENTIK_SOURCES_SAML_SAMLSOURCE @enum(subgraph: "Authentik", value: "\"authentik_sources_saml.samlsource\"")
  AUTHENTIK_SOURCES_SAML_USERSAMLSOURCECONNECTION @enum(subgraph: "Authentik", value: "\"authentik_sources_saml.usersamlsourceconnection\"")
  AUTHENTIK_SOURCES_SCIM_SCIMSOURCE @enum(subgraph: "Authentik", value: "\"authentik_sources_scim.scimsource\"")
  AUTHENTIK_STAGES_AUTHENTICATOR_DUO_AUTHENTICATORDUOSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_authenticator_duo.authenticatorduostage\"")
  AUTHENTIK_STAGES_AUTHENTICATOR_DUO_DUODEVICE @enum(subgraph: "Authentik", value: "\"authentik_stages_authenticator_duo.duodevice\"")
  AUTHENTIK_STAGES_AUTHENTICATOR_SMS_AUTHENTICATORSMSSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_authenticator_sms.authenticatorsmsstage\"")
  AUTHENTIK_STAGES_AUTHENTICATOR_SMS_SMSDEVICE @enum(subgraph: "Authentik", value: "\"authentik_stages_authenticator_sms.smsdevice\"")
  AUTHENTIK_STAGES_AUTHENTICATOR_STATIC_AUTHENTICATORSTATICSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_authenticator_static.authenticatorstaticstage\"")
  AUTHENTIK_STAGES_AUTHENTICATOR_STATIC_STATICDEVICE @enum(subgraph: "Authentik", value: "\"authentik_stages_authenticator_static.staticdevice\"")
  AUTHENTIK_STAGES_AUTHENTICATOR_TOTP_AUTHENTICATORTOTPSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_authenticator_totp.authenticatortotpstage\"")
  AUTHENTIK_STAGES_AUTHENTICATOR_TOTP_TOTPDEVICE @enum(subgraph: "Authentik", value: "\"authentik_stages_authenticator_totp.totpdevice\"")
  AUTHENTIK_STAGES_AUTHENTICATOR_VALIDATE_AUTHENTICATORVALIDATESTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_authenticator_validate.authenticatorvalidatestage\"")
  AUTHENTIK_STAGES_AUTHENTICATOR_WEBAUTHN_AUTHENTICATORWEBAUTHNSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_authenticator_webauthn.authenticatorwebauthnstage\"")
  AUTHENTIK_STAGES_AUTHENTICATOR_WEBAUTHN_WEBAUTHNDEVICE @enum(subgraph: "Authentik", value: "\"authentik_stages_authenticator_webauthn.webauthndevice\"")
  AUTHENTIK_STAGES_CAPTCHA_CAPTCHASTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_captcha.captchastage\"")
  AUTHENTIK_STAGES_CONSENT_CONSENTSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_consent.consentstage\"")
  AUTHENTIK_STAGES_CONSENT_USERCONSENT @enum(subgraph: "Authentik", value: "\"authentik_stages_consent.userconsent\"")
  AUTHENTIK_STAGES_DENY_DENYSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_deny.denystage\"")
  AUTHENTIK_STAGES_DUMMY_DUMMYSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_dummy.dummystage\"")
  AUTHENTIK_STAGES_EMAIL_EMAILSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_email.emailstage\"")
  AUTHENTIK_STAGES_IDENTIFICATION_IDENTIFICATIONSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_identification.identificationstage\"")
  AUTHENTIK_STAGES_INVITATION_INVITATION @enum(subgraph: "Authentik", value: "\"authentik_stages_invitation.invitation\"")
  AUTHENTIK_STAGES_INVITATION_INVITATIONSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_invitation.invitationstage\"")
  AUTHENTIK_STAGES_PASSWORD_PASSWORDSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_password.passwordstage\"")
  AUTHENTIK_STAGES_PROMPT_PROMPT @enum(subgraph: "Authentik", value: "\"authentik_stages_prompt.prompt\"")
  AUTHENTIK_STAGES_PROMPT_PROMPTSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_prompt.promptstage\"")
  AUTHENTIK_STAGES_SOURCE_SOURCESTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_source.sourcestage\"")
  AUTHENTIK_STAGES_USER_DELETE_USERDELETESTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_user_delete.userdeletestage\"")
  AUTHENTIK_STAGES_USER_LOGIN_USERLOGINSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_user_login.userloginstage\"")
  AUTHENTIK_STAGES_USER_LOGOUT_USERLOGOUTSTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_user_logout.userlogoutstage\"")
  AUTHENTIK_STAGES_USER_WRITE_USERWRITESTAGE @enum(subgraph: "Authentik", value: "\"authentik_stages_user_write.userwritestage\"")
  AUTHENTIK_TENANTS_DOMAIN @enum(subgraph: "Authentik", value: "\"authentik_tenants.domain\"")
}

union RbacPermissionsRolesListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedExtraRoleObjectPermissionList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedExtraRoleObjectPermissionList | ValidationError | GenericError

type PaginatedExtraRoleObjectPermissionList {
  pagination: Pagination!
  results: [ExtraRoleObjectPermission]!
}

"""User permission with additional object-related data"""
type ExtraRoleObjectPermission {
  id: Int!
  codename: String!
  model: String!
  appLabel: String!
  objectPk: String!
  name: String!
  """Get app label from permission's model"""
  appLabelVerbose: String!
  """Get model label from permission's model"""
  modelVerbose: String!
  """
  Get model description from attached model. This operation takes at least
  one additional query, and the description is only shown if the user/role has the
  view_ permission on the object
  """
  objectDescription: String
}

union RbacPermissionsUsersListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedExtraUserObjectPermissionList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedExtraUserObjectPermissionList | ValidationError | GenericError

type PaginatedExtraUserObjectPermissionList {
  pagination: Pagination!
  results: [ExtraUserObjectPermission]!
}

"""User permission with additional object-related data"""
type ExtraUserObjectPermission {
  id: Int!
  codename: String!
  model: String!
  appLabel: String!
  objectPk: String!
  name: String!
  """Get app label from permission's model"""
  appLabelVerbose: String!
  """Get model label from permission's model"""
  modelVerbose: String!
  """
  Get model description from attached model. This operation takes at least
  one additional query, and the description is only shown if the user/role has the
  view_ permission on the object
  """
  objectDescription: String
}

union RbacRolesListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedRoleList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedRoleList | ValidationError | GenericError

type PaginatedRoleList {
  pagination: Pagination!
  results: [Role]!
}

union RbacRolesRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Role") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Role | ValidationError | GenericError

union RbacRolesUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union RootConfigRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Config") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Config | ValidationError | GenericError

"""Serialize authentik Config into DRF Object"""
type Config {
  errorReporting: ErrorReportingConfig!
  capabilities: [CapabilitiesEnum]!
  cacheTimeout: Int!
  cacheTimeoutFlows: Int!
  cacheTimeoutPolicies: Int!
  cacheTimeoutReputation: Int!
}

"""Config for error reporting"""
type ErrorReportingConfig {
  enabled: Boolean!
  sentryDsn: String!
  environment: String!
  sendPii: Boolean!
  tracesSampleRate: Float!
}

enum CapabilitiesEnum {
  CAN_SAVE_MEDIA
  CAN_GEO_IP
  CAN_ASN
  CAN_IMPERSONATE
  CAN_DEBUG
  IS_ENTERPRISE
}

union SchemaRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "JSON_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = JsonContainer | ValidationError | GenericError

type JsonContainer {
  json: JSON @resolveRoot(subgraph: "Authentik")
}

enum QueryInputSchemaRetrieveFormat {
  JSON
  YAML
}

enum QueryInputSchemaRetrieveLang {
  AF
  AR
  AR_DZ @enum(subgraph: "Authentik", value: "\"ar-dz\"")
  AST
  AZ
  BE
  BG
  BN
  BR
  BS
  CA
  CKB
  CS
  CY
  DA
  DE
  DSB
  EL
  EN
  EN_AU @enum(subgraph: "Authentik", value: "\"en-au\"")
  EN_GB @enum(subgraph: "Authentik", value: "\"en-gb\"")
  EO
  ES
  ES_AR @enum(subgraph: "Authentik", value: "\"es-ar\"")
  ES_CO @enum(subgraph: "Authentik", value: "\"es-co\"")
  ES_MX @enum(subgraph: "Authentik", value: "\"es-mx\"")
  ES_NI @enum(subgraph: "Authentik", value: "\"es-ni\"")
  ES_VE @enum(subgraph: "Authentik", value: "\"es-ve\"")
  ET
  EU
  FA
  FI
  FR
  FY
  GA
  GD
  GL
  HE
  HI
  HR
  HSB
  HU
  HY
  IA
  ID
  IG
  IO
  IS
  IT
  JA
  KA
  KAB
  KK
  KM
  KN
  KO
  KY
  LB
  LT
  LV
  MK
  ML
  MN
  MR
  MS
  MY
  NB
  NE
  NL
  NN
  OS
  PA
  PL
  PT
  PT_BR @enum(subgraph: "Authentik", value: "\"pt-br\"")
  RO
  RU
  SK
  SL
  SQ
  SR
  SR_LATN @enum(subgraph: "Authentik", value: "\"sr-latn\"")
  SV
  SW
  TA
  TE
  TG
  TH
  TK
  TR
  TT
  UDM
  UG
  UK
  UR
  UZ
  VI
  ZH_HANS @enum(subgraph: "Authentik", value: "\"zh-hans\"")
  ZH_HANT @enum(subgraph: "Authentik", value: "\"zh-hant\"")
}

union SourcesAllListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedSourceList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedSourceList | ValidationError | GenericError

type PaginatedSourceList {
  pagination: Pagination!
  results: [Source]!
}

"""Source Serializer"""
type Source {
  pk: UUID!
  """Source's display Name."""
  name: String!
  slug: QuerySourcesAllListOneOf_0ResultsItemsSlug!
  enabled: Boolean
  """Flow to use when authenticating existing users."""
  authenticationFlow: UUID
  """Flow to use when enrolling new users."""
  enrollmentFlow: UUID
  """Get object component so that we know how to edit the object"""
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  policyEngineMode: PolicyEngineMode
  userMatchingMode: UserMatchingModeEnum
  """
  Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.
  """
  managed: String
  userPathTemplate: String
  """
  Get the URL to the Icon. If the name is /static or
  starts with http it is returned as-is
  """
  icon: String
  additionalProperties: JSON @resolveRoot(subgraph: "Authentik")
}

scalar QuerySourcesAllListOneOf_0ResultsItemsSlug @regexp(subgraph: "Authentik", pattern: "^[-a-zA-Z0-9_]+$") @typescript(subgraph: "Authentik", type: "string")

enum UserMatchingModeEnum {
  IDENTIFIER
  EMAIL_LINK
  EMAIL_DENY
  USERNAME_LINK
  USERNAME_DENY
}

union SourcesAllRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Source") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Source | ValidationError | GenericError

union SourcesAllUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union SourcesAllTypesListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "TypeCreate") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = TypeCreate | ValidationError | GenericError

union SourcesAllUserSettingsListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UserSetting") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UserSetting | ValidationError | GenericError

"""Serializer for User settings for stages and sources"""
type UserSetting {
  objectUid: String!
  component: String!
  title: String!
  configureUrl: String
  iconUrl: String
}

union SourcesLdapListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedLDAPSourceList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedLdapSourceList | ValidationError | GenericError

type PaginatedLdapSourceList {
  pagination: Pagination!
  results: [LdapSource]!
}

"""LDAP Source Serializer"""
type LdapSource {
  pk: UUID!
  """Source's display Name."""
  name: String!
  slug: QuerySourcesLdapListOneOf_0ResultsItemsSlug!
  enabled: Boolean
  """Flow to use when authenticating existing users."""
  authenticationFlow: UUID
  """Flow to use when enrolling new users."""
  enrollmentFlow: UUID
  """Get object component so that we know how to edit the object"""
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  policyEngineMode: PolicyEngineMode
  userMatchingMode: UserMatchingModeEnum
  """
  Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.
  """
  managed: String
  userPathTemplate: String
  """
  Get the URL to the Icon. If the name is /static or
  starts with http it is returned as-is
  """
  icon: String
  serverUri: URL!
  """
  Optionally verify the LDAP Server's Certificate against the CA Chain in this keypair.
  """
  peerCertificate: UUID
  """
  Client certificate to authenticate against the LDAP Server's Certificate.
  """
  clientCertificate: UUID
  bindCn: String
  startTls: Boolean
  sni: Boolean
  baseDn: String!
  """Prepended to Base DN for User-queries."""
  additionalUserDn: String
  """Prepended to Base DN for Group-queries."""
  additionalGroupDn: String
  """Consider Objects matching this filter to be Users."""
  userObjectFilter: String
  """Consider Objects matching this filter to be Groups."""
  groupObjectFilter: String
  """Field which contains members of a group."""
  groupMembershipField: String
  """Field which contains a unique Identifier."""
  objectUniquenessField: String
  """Update internal authentik password when login succeeds with LDAP"""
  passwordLoginUpdateInternalPassword: Boolean
  syncUsers: Boolean
  """
  When a user changes their password, sync it back to LDAP. This can only be enabled on a single LDAP source.
  """
  syncUsersPassword: Boolean
  syncGroups: Boolean
  syncParentGroup: UUID
  propertyMappings: [UUID]
  """Property mappings used for group creation/updating."""
  propertyMappingsGroup: [UUID]
  """Get cached source connectivity"""
  connectivity: JSON
}

scalar QuerySourcesLdapListOneOf_0ResultsItemsSlug @regexp(subgraph: "Authentik", pattern: "^[-a-zA-Z0-9_]+$") @typescript(subgraph: "Authentik", type: "string")

union SourcesLdapRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "LDAPSource") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = LdapSource | ValidationError | GenericError

union SourcesLdapDebugRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "LDAPDebug") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = LdapDebug | ValidationError | GenericError

type LdapDebug {
  user: [JSON]!
  group: [JSON]!
  membership: [JSON]!
}

union SourcesLdapSyncStatusRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "LDAPSyncStatus") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = LdapSyncStatus | ValidationError | GenericError

"""LDAP Source sync status"""
type LdapSyncStatus {
  isRunning: Boolean!
  tasks: [SystemTask]!
}

union SourcesLdapUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union SourcesOauthListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedOAuthSourceList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedOAuthSourceList | ValidationError | GenericError

type PaginatedOAuthSourceList {
  pagination: Pagination!
  results: [OAuthSource]!
}

"""OAuth Source Serializer"""
type OAuthSource {
  pk: UUID!
  """Source's display Name."""
  name: String!
  slug: QuerySourcesOauthListOneOf_0ResultsItemsSlug!
  enabled: Boolean
  """Flow to use when authenticating existing users."""
  authenticationFlow: UUID
  """Flow to use when enrolling new users."""
  enrollmentFlow: UUID
  """Get object component so that we know how to edit the object"""
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  policyEngineMode: PolicyEngineMode
  userMatchingMode: UserMatchingModeEnum
  """
  Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.
  """
  managed: String
  userPathTemplate: String
  """
  Get the URL to the Icon. If the name is /static or
  starts with http it is returned as-is
  """
  icon: String
  providerType: ProviderTypeEnum!
  """
  URL used to request the initial token. This URL is only required for OAuth 1.
  """
  requestTokenUrl: QuerySourcesOauthListOneOf_0ResultsItemsRequestTokenUrl
  """URL the user is redirect to to conest the flow."""
  authorizationUrl: QuerySourcesOauthListOneOf_0ResultsItemsAuthorizationUrl
  """URL used by authentik to retrieve tokens."""
  accessTokenUrl: QuerySourcesOauthListOneOf_0ResultsItemsAccessTokenUrl
  """URL used by authentik to get user information."""
  profileUrl: QuerySourcesOauthListOneOf_0ResultsItemsProfileUrl
  consumerKey: String!
  """Get OAuth Callback URL"""
  callbackUrl: String!
  additionalScopes: String
  type: SourceType!
  oidcWellKnownUrl: String
  oidcJwksUrl: String
  oidcJwks: JSON
}

scalar QuerySourcesOauthListOneOf_0ResultsItemsSlug @regexp(subgraph: "Authentik", pattern: "^[-a-zA-Z0-9_]+$") @typescript(subgraph: "Authentik", type: "string")

enum ProviderTypeEnum {
  APPLE
  OPENIDCONNECT
  AZUREAD
  DISCORD
  FACEBOOK
  GITHUB
  GITLAB
  GOOGLE
  MAILCOW
  OKTA
  PATREON
  REDDIT
  TWITCH
  TWITTER
}

"""
URL used to request the initial token. This URL is only required for OAuth 1.
"""
scalar QuerySourcesOauthListOneOf_0ResultsItemsRequestTokenUrl @length(subgraph: "Authentik", max: 255)

"""URL the user is redirect to to conest the flow."""
scalar QuerySourcesOauthListOneOf_0ResultsItemsAuthorizationUrl @length(subgraph: "Authentik", max: 255)

"""URL used by authentik to retrieve tokens."""
scalar QuerySourcesOauthListOneOf_0ResultsItemsAccessTokenUrl @length(subgraph: "Authentik", max: 255)

"""URL used by authentik to get user information."""
scalar QuerySourcesOauthListOneOf_0ResultsItemsProfileUrl @length(subgraph: "Authentik", max: 255)

"""Serializer for SourceType"""
type SourceType {
  name: String!
  verboseName: String!
  urlsCustomizable: Boolean!
  requestTokenUrl: String
  authorizationUrl: String
  accessTokenUrl: String
  profileUrl: String
  oidcWellKnownUrl: String
  oidcJwksUrl: String
  additionalProperties: JSON @resolveRoot(subgraph: "Authentik")
}

enum QueryInputSourcesOauthListPolicyEngineMode {
  ALL
  ANY
}

"""
How the source determines if an existing user should be authenticated or a new user enrolled.
"""
enum QueryInputSourcesOauthListUserMatchingMode {
  EMAIL_DENY
  EMAIL_LINK
  IDENTIFIER
  USERNAME_DENY
  USERNAME_LINK
}

union SourcesOauthRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "OAuthSource") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = OAuthSource | ValidationError | GenericError

union SourcesOauthUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union SourcesOauthSourceTypesListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "SourceType") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = SourceType | ValidationError | GenericError

union SourcesPlexListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedPlexSourceList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedPlexSourceList | ValidationError | GenericError

type PaginatedPlexSourceList {
  pagination: Pagination!
  results: [PlexSource]!
}

"""Plex Source Serializer"""
type PlexSource {
  pk: UUID!
  """Source's display Name."""
  name: String!
  slug: QuerySourcesPlexListOneOf_0ResultsItemsSlug!
  enabled: Boolean
  """Flow to use when authenticating existing users."""
  authenticationFlow: UUID
  """Flow to use when enrolling new users."""
  enrollmentFlow: UUID
  """Get object component so that we know how to edit the object"""
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  policyEngineMode: PolicyEngineMode
  userMatchingMode: UserMatchingModeEnum
  """
  Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.
  """
  managed: String
  userPathTemplate: String
  """
  Get the URL to the Icon. If the name is /static or
  starts with http it is returned as-is
  """
  icon: String
  """Client identifier used to talk to Plex."""
  clientId: String
  """
  Which servers a user has to be a member of to be granted access. Empty list allows every server.
  """
  allowedServers: [String]
  """Allow friends to authenticate, even if you don't share a server."""
  allowFriends: Boolean
  """Plex token used to check friends"""
  plexToken: String!
}

scalar QuerySourcesPlexListOneOf_0ResultsItemsSlug @regexp(subgraph: "Authentik", pattern: "^[-a-zA-Z0-9_]+$") @typescript(subgraph: "Authentik", type: "string")

enum QueryInputSourcesPlexListPolicyEngineMode {
  ALL
  ANY
}

"""
How the source determines if an existing user should be authenticated or a new user enrolled.
"""
enum QueryInputSourcesPlexListUserMatchingMode {
  EMAIL_DENY
  EMAIL_LINK
  IDENTIFIER
  USERNAME_DENY
  USERNAME_LINK
}

union SourcesPlexRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PlexSource") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PlexSource | ValidationError | GenericError

union SourcesPlexUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union SourcesSamlListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedSAMLSourceList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedSamlSourceList | ValidationError | GenericError

type PaginatedSamlSourceList {
  pagination: Pagination!
  results: [SamlSource]!
}

"""SAMLSource Serializer"""
type SamlSource {
  pk: UUID!
  """Source's display Name."""
  name: String!
  slug: QuerySourcesSamlListOneOf_0ResultsItemsSlug!
  enabled: Boolean
  """Flow to use when authenticating existing users."""
  authenticationFlow: UUID
  """Flow to use when enrolling new users."""
  enrollmentFlow: UUID
  """Get object component so that we know how to edit the object"""
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  policyEngineMode: PolicyEngineMode
  userMatchingMode: UserMatchingModeEnum
  """
  Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.
  """
  managed: String
  userPathTemplate: String
  """
  Get the URL to the Icon. If the name is /static or
  starts with http it is returned as-is
  """
  icon: String
  """Flow used before authentication."""
  preAuthenticationFlow: UUID!
  """Also known as Entity ID. Defaults the Metadata URL."""
  issuer: String
  """URL that the initial Login request is sent to."""
  ssoUrl: URL!
  """Optional URL if your IDP supports Single-Logout."""
  sloUrl: URL
  """
  Allows authentication flows initiated by the IdP. This can be a security risk, as no validation of the request ID is done.
  """
  allowIdpInitiated: Boolean
  nameIdPolicy: NameIdPolicyEnum
  bindingType: BindingTypeEnum
  """
  When selected, incoming assertion's Signatures will be validated against this certificate. To allow unsigned Requests, leave on default.
  """
  verificationKp: UUID
  """
  Keypair used to sign outgoing Responses going to the Identity Provider.
  """
  signingKp: UUID
  digestAlgorithm: DigestAlgorithmEnum
  signatureAlgorithm: SignatureAlgorithmEnum
  """
  Time offset when temporary users should be deleted. This only applies if your IDP uses the NameID Format 'transient', and the user doesn't log out manually. (Format: hours=1;minutes=2;seconds=3).
  """
  temporaryUserDeleteAfter: String
}

scalar QuerySourcesSamlListOneOf_0ResultsItemsSlug @regexp(subgraph: "Authentik", pattern: "^[-a-zA-Z0-9_]+$") @typescript(subgraph: "Authentik", type: "string")

enum NameIdPolicyEnum {
  URN_OASIS_NAMES_TC_SAML_1_1_NAMEID_FORMAT_EMAILADDRESS @enum(subgraph: "Authentik", value: "\"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\"")
  URN_OASIS_NAMES_TC_SAML_2_0_NAMEID_FORMAT_PERSISTENT @enum(subgraph: "Authentik", value: "\"urn:oasis:names:tc:SAML:2.0:nameid-format:persistent\"")
  URN_OASIS_NAMES_TC_SAML_2_0_NAMEID_FORMAT_X509SUBJECTNAME @enum(subgraph: "Authentik", value: "\"urn:oasis:names:tc:SAML:2.0:nameid-format:X509SubjectName\"")
  URN_OASIS_NAMES_TC_SAML_2_0_NAMEID_FORMAT_WINDOWSDOMAINQUALIFIEDNAME @enum(subgraph: "Authentik", value: "\"urn:oasis:names:tc:SAML:2.0:nameid-format:WindowsDomainQualifiedName\"")
  URN_OASIS_NAMES_TC_SAML_2_0_NAMEID_FORMAT_TRANSIENT @enum(subgraph: "Authentik", value: "\"urn:oasis:names:tc:SAML:2.0:nameid-format:transient\"")
}

enum BindingTypeEnum {
  REDIRECT
  POST
  POST_AUTO
}

enum QueryInputSourcesSamlListBindingType {
  POST
  POST_AUTO
  REDIRECT
}

enum QueryInputSourcesSamlListDigestAlgorithm {
  HTTP___WWW_W3_ORG_2000_09_XMLDSIG_POUND_SHA1 @enum(subgraph: "Authentik", value: "\"http://www.w3.org/2000/09/xmldsig#sha1\"")
  HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_SHA384 @enum(subgraph: "Authentik", value: "\"http://www.w3.org/2001/04/xmldsig-more#sha384\"")
  HTTP___WWW_W3_ORG_2001_04_XMLENC_POUND_SHA256 @enum(subgraph: "Authentik", value: "\"http://www.w3.org/2001/04/xmlenc#sha256\"")
  HTTP___WWW_W3_ORG_2001_04_XMLENC_POUND_SHA512 @enum(subgraph: "Authentik", value: "\"http://www.w3.org/2001/04/xmlenc#sha512\"")
}

"""
NameID Policy sent to the IdP. Can be unset, in which case no Policy is sent.
"""
enum QueryInputSourcesSamlListNameIdPolicy {
  URN_OASIS_NAMES_TC_SAML_1_1_NAMEID_FORMAT_EMAILADDRESS @enum(subgraph: "Authentik", value: "\"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\"")
  URN_OASIS_NAMES_TC_SAML_2_0_NAMEID_FORMAT_WINDOWSDOMAINQUALIFIEDNAME @enum(subgraph: "Authentik", value: "\"urn:oasis:names:tc:SAML:2.0:nameid-format:WindowsDomainQualifiedName\"")
  URN_OASIS_NAMES_TC_SAML_2_0_NAMEID_FORMAT_X509SUBJECTNAME @enum(subgraph: "Authentik", value: "\"urn:oasis:names:tc:SAML:2.0:nameid-format:X509SubjectName\"")
  URN_OASIS_NAMES_TC_SAML_2_0_NAMEID_FORMAT_PERSISTENT @enum(subgraph: "Authentik", value: "\"urn:oasis:names:tc:SAML:2.0:nameid-format:persistent\"")
  URN_OASIS_NAMES_TC_SAML_2_0_NAMEID_FORMAT_TRANSIENT @enum(subgraph: "Authentik", value: "\"urn:oasis:names:tc:SAML:2.0:nameid-format:transient\"")
}

enum QueryInputSourcesSamlListPolicyEngineMode {
  ALL
  ANY
}

enum QueryInputSourcesSamlListSignatureAlgorithm {
  HTTP___WWW_W3_ORG_2000_09_XMLDSIG_POUND_DSA_SHA1 @enum(subgraph: "Authentik", value: "\"http://www.w3.org/2000/09/xmldsig#dsa-sha1\"")
  HTTP___WWW_W3_ORG_2000_09_XMLDSIG_POUND_RSA_SHA1 @enum(subgraph: "Authentik", value: "\"http://www.w3.org/2000/09/xmldsig#rsa-sha1\"")
  HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_ECDSA_SHA1 @enum(subgraph: "Authentik", value: "\"http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha1\"")
  HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_ECDSA_SHA256 @enum(subgraph: "Authentik", value: "\"http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha256\"")
  HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_ECDSA_SHA384 @enum(subgraph: "Authentik", value: "\"http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha384\"")
  HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_ECDSA_SHA512 @enum(subgraph: "Authentik", value: "\"http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha512\"")
  HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_RSA_SHA256 @enum(subgraph: "Authentik", value: "\"http://www.w3.org/2001/04/xmldsig-more#rsa-sha256\"")
  HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_RSA_SHA384 @enum(subgraph: "Authentik", value: "\"http://www.w3.org/2001/04/xmldsig-more#rsa-sha384\"")
  HTTP___WWW_W3_ORG_2001_04_XMLDSIG_MORE_POUND_RSA_SHA512 @enum(subgraph: "Authentik", value: "\"http://www.w3.org/2001/04/xmldsig-more#rsa-sha512\"")
}

"""
How the source determines if an existing user should be authenticated or a new user enrolled.
"""
enum QueryInputSourcesSamlListUserMatchingMode {
  EMAIL_DENY
  EMAIL_LINK
  IDENTIFIER
  USERNAME_DENY
  USERNAME_LINK
}

union SourcesSamlRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "SAMLSource") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = SamlSource | ValidationError | GenericError

union SourcesSamlMetadataRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "SAMLMetadata") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = SamlMetadata | ValidationError | GenericError

union SourcesSamlUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union SourcesScimListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedSCIMSourceList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedScimSourceList | ValidationError | GenericError

type PaginatedScimSourceList {
  pagination: Pagination!
  results: [ScimSource]!
}

"""SCIMSource Serializer"""
type ScimSource {
  pk: UUID!
  """Source's display Name."""
  name: String!
  slug: QuerySourcesScimListOneOf_0ResultsItemsSlug!
  enabled: Boolean
  """Get object component so that we know how to edit the object"""
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  userMatchingMode: UserMatchingModeEnum
  """
  Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.
  """
  managed: String
  userPathTemplate: String
  """Get Root URL"""
  rootUrl: String!
  tokenObj: Token!
}

scalar QuerySourcesScimListOneOf_0ResultsItemsSlug @regexp(subgraph: "Authentik", pattern: "^[-a-zA-Z0-9_]+$") @typescript(subgraph: "Authentik", type: "string")

union SourcesScimRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "SCIMSource") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ScimSource | ValidationError | GenericError

union SourcesScimUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union SourcesScimGroupsListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedSCIMSourceGroupList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedScimSourceGroupList | ValidationError | GenericError

type PaginatedScimSourceGroupList {
  pagination: Pagination!
  results: [ScimSourceGroup]!
}

"""SCIMSourceGroup Serializer"""
type ScimSourceGroup {
  id: String!
  group: UUID!
  groupObj: UserGroup!
  source: UUID!
  attributes: JSON
}

union SourcesScimGroupsRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "SCIMSourceGroup") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ScimSourceGroup | ValidationError | GenericError

union SourcesScimGroupsUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union SourcesScimUsersListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedSCIMSourceUserList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedScimSourceUserList | ValidationError | GenericError

type PaginatedScimSourceUserList {
  pagination: Pagination!
  results: [ScimSourceUser]!
}

"""SCIMSourceUser Serializer"""
type ScimSourceUser {
  id: String!
  user: Int!
  userObj: GroupMember!
  source: UUID!
  attributes: JSON
}

union SourcesScimUsersRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "SCIMSourceUser") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ScimSourceUser | ValidationError | GenericError

union SourcesScimUsersUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union SourcesUserConnectionsAllListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedUserSourceConnectionList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedUserSourceConnectionList | ValidationError | GenericError

type PaginatedUserSourceConnectionList {
  pagination: Pagination!
  results: [UserSourceConnection]!
}

"""OAuth Source Serializer"""
type UserSourceConnection {
  pk: Int!
  user: Int!
  source: Source!
  created: DateTime!
}

union SourcesUserConnectionsAllRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UserSourceConnection") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UserSourceConnection | ValidationError | GenericError

union SourcesUserConnectionsAllUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union SourcesUserConnectionsOauthListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedUserOAuthSourceConnectionList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedUserOAuthSourceConnectionList | ValidationError | GenericError

type PaginatedUserOAuthSourceConnectionList {
  pagination: Pagination!
  results: [UserOAuthSourceConnection]!
}

"""OAuth Source Serializer"""
type UserOAuthSourceConnection {
  pk: Int!
  user: Int!
  source: Source!
  identifier: QuerySourcesUserConnectionsOauthListOneOf_0ResultsItemsIdentifier!
}

scalar QuerySourcesUserConnectionsOauthListOneOf_0ResultsItemsIdentifier @length(subgraph: "Authentik", max: 255)

union SourcesUserConnectionsOauthRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UserOAuthSourceConnection") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UserOAuthSourceConnection | ValidationError | GenericError

union SourcesUserConnectionsOauthUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union SourcesUserConnectionsPlexListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedPlexSourceConnectionList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedPlexSourceConnectionList | ValidationError | GenericError

type PaginatedPlexSourceConnectionList {
  pagination: Pagination!
  results: [PlexSourceConnection]!
}

"""Plex Source connection Serializer"""
type PlexSourceConnection {
  pk: Int!
  user: Int!
  source: Source!
  identifier: String!
  plexToken: String!
}

union SourcesUserConnectionsPlexRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PlexSourceConnection") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PlexSourceConnection | ValidationError | GenericError

union SourcesUserConnectionsPlexUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union SourcesUserConnectionsSamlListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedUserSAMLSourceConnectionList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedUserSamlSourceConnectionList | ValidationError | GenericError

type PaginatedUserSamlSourceConnectionList {
  pagination: Pagination!
  results: [UserSamlSourceConnection]!
}

"""SAML Source Serializer"""
type UserSamlSourceConnection {
  pk: Int!
  user: Int!
  source: Source!
  identifier: String!
}

union SourcesUserConnectionsSamlRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UserSAMLSourceConnection") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UserSamlSourceConnection | ValidationError | GenericError

union SourcesUserConnectionsSamlUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union StagesAllListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedStageList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedStageList | ValidationError | GenericError

type PaginatedStageList {
  pagination: Pagination!
  results: [Stage]!
}

union StagesAllRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Stage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Stage | ValidationError | GenericError

union StagesAllUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union StagesAllTypesListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "TypeCreate") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = TypeCreate | ValidationError | GenericError

union StagesAllUserSettingsListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UserSetting") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UserSetting | ValidationError | GenericError

union StagesAuthenticatorDuoListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedAuthenticatorDuoStageList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedAuthenticatorDuoStageList | ValidationError | GenericError

type PaginatedAuthenticatorDuoStageList {
  pagination: Pagination!
  results: [AuthenticatorDuoStage]!
}

"""AuthenticatorDuoStage Serializer"""
type AuthenticatorDuoStage {
  pk: UUID!
  name: String!
  """Get object type so that we know how to edit the object"""
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  flowSet: [FlowSet]
  """
  Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.
  """
  configureFlow: UUID
  friendlyName: String
  clientId: String!
  apiHostname: String!
  adminIntegrationKey: String
}

union StagesAuthenticatorDuoRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "AuthenticatorDuoStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = AuthenticatorDuoStage | ValidationError | GenericError

union StagesAuthenticatorDuoUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union StagesAuthenticatorSmsListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedAuthenticatorSMSStageList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedAuthenticatorSmsStageList | ValidationError | GenericError

type PaginatedAuthenticatorSmsStageList {
  pagination: Pagination!
  results: [AuthenticatorSmsStage]!
}

"""AuthenticatorSMSStage Serializer"""
type AuthenticatorSmsStage {
  pk: UUID!
  name: String!
  """Get object type so that we know how to edit the object"""
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  flowSet: [FlowSet]
  """
  Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.
  """
  configureFlow: UUID
  friendlyName: String
  provider: ProviderEnum!
  fromNumber: String!
  accountSid: String!
  auth: String!
  authPassword: String
  authType: AuthTypeEnum
  """
  When enabled, the Phone number is only used during enrollment to verify the users authenticity. Only a hash of the phone number is saved to ensure it is not reused in the future.
  """
  verifyOnly: Boolean
  """Optionally modify the payload being sent to custom providers."""
  mapping: UUID
}

enum ProviderEnum {
  TWILIO
  GENERIC
}

enum AuthTypeEnum {
  BASIC
  BEARER
}

enum QueryInputStagesAuthenticatorSmsListAuthType {
  BASIC
  BEARER
}

enum QueryInputStagesAuthenticatorSmsListProvider {
  GENERIC
  TWILIO
}

union StagesAuthenticatorSmsRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "AuthenticatorSMSStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = AuthenticatorSmsStage | ValidationError | GenericError

union StagesAuthenticatorSmsUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union StagesAuthenticatorStaticListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedAuthenticatorStaticStageList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedAuthenticatorStaticStageList | ValidationError | GenericError

type PaginatedAuthenticatorStaticStageList {
  pagination: Pagination!
  results: [AuthenticatorStaticStage]!
}

"""AuthenticatorStaticStage Serializer"""
type AuthenticatorStaticStage {
  pk: UUID!
  name: String!
  """Get object type so that we know how to edit the object"""
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  flowSet: [FlowSet]
  """
  Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.
  """
  configureFlow: UUID
  friendlyName: String
  tokenCount: NonNegativeInt
  tokenLength: NonNegativeInt
}

union StagesAuthenticatorStaticRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "AuthenticatorStaticStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = AuthenticatorStaticStage | ValidationError | GenericError

union StagesAuthenticatorStaticUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union StagesAuthenticatorTotpListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedAuthenticatorTOTPStageList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedAuthenticatorTotpStageList | ValidationError | GenericError

type PaginatedAuthenticatorTotpStageList {
  pagination: Pagination!
  results: [AuthenticatorTotpStage]!
}

"""AuthenticatorTOTPStage Serializer"""
type AuthenticatorTotpStage {
  pk: UUID!
  name: String!
  """Get object type so that we know how to edit the object"""
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  flowSet: [FlowSet]
  """
  Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.
  """
  configureFlow: UUID
  friendlyName: String
  digits: DigitsEnum!
}

enum DigitsEnum {
  _6 @enum(subgraph: "Authentik", value: "\"6\"")
  _8 @enum(subgraph: "Authentik", value: "\"8\"")
}

enum QueryInputStagesAuthenticatorTotpListDigits {
  _6 @enum(subgraph: "Authentik", value: "\"6\"")
  _8 @enum(subgraph: "Authentik", value: "\"8\"")
}

union StagesAuthenticatorTotpRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "AuthenticatorTOTPStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = AuthenticatorTotpStage | ValidationError | GenericError

union StagesAuthenticatorTotpUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union StagesAuthenticatorValidateListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedAuthenticatorValidateStageList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedAuthenticatorValidateStageList | ValidationError | GenericError

type PaginatedAuthenticatorValidateStageList {
  pagination: Pagination!
  results: [AuthenticatorValidateStage]!
}

"""AuthenticatorValidateStage Serializer"""
type AuthenticatorValidateStage {
  pk: UUID!
  name: String!
  """Get object type so that we know how to edit the object"""
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  flowSet: [FlowSet]
  notConfiguredAction: NotConfiguredActionEnum
  """Device classes which can be used to authenticate"""
  deviceClasses: [DeviceClassesEnum]
  """
  Stages used to configure Authenticator when user doesn't have any compatible devices. After this configuration Stage passes, the user is not prompted again.
  """
  configurationStages: [UUID]
  """
  If any of the user's device has been used within this threshold, this stage will be skipped
  """
  lastAuthThreshold: String
  webauthnUserVerification: UserVerificationEnum
  webauthnAllowedDeviceTypes: [UUID]
  webauthnAllowedDeviceTypesObj: [WebAuthnDeviceType]!
}

enum NotConfiguredActionEnum {
  SKIP
  DENY
  CONFIGURE
}

enum DeviceClassesEnum {
  STATIC
  TOTP
  WEBAUTHN
  DUO
  SMS
}

enum UserVerificationEnum {
  REQUIRED
  PREFERRED
  DISCOURAGED
}

enum QueryInputStagesAuthenticatorValidateListNotConfiguredAction {
  CONFIGURE
  DENY
  SKIP
}

union StagesAuthenticatorValidateRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "AuthenticatorValidateStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = AuthenticatorValidateStage | ValidationError | GenericError

union StagesAuthenticatorValidateUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union StagesAuthenticatorWebauthnListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedAuthenticatorWebAuthnStageList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedAuthenticatorWebAuthnStageList | ValidationError | GenericError

type PaginatedAuthenticatorWebAuthnStageList {
  pagination: Pagination!
  results: [AuthenticatorWebAuthnStage]!
}

"""AuthenticatorWebAuthnStage Serializer"""
type AuthenticatorWebAuthnStage {
  pk: UUID!
  name: String!
  """Get object type so that we know how to edit the object"""
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  flowSet: [FlowSet]
  """
  Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.
  """
  configureFlow: UUID
  friendlyName: String
  userVerification: UserVerificationEnum
  authenticatorAttachment: AuthenticatorAttachmentEnum
  residentKeyRequirement: ResidentKeyRequirementEnum
  deviceTypeRestrictions: [UUID]
  deviceTypeRestrictionsObj: [WebAuthnDeviceType]!
}

enum AuthenticatorAttachmentEnum {
  PLATFORM
  CROSS_PLATFORM @enum(subgraph: "Authentik", value: "\"cross-platform\"")
}

enum ResidentKeyRequirementEnum {
  DISCOURAGED
  PREFERRED
  REQUIRED
}

enum QueryInputStagesAuthenticatorWebauthnListAuthenticatorAttachment {
  CROSS_PLATFORM @enum(subgraph: "Authentik", value: "\"cross-platform\"")
  PLATFORM
}

enum QueryInputStagesAuthenticatorWebauthnListResidentKeyRequirement {
  DISCOURAGED
  PREFERRED
  REQUIRED
}

enum QueryInputStagesAuthenticatorWebauthnListUserVerification {
  DISCOURAGED
  PREFERRED
  REQUIRED
}

union StagesAuthenticatorWebauthnRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "AuthenticatorWebAuthnStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = AuthenticatorWebAuthnStage | ValidationError | GenericError

union StagesAuthenticatorWebauthnUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union StagesAuthenticatorWebauthnDeviceTypesListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedWebAuthnDeviceTypeList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedWebAuthnDeviceTypeList | ValidationError | GenericError

type PaginatedWebAuthnDeviceTypeList {
  pagination: Pagination!
  results: [WebAuthnDeviceType]!
}

union StagesAuthenticatorWebauthnDeviceTypesRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "WebAuthnDeviceType") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = WebAuthnDeviceType | ValidationError | GenericError

union StagesCaptchaListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedCaptchaStageList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedCaptchaStageList | ValidationError | GenericError

type PaginatedCaptchaStageList {
  pagination: Pagination!
  results: [CaptchaStage]!
}

"""CaptchaStage Serializer"""
type CaptchaStage {
  pk: UUID!
  name: String!
  """Get object type so that we know how to edit the object"""
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  flowSet: [FlowSet]
  """Public key, acquired your captcha Provider."""
  publicKey: String!
  jsUrl: String
  apiUrl: String
}

union StagesCaptchaRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "CaptchaStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = CaptchaStage | ValidationError | GenericError

union StagesCaptchaUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union StagesConsentListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedConsentStageList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedConsentStageList | ValidationError | GenericError

type PaginatedConsentStageList {
  pagination: Pagination!
  results: [ConsentStage]!
}

"""ConsentStage Serializer"""
type ConsentStage {
  pk: UUID!
  name: String!
  """Get object type so that we know how to edit the object"""
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  flowSet: [FlowSet]
  mode: ConsentStageModeEnum
  """
  Offset after which consent expires. (Format: hours=1;minutes=2;seconds=3).
  """
  consentExpireIn: String
}

enum ConsentStageModeEnum {
  ALWAYS_REQUIRE
  PERMANENT
  EXPIRING
}

enum QueryInputStagesConsentListMode {
  ALWAYS_REQUIRE
  EXPIRING
  PERMANENT
}

union StagesConsentRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "ConsentStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ConsentStage | ValidationError | GenericError

union StagesConsentUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union StagesDenyListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedDenyStageList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedDenyStageList | ValidationError | GenericError

type PaginatedDenyStageList {
  pagination: Pagination!
  results: [DenyStage]!
}

"""DenyStage Serializer"""
type DenyStage {
  pk: UUID!
  name: String!
  """Get object type so that we know how to edit the object"""
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  flowSet: [FlowSet]
  denyMessage: String
}

union StagesDenyRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "DenyStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = DenyStage | ValidationError | GenericError

union StagesDenyUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union StagesDummyListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedDummyStageList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedDummyStageList | ValidationError | GenericError

type PaginatedDummyStageList {
  pagination: Pagination!
  results: [DummyStage]!
}

"""DummyStage Serializer"""
type DummyStage {
  pk: UUID!
  name: String!
  """Get object type so that we know how to edit the object"""
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  flowSet: [FlowSet]
  throwError: Boolean
}

union StagesDummyRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "DummyStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = DummyStage | ValidationError | GenericError

union StagesDummyUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union StagesEmailListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedEmailStageList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedEmailStageList | ValidationError | GenericError

type PaginatedEmailStageList {
  pagination: Pagination!
  results: [EmailStage]!
}

"""EmailStage Serializer"""
type EmailStage {
  pk: UUID!
  name: String!
  """Get object type so that we know how to edit the object"""
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  flowSet: [FlowSet]
  """
  When enabled, global Email connection settings will be used and connection settings below will be ignored.
  """
  useGlobalSettings: Boolean
  host: String
  port: Int
  username: String
  useTls: Boolean
  useSsl: Boolean
  timeout: Int
  fromAddress: EmailAddress
  """Time in minutes the token sent is valid."""
  tokenExpiry: Int
  subject: String
  template: String
  """Activate users upon completion of stage."""
  activateUserOnSuccess: Boolean
}

union StagesEmailRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "EmailStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = EmailStage | ValidationError | GenericError

union StagesEmailUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union StagesEmailTemplatesListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "TypeCreate") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = TypeCreate | ValidationError | GenericError

union StagesIdentificationListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedIdentificationStageList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedIdentificationStageList | ValidationError | GenericError

type PaginatedIdentificationStageList {
  pagination: Pagination!
  results: [IdentificationStage]!
}

"""IdentificationStage Serializer"""
type IdentificationStage {
  pk: UUID!
  name: String!
  """Get object type so that we know how to edit the object"""
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  flowSet: [FlowSet]
  """
  Fields of the user object to match against. (Hold shift to select multiple options)
  """
  userFields: [UserFieldsEnum]
  """
  When set, shows a password field, instead of showing the password field as seaprate step.
  """
  passwordStage: UUID
  """When enabled, user fields are matched regardless of their casing."""
  caseInsensitiveMatching: Boolean
  """
  When a valid username/email has been entered, and this option is enabled, the user's username and avatar will be shown. Otherwise, the text that the user entered will be shown
  """
  showMatchedUser: Boolean
  """Optional enrollment flow, which is linked at the bottom of the page."""
  enrollmentFlow: UUID
  """Optional recovery flow, which is linked at the bottom of the page."""
  recoveryFlow: UUID
  """Optional passwordless flow, which is linked at the bottom of the page."""
  passwordlessFlow: UUID
  """Specify which sources should be shown."""
  sources: [UUID]
  showSourceLabels: Boolean
  """
  When enabled, the stage will succeed and continue even when incorrect user info is entered.
  """
  pretendUserExists: Boolean
}

enum UserFieldsEnum {
  EMAIL
  USERNAME
  UPN
}

union StagesIdentificationRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "IdentificationStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = IdentificationStage | ValidationError | GenericError

union StagesIdentificationUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union StagesInvitationInvitationsListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedInvitationList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedInvitationList | ValidationError | GenericError

type PaginatedInvitationList {
  pagination: Pagination!
  results: [Invitation]!
}

"""Invitation Serializer"""
type Invitation {
  pk: UUID!
  name: QueryStagesInvitationInvitationsListOneOf_0ResultsItemsName!
  expires: DateTime
  fixedData: JSON
  createdBy: GroupMember!
  """When enabled, the invitation will be deleted after usage."""
  singleUse: Boolean
  """When set, only the configured flow can use this invitation."""
  flow: UUID
  flowObj: Flow!
}

scalar QueryStagesInvitationInvitationsListOneOf_0ResultsItemsName @regexp(subgraph: "Authentik", pattern: "^[-a-zA-Z0-9_]+$") @typescript(subgraph: "Authentik", type: "string")

union StagesInvitationInvitationsRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Invitation") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Invitation | ValidationError | GenericError

union StagesInvitationInvitationsUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union StagesInvitationStagesListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedInvitationStageList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedInvitationStageList | ValidationError | GenericError

type PaginatedInvitationStageList {
  pagination: Pagination!
  results: [InvitationStage]!
}

"""InvitationStage Serializer"""
type InvitationStage {
  pk: UUID!
  name: String!
  """Get object type so that we know how to edit the object"""
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  flowSet: [FlowSet]
  """
  If this flag is set, this Stage will jump to the next Stage when no Invitation is given. By default this Stage will cancel the Flow when no invitation is given.
  """
  continueFlowWithoutInvitation: Boolean
}

union StagesInvitationStagesRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "InvitationStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = InvitationStage | ValidationError | GenericError

union StagesInvitationStagesUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union StagesPasswordListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedPasswordStageList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedPasswordStageList | ValidationError | GenericError

type PaginatedPasswordStageList {
  pagination: Pagination!
  results: [PasswordStage]!
}

"""PasswordStage Serializer"""
type PasswordStage {
  pk: UUID!
  name: String!
  """Get object type so that we know how to edit the object"""
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  flowSet: [FlowSet]
  """Selection of backends to test the password against."""
  backends: [BackendsEnum]!
  """
  Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.
  """
  configureFlow: UUID
  """
  How many attempts a user has before the flow is canceled. To lock the user out, use a reputation policy and a user_write stage.
  """
  failedAttemptsBeforeCancel: Int
}

enum BackendsEnum {
  AUTHENTIK_CORE_AUTH_INBUILTBACKEND @enum(subgraph: "Authentik", value: "\"authentik.core.auth.InbuiltBackend\"")
  AUTHENTIK_CORE_AUTH_TOKENBACKEND @enum(subgraph: "Authentik", value: "\"authentik.core.auth.TokenBackend\"")
  AUTHENTIK_SOURCES_LDAP_AUTH_LDAPBACKEND @enum(subgraph: "Authentik", value: "\"authentik.sources.ldap.auth.LDAPBackend\"")
}

union StagesPasswordRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PasswordStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PasswordStage | ValidationError | GenericError

union StagesPasswordUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union StagesPromptPromptsListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedPromptList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedPromptList | ValidationError | GenericError

type PaginatedPromptList {
  pagination: Pagination!
  results: [Prompt]!
}

"""Prompt Serializer"""
type Prompt {
  pk: UUID!
  name: String!
  """Name of the form field, also used to store the value"""
  fieldKey: String!
  label: String!
  type: PromptTypeEnum!
  required: Boolean
  """
  Optionally provide a short hint that describes the expected input value. When creating a fixed choice field, enable interpreting as expression and return a list to return multiple choices.
  """
  placeholder: String
  """
  Optionally pre-fill the input with an initial value. When creating a fixed choice field, enable interpreting as expression and return a list to return multiple default choices.
  """
  initialValue: String
  order: Int
  promptstageSet: [Stage]
  subText: String
  placeholderExpression: Boolean
  initialValueExpression: Boolean
}

enum QueryInputStagesPromptPromptsListType {
  AK_LOCALE @enum(subgraph: "Authentik", value: "\"ak-locale\"")
  CHECKBOX
  DATE
  DATE_TIME @enum(subgraph: "Authentik", value: "\"date-time\"")
  DROPDOWN
  EMAIL
  FILE
  HIDDEN
  NUMBER
  PASSWORD
  RADIO_BUTTON_GROUP @enum(subgraph: "Authentik", value: "\"radio-button-group\"")
  SEPARATOR
  STATIC
  TEXT
  TEXT_AREA
  TEXT_AREA_READ_ONLY
  TEXT_READ_ONLY
  USERNAME
}

union StagesPromptPromptsRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Prompt") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Prompt | ValidationError | GenericError

union StagesPromptPromptsUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union StagesPromptStagesListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedPromptStageList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedPromptStageList | ValidationError | GenericError

type PaginatedPromptStageList {
  pagination: Pagination!
  results: [PromptStage]!
}

"""PromptStage Serializer"""
type PromptStage {
  pk: UUID!
  name: String!
  """Get object type so that we know how to edit the object"""
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  flowSet: [FlowSet]
  fields: [UUID]!
  validationPolicies: [UUID]
}

union StagesPromptStagesRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PromptStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PromptStage | ValidationError | GenericError

union StagesPromptStagesUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union StagesSourceListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedSourceStageList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedSourceStageList | ValidationError | GenericError

type PaginatedSourceStageList {
  pagination: Pagination!
  results: [SourceStage]!
}

"""SourceStage Serializer"""
type SourceStage {
  pk: UUID!
  name: String!
  """Get object type so that we know how to edit the object"""
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  flowSet: [FlowSet]
  source: UUID!
  """
  Amount of time a user can take to return from the source to continue the flow (Format: hours=-1;minutes=-2;seconds=-3)
  """
  resumeTimeout: String
}

union StagesSourceRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "SourceStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = SourceStage | ValidationError | GenericError

union StagesSourceUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union StagesUserDeleteListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedUserDeleteStageList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedUserDeleteStageList | ValidationError | GenericError

type PaginatedUserDeleteStageList {
  pagination: Pagination!
  results: [UserDeleteStage]!
}

"""UserDeleteStage Serializer"""
type UserDeleteStage {
  pk: UUID!
  name: String!
  """Get object type so that we know how to edit the object"""
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  flowSet: [FlowSet]
}

union StagesUserDeleteRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UserDeleteStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UserDeleteStage | ValidationError | GenericError

union StagesUserDeleteUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union StagesUserLoginListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedUserLoginStageList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedUserLoginStageList | ValidationError | GenericError

type PaginatedUserLoginStageList {
  pagination: Pagination!
  results: [UserLoginStage]!
}

"""UserLoginStage Serializer"""
type UserLoginStage {
  pk: UUID!
  name: String!
  """Get object type so that we know how to edit the object"""
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  flowSet: [FlowSet]
  """
  Determines how long a session lasts. Default of 0 means that the sessions lasts until the browser is closed. (Format: hours=-1;minutes=-2;seconds=-3)
  """
  sessionDuration: String
  """Terminate all other sessions of the user logging in."""
  terminateOtherSessions: Boolean
  """
  Offset the session will be extended by when the user picks the remember me option. Default of 0 means that the remember me option will not be shown. (Format: hours=-1;minutes=-2;seconds=-3)
  """
  rememberMeOffset: String
  networkBinding: NetworkBindingEnum
  geoipBinding: GeoipBindingEnum
}

enum NetworkBindingEnum {
  NO_BINDING
  BIND_ASN
  BIND_ASN_NETWORK
  BIND_ASN_NETWORK_IP
}

enum GeoipBindingEnum {
  NO_BINDING
  BIND_CONTINENT
  BIND_CONTINENT_COUNTRY
  BIND_CONTINENT_COUNTRY_CITY
}

"""Bind sessions created by this stage to the configured GeoIP location"""
enum QueryInputStagesUserLoginListGeoipBinding {
  BIND_CONTINENT
  BIND_CONTINENT_COUNTRY
  BIND_CONTINENT_COUNTRY_CITY
  NO_BINDING
}

"""Bind sessions created by this stage to the configured network"""
enum QueryInputStagesUserLoginListNetworkBinding {
  BIND_ASN
  BIND_ASN_NETWORK
  BIND_ASN_NETWORK_IP
  NO_BINDING
}

union StagesUserLoginRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UserLoginStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UserLoginStage | ValidationError | GenericError

union StagesUserLoginUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union StagesUserLogoutListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedUserLogoutStageList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedUserLogoutStageList | ValidationError | GenericError

type PaginatedUserLogoutStageList {
  pagination: Pagination!
  results: [UserLogoutStage]!
}

"""UserLogoutStage Serializer"""
type UserLogoutStage {
  pk: UUID!
  name: String!
  """Get object type so that we know how to edit the object"""
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  flowSet: [FlowSet]
}

union StagesUserLogoutRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UserLogoutStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UserLogoutStage | ValidationError | GenericError

union StagesUserLogoutUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union StagesUserWriteListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PaginatedUserWriteStageList") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PaginatedUserWriteStageList | ValidationError | GenericError

type PaginatedUserWriteStageList {
  pagination: Pagination!
  results: [UserWriteStage]!
}

"""UserWriteStage Serializer"""
type UserWriteStage {
  pk: UUID!
  name: String!
  """Get object type so that we know how to edit the object"""
  component: String!
  """Return object's verbose_name"""
  verboseName: String!
  """Return object's plural verbose_name"""
  verboseNamePlural: String!
  """Return internal model name"""
  metaModelName: String!
  flowSet: [FlowSet]
  userCreationMode: UserCreationModeEnum
  """When set, newly created users are inactive and cannot login."""
  createUsersAsInactive: Boolean
  """Optionally add newly created users to this group."""
  createUsersGroup: UUID
  userType: UserTypeEnum
  userPathTemplate: String
}

enum UserCreationModeEnum {
  NEVER_CREATE
  CREATE_WHEN_REQUIRED
  ALWAYS_CREATE
}

enum QueryInputStagesUserWriteListUserCreationMode {
  ALWAYS_CREATE
  CREATE_WHEN_REQUIRED
  NEVER_CREATE
}

enum QueryInputStagesUserWriteListUserType {
  EXTERNAL
  INTERNAL
  INTERNAL_SERVICE_ACCOUNT
  SERVICE_ACCOUNT
}

union StagesUserWriteRetrieveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UserWriteStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UserWriteStage | ValidationError | GenericError

union StagesUserWriteUsedByListResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UsedBy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UsedBy | ValidationError | GenericError

union AdminSettingsUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Settings") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Settings | ValidationError | GenericError

"""Settings Serializer"""
input SettingsRequestInput {
  """Configure how authentik should show avatars for users."""
  avatars: NonEmptyString
  """Enable the ability for users to change their name."""
  defaultUserChangeName: Boolean
  """Enable the ability for users to change their email address."""
  defaultUserChangeEmail: Boolean
  """Enable the ability for users to change their username."""
  defaultUserChangeUsername: Boolean
  """
  Events will be deleted after this duration.(Format: weeks=3;days=2;hours=3,seconds=2).
  """
  eventRetention: NonEmptyString
  """The option configures the footer links on the flow executor pages."""
  footerLinks: JSON
  """
  When enabled, all the events caused by a user will be deleted upon the user's deletion.
  """
  gdprCompliance: Boolean
  """Globally enable/disable impersonation."""
  impersonation: Boolean
  """Default token duration"""
  defaultTokenDuration: NonEmptyString
  """Default token length"""
  defaultTokenLength: PositiveInt
}

"""A string that cannot be passed as an empty value"""
scalar NonEmptyString

union AdminSettingsPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Settings") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Settings | ValidationError | GenericError

"""Settings Serializer"""
input PatchedSettingsRequestInput {
  """Configure how authentik should show avatars for users."""
  avatars: NonEmptyString
  """Enable the ability for users to change their name."""
  defaultUserChangeName: Boolean
  """Enable the ability for users to change their email address."""
  defaultUserChangeEmail: Boolean
  """Enable the ability for users to change their username."""
  defaultUserChangeUsername: Boolean
  """
  Events will be deleted after this duration.(Format: weeks=3;days=2;hours=3,seconds=2).
  """
  eventRetention: NonEmptyString
  """The option configures the footer links on the flow executor pages."""
  footerLinks: JSON
  """
  When enabled, all the events caused by a user will be deleted upon the user's deletion.
  """
  gdprCompliance: Boolean
  """Globally enable/disable impersonation."""
  impersonation: Boolean
  """Default token duration"""
  defaultTokenDuration: NonEmptyString
  """Default token length"""
  defaultTokenLength: PositiveInt
}

union AdminSystemCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "SystemInfo") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = SystemInfo | ValidationError | GenericError

union AuthenticatorsAdminDuoCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "DuoDevice") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = DuoDevice | ValidationError | GenericError

"""Serializer for Duo authenticator devices"""
input DuoDeviceRequestInput {
  """The human-readable name of this device."""
  name: MutationInputAuthenticatorsAdminDuoCreateInputName!
}

"""The human-readable name of this device."""
scalar MutationInputAuthenticatorsAdminDuoCreateInputName @length(subgraph: "Authentik", min: 1, max: 64)

union AuthenticatorsAdminDuoUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "DuoDevice") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = DuoDevice | ValidationError | GenericError

union AuthenticatorsAdminDuoPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "DuoDevice") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = DuoDevice | ValidationError | GenericError

"""Serializer for Duo authenticator devices"""
input PatchedDuoDeviceRequestInput {
  """The human-readable name of this device."""
  name: MutationInputAuthenticatorsAdminDuoPartialUpdateInputName
}

"""The human-readable name of this device."""
scalar MutationInputAuthenticatorsAdminDuoPartialUpdateInputName @length(subgraph: "Authentik", min: 1, max: 64)

union AuthenticatorsAdminDuoDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union AuthenticatorsAdminSmsCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "SMSDevice") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = SmsDevice | ValidationError | GenericError

"""Serializer for sms authenticator devices"""
input SmsDeviceRequestInput {
  """The human-readable name of this device."""
  name: MutationInputAuthenticatorsAdminSmsCreateInputName!
}

"""The human-readable name of this device."""
scalar MutationInputAuthenticatorsAdminSmsCreateInputName @length(subgraph: "Authentik", min: 1, max: 64)

union AuthenticatorsAdminSmsUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "SMSDevice") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = SmsDevice | ValidationError | GenericError

union AuthenticatorsAdminSmsPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "SMSDevice") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = SmsDevice | ValidationError | GenericError

"""Serializer for sms authenticator devices"""
input PatchedSmsDeviceRequestInput {
  """The human-readable name of this device."""
  name: MutationInputAuthenticatorsAdminSmsPartialUpdateInputName
}

"""The human-readable name of this device."""
scalar MutationInputAuthenticatorsAdminSmsPartialUpdateInputName @length(subgraph: "Authentik", min: 1, max: 64)

union AuthenticatorsAdminSmsDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union AuthenticatorsAdminStaticCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "StaticDevice") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = StaticDevice | ValidationError | GenericError

"""Serializer for static authenticator devices"""
input StaticDeviceRequestInput {
  """The human-readable name of this device."""
  name: MutationInputAuthenticatorsAdminStaticCreateInputName!
}

"""The human-readable name of this device."""
scalar MutationInputAuthenticatorsAdminStaticCreateInputName @length(subgraph: "Authentik", min: 1, max: 64)

union AuthenticatorsAdminStaticUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "StaticDevice") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = StaticDevice | ValidationError | GenericError

union AuthenticatorsAdminStaticPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "StaticDevice") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = StaticDevice | ValidationError | GenericError

"""Serializer for static authenticator devices"""
input PatchedStaticDeviceRequestInput {
  """The human-readable name of this device."""
  name: MutationInputAuthenticatorsAdminStaticPartialUpdateInputName
}

"""The human-readable name of this device."""
scalar MutationInputAuthenticatorsAdminStaticPartialUpdateInputName @length(subgraph: "Authentik", min: 1, max: 64)

union AuthenticatorsAdminStaticDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union AuthenticatorsAdminTotpCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "TOTPDevice") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = TotpDevice | ValidationError | GenericError

"""Serializer for totp authenticator devices"""
input TotpDeviceRequestInput {
  """The human-readable name of this device."""
  name: MutationInputAuthenticatorsAdminTotpCreateInputName!
}

"""The human-readable name of this device."""
scalar MutationInputAuthenticatorsAdminTotpCreateInputName @length(subgraph: "Authentik", min: 1, max: 64)

union AuthenticatorsAdminTotpUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "TOTPDevice") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = TotpDevice | ValidationError | GenericError

union AuthenticatorsAdminTotpPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "TOTPDevice") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = TotpDevice | ValidationError | GenericError

"""Serializer for totp authenticator devices"""
input PatchedTotpDeviceRequestInput {
  """The human-readable name of this device."""
  name: MutationInputAuthenticatorsAdminTotpPartialUpdateInputName
}

"""The human-readable name of this device."""
scalar MutationInputAuthenticatorsAdminTotpPartialUpdateInputName @length(subgraph: "Authentik", min: 1, max: 64)

union AuthenticatorsAdminTotpDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union AuthenticatorsAdminWebauthnCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "WebAuthnDevice") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = WebAuthnDevice | ValidationError | GenericError

"""Serializer for WebAuthn authenticator devices"""
input WebAuthnDeviceRequestInput {
  name: MutationInputAuthenticatorsAdminWebauthnCreateInputName!
}

scalar MutationInputAuthenticatorsAdminWebauthnCreateInputName @length(subgraph: "Authentik", min: 1, max: 200)

union AuthenticatorsAdminWebauthnUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "WebAuthnDevice") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = WebAuthnDevice | ValidationError | GenericError

union AuthenticatorsAdminWebauthnPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "WebAuthnDevice") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = WebAuthnDevice | ValidationError | GenericError

"""Serializer for WebAuthn authenticator devices"""
input PatchedWebAuthnDeviceRequestInput {
  name: MutationInputAuthenticatorsAdminWebauthnPartialUpdateInputName
}

scalar MutationInputAuthenticatorsAdminWebauthnPartialUpdateInputName @length(subgraph: "Authentik", min: 1, max: 200)

union AuthenticatorsAdminWebauthnDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union AuthenticatorsDuoUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "DuoDevice") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = DuoDevice | ValidationError | GenericError

union AuthenticatorsDuoPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "DuoDevice") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = DuoDevice | ValidationError | GenericError

union AuthenticatorsDuoDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union AuthenticatorsSmsUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "SMSDevice") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = SmsDevice | ValidationError | GenericError

union AuthenticatorsSmsPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "SMSDevice") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = SmsDevice | ValidationError | GenericError

union AuthenticatorsSmsDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union AuthenticatorsStaticUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "StaticDevice") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = StaticDevice | ValidationError | GenericError

union AuthenticatorsStaticPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "StaticDevice") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = StaticDevice | ValidationError | GenericError

union AuthenticatorsStaticDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union AuthenticatorsTotpUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "TOTPDevice") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = TotpDevice | ValidationError | GenericError

union AuthenticatorsTotpPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "TOTPDevice") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = TotpDevice | ValidationError | GenericError

union AuthenticatorsTotpDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union AuthenticatorsWebauthnUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "WebAuthnDevice") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = WebAuthnDevice | ValidationError | GenericError

union AuthenticatorsWebauthnPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "WebAuthnDevice") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = WebAuthnDevice | ValidationError | GenericError

union AuthenticatorsWebauthnDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union CoreApplicationsCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "Application") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Application | ValidationError | GenericError

"""Application Serializer"""
input ApplicationRequestInput {
  """Application's display Name."""
  name: NonEmptyString!
  slug: MutationInputCoreApplicationsCreateInputSlug!
  provider: Int
  backchannelProviders: [Int]
  """Open launch URL in a new browser tab or window."""
  openInNewTab: Boolean
  metaLaunchUrl: URL
  metaDescription: String
  metaPublisher: String
  policyEngineMode: PolicyEngineMode
  group: String
}

scalar MutationInputCoreApplicationsCreateInputSlug @regexp(subgraph: "Authentik", pattern: "^[-a-zA-Z0-9_]+$") @typescript(subgraph: "Authentik", type: "string")

union CoreApplicationsUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Application") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Application | ValidationError | GenericError

union CoreApplicationsPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Application") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Application | ValidationError | GenericError

"""Application Serializer"""
input PatchedApplicationRequestInput {
  """Application's display Name."""
  name: NonEmptyString
  slug: MutationInputCoreApplicationsPartialUpdateInputSlug
  provider: Int
  backchannelProviders: [Int]
  """Open launch URL in a new browser tab or window."""
  openInNewTab: Boolean
  metaLaunchUrl: URL
  metaDescription: String
  metaPublisher: String
  policyEngineMode: PolicyEngineMode
  group: String
}

scalar MutationInputCoreApplicationsPartialUpdateInputSlug @regexp(subgraph: "Authentik", pattern: "^[-a-zA-Z0-9_]+$") @typescript(subgraph: "Authentik", type: "string")

union CoreApplicationsDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

"""Serializer to upload file"""
input FileUploadRequestInput {
  file: File
  clear: Boolean
}

"""Serializer to upload file"""
input FilePathRequestInput {
  url: NonEmptyString!
}

union CoreAuthenticatedSessionsDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union CoreBrandsCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "Brand") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Brand | ValidationError | GenericError

"""Brand Serializer"""
input BrandRequestInput {
  """
  Domain that activates this brand. Can be a superset, i.e. `a.b` for `aa.b` and `ba.b`
  """
  domain: NonEmptyString!
  default: Boolean
  brandingTitle: NonEmptyString
  brandingLogo: NonEmptyString
  brandingFavicon: NonEmptyString
  flowAuthentication: UUID
  flowInvalidation: UUID
  flowRecovery: UUID
  flowUnenrollment: UUID
  flowUserSettings: UUID
  flowDeviceCode: UUID
  """Web Certificate used by the authentik Core webserver."""
  webCertificate: UUID
  attributes: JSON
}

union CoreBrandsUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Brand") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Brand | ValidationError | GenericError

union CoreBrandsPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Brand") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Brand | ValidationError | GenericError

"""Brand Serializer"""
input PatchedBrandRequestInput {
  """
  Domain that activates this brand. Can be a superset, i.e. `a.b` for `aa.b` and `ba.b`
  """
  domain: NonEmptyString
  default: Boolean
  brandingTitle: NonEmptyString
  brandingLogo: NonEmptyString
  brandingFavicon: NonEmptyString
  flowAuthentication: UUID
  flowInvalidation: UUID
  flowRecovery: UUID
  flowUnenrollment: UUID
  flowUserSettings: UUID
  flowDeviceCode: UUID
  """Web Certificate used by the authentik Core webserver."""
  webCertificate: UUID
  attributes: JSON
}

union CoreBrandsDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union CoreGroupsCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "Group") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Group | ValidationError | GenericError

"""Group Serializer"""
input GroupRequestInput {
  name: MutationInputCoreGroupsCreateInputName!
  """Users added to this group will be superusers."""
  isSuperuser: Boolean
  parent: UUID
  users: [Int]
  attributes: JSON
  roles: [UUID]
}

scalar MutationInputCoreGroupsCreateInputName @length(subgraph: "Authentik", min: 1, max: 80)

union CoreGroupsUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Group") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Group | ValidationError | GenericError

union CoreGroupsPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Group") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Group | ValidationError | GenericError

"""Group Serializer"""
input PatchedGroupRequestInput {
  name: MutationInputCoreGroupsPartialUpdateInputName
  """Users added to this group will be superusers."""
  isSuperuser: Boolean
  parent: UUID
  users: [Int]
  attributes: JSON
  roles: [UUID]
}

scalar MutationInputCoreGroupsPartialUpdateInputName @length(subgraph: "Authentik", min: 1, max: 80)

union CoreGroupsDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union CoreGroupsAddUserCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

"""Account adding/removing operations"""
input UserAccountRequestInput {
  pk: Int!
}

union CoreGroupsRemoveUserCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union CoreTokensCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "Token") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Token | ValidationError | GenericError

"""Token Serializer"""
input TokenRequestInput {
  """
  Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.
  """
  managed: NonEmptyString
  identifier: MutationInputCoreTokensCreateInputIdentifier!
  intent: IntentEnum
  user: Int
  description: String
  expires: DateTime
  expiring: Boolean
}

scalar MutationInputCoreTokensCreateInputIdentifier @regexp(subgraph: "Authentik", pattern: "^[-a-zA-Z0-9_]+$") @typescript(subgraph: "Authentik", type: "string")

union CoreTokensUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Token") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Token | ValidationError | GenericError

union CoreTokensPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Token") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Token | ValidationError | GenericError

"""Token Serializer"""
input PatchedTokenRequestInput {
  """
  Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.
  """
  managed: NonEmptyString
  identifier: MutationInputCoreTokensPartialUpdateInputIdentifier
  intent: IntentEnum
  user: Int
  description: String
  expires: DateTime
  expiring: Boolean
}

scalar MutationInputCoreTokensPartialUpdateInputIdentifier @regexp(subgraph: "Authentik", pattern: "^[-a-zA-Z0-9_]+$") @typescript(subgraph: "Authentik", type: "string")

union CoreTokensDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union CoreTokensSetKeyCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | GenericError

input TokenSetKeyRequestInput {
  key: NonEmptyString!
}

union CoreTransactionalApplicationsUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "TransactionApplicationResponse") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = TransactionApplicationResponse | ValidationError | GenericError

"""Transactional creation response"""
type TransactionApplicationResponse {
  applied: Boolean!
  logs: [String]!
}

"""
Serializer for creating a provider and an application in one transaction
"""
input TransactionApplicationRequestInput {
  app: ApplicationRequestInput!
  providerModel: ProviderModelEnum!
  provider: ModelRequestInput!
}

enum ProviderModelEnum {
  AUTHENTIK_PROVIDERS_LDAP_LDAPPROVIDER @enum(subgraph: "Authentik", value: "\"authentik_providers_ldap.ldapprovider\"")
  AUTHENTIK_PROVIDERS_OAUTH2_OAUTH2PROVIDER @enum(subgraph: "Authentik", value: "\"authentik_providers_oauth2.oauth2provider\"")
  AUTHENTIK_PROVIDERS_PROXY_PROXYPROVIDER @enum(subgraph: "Authentik", value: "\"authentik_providers_proxy.proxyprovider\"")
  AUTHENTIK_PROVIDERS_RAC_RACPROVIDER @enum(subgraph: "Authentik", value: "\"authentik_providers_rac.racprovider\"")
  AUTHENTIK_PROVIDERS_RADIUS_RADIUSPROVIDER @enum(subgraph: "Authentik", value: "\"authentik_providers_radius.radiusprovider\"")
  AUTHENTIK_PROVIDERS_SAML_SAMLPROVIDER @enum(subgraph: "Authentik", value: "\"authentik_providers_saml.samlprovider\"")
  AUTHENTIK_PROVIDERS_SCIM_SCIMPROVIDER @enum(subgraph: "Authentik", value: "\"authentik_providers_scim.scimprovider\"")
}

input ModelRequestInput @oneOf(subgraph: "Authentik") {
  ldapProviderRequestInput: LdapProviderRequestInput
  oAuth2ProviderRequestInput: OAuth2ProviderRequestInput
  proxyProviderRequestInput: ProxyProviderRequestInput
  racProviderRequestInput: RacProviderRequestInput
  radiusProviderRequestInput: RadiusProviderRequestInput
  samlProviderRequestInput: SamlProviderRequestInput
  scimProviderRequestInput: ScimProviderRequestInput
}

"""LDAPProvider Serializer"""
input LdapProviderRequestInput {
  name: NonEmptyString!
  """
  Flow used for authentication when the associated application is accessed by an un-authenticated user.
  """
  authenticationFlow: UUID
  """Flow used when authorizing this provider."""
  authorizationFlow: UUID!
  propertyMappings: [UUID]
  """DN under which objects are accessible."""
  baseDn: NonEmptyString
  """
  Users in this group can do search queries. If not set, every user can execute search queries.
  """
  searchGroup: UUID
  certificate: UUID
  tlsServerName: String
  """
  The start for uidNumbers, this number is added to the user.pk to make sure that the numbers aren't too low for POSIX users. Default is 2000 to ensure that we don't collide with local users uidNumber
  """
  uidStartNumber: Int
  """
  The start for gidNumbers, this number is added to a number generated from the group.pk to make sure that the numbers aren't too low for POSIX groups. Default is 4000 to ensure that we don't collide with local groups or users primary groups gidNumber
  """
  gidStartNumber: Int
  searchMode: LdapapiAccessMode
  bindMode: LdapapiAccessMode
  """
  When enabled, code-based multi-factor authentication can be used by appending a semicolon and the TOTP code to the password. This should only be enabled if all users that will bind to this provider have a TOTP device configured, as otherwise a password may incorrectly be rejected if it contains a semicolon.
  """
  mfaSupport: Boolean
}

"""OAuth2Provider Serializer"""
input OAuth2ProviderRequestInput {
  name: NonEmptyString!
  """
  Flow used for authentication when the associated application is accessed by an un-authenticated user.
  """
  authenticationFlow: UUID
  """Flow used when authorizing this provider."""
  authorizationFlow: UUID!
  propertyMappings: [UUID]
  clientType: ClientTypeEnum
  clientId: MutationInputCoreTransactionalApplicationsUpdateInputProviderOneOf_1ClientId
  clientSecret: MutationInputCoreTransactionalApplicationsUpdateInputProviderOneOf_1ClientSecret
  """
  Access codes not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).
  """
  accessCodeValidity: NonEmptyString
  """
  Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).
  """
  accessTokenValidity: NonEmptyString
  """
  Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).
  """
  refreshTokenValidity: NonEmptyString
  """
  Include User claims from scopes in the id_token, for applications that don't access the userinfo endpoint.
  """
  includeClaimsInIdToken: Boolean
  """
  Key used to sign the tokens. Only required when JWT Algorithm is set to RS256.
  """
  signingKey: UUID
  """Enter each URI on a new line."""
  redirectUris: String
  subMode: SubModeEnum
  issuerMode: IssuerModeEnum
  jwksSources: [UUID]
}

scalar MutationInputCoreTransactionalApplicationsUpdateInputProviderOneOf_1ClientId @length(subgraph: "Authentik", min: 1, max: 255)

scalar MutationInputCoreTransactionalApplicationsUpdateInputProviderOneOf_1ClientSecret @length(subgraph: "Authentik", max: 255)

"""ProxyProvider Serializer"""
input ProxyProviderRequestInput {
  name: NonEmptyString!
  """
  Flow used for authentication when the associated application is accessed by an un-authenticated user.
  """
  authenticationFlow: UUID
  """Flow used when authorizing this provider."""
  authorizationFlow: UUID!
  propertyMappings: [UUID]
  internalHost: URL
  externalHost: URL!
  """Validate SSL Certificates of upstream servers"""
  internalHostSslValidation: Boolean
  certificate: UUID
  """
  Regular expressions for which authentication is not required. Each new line is interpreted as a new Regular Expression.
  """
  skipPathRegex: String
  """
  Set a custom HTTP-Basic Authentication header based on values from authentik.
  """
  basicAuthEnabled: Boolean
  """
  User/Group Attribute used for the password part of the HTTP-Basic Header.
  """
  basicAuthPasswordAttribute: String
  """
  User/Group Attribute used for the user part of the HTTP-Basic Header. If not set, the user's Email address is used.
  """
  basicAuthUserAttribute: String
  mode: ProxyMode
  """
  When enabled, this provider will intercept the authorization header and authenticate requests based on its value.
  """
  interceptHeaderAuth: Boolean
  cookieDomain: String
  jwksSources: [UUID]
  """
  Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).
  """
  accessTokenValidity: NonEmptyString
  """
  Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).
  """
  refreshTokenValidity: NonEmptyString
}

"""RACProvider Serializer"""
input RacProviderRequestInput {
  name: NonEmptyString!
  """
  Flow used for authentication when the associated application is accessed by an un-authenticated user.
  """
  authenticationFlow: UUID
  """Flow used when authorizing this provider."""
  authorizationFlow: UUID!
  propertyMappings: [UUID]
  settings: JSON
  """
  Determines how long a session lasts. Default of 0 means that the sessions lasts until the browser is closed. (Format: hours=-1;minutes=-2;seconds=-3)
  """
  connectionExpiry: NonEmptyString
  """When set to true, connection tokens will be deleted upon disconnect."""
  deleteTokenOnDisconnect: Boolean
}

"""RadiusProvider Serializer"""
input RadiusProviderRequestInput {
  name: NonEmptyString!
  """
  Flow used for authentication when the associated application is accessed by an un-authenticated user.
  """
  authenticationFlow: UUID
  """Flow used when authorizing this provider."""
  authorizationFlow: UUID!
  propertyMappings: [UUID]
  """
  List of CIDRs (comma-separated) that clients can connect from. A more specific CIDR will match before a looser one. Clients connecting from a non-specified CIDR will be dropped.
  """
  clientNetworks: NonEmptyString
  """Shared secret between clients and server to hash packets."""
  sharedSecret: NonEmptyString
  """
  When enabled, code-based multi-factor authentication can be used by appending a semicolon and the TOTP code to the password. This should only be enabled if all users that will bind to this provider have a TOTP device configured, as otherwise a password may incorrectly be rejected if it contains a semicolon.
  """
  mfaSupport: Boolean
}

"""SAMLProvider Serializer"""
input SamlProviderRequestInput {
  name: NonEmptyString!
  """
  Flow used for authentication when the associated application is accessed by an un-authenticated user.
  """
  authenticationFlow: UUID
  """Flow used when authorizing this provider."""
  authorizationFlow: UUID!
  propertyMappings: [UUID]
  acsUrl: URL!
  """
  Value of the audience restriction field of the assertion. When left empty, no audience restriction will be added.
  """
  audience: String
  """Also known as EntityID"""
  issuer: NonEmptyString
  """
  Assertion valid not before current time + this value (Format: hours=-1;minutes=-2;seconds=-3).
  """
  assertionValidNotBefore: NonEmptyString
  """
  Assertion not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).
  """
  assertionValidNotOnOrAfter: NonEmptyString
  """
  Session not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).
  """
  sessionValidNotOnOrAfter: NonEmptyString
  """
  Configure how the NameID value will be created. When left empty, the NameIDPolicy of the incoming request will be considered
  """
  nameIdMapping: UUID
  digestAlgorithm: DigestAlgorithmEnum
  signatureAlgorithm: SignatureAlgorithmEnum
  """Keypair used to sign outgoing Responses going to the Service Provider."""
  signingKp: UUID
  """
  When selected, incoming assertion's Signatures will be validated against this certificate. To allow unsigned Requests, leave on default.
  """
  verificationKp: UUID
  """
  This determines how authentik sends the response back to the Service Provider.
  """
  spBinding: JSON
  """Default relay_state value for IDP-initiated logins"""
  defaultRelayState: String
}

"""SCIMProvider Serializer"""
input ScimProviderRequestInput {
  name: NonEmptyString!
  propertyMappings: [UUID]
  """Property mappings used for group creation/updating."""
  propertyMappingsGroup: [UUID]
  """Base URL to SCIM requests, usually ends in /v2"""
  url: NonEmptyString!
  """Authentication token"""
  token: NonEmptyString!
  excludeUsersServiceAccount: Boolean
  filterGroup: UUID
}

union CoreUserConsentDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union CoreUsersCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "User") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = User | ValidationError | GenericError

"""User Serializer"""
input UserRequestInput {
  username: MutationInputCoreUsersCreateInputUsername!
  """User's display name."""
  name: String!
  """
  Designates whether this user should be treated as active. Unselect this instead of deleting accounts.
  """
  isActive: Boolean
  lastLogin: DateTime
  groups: [UUID]
  email: EmailAddress
  attributes: JSON
  path: NonEmptyString
  type: UserTypeEnum
}

scalar MutationInputCoreUsersCreateInputUsername @length(subgraph: "Authentik", min: 1, max: 150)

union CoreUsersUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "User") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = User | ValidationError | GenericError

union CoreUsersPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "User") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = User | ValidationError | GenericError

"""User Serializer"""
input PatchedUserRequestInput {
  username: MutationInputCoreUsersPartialUpdateInputUsername
  """User's display name."""
  name: String
  """
  Designates whether this user should be treated as active. Unselect this instead of deleting accounts.
  """
  isActive: Boolean
  lastLogin: DateTime
  groups: [UUID]
  email: EmailAddress
  attributes: JSON
  path: NonEmptyString
  type: UserTypeEnum
}

scalar MutationInputCoreUsersPartialUpdateInputUsername @length(subgraph: "Authentik", min: 1, max: 150)

union CoreUsersDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union CoreUsersImpersonateCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union CoreUsersRecoveryCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Link") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Link | ValidationError | GenericError

union CoreUsersRecoveryEmailCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union CoreUsersSetPasswordCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | GenericError

input UserPasswordSetRequestInput {
  password: NonEmptyString!
}

union CoreUsersServiceAccountCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UserServiceAccountResponse") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UserServiceAccountResponse | ValidationError | GenericError

type UserServiceAccountResponse {
  username: String!
  token: String!
  userUid: String!
  userPk: Int!
  groupPk: String
}

input UserServiceAccountRequestInput {
  name: NonEmptyString!
  createGroup: Boolean
  expiring: Boolean = true
  """If not provided, valid for 360 days"""
  expires: DateTime
}

union CryptoCertificatekeypairsCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "CertificateKeyPair") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = CertificateKeyPair | ValidationError | GenericError

"""CertificateKeyPair Serializer"""
input CertificateKeyPairRequestInput {
  name: NonEmptyString!
  """PEM-encoded Certificate data"""
  certificateData: NonEmptyString!
  """
  Optional Private Key. If this is set, you can use this keypair for encryption.
  """
  keyData: String
}

union CryptoCertificatekeypairsUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "CertificateKeyPair") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = CertificateKeyPair | ValidationError | GenericError

union CryptoCertificatekeypairsPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "CertificateKeyPair") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = CertificateKeyPair | ValidationError | GenericError

"""CertificateKeyPair Serializer"""
input PatchedCertificateKeyPairRequestInput {
  name: NonEmptyString
  """PEM-encoded Certificate data"""
  certificateData: NonEmptyString
  """
  Optional Private Key. If this is set, you can use this keypair for encryption.
  """
  keyData: String
}

union CryptoCertificatekeypairsDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union CryptoCertificatekeypairsGenerateCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "CertificateKeyPair") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = CertificateKeyPair | GenericError

"""Certificate generation parameters"""
input CertificateGenerationRequestInput {
  commonName: NonEmptyString!
  subjectAltName: String
  validityDays: Int!
  alg: AlgEnum
}

enum AlgEnum {
  RSA
  ECDSA
}

union EnterpriseLicenseCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "License") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = License | ValidationError | GenericError

"""License Serializer"""
input LicenseRequestInput {
  key: NonEmptyString!
}

union EnterpriseLicenseUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "License") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = License | ValidationError | GenericError

union EnterpriseLicensePartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "License") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = License | ValidationError | GenericError

"""License Serializer"""
input PatchedLicenseRequestInput {
  key: NonEmptyString
}

union EnterpriseLicenseDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union EventsEventsCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "Event") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Event | ValidationError | GenericError

"""Event Serializer"""
input EventRequestInput {
  user: JSON
  action: EventActions!
  app: NonEmptyString!
  context: JSON
  clientIp: NonEmptyString
  expires: DateTime
  brand: JSON
}

union EventsEventsUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Event") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Event | ValidationError | GenericError

union EventsEventsPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Event") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Event | ValidationError | GenericError

"""Event Serializer"""
input PatchedEventRequestInput {
  user: JSON
  action: EventActions
  app: NonEmptyString
  context: JSON
  clientIp: NonEmptyString
  expires: DateTime
  brand: JSON
}

union EventsEventsDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union EventsNotificationsUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Notification") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Notification | ValidationError | GenericError

"""Notification Serializer"""
input NotificationRequestInput {
  event: EventRequestInput
  seen: Boolean
}

union EventsNotificationsPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Notification") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Notification | ValidationError | GenericError

"""Notification Serializer"""
input PatchedNotificationRequestInput {
  event: EventRequestInput
  seen: Boolean
}

union EventsNotificationsDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union EventsNotificationsMarkAllSeenCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union EventsRulesCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "NotificationRule") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = NotificationRule | ValidationError | GenericError

"""NotificationRule Serializer"""
input NotificationRuleRequestInput {
  name: NonEmptyString!
  """
  Select which transports should be used to notify the user. If none are selected, the notification will only be shown in the authentik UI.
  """
  transports: [UUID]
  severity: SeverityEnum
  """
  Define which group of users this notification should be sent and shown to. If left empty, Notification won't ben sent.
  """
  group: UUID
}

union EventsRulesUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "NotificationRule") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = NotificationRule | ValidationError | GenericError

union EventsRulesPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "NotificationRule") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = NotificationRule | ValidationError | GenericError

"""NotificationRule Serializer"""
input PatchedNotificationRuleRequestInput {
  name: NonEmptyString
  """
  Select which transports should be used to notify the user. If none are selected, the notification will only be shown in the authentik UI.
  """
  transports: [UUID]
  severity: SeverityEnum
  """
  Define which group of users this notification should be sent and shown to. If left empty, Notification won't ben sent.
  """
  group: UUID
}

union EventsRulesDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union EventsSystemTasksRunCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union EventsTransportsCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "NotificationTransport") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = NotificationTransport | ValidationError | GenericError

"""NotificationTransport Serializer"""
input NotificationTransportRequestInput {
  name: NonEmptyString!
  mode: NotificationTransportModeEnum
  webhookUrl: URL
  webhookMapping: UUID
  """
  Only send notification once, for example when sending a webhook into a chat channel.
  """
  sendOnce: Boolean
}

union EventsTransportsUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "NotificationTransport") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = NotificationTransport | ValidationError | GenericError

union EventsTransportsPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "NotificationTransport") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = NotificationTransport | ValidationError | GenericError

"""NotificationTransport Serializer"""
input PatchedNotificationTransportRequestInput {
  name: NonEmptyString
  mode: NotificationTransportModeEnum
  webhookUrl: URL
  webhookMapping: UUID
  """
  Only send notification once, for example when sending a webhook into a chat channel.
  """
  sendOnce: Boolean
}

union EventsTransportsDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union EventsTransportsTestCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "NotificationTransportTest") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = NotificationTransportTest | ValidationError | GenericError

"""Notification test serializer"""
type NotificationTransportTest {
  messages: [String]!
}

union FlowsBindingsCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "FlowStageBinding") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = FlowStageBinding | ValidationError | GenericError

"""FlowStageBinding Serializer"""
input FlowStageBindingRequestInput {
  target: UUID!
  stage: UUID!
  """Evaluate policies during the Flow planning process."""
  evaluateOnPlan: Boolean
  """Evaluate policies when the Stage is present to the user."""
  reEvaluatePolicies: Boolean
  order: Int!
  policyEngineMode: PolicyEngineMode
  invalidResponseAction: InvalidResponseActionEnum
}

union FlowsBindingsUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "FlowStageBinding") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = FlowStageBinding | ValidationError | GenericError

union FlowsBindingsPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "FlowStageBinding") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = FlowStageBinding | ValidationError | GenericError

"""FlowStageBinding Serializer"""
input PatchedFlowStageBindingRequestInput {
  target: UUID
  stage: UUID
  """Evaluate policies during the Flow planning process."""
  evaluateOnPlan: Boolean
  """Evaluate policies when the Stage is present to the user."""
  reEvaluatePolicies: Boolean
  order: Int
  policyEngineMode: PolicyEngineMode
  invalidResponseAction: InvalidResponseActionEnum
}

union FlowsBindingsDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union FlowsExecutorSolveResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = AccessDeniedChallenge | AppleLoginChallenge | AuthenticatorDuoChallenge | AuthenticatorSmsChallenge | AuthenticatorStaticChallenge | AuthenticatorTotpChallenge | AuthenticatorValidationChallenge | AuthenticatorWebAuthnChallenge | AutosubmitChallenge | CaptchaChallenge | ConsentChallenge | EmailChallenge | FlowErrorChallenge | IdentificationChallenge | OAuthDeviceCodeChallenge | OAuthDeviceCodeFinishChallenge | PasswordChallenge | PlexAuthenticationChallenge | PromptChallenge | RedirectChallenge | ShellChallenge | UserLoginChallenge | ValidationError | GenericError

input FlowChallengeResponseRequestInput @oneOf(subgraph: "Authentik") {
  appleChallengeResponseRequestInput: AppleChallengeResponseRequestInput
  authenticatorDuoChallengeResponseRequestInput: AuthenticatorDuoChallengeResponseRequestInput
  authenticatorSmsChallengeResponseRequestInput: AuthenticatorSmsChallengeResponseRequestInput
  authenticatorStaticChallengeResponseRequestInput: AuthenticatorStaticChallengeResponseRequestInput
  authenticatorTotpChallengeResponseRequestInput: AuthenticatorTotpChallengeResponseRequestInput
  authenticatorValidationChallengeResponseRequestInput: AuthenticatorValidationChallengeResponseRequestInput
  authenticatorWebAuthnChallengeResponseRequestInput: AuthenticatorWebAuthnChallengeResponseRequestInput
  autoSubmitChallengeResponseRequestInput: AutoSubmitChallengeResponseRequestInput
  captchaChallengeResponseRequestInput: CaptchaChallengeResponseRequestInput
  consentChallengeResponseRequestInput: ConsentChallengeResponseRequestInput
  emailChallengeResponseRequestInput: EmailChallengeResponseRequestInput
  identificationChallengeResponseRequestInput: IdentificationChallengeResponseRequestInput
  oAuthDeviceCodeChallengeResponseRequestInput: OAuthDeviceCodeChallengeResponseRequestInput
  oAuthDeviceCodeFinishChallengeResponseRequestInput: OAuthDeviceCodeFinishChallengeResponseRequestInput
  passwordChallengeResponseRequestInput: PasswordChallengeResponseRequestInput
  plexAuthenticationChallengeResponseRequestInput: PlexAuthenticationChallengeResponseRequestInput
  promptChallengeResponseRequestInput: PromptChallengeResponseRequestInput
  userLoginChallengeResponseRequestInput: UserLoginChallengeResponseRequestInput
}

"""Pseudo class for apple response"""
input AppleChallengeResponseRequestInput {
  component: NonEmptyString = "ak-source-oauth-apple"
}

"""Pseudo class for duo response"""
input AuthenticatorDuoChallengeResponseRequestInput {
  component: NonEmptyString = "ak-stage-authenticator-duo"
}

"""SMS Challenge response, device is set by get_response_instance"""
input AuthenticatorSmsChallengeResponseRequestInput {
  component: NonEmptyString = "ak-stage-authenticator-sms"
  code: Int
  phoneNumber: NonEmptyString
}

"""Pseudo class for static response"""
input AuthenticatorStaticChallengeResponseRequestInput {
  component: NonEmptyString = "ak-stage-authenticator-static"
}

"""TOTP Challenge response, device is set by get_response_instance"""
input AuthenticatorTotpChallengeResponseRequestInput {
  component: NonEmptyString = "ak-stage-authenticator-totp"
  code: Int!
}

"""Challenge used for Code-based and WebAuthn authenticators"""
input AuthenticatorValidationChallengeResponseRequestInput {
  component: NonEmptyString = "ak-stage-authenticator-validate"
  selectedChallenge: DeviceChallengeRequestInput
  selectedStage: NonEmptyString
  code: NonEmptyString
  webauthn: JSON
  duo: Int
}

"""Single device challenge"""
input DeviceChallengeRequestInput {
  deviceClass: NonEmptyString!
  deviceUid: NonEmptyString!
  challenge: JSON!
}

"""WebAuthn Challenge response"""
input AuthenticatorWebAuthnChallengeResponseRequestInput {
  component: NonEmptyString = "ak-stage-authenticator-webauthn"
  response: JSON!
}

"""Pseudo class for autosubmit response"""
input AutoSubmitChallengeResponseRequestInput {
  component: NonEmptyString = "ak-stage-autosubmit"
}

"""Validate captcha token"""
input CaptchaChallengeResponseRequestInput {
  component: NonEmptyString = "ak-stage-captcha"
  token: NonEmptyString!
}

"""Consent challenge response, any valid response request is valid"""
input ConsentChallengeResponseRequestInput {
  component: NonEmptyString = "ak-stage-consent"
  token: NonEmptyString!
}

"""
Email challenge resposen. No fields. This challenge is
always declared invalid to give the user a chance to retry
"""
input EmailChallengeResponseRequestInput {
  component: NonEmptyString = "ak-stage-email"
}

"""Identification challenge"""
input IdentificationChallengeResponseRequestInput {
  component: NonEmptyString = "ak-stage-identification"
  uidField: NonEmptyString!
  password: String
}

"""Response that includes the user-entered device code"""
input OAuthDeviceCodeChallengeResponseRequestInput {
  component: NonEmptyString = "ak-provider-oauth2-device-code"
  code: Int!
}

"""Response that device has been authenticated and tab can be closed"""
input OAuthDeviceCodeFinishChallengeResponseRequestInput {
  component: NonEmptyString = "ak-provider-oauth2-device-code-finish"
}

"""Password challenge response"""
input PasswordChallengeResponseRequestInput {
  component: NonEmptyString = "ak-stage-password"
  password: NonEmptyString!
}

"""Pseudo class for plex response"""
input PlexAuthenticationChallengeResponseRequestInput {
  component: NonEmptyString = "ak-source-plex"
}

"""
Validate response, fields are dynamically created based
on the stage
"""
input PromptChallengeResponseRequestInput {
  component: NonEmptyString = "ak-stage-prompt"
}

"""User login challenge"""
input UserLoginChallengeResponseRequestInput {
  component: NonEmptyString = "ak-stage-user-login"
  rememberMe: Boolean!
}

union FlowsInstancesCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "Flow") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Flow | ValidationError | GenericError

"""Flow Serializer"""
input FlowRequestInput {
  name: NonEmptyString!
  slug: MutationInputFlowsInstancesCreateInputSlug!
  """Shown as the Title in Flow pages."""
  title: NonEmptyString!
  designation: FlowDesignationEnum!
  policyEngineMode: PolicyEngineMode
  """
  Enable compatibility mode, increases compatibility with password managers on mobile devices.
  """
  compatibilityMode: Boolean
  layout: FlowLayoutEnum
  deniedAction: DeniedActionEnum
  authentication: AuthenticationEnum
}

scalar MutationInputFlowsInstancesCreateInputSlug @regexp(subgraph: "Authentik", pattern: "^[-a-zA-Z0-9_]+$") @typescript(subgraph: "Authentik", type: "string")

union FlowsInstancesUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Flow") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Flow | ValidationError | GenericError

union FlowsInstancesPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Flow") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Flow | ValidationError | GenericError

"""Flow Serializer"""
input PatchedFlowRequestInput {
  name: NonEmptyString
  slug: MutationInputFlowsInstancesPartialUpdateInputSlug
  """Shown as the Title in Flow pages."""
  title: NonEmptyString
  designation: FlowDesignationEnum
  policyEngineMode: PolicyEngineMode
  """
  Enable compatibility mode, increases compatibility with password managers on mobile devices.
  """
  compatibilityMode: Boolean
  layout: FlowLayoutEnum
  deniedAction: DeniedActionEnum
  authentication: AuthenticationEnum
}

scalar MutationInputFlowsInstancesPartialUpdateInputSlug @regexp(subgraph: "Authentik", pattern: "^[-a-zA-Z0-9_]+$") @typescript(subgraph: "Authentik", type: "string")

union FlowsInstancesDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union FlowsInstancesCacheClearCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | GenericError

union FlowsInstancesImportCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "FlowImportResult") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "FlowImportResult") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = FlowImportResult | GenericError

"""Logs of an attempted flow import"""
type FlowImportResult {
  logs: [LogEvent]!
  success: Boolean!
}

union ManagedBlueprintsCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "BlueprintInstance") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = BlueprintInstance | ValidationError | GenericError

"""Info about a single blueprint instance file"""
input BlueprintInstanceRequestInput {
  name: NonEmptyString!
  path: String
  context: JSON
  enabled: Boolean
  content: String
}

union ManagedBlueprintsUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "BlueprintInstance") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = BlueprintInstance | ValidationError | GenericError

union ManagedBlueprintsPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "BlueprintInstance") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = BlueprintInstance | ValidationError | GenericError

"""Info about a single blueprint instance file"""
input PatchedBlueprintInstanceRequestInput {
  name: NonEmptyString
  path: String
  context: JSON
  enabled: Boolean
  content: String
}

union ManagedBlueprintsDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union ManagedBlueprintsApplyCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "BlueprintInstance") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = BlueprintInstance | ValidationError | GenericError

union Oauth2AccessTokensDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union Oauth2AuthorizationCodesDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union Oauth2RefreshTokensDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union OutpostsInstancesCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "Outpost") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Outpost | ValidationError | GenericError

"""Outpost Serializer"""
input OutpostRequestInput {
  name: NonEmptyString!
  type: OutpostTypeEnum!
  providers: [Int]!
  """
  Select Service-Connection authentik should use to manage this outpost. Leave empty if authentik should not handle the deployment.
  """
  serviceConnection: UUID
  config: JSON!
  """
  Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.
  """
  managed: NonEmptyString
}

union OutpostsInstancesUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Outpost") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Outpost | ValidationError | GenericError

union OutpostsInstancesPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Outpost") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Outpost | ValidationError | GenericError

"""Outpost Serializer"""
input PatchedOutpostRequestInput {
  name: NonEmptyString
  type: OutpostTypeEnum
  providers: [Int]
  """
  Select Service-Connection authentik should use to manage this outpost. Leave empty if authentik should not handle the deployment.
  """
  serviceConnection: UUID
  config: JSON
  """
  Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.
  """
  managed: NonEmptyString
}

union OutpostsInstancesDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union OutpostsServiceConnectionsAllDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union OutpostsServiceConnectionsDockerCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "DockerServiceConnection") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = DockerServiceConnection | ValidationError | GenericError

"""DockerServiceConnection Serializer"""
input DockerServiceConnectionRequestInput {
  name: NonEmptyString!
  """
  If enabled, use the local connection. Required Docker socket/Kubernetes Integration
  """
  local: Boolean
  """
  Can be in the format of 'unix://<path>' when connecting to a local docker daemon, or 'https://<hostname>:2376' when connecting to a remote system.
  """
  url: NonEmptyString!
  """
  CA which the endpoint's Certificate is verified against. Can be left empty for no validation.
  """
  tlsVerification: UUID
  """
  Certificate/Key used for authentication. Can be left empty for no authentication.
  """
  tlsAuthentication: UUID
}

union OutpostsServiceConnectionsDockerUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "DockerServiceConnection") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = DockerServiceConnection | ValidationError | GenericError

union OutpostsServiceConnectionsDockerPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "DockerServiceConnection") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = DockerServiceConnection | ValidationError | GenericError

"""DockerServiceConnection Serializer"""
input PatchedDockerServiceConnectionRequestInput {
  name: NonEmptyString
  """
  If enabled, use the local connection. Required Docker socket/Kubernetes Integration
  """
  local: Boolean
  """
  Can be in the format of 'unix://<path>' when connecting to a local docker daemon, or 'https://<hostname>:2376' when connecting to a remote system.
  """
  url: NonEmptyString
  """
  CA which the endpoint's Certificate is verified against. Can be left empty for no validation.
  """
  tlsVerification: UUID
  """
  Certificate/Key used for authentication. Can be left empty for no authentication.
  """
  tlsAuthentication: UUID
}

union OutpostsServiceConnectionsDockerDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union OutpostsServiceConnectionsKubernetesCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "KubernetesServiceConnection") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = KubernetesServiceConnection | ValidationError | GenericError

"""KubernetesServiceConnection Serializer"""
input KubernetesServiceConnectionRequestInput {
  name: NonEmptyString!
  """
  If enabled, use the local connection. Required Docker socket/Kubernetes Integration
  """
  local: Boolean
  """
  Paste your kubeconfig here. authentik will automatically use the currently selected context.
  """
  kubeconfig: JSON
  """Verify SSL Certificates of the Kubernetes API endpoint"""
  verifySsl: Boolean
}

union OutpostsServiceConnectionsKubernetesUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "KubernetesServiceConnection") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = KubernetesServiceConnection | ValidationError | GenericError

union OutpostsServiceConnectionsKubernetesPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "KubernetesServiceConnection") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = KubernetesServiceConnection | ValidationError | GenericError

"""KubernetesServiceConnection Serializer"""
input PatchedKubernetesServiceConnectionRequestInput {
  name: NonEmptyString
  """
  If enabled, use the local connection. Required Docker socket/Kubernetes Integration
  """
  local: Boolean
  """
  Paste your kubeconfig here. authentik will automatically use the currently selected context.
  """
  kubeconfig: JSON
  """Verify SSL Certificates of the Kubernetes API endpoint"""
  verifySsl: Boolean
}

union OutpostsServiceConnectionsKubernetesDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union PoliciesAllDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union PoliciesAllTestCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PolicyTestResult") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PolicyTestResult | GenericError

"""Test policy execution for a user with context"""
input PolicyTestRequestInput {
  user: Int!
  context: JSON
}

union PoliciesAllCacheClearCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | GenericError

union PoliciesBindingsCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "PolicyBinding") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PolicyBinding | ValidationError | GenericError

"""PolicyBinding Serializer"""
input PolicyBindingRequestInput {
  policy: UUID
  group: UUID
  user: Int
  target: UUID!
  """Negates the outcome of the policy. Messages are unaffected."""
  negate: Boolean
  enabled: Boolean
  order: Int!
  """Timeout after which Policy execution is terminated."""
  timeout: NonNegativeInt
  """Result if the Policy execution fails."""
  failureResult: Boolean
}

union PoliciesBindingsUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PolicyBinding") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PolicyBinding | ValidationError | GenericError

union PoliciesBindingsPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PolicyBinding") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PolicyBinding | ValidationError | GenericError

"""PolicyBinding Serializer"""
input PatchedPolicyBindingRequestInput {
  policy: UUID
  group: UUID
  user: Int
  target: UUID
  """Negates the outcome of the policy. Messages are unaffected."""
  negate: Boolean
  enabled: Boolean
  order: Int
  """Timeout after which Policy execution is terminated."""
  timeout: NonNegativeInt
  """Result if the Policy execution fails."""
  failureResult: Boolean
}

union PoliciesBindingsDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union PoliciesDummyCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "DummyPolicy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = DummyPolicy | ValidationError | GenericError

"""Dummy Policy Serializer"""
input DummyPolicyRequestInput {
  name: NonEmptyString!
  """
  When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.
  """
  executionLogging: Boolean
  result: Boolean
  waitMin: Int
  waitMax: Int
}

union PoliciesDummyUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "DummyPolicy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = DummyPolicy | ValidationError | GenericError

union PoliciesDummyPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "DummyPolicy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = DummyPolicy | ValidationError | GenericError

"""Dummy Policy Serializer"""
input PatchedDummyPolicyRequestInput {
  name: NonEmptyString
  """
  When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.
  """
  executionLogging: Boolean
  result: Boolean
  waitMin: Int
  waitMax: Int
}

union PoliciesDummyDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union PoliciesEventMatcherCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "EventMatcherPolicy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = EventMatcherPolicy | ValidationError | GenericError

"""Event Matcher Policy Serializer"""
input EventMatcherPolicyRequestInput {
  name: NonEmptyString!
  """
  When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.
  """
  executionLogging: Boolean
  action: EventActions
  """
  Matches Event's Client IP (strict matching, for network matching use an Expression Policy)
  """
  clientIp: NonEmptyString
  app: AppEnum
  model: ModelEnum
}

union PoliciesEventMatcherUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "EventMatcherPolicy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = EventMatcherPolicy | ValidationError | GenericError

union PoliciesEventMatcherPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "EventMatcherPolicy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = EventMatcherPolicy | ValidationError | GenericError

"""Event Matcher Policy Serializer"""
input PatchedEventMatcherPolicyRequestInput {
  name: NonEmptyString
  """
  When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.
  """
  executionLogging: Boolean
  action: EventActions
  """
  Matches Event's Client IP (strict matching, for network matching use an Expression Policy)
  """
  clientIp: NonEmptyString
  app: AppEnum
  model: ModelEnum
}

union PoliciesEventMatcherDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union PoliciesExpressionCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "ExpressionPolicy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ExpressionPolicy | ValidationError | GenericError

"""Group Membership Policy Serializer"""
input ExpressionPolicyRequestInput {
  name: NonEmptyString!
  """
  When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.
  """
  executionLogging: Boolean
  expression: NonEmptyString!
}

union PoliciesExpressionUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "ExpressionPolicy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ExpressionPolicy | ValidationError | GenericError

union PoliciesExpressionPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "ExpressionPolicy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ExpressionPolicy | ValidationError | GenericError

"""Group Membership Policy Serializer"""
input PatchedExpressionPolicyRequestInput {
  name: NonEmptyString
  """
  When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.
  """
  executionLogging: Boolean
  expression: NonEmptyString
}

union PoliciesExpressionDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union PoliciesPasswordCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "PasswordPolicy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PasswordPolicy | ValidationError | GenericError

"""Password Policy Serializer"""
input PasswordPolicyRequestInput {
  name: NonEmptyString!
  """
  When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.
  """
  executionLogging: Boolean
  """Field key to check, field keys defined in Prompt stages are available."""
  passwordField: NonEmptyString
  amountDigits: NonNegativeInt
  amountUppercase: NonNegativeInt
  amountLowercase: NonNegativeInt
  amountSymbols: NonNegativeInt
  lengthMin: NonNegativeInt
  symbolCharset: NonEmptyString
  errorMessage: String
  checkStaticRules: Boolean
  checkHaveIBeenPwned: Boolean
  checkZxcvbn: Boolean
  """How many times the password hash is allowed to be on haveibeenpwned"""
  hibpAllowedCount: NonNegativeInt
  """
  If the zxcvbn score is equal or less than this value, the policy will fail.
  """
  zxcvbnScoreThreshold: NonNegativeInt
}

union PoliciesPasswordUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PasswordPolicy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PasswordPolicy | ValidationError | GenericError

union PoliciesPasswordPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PasswordPolicy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PasswordPolicy | ValidationError | GenericError

"""Password Policy Serializer"""
input PatchedPasswordPolicyRequestInput {
  name: NonEmptyString
  """
  When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.
  """
  executionLogging: Boolean
  """Field key to check, field keys defined in Prompt stages are available."""
  passwordField: NonEmptyString
  amountDigits: NonNegativeInt
  amountUppercase: NonNegativeInt
  amountLowercase: NonNegativeInt
  amountSymbols: NonNegativeInt
  lengthMin: NonNegativeInt
  symbolCharset: NonEmptyString
  errorMessage: String
  checkStaticRules: Boolean
  checkHaveIBeenPwned: Boolean
  checkZxcvbn: Boolean
  """How many times the password hash is allowed to be on haveibeenpwned"""
  hibpAllowedCount: NonNegativeInt
  """
  If the zxcvbn score is equal or less than this value, the policy will fail.
  """
  zxcvbnScoreThreshold: NonNegativeInt
}

union PoliciesPasswordDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union PoliciesPasswordExpiryCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "PasswordExpiryPolicy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PasswordExpiryPolicy | ValidationError | GenericError

"""Password Expiry Policy Serializer"""
input PasswordExpiryPolicyRequestInput {
  name: NonEmptyString!
  """
  When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.
  """
  executionLogging: Boolean
  days: Int!
  denyOnly: Boolean
}

union PoliciesPasswordExpiryUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PasswordExpiryPolicy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PasswordExpiryPolicy | ValidationError | GenericError

union PoliciesPasswordExpiryPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PasswordExpiryPolicy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PasswordExpiryPolicy | ValidationError | GenericError

"""Password Expiry Policy Serializer"""
input PatchedPasswordExpiryPolicyRequestInput {
  name: NonEmptyString
  """
  When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.
  """
  executionLogging: Boolean
  days: Int
  denyOnly: Boolean
}

union PoliciesPasswordExpiryDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union PoliciesReputationCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "ReputationPolicy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ReputationPolicy | ValidationError | GenericError

"""Reputation Policy Serializer"""
input ReputationPolicyRequestInput {
  name: NonEmptyString!
  """
  When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.
  """
  executionLogging: Boolean
  checkIp: Boolean
  checkUsername: Boolean
  threshold: Int
}

union PoliciesReputationUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "ReputationPolicy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ReputationPolicy | ValidationError | GenericError

union PoliciesReputationPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "ReputationPolicy") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ReputationPolicy | ValidationError | GenericError

"""Reputation Policy Serializer"""
input PatchedReputationPolicyRequestInput {
  name: NonEmptyString
  """
  When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.
  """
  executionLogging: Boolean
  checkIp: Boolean
  checkUsername: Boolean
  threshold: Int
}

union PoliciesReputationDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union PoliciesReputationScoresDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union PropertymappingsAllDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union PropertymappingsAllTestCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PropertyMappingTestResult") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PropertyMappingTestResult | GenericError

"""Result of a Property-mapping test"""
type PropertyMappingTestResult {
  result: String!
  successful: Boolean!
}

union PropertymappingsLdapCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "LDAPPropertyMapping") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = LdapPropertyMapping | ValidationError | GenericError

"""LDAP PropertyMapping Serializer"""
input LdapPropertyMappingRequestInput {
  """
  Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.
  """
  managed: NonEmptyString
  name: NonEmptyString!
  expression: NonEmptyString!
  objectField: NonEmptyString!
}

union PropertymappingsLdapUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "LDAPPropertyMapping") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = LdapPropertyMapping | ValidationError | GenericError

union PropertymappingsLdapPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "LDAPPropertyMapping") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = LdapPropertyMapping | ValidationError | GenericError

"""LDAP PropertyMapping Serializer"""
input PatchedLdapPropertyMappingRequestInput {
  """
  Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.
  """
  managed: NonEmptyString
  name: NonEmptyString
  expression: NonEmptyString
  objectField: NonEmptyString
}

union PropertymappingsLdapDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union PropertymappingsNotificationCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "NotificationWebhookMapping") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = NotificationWebhookMapping | ValidationError | GenericError

"""NotificationWebhookMapping Serializer"""
input NotificationWebhookMappingRequestInput {
  name: NonEmptyString!
  expression: NonEmptyString!
}

union PropertymappingsNotificationUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "NotificationWebhookMapping") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = NotificationWebhookMapping | ValidationError | GenericError

union PropertymappingsNotificationPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "NotificationWebhookMapping") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = NotificationWebhookMapping | ValidationError | GenericError

"""NotificationWebhookMapping Serializer"""
input PatchedNotificationWebhookMappingRequestInput {
  name: NonEmptyString
  expression: NonEmptyString
}

union PropertymappingsNotificationDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union PropertymappingsRacCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "RACPropertyMapping") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = RacPropertyMapping | ValidationError | GenericError

"""RACPropertyMapping Serializer"""
input RacPropertyMappingRequestInput {
  """
  Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.
  """
  managed: NonEmptyString
  name: NonEmptyString!
  expression: String
  staticSettings: JSON!
}

union PropertymappingsRacUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "RACPropertyMapping") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = RacPropertyMapping | ValidationError | GenericError

union PropertymappingsRacPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "RACPropertyMapping") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = RacPropertyMapping | ValidationError | GenericError

"""RACPropertyMapping Serializer"""
input PatchedRacPropertyMappingRequestInput {
  """
  Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.
  """
  managed: NonEmptyString
  name: NonEmptyString
  expression: String
  staticSettings: JSON
}

union PropertymappingsRacDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union PropertymappingsSamlCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "SAMLPropertyMapping") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = SamlPropertyMapping | ValidationError | GenericError

"""SAMLPropertyMapping Serializer"""
input SamlPropertyMappingRequestInput {
  """
  Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.
  """
  managed: NonEmptyString
  name: NonEmptyString!
  expression: NonEmptyString!
  samlName: NonEmptyString!
  friendlyName: String
}

union PropertymappingsSamlUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "SAMLPropertyMapping") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = SamlPropertyMapping | ValidationError | GenericError

union PropertymappingsSamlPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "SAMLPropertyMapping") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = SamlPropertyMapping | ValidationError | GenericError

"""SAMLPropertyMapping Serializer"""
input PatchedSamlPropertyMappingRequestInput {
  """
  Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.
  """
  managed: NonEmptyString
  name: NonEmptyString
  expression: NonEmptyString
  samlName: NonEmptyString
  friendlyName: String
}

union PropertymappingsSamlDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union PropertymappingsScimCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "SCIMMapping") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ScimMapping | ValidationError | GenericError

"""SCIMMapping Serializer"""
input ScimMappingRequestInput {
  """
  Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.
  """
  managed: NonEmptyString
  name: NonEmptyString!
  expression: NonEmptyString!
}

union PropertymappingsScimUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "SCIMMapping") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ScimMapping | ValidationError | GenericError

union PropertymappingsScimPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "SCIMMapping") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ScimMapping | ValidationError | GenericError

"""SCIMMapping Serializer"""
input PatchedScimMappingRequestInput {
  """
  Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.
  """
  managed: NonEmptyString
  name: NonEmptyString
  expression: NonEmptyString
}

union PropertymappingsScimDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union PropertymappingsScopeCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "ScopeMapping") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ScopeMapping | ValidationError | GenericError

"""ScopeMapping Serializer"""
input ScopeMappingRequestInput {
  """
  Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.
  """
  managed: NonEmptyString
  name: NonEmptyString!
  expression: NonEmptyString!
  """Scope name requested by the client"""
  scopeName: NonEmptyString!
  """
  Description shown to the user when consenting. If left empty, the user won't be informed.
  """
  description: String
}

union PropertymappingsScopeUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "ScopeMapping") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ScopeMapping | ValidationError | GenericError

union PropertymappingsScopePartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "ScopeMapping") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ScopeMapping | ValidationError | GenericError

"""ScopeMapping Serializer"""
input PatchedScopeMappingRequestInput {
  """
  Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.
  """
  managed: NonEmptyString
  name: NonEmptyString
  expression: NonEmptyString
  """Scope name requested by the client"""
  scopeName: NonEmptyString
  """
  Description shown to the user when consenting. If left empty, the user won't be informed.
  """
  description: String
}

union PropertymappingsScopeDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union ProvidersAllDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union ProvidersLdapCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "LDAPProvider") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = LdapProvider | ValidationError | GenericError

union ProvidersLdapUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "LDAPProvider") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = LdapProvider | ValidationError | GenericError

union ProvidersLdapPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "LDAPProvider") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = LdapProvider | ValidationError | GenericError

"""LDAPProvider Serializer"""
input PatchedLdapProviderRequestInput {
  name: NonEmptyString
  """
  Flow used for authentication when the associated application is accessed by an un-authenticated user.
  """
  authenticationFlow: UUID
  """Flow used when authorizing this provider."""
  authorizationFlow: UUID
  propertyMappings: [UUID]
  """DN under which objects are accessible."""
  baseDn: NonEmptyString
  """
  Users in this group can do search queries. If not set, every user can execute search queries.
  """
  searchGroup: UUID
  certificate: UUID
  tlsServerName: String
  """
  The start for uidNumbers, this number is added to the user.pk to make sure that the numbers aren't too low for POSIX users. Default is 2000 to ensure that we don't collide with local users uidNumber
  """
  uidStartNumber: Int
  """
  The start for gidNumbers, this number is added to a number generated from the group.pk to make sure that the numbers aren't too low for POSIX groups. Default is 4000 to ensure that we don't collide with local groups or users primary groups gidNumber
  """
  gidStartNumber: Int
  searchMode: LdapapiAccessMode
  bindMode: LdapapiAccessMode
  """
  When enabled, code-based multi-factor authentication can be used by appending a semicolon and the TOTP code to the password. This should only be enabled if all users that will bind to this provider have a TOTP device configured, as otherwise a password may incorrectly be rejected if it contains a semicolon.
  """
  mfaSupport: Boolean
}

union ProvidersLdapDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union ProvidersOauth2CreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "OAuth2Provider") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = OAuth2Provider | ValidationError | GenericError

union ProvidersOauth2UpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "OAuth2Provider") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = OAuth2Provider | ValidationError | GenericError

union ProvidersOauth2PartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "OAuth2Provider") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = OAuth2Provider | ValidationError | GenericError

"""OAuth2Provider Serializer"""
input PatchedOAuth2ProviderRequestInput {
  name: NonEmptyString
  """
  Flow used for authentication when the associated application is accessed by an un-authenticated user.
  """
  authenticationFlow: UUID
  """Flow used when authorizing this provider."""
  authorizationFlow: UUID
  propertyMappings: [UUID]
  clientType: ClientTypeEnum
  clientId: MutationInputProvidersOauth2PartialUpdateInputClientId
  clientSecret: MutationInputProvidersOauth2PartialUpdateInputClientSecret
  """
  Access codes not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).
  """
  accessCodeValidity: NonEmptyString
  """
  Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).
  """
  accessTokenValidity: NonEmptyString
  """
  Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).
  """
  refreshTokenValidity: NonEmptyString
  """
  Include User claims from scopes in the id_token, for applications that don't access the userinfo endpoint.
  """
  includeClaimsInIdToken: Boolean
  """
  Key used to sign the tokens. Only required when JWT Algorithm is set to RS256.
  """
  signingKey: UUID
  """Enter each URI on a new line."""
  redirectUris: String
  subMode: SubModeEnum
  issuerMode: IssuerModeEnum
  jwksSources: [UUID]
}

scalar MutationInputProvidersOauth2PartialUpdateInputClientId @length(subgraph: "Authentik", min: 1, max: 255)

scalar MutationInputProvidersOauth2PartialUpdateInputClientSecret @length(subgraph: "Authentik", max: 255)

union ProvidersOauth2DestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union ProvidersProxyCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "ProxyProvider") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ProxyProvider | ValidationError | GenericError

union ProvidersProxyUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "ProxyProvider") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ProxyProvider | ValidationError | GenericError

union ProvidersProxyPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "ProxyProvider") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ProxyProvider | ValidationError | GenericError

"""ProxyProvider Serializer"""
input PatchedProxyProviderRequestInput {
  name: NonEmptyString
  """
  Flow used for authentication when the associated application is accessed by an un-authenticated user.
  """
  authenticationFlow: UUID
  """Flow used when authorizing this provider."""
  authorizationFlow: UUID
  propertyMappings: [UUID]
  internalHost: URL
  externalHost: URL
  """Validate SSL Certificates of upstream servers"""
  internalHostSslValidation: Boolean
  certificate: UUID
  """
  Regular expressions for which authentication is not required. Each new line is interpreted as a new Regular Expression.
  """
  skipPathRegex: String
  """
  Set a custom HTTP-Basic Authentication header based on values from authentik.
  """
  basicAuthEnabled: Boolean
  """
  User/Group Attribute used for the password part of the HTTP-Basic Header.
  """
  basicAuthPasswordAttribute: String
  """
  User/Group Attribute used for the user part of the HTTP-Basic Header. If not set, the user's Email address is used.
  """
  basicAuthUserAttribute: String
  mode: ProxyMode
  """
  When enabled, this provider will intercept the authorization header and authenticate requests based on its value.
  """
  interceptHeaderAuth: Boolean
  cookieDomain: String
  jwksSources: [UUID]
  """
  Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).
  """
  accessTokenValidity: NonEmptyString
  """
  Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).
  """
  refreshTokenValidity: NonEmptyString
}

union ProvidersProxyDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union ProvidersRacCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "RACProvider") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = RacProvider | ValidationError | GenericError

union ProvidersRacUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "RACProvider") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = RacProvider | ValidationError | GenericError

union ProvidersRacPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "RACProvider") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = RacProvider | ValidationError | GenericError

"""RACProvider Serializer"""
input PatchedRacProviderRequestInput {
  name: NonEmptyString
  """
  Flow used for authentication when the associated application is accessed by an un-authenticated user.
  """
  authenticationFlow: UUID
  """Flow used when authorizing this provider."""
  authorizationFlow: UUID
  propertyMappings: [UUID]
  settings: JSON
  """
  Determines how long a session lasts. Default of 0 means that the sessions lasts until the browser is closed. (Format: hours=-1;minutes=-2;seconds=-3)
  """
  connectionExpiry: NonEmptyString
  """When set to true, connection tokens will be deleted upon disconnect."""
  deleteTokenOnDisconnect: Boolean
}

union ProvidersRacDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union ProvidersRadiusCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "RadiusProvider") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = RadiusProvider | ValidationError | GenericError

union ProvidersRadiusUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "RadiusProvider") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = RadiusProvider | ValidationError | GenericError

union ProvidersRadiusPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "RadiusProvider") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = RadiusProvider | ValidationError | GenericError

"""RadiusProvider Serializer"""
input PatchedRadiusProviderRequestInput {
  name: NonEmptyString
  """
  Flow used for authentication when the associated application is accessed by an un-authenticated user.
  """
  authenticationFlow: UUID
  """Flow used when authorizing this provider."""
  authorizationFlow: UUID
  propertyMappings: [UUID]
  """
  List of CIDRs (comma-separated) that clients can connect from. A more specific CIDR will match before a looser one. Clients connecting from a non-specified CIDR will be dropped.
  """
  clientNetworks: NonEmptyString
  """Shared secret between clients and server to hash packets."""
  sharedSecret: NonEmptyString
  """
  When enabled, code-based multi-factor authentication can be used by appending a semicolon and the TOTP code to the password. This should only be enabled if all users that will bind to this provider have a TOTP device configured, as otherwise a password may incorrectly be rejected if it contains a semicolon.
  """
  mfaSupport: Boolean
}

union ProvidersRadiusDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union ProvidersSamlCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "SAMLProvider") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = SamlProvider | ValidationError | GenericError

union ProvidersSamlUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "SAMLProvider") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = SamlProvider | ValidationError | GenericError

union ProvidersSamlPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "SAMLProvider") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = SamlProvider | ValidationError | GenericError

"""SAMLProvider Serializer"""
input PatchedSamlProviderRequestInput {
  name: NonEmptyString
  """
  Flow used for authentication when the associated application is accessed by an un-authenticated user.
  """
  authenticationFlow: UUID
  """Flow used when authorizing this provider."""
  authorizationFlow: UUID
  propertyMappings: [UUID]
  acsUrl: URL
  """
  Value of the audience restriction field of the assertion. When left empty, no audience restriction will be added.
  """
  audience: String
  """Also known as EntityID"""
  issuer: NonEmptyString
  """
  Assertion valid not before current time + this value (Format: hours=-1;minutes=-2;seconds=-3).
  """
  assertionValidNotBefore: NonEmptyString
  """
  Assertion not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).
  """
  assertionValidNotOnOrAfter: NonEmptyString
  """
  Session not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).
  """
  sessionValidNotOnOrAfter: NonEmptyString
  """
  Configure how the NameID value will be created. When left empty, the NameIDPolicy of the incoming request will be considered
  """
  nameIdMapping: UUID
  digestAlgorithm: DigestAlgorithmEnum
  signatureAlgorithm: SignatureAlgorithmEnum
  """Keypair used to sign outgoing Responses going to the Service Provider."""
  signingKp: UUID
  """
  When selected, incoming assertion's Signatures will be validated against this certificate. To allow unsigned Requests, leave on default.
  """
  verificationKp: UUID
  """
  This determines how authentik sends the response back to the Service Provider.
  """
  spBinding: JSON
  """Default relay_state value for IDP-initiated logins"""
  defaultRelayState: String
}

union ProvidersSamlDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union ProvidersSamlImportMetadataCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | GenericError

"""Import saml provider from XML Metadata"""
input SamlProviderImportRequestInput {
  name: NonEmptyString!
  authorizationFlow: UUID!
  file: File!
}

union ProvidersScimCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "SCIMProvider") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ScimProvider | ValidationError | GenericError

union ProvidersScimUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "SCIMProvider") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ScimProvider | ValidationError | GenericError

union ProvidersScimPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "SCIMProvider") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ScimProvider | ValidationError | GenericError

"""SCIMProvider Serializer"""
input PatchedScimProviderRequestInput {
  name: NonEmptyString
  propertyMappings: [UUID]
  """Property mappings used for group creation/updating."""
  propertyMappingsGroup: [UUID]
  """Base URL to SCIM requests, usually ends in /v2"""
  url: NonEmptyString
  """Authentication token"""
  token: NonEmptyString
  excludeUsersServiceAccount: Boolean
  filterGroup: UUID
}

union ProvidersScimDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union RacConnectionTokensUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "ConnectionToken") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ConnectionToken | ValidationError | GenericError

"""ConnectionToken Serializer"""
input ConnectionTokenRequestInput {
  pk: UUID
  provider: Int!
  endpoint: UUID!
}

union RacConnectionTokensPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "ConnectionToken") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ConnectionToken | ValidationError | GenericError

"""ConnectionToken Serializer"""
input PatchedConnectionTokenRequestInput {
  pk: UUID
  provider: Int
  endpoint: UUID
}

union RacConnectionTokensDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union RacEndpointsCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "Endpoint") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Endpoint | ValidationError | GenericError

"""Endpoint Serializer"""
input EndpointRequestInput {
  name: NonEmptyString!
  provider: Int!
  protocol: ProtocolEnum!
  host: NonEmptyString!
  settings: JSON
  propertyMappings: [UUID]
  authMode: AuthModeEnum!
  maximumConnections: Int
}

union RacEndpointsUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Endpoint") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Endpoint | ValidationError | GenericError

union RacEndpointsPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Endpoint") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Endpoint | ValidationError | GenericError

"""Endpoint Serializer"""
input PatchedEndpointRequestInput {
  name: NonEmptyString
  provider: Int
  protocol: ProtocolEnum
  host: NonEmptyString
  settings: JSON
  propertyMappings: [UUID]
  authMode: AuthModeEnum
  maximumConnections: Int
}

union RacEndpointsDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union RbacPermissionsAssignedByRolesAssignCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

"""Request to assign a new permission"""
input PermissionAssignRequestInput {
  permissions: [NonEmptyString]!
  model: ModelEnum
  objectPk: NonEmptyString
}

union RbacPermissionsAssignedByRolesUnassignPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

"""Request to assign a new permission"""
input PatchedPermissionAssignRequestInput {
  permissions: [NonEmptyString]
  model: ModelEnum
  objectPk: NonEmptyString
}

union RbacPermissionsAssignedByUsersAssignCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union RbacPermissionsAssignedByUsersUnassignPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union RbacRolesCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "Role") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Role | ValidationError | GenericError

"""Role serializer"""
input RoleRequestInput {
  name: MutationInputRbacRolesCreateInputName!
}

scalar MutationInputRbacRolesCreateInputName @length(subgraph: "Authentik", min: 1, max: 150)

union RbacRolesUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Role") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Role | ValidationError | GenericError

union RbacRolesPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Role") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Role | ValidationError | GenericError

"""Role serializer"""
input PatchedRoleRequestInput {
  name: MutationInputRbacRolesPartialUpdateInputName
}

scalar MutationInputRbacRolesPartialUpdateInputName @length(subgraph: "Authentik", min: 1, max: 150)

union RbacRolesDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union SourcesAllDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union SourcesLdapCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "LDAPSource") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = LdapSource | ValidationError | GenericError

"""LDAP Source Serializer"""
input LdapSourceRequestInput {
  """Source's display Name."""
  name: NonEmptyString!
  slug: MutationInputSourcesLdapCreateInputSlug!
  enabled: Boolean
  """Flow to use when authenticating existing users."""
  authenticationFlow: UUID
  """Flow to use when enrolling new users."""
  enrollmentFlow: UUID
  policyEngineMode: PolicyEngineMode
  userMatchingMode: UserMatchingModeEnum
  userPathTemplate: NonEmptyString
  serverUri: URL!
  """
  Optionally verify the LDAP Server's Certificate against the CA Chain in this keypair.
  """
  peerCertificate: UUID
  """
  Client certificate to authenticate against the LDAP Server's Certificate.
  """
  clientCertificate: UUID
  bindCn: String
  bindPassword: String
  startTls: Boolean
  sni: Boolean
  baseDn: NonEmptyString!
  """Prepended to Base DN for User-queries."""
  additionalUserDn: String
  """Prepended to Base DN for Group-queries."""
  additionalGroupDn: String
  """Consider Objects matching this filter to be Users."""
  userObjectFilter: NonEmptyString
  """Consider Objects matching this filter to be Groups."""
  groupObjectFilter: NonEmptyString
  """Field which contains members of a group."""
  groupMembershipField: NonEmptyString
  """Field which contains a unique Identifier."""
  objectUniquenessField: NonEmptyString
  """Update internal authentik password when login succeeds with LDAP"""
  passwordLoginUpdateInternalPassword: Boolean
  syncUsers: Boolean
  """
  When a user changes their password, sync it back to LDAP. This can only be enabled on a single LDAP source.
  """
  syncUsersPassword: Boolean
  syncGroups: Boolean
  syncParentGroup: UUID
  propertyMappings: [UUID]
  """Property mappings used for group creation/updating."""
  propertyMappingsGroup: [UUID]
}

scalar MutationInputSourcesLdapCreateInputSlug @regexp(subgraph: "Authentik", pattern: "^[-a-zA-Z0-9_]+$") @typescript(subgraph: "Authentik", type: "string")

union SourcesLdapUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "LDAPSource") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = LdapSource | ValidationError | GenericError

union SourcesLdapPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "LDAPSource") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = LdapSource | ValidationError | GenericError

"""LDAP Source Serializer"""
input PatchedLdapSourceRequestInput {
  """Source's display Name."""
  name: NonEmptyString
  slug: MutationInputSourcesLdapPartialUpdateInputSlug
  enabled: Boolean
  """Flow to use when authenticating existing users."""
  authenticationFlow: UUID
  """Flow to use when enrolling new users."""
  enrollmentFlow: UUID
  policyEngineMode: PolicyEngineMode
  userMatchingMode: UserMatchingModeEnum
  userPathTemplate: NonEmptyString
  serverUri: URL
  """
  Optionally verify the LDAP Server's Certificate against the CA Chain in this keypair.
  """
  peerCertificate: UUID
  """
  Client certificate to authenticate against the LDAP Server's Certificate.
  """
  clientCertificate: UUID
  bindCn: String
  bindPassword: String
  startTls: Boolean
  sni: Boolean
  baseDn: NonEmptyString
  """Prepended to Base DN for User-queries."""
  additionalUserDn: String
  """Prepended to Base DN for Group-queries."""
  additionalGroupDn: String
  """Consider Objects matching this filter to be Users."""
  userObjectFilter: NonEmptyString
  """Consider Objects matching this filter to be Groups."""
  groupObjectFilter: NonEmptyString
  """Field which contains members of a group."""
  groupMembershipField: NonEmptyString
  """Field which contains a unique Identifier."""
  objectUniquenessField: NonEmptyString
  """Update internal authentik password when login succeeds with LDAP"""
  passwordLoginUpdateInternalPassword: Boolean
  syncUsers: Boolean
  """
  When a user changes their password, sync it back to LDAP. This can only be enabled on a single LDAP source.
  """
  syncUsersPassword: Boolean
  syncGroups: Boolean
  syncParentGroup: UUID
  propertyMappings: [UUID]
  """Property mappings used for group creation/updating."""
  propertyMappingsGroup: [UUID]
}

scalar MutationInputSourcesLdapPartialUpdateInputSlug @regexp(subgraph: "Authentik", pattern: "^[-a-zA-Z0-9_]+$") @typescript(subgraph: "Authentik", type: "string")

union SourcesLdapDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union SourcesOauthCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "OAuthSource") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = OAuthSource | ValidationError | GenericError

"""OAuth Source Serializer"""
input OAuthSourceRequestInput {
  """Source's display Name."""
  name: NonEmptyString!
  slug: MutationInputSourcesOauthCreateInputSlug!
  enabled: Boolean
  """Flow to use when authenticating existing users."""
  authenticationFlow: UUID
  """Flow to use when enrolling new users."""
  enrollmentFlow: UUID
  policyEngineMode: PolicyEngineMode
  userMatchingMode: UserMatchingModeEnum
  userPathTemplate: NonEmptyString
  providerType: ProviderTypeEnum!
  """
  URL used to request the initial token. This URL is only required for OAuth 1.
  """
  requestTokenUrl: MutationInputSourcesOauthCreateInputRequestTokenUrl
  """URL the user is redirect to to conest the flow."""
  authorizationUrl: MutationInputSourcesOauthCreateInputAuthorizationUrl
  """URL used by authentik to retrieve tokens."""
  accessTokenUrl: MutationInputSourcesOauthCreateInputAccessTokenUrl
  """URL used by authentik to get user information."""
  profileUrl: MutationInputSourcesOauthCreateInputProfileUrl
  consumerKey: NonEmptyString!
  consumerSecret: NonEmptyString!
  additionalScopes: String
  oidcWellKnownUrl: String
  oidcJwksUrl: String
  oidcJwks: JSON
}

scalar MutationInputSourcesOauthCreateInputSlug @regexp(subgraph: "Authentik", pattern: "^[-a-zA-Z0-9_]+$") @typescript(subgraph: "Authentik", type: "string")

"""
URL used to request the initial token. This URL is only required for OAuth 1.
"""
scalar MutationInputSourcesOauthCreateInputRequestTokenUrl @length(subgraph: "Authentik", max: 255)

"""URL the user is redirect to to conest the flow."""
scalar MutationInputSourcesOauthCreateInputAuthorizationUrl @length(subgraph: "Authentik", max: 255)

"""URL used by authentik to retrieve tokens."""
scalar MutationInputSourcesOauthCreateInputAccessTokenUrl @length(subgraph: "Authentik", max: 255)

"""URL used by authentik to get user information."""
scalar MutationInputSourcesOauthCreateInputProfileUrl @length(subgraph: "Authentik", max: 255)

union SourcesOauthUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "OAuthSource") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = OAuthSource | ValidationError | GenericError

union SourcesOauthPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "OAuthSource") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = OAuthSource | ValidationError | GenericError

"""OAuth Source Serializer"""
input PatchedOAuthSourceRequestInput {
  """Source's display Name."""
  name: NonEmptyString
  slug: MutationInputSourcesOauthPartialUpdateInputSlug
  enabled: Boolean
  """Flow to use when authenticating existing users."""
  authenticationFlow: UUID
  """Flow to use when enrolling new users."""
  enrollmentFlow: UUID
  policyEngineMode: PolicyEngineMode
  userMatchingMode: UserMatchingModeEnum
  userPathTemplate: NonEmptyString
  providerType: ProviderTypeEnum
  """
  URL used to request the initial token. This URL is only required for OAuth 1.
  """
  requestTokenUrl: MutationInputSourcesOauthPartialUpdateInputRequestTokenUrl
  """URL the user is redirect to to conest the flow."""
  authorizationUrl: MutationInputSourcesOauthPartialUpdateInputAuthorizationUrl
  """URL used by authentik to retrieve tokens."""
  accessTokenUrl: MutationInputSourcesOauthPartialUpdateInputAccessTokenUrl
  """URL used by authentik to get user information."""
  profileUrl: MutationInputSourcesOauthPartialUpdateInputProfileUrl
  consumerKey: NonEmptyString
  consumerSecret: NonEmptyString
  additionalScopes: String
  oidcWellKnownUrl: String
  oidcJwksUrl: String
  oidcJwks: JSON
}

scalar MutationInputSourcesOauthPartialUpdateInputSlug @regexp(subgraph: "Authentik", pattern: "^[-a-zA-Z0-9_]+$") @typescript(subgraph: "Authentik", type: "string")

"""
URL used to request the initial token. This URL is only required for OAuth 1.
"""
scalar MutationInputSourcesOauthPartialUpdateInputRequestTokenUrl @length(subgraph: "Authentik", max: 255)

"""URL the user is redirect to to conest the flow."""
scalar MutationInputSourcesOauthPartialUpdateInputAuthorizationUrl @length(subgraph: "Authentik", max: 255)

"""URL used by authentik to retrieve tokens."""
scalar MutationInputSourcesOauthPartialUpdateInputAccessTokenUrl @length(subgraph: "Authentik", max: 255)

"""URL used by authentik to get user information."""
scalar MutationInputSourcesOauthPartialUpdateInputProfileUrl @length(subgraph: "Authentik", max: 255)

union SourcesOauthDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union SourcesPlexCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "PlexSource") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PlexSource | ValidationError | GenericError

"""Plex Source Serializer"""
input PlexSourceRequestInput {
  """Source's display Name."""
  name: NonEmptyString!
  slug: MutationInputSourcesPlexCreateInputSlug!
  enabled: Boolean
  """Flow to use when authenticating existing users."""
  authenticationFlow: UUID
  """Flow to use when enrolling new users."""
  enrollmentFlow: UUID
  policyEngineMode: PolicyEngineMode
  userMatchingMode: UserMatchingModeEnum
  userPathTemplate: NonEmptyString
  """Client identifier used to talk to Plex."""
  clientId: NonEmptyString
  """
  Which servers a user has to be a member of to be granted access. Empty list allows every server.
  """
  allowedServers: [NonEmptyString]
  """Allow friends to authenticate, even if you don't share a server."""
  allowFriends: Boolean
  """Plex token used to check friends"""
  plexToken: NonEmptyString!
}

scalar MutationInputSourcesPlexCreateInputSlug @regexp(subgraph: "Authentik", pattern: "^[-a-zA-Z0-9_]+$") @typescript(subgraph: "Authentik", type: "string")

union SourcesPlexUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PlexSource") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PlexSource | ValidationError | GenericError

union SourcesPlexPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PlexSource") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PlexSource | ValidationError | GenericError

"""Plex Source Serializer"""
input PatchedPlexSourceRequestInput {
  """Source's display Name."""
  name: NonEmptyString
  slug: MutationInputSourcesPlexPartialUpdateInputSlug
  enabled: Boolean
  """Flow to use when authenticating existing users."""
  authenticationFlow: UUID
  """Flow to use when enrolling new users."""
  enrollmentFlow: UUID
  policyEngineMode: PolicyEngineMode
  userMatchingMode: UserMatchingModeEnum
  userPathTemplate: NonEmptyString
  """Client identifier used to talk to Plex."""
  clientId: NonEmptyString
  """
  Which servers a user has to be a member of to be granted access. Empty list allows every server.
  """
  allowedServers: [NonEmptyString]
  """Allow friends to authenticate, even if you don't share a server."""
  allowFriends: Boolean
  """Plex token used to check friends"""
  plexToken: NonEmptyString
}

scalar MutationInputSourcesPlexPartialUpdateInputSlug @regexp(subgraph: "Authentik", pattern: "^[-a-zA-Z0-9_]+$") @typescript(subgraph: "Authentik", type: "string")

union SourcesPlexDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

"""Serializer to redeem a plex token"""
input PlexTokenRedeemRequestInput {
  plexToken: NonEmptyString!
}

union SourcesSamlCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "SAMLSource") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = SamlSource | ValidationError | GenericError

"""SAMLSource Serializer"""
input SamlSourceRequestInput {
  """Source's display Name."""
  name: NonEmptyString!
  slug: MutationInputSourcesSamlCreateInputSlug!
  enabled: Boolean
  """Flow to use when authenticating existing users."""
  authenticationFlow: UUID
  """Flow to use when enrolling new users."""
  enrollmentFlow: UUID
  policyEngineMode: PolicyEngineMode
  userMatchingMode: UserMatchingModeEnum
  userPathTemplate: NonEmptyString
  """Flow used before authentication."""
  preAuthenticationFlow: UUID!
  """Also known as Entity ID. Defaults the Metadata URL."""
  issuer: String
  """URL that the initial Login request is sent to."""
  ssoUrl: URL!
  """Optional URL if your IDP supports Single-Logout."""
  sloUrl: URL
  """
  Allows authentication flows initiated by the IdP. This can be a security risk, as no validation of the request ID is done.
  """
  allowIdpInitiated: Boolean
  nameIdPolicy: NameIdPolicyEnum
  bindingType: BindingTypeEnum
  """
  When selected, incoming assertion's Signatures will be validated against this certificate. To allow unsigned Requests, leave on default.
  """
  verificationKp: UUID
  """
  Keypair used to sign outgoing Responses going to the Identity Provider.
  """
  signingKp: UUID
  digestAlgorithm: DigestAlgorithmEnum
  signatureAlgorithm: SignatureAlgorithmEnum
  """
  Time offset when temporary users should be deleted. This only applies if your IDP uses the NameID Format 'transient', and the user doesn't log out manually. (Format: hours=1;minutes=2;seconds=3).
  """
  temporaryUserDeleteAfter: NonEmptyString
}

scalar MutationInputSourcesSamlCreateInputSlug @regexp(subgraph: "Authentik", pattern: "^[-a-zA-Z0-9_]+$") @typescript(subgraph: "Authentik", type: "string")

union SourcesSamlUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "SAMLSource") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = SamlSource | ValidationError | GenericError

union SourcesSamlPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "SAMLSource") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = SamlSource | ValidationError | GenericError

"""SAMLSource Serializer"""
input PatchedSamlSourceRequestInput {
  """Source's display Name."""
  name: NonEmptyString
  slug: MutationInputSourcesSamlPartialUpdateInputSlug
  enabled: Boolean
  """Flow to use when authenticating existing users."""
  authenticationFlow: UUID
  """Flow to use when enrolling new users."""
  enrollmentFlow: UUID
  policyEngineMode: PolicyEngineMode
  userMatchingMode: UserMatchingModeEnum
  userPathTemplate: NonEmptyString
  """Flow used before authentication."""
  preAuthenticationFlow: UUID
  """Also known as Entity ID. Defaults the Metadata URL."""
  issuer: String
  """URL that the initial Login request is sent to."""
  ssoUrl: URL
  """Optional URL if your IDP supports Single-Logout."""
  sloUrl: URL
  """
  Allows authentication flows initiated by the IdP. This can be a security risk, as no validation of the request ID is done.
  """
  allowIdpInitiated: Boolean
  nameIdPolicy: NameIdPolicyEnum
  bindingType: BindingTypeEnum
  """
  When selected, incoming assertion's Signatures will be validated against this certificate. To allow unsigned Requests, leave on default.
  """
  verificationKp: UUID
  """
  Keypair used to sign outgoing Responses going to the Identity Provider.
  """
  signingKp: UUID
  digestAlgorithm: DigestAlgorithmEnum
  signatureAlgorithm: SignatureAlgorithmEnum
  """
  Time offset when temporary users should be deleted. This only applies if your IDP uses the NameID Format 'transient', and the user doesn't log out manually. (Format: hours=1;minutes=2;seconds=3).
  """
  temporaryUserDeleteAfter: NonEmptyString
}

scalar MutationInputSourcesSamlPartialUpdateInputSlug @regexp(subgraph: "Authentik", pattern: "^[-a-zA-Z0-9_]+$") @typescript(subgraph: "Authentik", type: "string")

union SourcesSamlDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union SourcesScimCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "SCIMSource") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ScimSource | ValidationError | GenericError

"""SCIMSource Serializer"""
input ScimSourceRequestInput {
  """Source's display Name."""
  name: NonEmptyString!
  slug: MutationInputSourcesScimCreateInputSlug!
  enabled: Boolean
  userMatchingMode: UserMatchingModeEnum
  userPathTemplate: NonEmptyString
}

scalar MutationInputSourcesScimCreateInputSlug @regexp(subgraph: "Authentik", pattern: "^[-a-zA-Z0-9_]+$") @typescript(subgraph: "Authentik", type: "string")

union SourcesScimUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "SCIMSource") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ScimSource | ValidationError | GenericError

union SourcesScimPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "SCIMSource") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ScimSource | ValidationError | GenericError

"""SCIMSource Serializer"""
input PatchedScimSourceRequestInput {
  """Source's display Name."""
  name: NonEmptyString
  slug: MutationInputSourcesScimPartialUpdateInputSlug
  enabled: Boolean
  userMatchingMode: UserMatchingModeEnum
  userPathTemplate: NonEmptyString
}

scalar MutationInputSourcesScimPartialUpdateInputSlug @regexp(subgraph: "Authentik", pattern: "^[-a-zA-Z0-9_]+$") @typescript(subgraph: "Authentik", type: "string")

union SourcesScimDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union SourcesScimGroupsCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "SCIMSourceGroup") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ScimSourceGroup | ValidationError | GenericError

"""SCIMSourceGroup Serializer"""
input ScimSourceGroupRequestInput {
  id: NonEmptyString!
  group: UUID!
  source: UUID!
  attributes: JSON
}

union SourcesScimGroupsUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "SCIMSourceGroup") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ScimSourceGroup | ValidationError | GenericError

union SourcesScimGroupsPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "SCIMSourceGroup") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ScimSourceGroup | ValidationError | GenericError

"""SCIMSourceGroup Serializer"""
input PatchedScimSourceGroupRequestInput {
  id: NonEmptyString
  group: UUID
  source: UUID
  attributes: JSON
}

union SourcesScimGroupsDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union SourcesScimUsersCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "SCIMSourceUser") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ScimSourceUser | ValidationError | GenericError

"""SCIMSourceUser Serializer"""
input ScimSourceUserRequestInput {
  id: NonEmptyString!
  user: Int!
  source: UUID!
  attributes: JSON
}

union SourcesScimUsersUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "SCIMSourceUser") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ScimSourceUser | ValidationError | GenericError

union SourcesScimUsersPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "SCIMSourceUser") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ScimSourceUser | ValidationError | GenericError

"""SCIMSourceUser Serializer"""
input PatchedScimSourceUserRequestInput {
  id: NonEmptyString
  user: Int
  source: UUID
  attributes: JSON
}

union SourcesScimUsersDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union SourcesUserConnectionsAllUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UserSourceConnection") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UserSourceConnection | ValidationError | GenericError

union SourcesUserConnectionsAllPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UserSourceConnection") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UserSourceConnection | ValidationError | GenericError

union SourcesUserConnectionsAllDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union SourcesUserConnectionsOauthCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "UserOAuthSourceConnection") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UserOAuthSourceConnection | ValidationError | GenericError

"""OAuth Source Serializer"""
input UserOAuthSourceConnectionRequestInput {
  user: Int!
  identifier: MutationInputSourcesUserConnectionsOauthCreateInputIdentifier!
  accessToken: String
}

scalar MutationInputSourcesUserConnectionsOauthCreateInputIdentifier @length(subgraph: "Authentik", min: 1, max: 255)

union SourcesUserConnectionsOauthUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UserOAuthSourceConnection") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UserOAuthSourceConnection | ValidationError | GenericError

union SourcesUserConnectionsOauthPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UserOAuthSourceConnection") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UserOAuthSourceConnection | ValidationError | GenericError

"""OAuth Source Serializer"""
input PatchedUserOAuthSourceConnectionRequestInput {
  user: Int
  identifier: MutationInputSourcesUserConnectionsOauthPartialUpdateInputIdentifier
  accessToken: String
}

scalar MutationInputSourcesUserConnectionsOauthPartialUpdateInputIdentifier @length(subgraph: "Authentik", min: 1, max: 255)

union SourcesUserConnectionsOauthDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union SourcesUserConnectionsPlexCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "PlexSourceConnection") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PlexSourceConnection | ValidationError | GenericError

"""Plex Source connection Serializer"""
input PlexSourceConnectionRequestInput {
  identifier: NonEmptyString!
  plexToken: NonEmptyString!
}

union SourcesUserConnectionsPlexUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PlexSourceConnection") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PlexSourceConnection | ValidationError | GenericError

union SourcesUserConnectionsPlexPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PlexSourceConnection") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PlexSourceConnection | ValidationError | GenericError

"""Plex Source connection Serializer"""
input PatchedPlexSourceConnectionRequestInput {
  identifier: NonEmptyString
  plexToken: NonEmptyString
}

union SourcesUserConnectionsPlexDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union SourcesUserConnectionsSamlCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "UserSAMLSourceConnection") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UserSamlSourceConnection | ValidationError | GenericError

"""SAML Source Serializer"""
input UserSamlSourceConnectionRequestInput {
  user: Int!
  identifier: NonEmptyString!
}

union SourcesUserConnectionsSamlUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UserSAMLSourceConnection") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UserSamlSourceConnection | ValidationError | GenericError

union SourcesUserConnectionsSamlPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UserSAMLSourceConnection") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UserSamlSourceConnection | ValidationError | GenericError

"""SAML Source Serializer"""
input PatchedUserSamlSourceConnectionRequestInput {
  user: Int
  identifier: NonEmptyString
}

union SourcesUserConnectionsSamlDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union StagesAllDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union StagesAuthenticatorDuoCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "AuthenticatorDuoStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = AuthenticatorDuoStage | ValidationError | GenericError

"""AuthenticatorDuoStage Serializer"""
input AuthenticatorDuoStageRequestInput {
  name: NonEmptyString!
  flowSet: [FlowSetRequestInput]
  """
  Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.
  """
  configureFlow: UUID
  friendlyName: NonEmptyString
  clientId: NonEmptyString!
  clientSecret: NonEmptyString!
  apiHostname: NonEmptyString!
  adminIntegrationKey: String
  adminSecretKey: String
}

"""Stripped down flow serializer"""
input FlowSetRequestInput {
  name: NonEmptyString!
  slug: MutationInputStagesAuthenticatorDuoCreateInputFlowSetItemsSlug!
  """Shown as the Title in Flow pages."""
  title: NonEmptyString!
  designation: FlowDesignationEnum!
  policyEngineMode: PolicyEngineMode
  """
  Enable compatibility mode, increases compatibility with password managers on mobile devices.
  """
  compatibilityMode: Boolean
  layout: FlowLayoutEnum
  deniedAction: DeniedActionEnum
}

scalar MutationInputStagesAuthenticatorDuoCreateInputFlowSetItemsSlug @regexp(subgraph: "Authentik", pattern: "^[-a-zA-Z0-9_]+$") @typescript(subgraph: "Authentik", type: "string")

union StagesAuthenticatorDuoUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "AuthenticatorDuoStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = AuthenticatorDuoStage | ValidationError | GenericError

union StagesAuthenticatorDuoPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "AuthenticatorDuoStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = AuthenticatorDuoStage | ValidationError | GenericError

"""AuthenticatorDuoStage Serializer"""
input PatchedAuthenticatorDuoStageRequestInput {
  name: NonEmptyString
  flowSet: [FlowSetRequestInput]
  """
  Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.
  """
  configureFlow: UUID
  friendlyName: NonEmptyString
  clientId: NonEmptyString
  clientSecret: NonEmptyString
  apiHostname: NonEmptyString
  adminIntegrationKey: String
  adminSecretKey: String
}

union StagesAuthenticatorDuoDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union StagesAuthenticatorDuoEnrollmentStatusCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "DuoDeviceEnrollmentStatus") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = DuoDeviceEnrollmentStatus | ValidationError | GenericError

type DuoDeviceEnrollmentStatus {
  duoResponse: DuoResponseEnum!
}

enum DuoResponseEnum {
  SUCCESS
  WAITING
  INVALID
}

union StagesAuthenticatorDuoImportDeviceManualCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | GenericError

input AuthenticatorDuoStageManualDeviceImportRequestInput {
  duoUserId: NonEmptyString!
  username: NonEmptyString!
}

union StagesAuthenticatorDuoImportDevicesAutomaticCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "AuthenticatorDuoStageDeviceImportResponse") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = AuthenticatorDuoStageDeviceImportResponse | GenericError

type AuthenticatorDuoStageDeviceImportResponse {
  count: Int!
  error: String!
}

union StagesAuthenticatorSmsCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "AuthenticatorSMSStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = AuthenticatorSmsStage | ValidationError | GenericError

"""AuthenticatorSMSStage Serializer"""
input AuthenticatorSmsStageRequestInput {
  name: NonEmptyString!
  flowSet: [FlowSetRequestInput]
  """
  Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.
  """
  configureFlow: UUID
  friendlyName: NonEmptyString
  provider: ProviderEnum!
  fromNumber: NonEmptyString!
  accountSid: NonEmptyString!
  auth: NonEmptyString!
  authPassword: String
  authType: AuthTypeEnum
  """
  When enabled, the Phone number is only used during enrollment to verify the users authenticity. Only a hash of the phone number is saved to ensure it is not reused in the future.
  """
  verifyOnly: Boolean
  """Optionally modify the payload being sent to custom providers."""
  mapping: UUID
}

union StagesAuthenticatorSmsUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "AuthenticatorSMSStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = AuthenticatorSmsStage | ValidationError | GenericError

union StagesAuthenticatorSmsPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "AuthenticatorSMSStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = AuthenticatorSmsStage | ValidationError | GenericError

"""AuthenticatorSMSStage Serializer"""
input PatchedAuthenticatorSmsStageRequestInput {
  name: NonEmptyString
  flowSet: [FlowSetRequestInput]
  """
  Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.
  """
  configureFlow: UUID
  friendlyName: NonEmptyString
  provider: ProviderEnum
  fromNumber: NonEmptyString
  accountSid: NonEmptyString
  auth: NonEmptyString
  authPassword: String
  authType: AuthTypeEnum
  """
  When enabled, the Phone number is only used during enrollment to verify the users authenticity. Only a hash of the phone number is saved to ensure it is not reused in the future.
  """
  verifyOnly: Boolean
  """Optionally modify the payload being sent to custom providers."""
  mapping: UUID
}

union StagesAuthenticatorSmsDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union StagesAuthenticatorStaticCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "AuthenticatorStaticStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = AuthenticatorStaticStage | ValidationError | GenericError

"""AuthenticatorStaticStage Serializer"""
input AuthenticatorStaticStageRequestInput {
  name: NonEmptyString!
  flowSet: [FlowSetRequestInput]
  """
  Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.
  """
  configureFlow: UUID
  friendlyName: NonEmptyString
  tokenCount: NonNegativeInt
  tokenLength: NonNegativeInt
}

union StagesAuthenticatorStaticUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "AuthenticatorStaticStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = AuthenticatorStaticStage | ValidationError | GenericError

union StagesAuthenticatorStaticPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "AuthenticatorStaticStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = AuthenticatorStaticStage | ValidationError | GenericError

"""AuthenticatorStaticStage Serializer"""
input PatchedAuthenticatorStaticStageRequestInput {
  name: NonEmptyString
  flowSet: [FlowSetRequestInput]
  """
  Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.
  """
  configureFlow: UUID
  friendlyName: NonEmptyString
  tokenCount: NonNegativeInt
  tokenLength: NonNegativeInt
}

union StagesAuthenticatorStaticDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union StagesAuthenticatorTotpCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "AuthenticatorTOTPStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = AuthenticatorTotpStage | ValidationError | GenericError

"""AuthenticatorTOTPStage Serializer"""
input AuthenticatorTotpStageRequestInput {
  name: NonEmptyString!
  flowSet: [FlowSetRequestInput]
  """
  Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.
  """
  configureFlow: UUID
  friendlyName: NonEmptyString
  digits: DigitsEnum!
}

union StagesAuthenticatorTotpUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "AuthenticatorTOTPStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = AuthenticatorTotpStage | ValidationError | GenericError

union StagesAuthenticatorTotpPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "AuthenticatorTOTPStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = AuthenticatorTotpStage | ValidationError | GenericError

"""AuthenticatorTOTPStage Serializer"""
input PatchedAuthenticatorTotpStageRequestInput {
  name: NonEmptyString
  flowSet: [FlowSetRequestInput]
  """
  Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.
  """
  configureFlow: UUID
  friendlyName: NonEmptyString
  digits: DigitsEnum
}

union StagesAuthenticatorTotpDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union StagesAuthenticatorValidateCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "AuthenticatorValidateStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = AuthenticatorValidateStage | ValidationError | GenericError

"""AuthenticatorValidateStage Serializer"""
input AuthenticatorValidateStageRequestInput {
  name: NonEmptyString!
  flowSet: [FlowSetRequestInput]
  notConfiguredAction: NotConfiguredActionEnum
  """Device classes which can be used to authenticate"""
  deviceClasses: [DeviceClassesEnum]
  """
  Stages used to configure Authenticator when user doesn't have any compatible devices. After this configuration Stage passes, the user is not prompted again.
  """
  configurationStages: [UUID]
  """
  If any of the user's device has been used within this threshold, this stage will be skipped
  """
  lastAuthThreshold: NonEmptyString
  webauthnUserVerification: UserVerificationEnum
  webauthnAllowedDeviceTypes: [UUID]
}

union StagesAuthenticatorValidateUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "AuthenticatorValidateStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = AuthenticatorValidateStage | ValidationError | GenericError

union StagesAuthenticatorValidatePartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "AuthenticatorValidateStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = AuthenticatorValidateStage | ValidationError | GenericError

"""AuthenticatorValidateStage Serializer"""
input PatchedAuthenticatorValidateStageRequestInput {
  name: NonEmptyString
  flowSet: [FlowSetRequestInput]
  notConfiguredAction: NotConfiguredActionEnum
  """Device classes which can be used to authenticate"""
  deviceClasses: [DeviceClassesEnum]
  """
  Stages used to configure Authenticator when user doesn't have any compatible devices. After this configuration Stage passes, the user is not prompted again.
  """
  configurationStages: [UUID]
  """
  If any of the user's device has been used within this threshold, this stage will be skipped
  """
  lastAuthThreshold: NonEmptyString
  webauthnUserVerification: UserVerificationEnum
  webauthnAllowedDeviceTypes: [UUID]
}

union StagesAuthenticatorValidateDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union StagesAuthenticatorWebauthnCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "AuthenticatorWebAuthnStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = AuthenticatorWebAuthnStage | ValidationError | GenericError

"""AuthenticatorWebAuthnStage Serializer"""
input AuthenticatorWebAuthnStageRequestInput {
  name: NonEmptyString!
  flowSet: [FlowSetRequestInput]
  """
  Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.
  """
  configureFlow: UUID
  friendlyName: NonEmptyString
  userVerification: UserVerificationEnum
  authenticatorAttachment: AuthenticatorAttachmentEnum
  residentKeyRequirement: ResidentKeyRequirementEnum
  deviceTypeRestrictions: [UUID]
}

union StagesAuthenticatorWebauthnUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "AuthenticatorWebAuthnStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = AuthenticatorWebAuthnStage | ValidationError | GenericError

union StagesAuthenticatorWebauthnPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "AuthenticatorWebAuthnStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = AuthenticatorWebAuthnStage | ValidationError | GenericError

"""AuthenticatorWebAuthnStage Serializer"""
input PatchedAuthenticatorWebAuthnStageRequestInput {
  name: NonEmptyString
  flowSet: [FlowSetRequestInput]
  """
  Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.
  """
  configureFlow: UUID
  friendlyName: NonEmptyString
  userVerification: UserVerificationEnum
  authenticatorAttachment: AuthenticatorAttachmentEnum
  residentKeyRequirement: ResidentKeyRequirementEnum
  deviceTypeRestrictions: [UUID]
}

union StagesAuthenticatorWebauthnDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union StagesCaptchaCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "CaptchaStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = CaptchaStage | ValidationError | GenericError

"""CaptchaStage Serializer"""
input CaptchaStageRequestInput {
  name: NonEmptyString!
  flowSet: [FlowSetRequestInput]
  """Public key, acquired your captcha Provider."""
  publicKey: NonEmptyString!
  """Private key, acquired your captcha Provider."""
  privateKey: NonEmptyString!
  jsUrl: NonEmptyString
  apiUrl: NonEmptyString
}

union StagesCaptchaUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "CaptchaStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = CaptchaStage | ValidationError | GenericError

union StagesCaptchaPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "CaptchaStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = CaptchaStage | ValidationError | GenericError

"""CaptchaStage Serializer"""
input PatchedCaptchaStageRequestInput {
  name: NonEmptyString
  flowSet: [FlowSetRequestInput]
  """Public key, acquired your captcha Provider."""
  publicKey: NonEmptyString
  """Private key, acquired your captcha Provider."""
  privateKey: NonEmptyString
  jsUrl: NonEmptyString
  apiUrl: NonEmptyString
}

union StagesCaptchaDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union StagesConsentCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "ConsentStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ConsentStage | ValidationError | GenericError

"""ConsentStage Serializer"""
input ConsentStageRequestInput {
  name: NonEmptyString!
  flowSet: [FlowSetRequestInput]
  mode: ConsentStageModeEnum
  """
  Offset after which consent expires. (Format: hours=1;minutes=2;seconds=3).
  """
  consentExpireIn: NonEmptyString
}

union StagesConsentUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "ConsentStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ConsentStage | ValidationError | GenericError

union StagesConsentPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "ConsentStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = ConsentStage | ValidationError | GenericError

"""ConsentStage Serializer"""
input PatchedConsentStageRequestInput {
  name: NonEmptyString
  flowSet: [FlowSetRequestInput]
  mode: ConsentStageModeEnum
  """
  Offset after which consent expires. (Format: hours=1;minutes=2;seconds=3).
  """
  consentExpireIn: NonEmptyString
}

union StagesConsentDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union StagesDenyCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "DenyStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = DenyStage | ValidationError | GenericError

"""DenyStage Serializer"""
input DenyStageRequestInput {
  name: NonEmptyString!
  flowSet: [FlowSetRequestInput]
  denyMessage: String
}

union StagesDenyUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "DenyStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = DenyStage | ValidationError | GenericError

union StagesDenyPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "DenyStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = DenyStage | ValidationError | GenericError

"""DenyStage Serializer"""
input PatchedDenyStageRequestInput {
  name: NonEmptyString
  flowSet: [FlowSetRequestInput]
  denyMessage: String
}

union StagesDenyDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union StagesDummyCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "DummyStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = DummyStage | ValidationError | GenericError

"""DummyStage Serializer"""
input DummyStageRequestInput {
  name: NonEmptyString!
  flowSet: [FlowSetRequestInput]
  throwError: Boolean
}

union StagesDummyUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "DummyStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = DummyStage | ValidationError | GenericError

union StagesDummyPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "DummyStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = DummyStage | ValidationError | GenericError

"""DummyStage Serializer"""
input PatchedDummyStageRequestInput {
  name: NonEmptyString
  flowSet: [FlowSetRequestInput]
  throwError: Boolean
}

union StagesDummyDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union StagesEmailCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "EmailStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = EmailStage | ValidationError | GenericError

"""EmailStage Serializer"""
input EmailStageRequestInput {
  name: NonEmptyString!
  flowSet: [FlowSetRequestInput]
  """
  When enabled, global Email connection settings will be used and connection settings below will be ignored.
  """
  useGlobalSettings: Boolean
  host: NonEmptyString
  port: Int
  username: String
  password: String
  useTls: Boolean
  useSsl: Boolean
  timeout: Int
  fromAddress: EmailAddress
  """Time in minutes the token sent is valid."""
  tokenExpiry: Int
  subject: NonEmptyString
  template: NonEmptyString
  """Activate users upon completion of stage."""
  activateUserOnSuccess: Boolean
}

union StagesEmailUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "EmailStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = EmailStage | ValidationError | GenericError

union StagesEmailPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "EmailStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = EmailStage | ValidationError | GenericError

"""EmailStage Serializer"""
input PatchedEmailStageRequestInput {
  name: NonEmptyString
  flowSet: [FlowSetRequestInput]
  """
  When enabled, global Email connection settings will be used and connection settings below will be ignored.
  """
  useGlobalSettings: Boolean
  host: NonEmptyString
  port: Int
  username: String
  password: String
  useTls: Boolean
  useSsl: Boolean
  timeout: Int
  fromAddress: EmailAddress
  """Time in minutes the token sent is valid."""
  tokenExpiry: Int
  subject: NonEmptyString
  template: NonEmptyString
  """Activate users upon completion of stage."""
  activateUserOnSuccess: Boolean
}

union StagesEmailDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union StagesIdentificationCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "IdentificationStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = IdentificationStage | ValidationError | GenericError

"""IdentificationStage Serializer"""
input IdentificationStageRequestInput {
  name: NonEmptyString!
  flowSet: [FlowSetRequestInput]
  """
  Fields of the user object to match against. (Hold shift to select multiple options)
  """
  userFields: [UserFieldsEnum]
  """
  When set, shows a password field, instead of showing the password field as seaprate step.
  """
  passwordStage: UUID
  """When enabled, user fields are matched regardless of their casing."""
  caseInsensitiveMatching: Boolean
  """
  When a valid username/email has been entered, and this option is enabled, the user's username and avatar will be shown. Otherwise, the text that the user entered will be shown
  """
  showMatchedUser: Boolean
  """Optional enrollment flow, which is linked at the bottom of the page."""
  enrollmentFlow: UUID
  """Optional recovery flow, which is linked at the bottom of the page."""
  recoveryFlow: UUID
  """Optional passwordless flow, which is linked at the bottom of the page."""
  passwordlessFlow: UUID
  """Specify which sources should be shown."""
  sources: [UUID]
  showSourceLabels: Boolean
  """
  When enabled, the stage will succeed and continue even when incorrect user info is entered.
  """
  pretendUserExists: Boolean
}

union StagesIdentificationUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "IdentificationStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = IdentificationStage | ValidationError | GenericError

union StagesIdentificationPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "IdentificationStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = IdentificationStage | ValidationError | GenericError

"""IdentificationStage Serializer"""
input PatchedIdentificationStageRequestInput {
  name: NonEmptyString
  flowSet: [FlowSetRequestInput]
  """
  Fields of the user object to match against. (Hold shift to select multiple options)
  """
  userFields: [UserFieldsEnum]
  """
  When set, shows a password field, instead of showing the password field as seaprate step.
  """
  passwordStage: UUID
  """When enabled, user fields are matched regardless of their casing."""
  caseInsensitiveMatching: Boolean
  """
  When a valid username/email has been entered, and this option is enabled, the user's username and avatar will be shown. Otherwise, the text that the user entered will be shown
  """
  showMatchedUser: Boolean
  """Optional enrollment flow, which is linked at the bottom of the page."""
  enrollmentFlow: UUID
  """Optional recovery flow, which is linked at the bottom of the page."""
  recoveryFlow: UUID
  """Optional passwordless flow, which is linked at the bottom of the page."""
  passwordlessFlow: UUID
  """Specify which sources should be shown."""
  sources: [UUID]
  showSourceLabels: Boolean
  """
  When enabled, the stage will succeed and continue even when incorrect user info is entered.
  """
  pretendUserExists: Boolean
}

union StagesIdentificationDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union StagesInvitationInvitationsCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "Invitation") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Invitation | ValidationError | GenericError

"""Invitation Serializer"""
input InvitationRequestInput {
  name: MutationInputStagesInvitationInvitationsCreateInputName!
  expires: DateTime
  fixedData: JSON
  """When enabled, the invitation will be deleted after usage."""
  singleUse: Boolean
  """When set, only the configured flow can use this invitation."""
  flow: UUID
}

scalar MutationInputStagesInvitationInvitationsCreateInputName @regexp(subgraph: "Authentik", pattern: "^[-a-zA-Z0-9_]+$") @typescript(subgraph: "Authentik", type: "string")

union StagesInvitationInvitationsUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Invitation") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Invitation | ValidationError | GenericError

union StagesInvitationInvitationsPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Invitation") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Invitation | ValidationError | GenericError

"""Invitation Serializer"""
input PatchedInvitationRequestInput {
  name: MutationInputStagesInvitationInvitationsPartialUpdateInputName
  expires: DateTime
  fixedData: JSON
  """When enabled, the invitation will be deleted after usage."""
  singleUse: Boolean
  """When set, only the configured flow can use this invitation."""
  flow: UUID
}

scalar MutationInputStagesInvitationInvitationsPartialUpdateInputName @regexp(subgraph: "Authentik", pattern: "^[-a-zA-Z0-9_]+$") @typescript(subgraph: "Authentik", type: "string")

union StagesInvitationInvitationsDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union StagesInvitationStagesCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "InvitationStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = InvitationStage | ValidationError | GenericError

"""InvitationStage Serializer"""
input InvitationStageRequestInput {
  name: NonEmptyString!
  flowSet: [FlowSetRequestInput]
  """
  If this flag is set, this Stage will jump to the next Stage when no Invitation is given. By default this Stage will cancel the Flow when no invitation is given.
  """
  continueFlowWithoutInvitation: Boolean
}

union StagesInvitationStagesUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "InvitationStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = InvitationStage | ValidationError | GenericError

union StagesInvitationStagesPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "InvitationStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = InvitationStage | ValidationError | GenericError

"""InvitationStage Serializer"""
input PatchedInvitationStageRequestInput {
  name: NonEmptyString
  flowSet: [FlowSetRequestInput]
  """
  If this flag is set, this Stage will jump to the next Stage when no Invitation is given. By default this Stage will cancel the Flow when no invitation is given.
  """
  continueFlowWithoutInvitation: Boolean
}

union StagesInvitationStagesDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union StagesPasswordCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "PasswordStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PasswordStage | ValidationError | GenericError

"""PasswordStage Serializer"""
input PasswordStageRequestInput {
  name: NonEmptyString!
  flowSet: [FlowSetRequestInput]
  """Selection of backends to test the password against."""
  backends: [BackendsEnum]!
  """
  Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.
  """
  configureFlow: UUID
  """
  How many attempts a user has before the flow is canceled. To lock the user out, use a reputation policy and a user_write stage.
  """
  failedAttemptsBeforeCancel: Int
}

union StagesPasswordUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PasswordStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PasswordStage | ValidationError | GenericError

union StagesPasswordPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PasswordStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PasswordStage | ValidationError | GenericError

"""PasswordStage Serializer"""
input PatchedPasswordStageRequestInput {
  name: NonEmptyString
  flowSet: [FlowSetRequestInput]
  """Selection of backends to test the password against."""
  backends: [BackendsEnum]
  """
  Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.
  """
  configureFlow: UUID
  """
  How many attempts a user has before the flow is canceled. To lock the user out, use a reputation policy and a user_write stage.
  """
  failedAttemptsBeforeCancel: Int
}

union StagesPasswordDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union StagesPromptPromptsCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "Prompt") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Prompt | ValidationError | GenericError

"""Prompt Serializer"""
input PromptRequestInput {
  name: NonEmptyString!
  """Name of the form field, also used to store the value"""
  fieldKey: NonEmptyString!
  label: NonEmptyString!
  type: PromptTypeEnum!
  required: Boolean
  """
  Optionally provide a short hint that describes the expected input value. When creating a fixed choice field, enable interpreting as expression and return a list to return multiple choices.
  """
  placeholder: String
  """
  Optionally pre-fill the input with an initial value. When creating a fixed choice field, enable interpreting as expression and return a list to return multiple default choices.
  """
  initialValue: String
  order: Int
  promptstageSet: [StageRequestInput]
  subText: String
  placeholderExpression: Boolean
  initialValueExpression: Boolean
}

"""Stage Serializer"""
input StageRequestInput {
  name: NonEmptyString!
  flowSet: [FlowSetRequestInput]
}

union StagesPromptPromptsUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Prompt") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Prompt | ValidationError | GenericError

union StagesPromptPromptsPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "Prompt") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = Prompt | ValidationError | GenericError

"""Prompt Serializer"""
input PatchedPromptRequestInput {
  name: NonEmptyString
  """Name of the form field, also used to store the value"""
  fieldKey: NonEmptyString
  label: NonEmptyString
  type: PromptTypeEnum
  required: Boolean
  """
  Optionally provide a short hint that describes the expected input value. When creating a fixed choice field, enable interpreting as expression and return a list to return multiple choices.
  """
  placeholder: String
  """
  Optionally pre-fill the input with an initial value. When creating a fixed choice field, enable interpreting as expression and return a list to return multiple default choices.
  """
  initialValue: String
  order: Int
  promptstageSet: [StageRequestInput]
  subText: String
  placeholderExpression: Boolean
  initialValueExpression: Boolean
}

union StagesPromptPromptsDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union StagesPromptPromptsPreviewCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PromptChallenge") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PromptChallenge | ValidationError | GenericError

union StagesPromptStagesCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "PromptStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PromptStage | ValidationError | GenericError

"""PromptStage Serializer"""
input PromptStageRequestInput {
  name: NonEmptyString!
  flowSet: [FlowSetRequestInput]
  fields: [UUID]!
  validationPolicies: [UUID]
}

union StagesPromptStagesUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PromptStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PromptStage | ValidationError | GenericError

union StagesPromptStagesPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "PromptStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = PromptStage | ValidationError | GenericError

"""PromptStage Serializer"""
input PatchedPromptStageRequestInput {
  name: NonEmptyString
  flowSet: [FlowSetRequestInput]
  fields: [UUID]
  validationPolicies: [UUID]
}

union StagesPromptStagesDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union StagesSourceCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "SourceStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = SourceStage | ValidationError | GenericError

"""SourceStage Serializer"""
input SourceStageRequestInput {
  name: NonEmptyString!
  flowSet: [FlowSetRequestInput]
  source: UUID!
  """
  Amount of time a user can take to return from the source to continue the flow (Format: hours=-1;minutes=-2;seconds=-3)
  """
  resumeTimeout: NonEmptyString
}

union StagesSourceUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "SourceStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = SourceStage | ValidationError | GenericError

union StagesSourcePartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "SourceStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = SourceStage | ValidationError | GenericError

"""SourceStage Serializer"""
input PatchedSourceStageRequestInput {
  name: NonEmptyString
  flowSet: [FlowSetRequestInput]
  source: UUID
  """
  Amount of time a user can take to return from the source to continue the flow (Format: hours=-1;minutes=-2;seconds=-3)
  """
  resumeTimeout: NonEmptyString
}

union StagesSourceDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union StagesUserDeleteCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "UserDeleteStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UserDeleteStage | ValidationError | GenericError

"""UserDeleteStage Serializer"""
input UserDeleteStageRequestInput {
  name: NonEmptyString!
  flowSet: [FlowSetRequestInput]
}

union StagesUserDeleteUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UserDeleteStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UserDeleteStage | ValidationError | GenericError

union StagesUserDeletePartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UserDeleteStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UserDeleteStage | ValidationError | GenericError

"""UserDeleteStage Serializer"""
input PatchedUserDeleteStageRequestInput {
  name: NonEmptyString
  flowSet: [FlowSetRequestInput]
}

union StagesUserDeleteDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union StagesUserLoginCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "UserLoginStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UserLoginStage | ValidationError | GenericError

"""UserLoginStage Serializer"""
input UserLoginStageRequestInput {
  name: NonEmptyString!
  flowSet: [FlowSetRequestInput]
  """
  Determines how long a session lasts. Default of 0 means that the sessions lasts until the browser is closed. (Format: hours=-1;minutes=-2;seconds=-3)
  """
  sessionDuration: NonEmptyString
  """Terminate all other sessions of the user logging in."""
  terminateOtherSessions: Boolean
  """
  Offset the session will be extended by when the user picks the remember me option. Default of 0 means that the remember me option will not be shown. (Format: hours=-1;minutes=-2;seconds=-3)
  """
  rememberMeOffset: NonEmptyString
  networkBinding: NetworkBindingEnum
  geoipBinding: GeoipBindingEnum
}

union StagesUserLoginUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UserLoginStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UserLoginStage | ValidationError | GenericError

union StagesUserLoginPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UserLoginStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UserLoginStage | ValidationError | GenericError

"""UserLoginStage Serializer"""
input PatchedUserLoginStageRequestInput {
  name: NonEmptyString
  flowSet: [FlowSetRequestInput]
  """
  Determines how long a session lasts. Default of 0 means that the sessions lasts until the browser is closed. (Format: hours=-1;minutes=-2;seconds=-3)
  """
  sessionDuration: NonEmptyString
  """Terminate all other sessions of the user logging in."""
  terminateOtherSessions: Boolean
  """
  Offset the session will be extended by when the user picks the remember me option. Default of 0 means that the remember me option will not be shown. (Format: hours=-1;minutes=-2;seconds=-3)
  """
  rememberMeOffset: NonEmptyString
  networkBinding: NetworkBindingEnum
  geoipBinding: GeoipBindingEnum
}

union StagesUserLoginDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union StagesUserLogoutCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "UserLogoutStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UserLogoutStage | ValidationError | GenericError

"""UserLogoutStage Serializer"""
input UserLogoutStageRequestInput {
  name: NonEmptyString!
  flowSet: [FlowSetRequestInput]
}

union StagesUserLogoutUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UserLogoutStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UserLogoutStage | ValidationError | GenericError

union StagesUserLogoutPartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UserLogoutStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UserLogoutStage | ValidationError | GenericError

"""UserLogoutStage Serializer"""
input PatchedUserLogoutStageRequestInput {
  name: NonEmptyString
  flowSet: [FlowSetRequestInput]
}

union StagesUserLogoutDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

union StagesUserWriteCreateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 201, typeName: "UserWriteStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UserWriteStage | ValidationError | GenericError

"""UserWriteStage Serializer"""
input UserWriteStageRequestInput {
  name: NonEmptyString!
  flowSet: [FlowSetRequestInput]
  userCreationMode: UserCreationModeEnum
  """When set, newly created users are inactive and cannot login."""
  createUsersAsInactive: Boolean
  """Optionally add newly created users to this group."""
  createUsersGroup: UUID
  userType: UserTypeEnum
  userPathTemplate: String
}

union StagesUserWriteUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UserWriteStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UserWriteStage | ValidationError | GenericError

union StagesUserWritePartialUpdateResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 200, typeName: "UserWriteStage") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = UserWriteStage | ValidationError | GenericError

"""UserWriteStage Serializer"""
input PatchedUserWriteStageRequestInput {
  name: NonEmptyString
  flowSet: [FlowSetRequestInput]
  userCreationMode: UserCreationModeEnum
  """When set, newly created users are inactive and cannot login."""
  createUsersAsInactive: Boolean
  """Optionally add newly created users to this group."""
  createUsersGroup: UUID
  userType: UserTypeEnum
  userPathTemplate: String
}

union StagesUserWriteDestroyResponse @statusCodeTypeName(subgraph: "Authentik", statusCode: 204, typeName: "Void_container") @statusCodeTypeName(subgraph: "Authentik", statusCode: 400, typeName: "ValidationError") @statusCodeTypeName(subgraph: "Authentik", statusCode: 403, typeName: "GenericError") = VoidContainer | ValidationError | GenericError

scalar ObjMap

enum HttpMethod {
  GET
  HEAD
  POST
  PUT
  DELETE
  CONNECT
  OPTIONS
  TRACE
  PATCH
}

scalar ResolveToSourceArgs